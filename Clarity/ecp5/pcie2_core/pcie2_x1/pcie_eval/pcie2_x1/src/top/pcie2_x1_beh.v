// pcie_beh.v generated by Lattice IP Model Creator version 1
// created on Tue, Aug 01, 2017  1:26:37 PM
// Copyright(c) 2007 Lattice Semiconductor Corporation. All rights reserved
// obfuscator_exe version 1.mar0807

// top// obfuscator_exe version 1.mar0807


// top// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : sonet framer


// File             : sync1s.v


// Title            :


// Dependencies     : 


// Description      : Synchronizer :Transfers signal from faster clock


//                    domain to slower clock domain.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        :  


// Mod. Date        : Dec 14, 2004


// Changes Made     : Initial Creation


// =============================================================================




`timescale 1 ns / 100 ps
module sync1s (
                f_clk ,
                s_clk ,
                rst_n ,
                in_fclk,
                out_sclk
               );
parameter WIDTH = 1 ;
input              f_clk ;
input              s_clk ;
input              rst_n ;
input  [WIDTH-1:0] in_fclk ;
output [WIDTH-1:0] out_sclk ;
reg [WIDTH-1:0]   f_reg1 ;
reg [WIDTH-1:0]   f_reg2 ;
reg [WIDTH-1:0]   f_reg3 ;
reg [WIDTH-1:0]   s_reg1 ;
reg [WIDTH-1:0]   s_reg2 ;
wire [WIDTH-1:0]  hold_fb ;
wire [WIDTH-1:0]  out_sclk ;
integer i ;
reg [WIDTH - 1 : 0] in_fclk_split;
reg [WIDTH - 1 : 0] f_reg1_split;
reg [WIDTH - 1 : 0] f_reg2_split;
reg [WIDTH - 1 : 0] f_reg3_split;
reg [WIDTH - 1 : 0] s_reg1_split;
reg [WIDTH - 1 : 0] s_reg2_split;
reg [WIDTH - 1 : 0] hold_fb_split;
reg [2047:0] descram_in;
wire [6:0] descram_out;

localparam descram_inst_SIZE = 7,descram_inst_SCRAMSTRING = 32'hfdffc68b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

// Fast clock.
// Slow clock.
// reset signal.
// Input pulse in fast clock domain.
// Output pulse in slow clock domain.

// register fast clock signal edge and hold it untill
// it is transfered into slower clock domain.
always @(posedge f_clk or negedge rst_n) begin
   if (!rst_n)
      f_reg1 <= {WIDTH{1'b0}};
   else
      for (i = 0; i <= WIDTH-1; i = i+1) begin
         f_reg1[i] <= (hold_fb_split[i]== 1'b1) ? f_reg1_split[i] : in_fclk_split[i];
      end
end

// first register in slower clock domain, this can be 
// a metastable flop.
always @(posedge s_clk or negedge rst_n) begin
   if (!rst_n)
      s_reg1 <= {WIDTH{1'b0}};
   else
      s_reg1 <= f_reg1_split;
end

// Cleaner registering in slower clock domain.
always @(posedge s_clk or negedge rst_n) begin
   if (!rst_n)
      s_reg2 <= {WIDTH{1'b0}};
   else
      s_reg2 <= s_reg1_split;
end

// Output signal.
assign out_sclk  = s_reg2_split ;

// Register clean output in slower clock domain into
// fast clock domains, this can be metastable flop.
always @(posedge f_clk or negedge rst_n) begin
   if (!rst_n)
      f_reg2 <= {WIDTH{1'b0}};
   else
      f_reg2 <= s_reg2_split;
end

// Cleaner registering in faster clock domain.
always @(posedge f_clk or negedge rst_n) begin
   if (!rst_n)
      f_reg3 <= {WIDTH{1'b0}};
   else
      f_reg3 <= f_reg2_split;
end

// generate feed back hold signal for holding
// input signal in fast clock domain, until it reaches
// slower clock domain.
assign hold_fb  = f_reg1_split ^ f_reg3_split;

always@* begin in_fclk_split<={in_fclk>>1,descram_out[0]};f_reg1_split<={f_reg1>>1,descram_out[1]};f_reg2_split<={f_reg2>>1,descram_out[2]};f_reg3_split<={f_reg3>>1,descram_out[3]};s_reg1_split<={s_reg1>>1,descram_out[4]};s_reg2_split<={s_reg2>>1,descram_out[5]};hold_fb_split<={hold_fb>>1,descram_out[6]};end
always@* begin descram_in[2047]<=f_reg1[0];descram_in[2046]<=f_reg2[0];descram_in[2044]<=f_reg3[0];descram_in[2040]<=s_reg1[0];descram_in[2032]<=s_reg2[0];descram_in[2017]<=hold_fb[0];descram_in[1023]<=in_fclk[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : pipe.v


// Description      : This module generates PIPE interface signals


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh


// Mod. Date        : Mar 1, 2004


// =============================================================================



`timescale 1 ns / 100 ps
module pipe #(
   parameter LANE_WIDTH   = 2 ,
   parameter D_WIDTH      = 64 )
  (input wire               rst_n,            
   input wire               sys_clk,          
   input wire               pclk,             
   input wire [LANE_WIDTH*16-1:0]rx_data,     
   input wire [LANE_WIDTH*2-1:0] rx_data_k,   
   input wire [LANE_WIDTH-1:0]   rx_valid,    
   input wire [LANE_WIDTH-1:0]   rx_elec_idle,
   input wire [LANE_WIDTH*3-1:0] rx_status,   
   input wire                    phy_status,  

   
   input wire [LANE_WIDTH-1:0]   phy_disable_scr, 
   input wire [LANE_WIDTH-1:0]   phy_inv_polar,   
   input wire [LANE_WIDTH-1:0]   phy_eidle_tx,    
   input wire [LANE_WIDTH-1:0]   phy_godet_rx,    
   input wire [LANE_WIDTH-1:0]   phy_sloopback,   
   input wire [LANE_WIDTH-1:0]   phy_snd_beacon,  
   input wire [LANE_WIDTH*16-1:0] phy_data,       
   input wire [LANE_WIDTH*2-1:0]  phy_kcntl,      
   input wire [LANE_WIDTH*2-1:0]  phy_fndisp,      
   input wire [3:0]              phy_ltssm_state, 
   input wire [2:0]              l0s_tx_state,    
   input wire [1:0]              l1_state,        
   input wire [1:0]              l2_state,        
   input wire                    rate_5g,         
   input wire                    phy_deemph,      
   input wire [2:0]              phy_margin,      

   
   input wire                force_lsm_active,   
   input wire                force_rec_ei,       
   input wire                force_phy_status,   

   
   output [LANE_WIDTH*16-1:0]tx_data,            
   output [LANE_WIDTH*2-1:0] tx_data_k,          
   output                    tx_detect_rx_lb,    
   output [LANE_WIDTH-1:0]   tx_elec_idle,       
   output [LANE_WIDTH*2-1:0] tx_compliance,      
   output [LANE_WIDTH-1:0]   rx_polarity,        
   output                    reset_n,            
   output reg [1:0]          power_down,         
   output reg                rate,               
   output reg                tx_deemph,          
   output reg [2:0]          tx_margin,          

   
   output reg                    rate_phy_sts_pulse,
   output reg [LANE_WIDTH*16-1:0]asb_data,      
   output reg [LANE_WIDTH*2-1:0] asb_kcntl,     
   output reg [LANE_WIDTH-1:0]   asb_err,       
   output reg [LANE_WIDTH-1:0]   asb_eidle_rx,  
   output reg [LANE_WIDTH-1:0]   asb_detdone_rx,
   output reg [LANE_WIDTH-1:0]   asb_detres_rx, 
   output reg [LANE_WIDTH-1:0]   asb_beacon_rx, 
   output reg [LANE_WIDTH-1:0]   asb_lane_sync, 
   output reg [LANE_WIDTH*2-1:0]   asb_skip_found,
   output reg [LANE_WIDTH*2-1:0]   skip_added,    
   output reg [LANE_WIDTH*2-1:0]   skip_removed   // signal Indicating Skip was removed


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam L1_IDLE     = 2'd2 ;
localparam L2_IDLE     = 2'd1 ;
localparam L2_TRNSWAKE = 2'd2 ;
localparam L0s_TX_IDLE = 3'd3 ;
localparam P0  = 2'b00;
localparam P0s = 2'b10;
localparam P1  = 2'b10;
localparam P2  = 2'b11;
wire [LANE_WIDTH-1:0] rx_status_res, rx_status_res_sync;
wire phy_status_sync;
wire[LANE_WIDTH-1:0] asb_skip_found_i,asb_detdone_rx_i,asb_detres_rx_i;
reg [1:0] power_down_sys,power_down_int /* synthesis syn_srlstyle="registers" */  ;
reg [2:0] tx_margin_int /* synthesis syn_srlstyle="registers" */  ;
reg rate_int, tx_deemph_int;
reg tx_detect_rx_reg, line_active, comma, exit_done;
reg phy_sloopback_r1, phy_sloopback_r2, phy_status_r;
reg [LANE_WIDTH*3-1:0]  rx_status_r;
reg [LANE_WIDTH*16-1:0] asb_data_i;
reg [LANE_WIDTH*2-1:0] asb_kcntl_i;
reg [LANE_WIDTH-1:0] asb_data_k28_5,asb_err_i,skip_added_i,skip_removed_i,asb_eidle_rx_i,asb_beacon_rx_i,asb_lane_sync_i;
reg [2:0]           rate_phy_sts_rcvd;
reg                 rate_phy_sts_ext;
reg [2:0]           rate_phy_sts_sysclk;

`ifdef ECP3

`else

`endif
reg [LANE_WIDTH * 16 - 1 : 0] rx_data_split;
reg [LANE_WIDTH * 2 - 1 : 0] rx_data_k_split;
reg [LANE_WIDTH - 1 : 0] rx_valid_split;
reg [LANE_WIDTH - 1 : 0] rx_elec_idle_split;
reg [LANE_WIDTH * 3 - 1 : 0] rx_status_split;
reg phy_status_split;
reg [LANE_WIDTH - 1 : 0] phy_disable_scr_split;
reg [LANE_WIDTH - 1 : 0] phy_inv_polar_split;
reg [LANE_WIDTH - 1 : 0] phy_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] phy_godet_rx_split;
reg [LANE_WIDTH - 1 : 0] phy_sloopback_split;
reg [LANE_WIDTH - 1 : 0] phy_snd_beacon_split;
reg [LANE_WIDTH * 16 - 1 : 0] phy_data_split;
reg [LANE_WIDTH * 2 - 1 : 0] phy_kcntl_split;
reg [LANE_WIDTH * 2 - 1 : 0] phy_fndisp_split;
reg [3 : 0] phy_ltssm_state_split;
reg [2 : 0] l0s_tx_state_split;
reg [1 : 0] l1_state_split;
reg [1 : 0] l2_state_split;
reg rate_5g_split;
reg phy_deemph_split;
reg [2 : 0] phy_margin_split;
reg force_lsm_active_split;
reg force_rec_ei_split;
reg force_phy_status_split;
reg [LANE_WIDTH - 1 : 0] rx_status_res_split;
reg [LANE_WIDTH - 1 : 0] rx_status_res_sync_split;
reg phy_status_sync_split;
reg [LANE_WIDTH - 1 : 0] asb_skip_found_i_split;
reg [LANE_WIDTH - 1 : 0] asb_detdone_rx_i_split;
reg [LANE_WIDTH - 1 : 0] asb_detres_rx_i_split;
reg [1 : 0] power_down_sys_split;
reg [1 : 0] power_down_int_split;
reg [2 : 0] tx_margin_int_split;
reg rate_int_split;
reg tx_deemph_int_split;
reg tx_detect_rx_reg_split;
reg line_active_split;
reg comma_split;
reg exit_done_split;
reg phy_sloopback_r1_split;
reg phy_sloopback_r2_split;
reg phy_status_r_split;
reg [LANE_WIDTH * 3 - 1 : 0] rx_status_r_split;
reg [LANE_WIDTH * 16 - 1 : 0] asb_data_i_split;
reg [LANE_WIDTH * 2 - 1 : 0] asb_kcntl_i_split;
reg [LANE_WIDTH - 1 : 0] asb_data_k28_5_split;
reg [LANE_WIDTH - 1 : 0] asb_err_i_split;
reg [LANE_WIDTH - 1 : 0] skip_added_i_split;
reg [LANE_WIDTH - 1 : 0] skip_removed_i_split;
reg [LANE_WIDTH - 1 : 0] asb_eidle_rx_i_split;
reg [LANE_WIDTH - 1 : 0] asb_beacon_rx_i_split;
reg [LANE_WIDTH - 1 : 0] asb_lane_sync_i_split;
reg [2 : 0] rate_phy_sts_rcvd_split;
reg rate_phy_sts_ext_split;
reg [2 : 0] rate_phy_sts_sysclk_split;
reg [2047:0] descram_in;
wire [55:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif


`ifdef ECP3

`else

`endif

localparam descram_inst_SIZE = 56,descram_inst_SCRAMSTRING = 32'hfdffc68b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif


`ifdef ECP3



`else



`endif

// =============================================================================
// Parameters
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================


// Data To External Phy
assign tx_data       = phy_data_split;
assign tx_data_k     = phy_kcntl_split;
assign tx_elec_idle  = phy_eidle_tx_split;
assign tx_compliance = phy_fndisp_split;
assign rx_polarity   = phy_inv_polar_split;
assign reset_n       = rst_n;

// Resync to 125 Mhz clock from 250 Mhz clock
// data is used by ltssm running at 125 Mhz
always @(posedge pclk or negedge rst_n) begin
   if (!rst_n) {phy_status_r,rx_status_r} <= 'd0;
   else        {phy_status_r,rx_status_r} <= {phy_status_split,rx_status_split};
end

//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge pclk or negedge rst_n) begin
  if(~rst_n) begin
    /*AUTORESET*/
    rate_phy_sts_rcvd   <= 3'd0;
    rate_phy_sts_ext    <= 1'b0;
  end
  else begin
    rate_phy_sts_rcvd   <= {rate_phy_sts_rcvd_split[1:0],rate_phy_sts_sysclk_split};
    rate_phy_sts_ext    <= (rate_phy_sts_ext_split | phy_status_split) & ~(rate_phy_sts_rcvd_split[1] & ~rate_phy_sts_rcvd_split[2]);
  end
end //--always @(posedge pclk or negedge rst_n)--


//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge sys_clk or negedge rst_n) begin
  if(~rst_n) begin
    /*AUTORESET*/
    rate_phy_sts_sysclk <= 3'd0;
    rate_phy_sts_pulse <= 1'b0;
  end
  else begin
    rate_phy_sts_sysclk <= {rate_phy_sts_sysclk_split[1:0],rate_phy_sts_ext_split};
    rate_phy_sts_pulse <= rate_phy_sts_sysclk_split[1] & ~rate_phy_sts_sysclk_split[2];
  end
end //--always @(posedge sys_clk or negedge rst_n)--

assign rx_status_res[0] = (rx_status_r_split[2:0]  == 3'b011);
assign rx_status_res[1] = (rx_status_r_split[5:3]  == 3'b011);

sync1s #(3) u1_sync1s (
   .f_clk     (pclk) ,
   .s_clk     (sys_clk) ,
   .rst_n     (rst_n),
   .in_fclk   ({phy_status_r_split,rx_status_res_split}),
   .out_sclk  ({phy_status_sync,rx_status_res_sync})
   );

assign asb_detdone_rx_i[1:0] = {(4){phy_status_sync_split}};
assign asb_detres_rx_i[1:0]  = force_phy_status_split ? 2'b11 : rx_status_res_sync_split[1:0];

// Receiver Detection/Loopback
always @(posedge pclk or negedge rst_n) begin
   if (!rst_n)             tx_detect_rx_reg <= 1'b0;
   else if (phy_status_split)    tx_detect_rx_reg <= 1'b0;
   else if (|phy_godet_rx_split) tx_detect_rx_reg <= 1'b1;
end

always @(posedge pclk or negedge rst_n) begin
   if (!rst_n)
        {phy_sloopback_r2,phy_sloopback_r1} <= 'd0;
   else {phy_sloopback_r2,phy_sloopback_r1} <= {phy_sloopback_r1_split,(|phy_sloopback_split)};
end
assign tx_detect_rx_lb = (tx_detect_rx_reg_split | phy_sloopback_r2_split);

// Data From External Phy.
// No need to resync these signals since these are used at 250 Mhz
always @(posedge pclk or negedge rst_n) begin
   if (!rst_n) {asb_data_i,asb_kcntl_i,asb_data_k28_5} <= 'd0;
   else begin
      asb_data_i  <= rx_data_split;
      asb_kcntl_i <= rx_data_k_split;
      asb_data_k28_5[0]  <= ((rx_data_split[7:0]== K28_5 && rx_data_k_split[0]) || (rx_data_split[15:8]== K28_5 && rx_data_k_split[1])) ? 1'b1 : 1'b0;
      asb_data_k28_5[1]  <= ((rx_data_split[23:16]== K28_5 && rx_data_k_split[2]) || (rx_data_split[31:24]== K28_5 && rx_data_k_split[3])) ? 1'b1 : 1'b0;
   end
end
assign  asb_skip_found_i[0] = (asb_data_k28_5_split && ((rx_data_split[7:0]==K28_0 && rx_data_k_split[0] && !asb_err_i_split[0]) ||
                                                  (rx_data_split[15:8]== K28_0 && rx_data_k_split[1] && !asb_err_i_split[0])))?1'b1:1'b0;
assign  asb_skip_found_i[1] = (asb_data_k28_5_split && ((rx_data_split[23:16]== K28_0 && rx_data_k_split[2] && !asb_err_i_split[1])||
                                                  (rx_data_split[31:24]== K28_0 && rx_data_k_split[3] && !asb_err_i_split[1])))?1'b1:1'b0;


// For an X1 PCIE rx_valid is same as asb_lane_sync, but for >X1 this has to
// be generated by a MCA (Multi Channel Aligner Block)
// No need to resync these signals to 125 Mhz clock since these are static signals
always @(posedge pclk or negedge rst_n) begin
   if (!rst_n)
      {asb_lane_sync_i,asb_eidle_rx_i,asb_beacon_rx_i} <= 'd0;
   else begin
      asb_lane_sync_i[1:0] <= (force_lsm_active_split) ? 2'b11 : rx_valid_split[1:0];
      

`ifdef ECP3


         // To take care of LOS issue
         asb_eidle_rx_i[1:0]  <= (force_rec_ei_split) ? 2'b11 : ~rx_valid_split[1:0];
      

`else


         asb_eidle_rx_i[1:0]  <= (force_rec_ei_split) ? 2'b11 : rx_elec_idle_split[1:0];
      

`endif


      asb_beacon_rx_i[0] <= (power_down == P2 && rx_elec_idle_split[0] == 1'b0);
      asb_beacon_rx_i[1] <= (power_down == P2 && rx_elec_idle_split[1] == 1'b0);
   end
end

// Error Signal: No need to resync these signals since these are used at 250 Mhz
always @(posedge pclk or negedge rst_n) begin
   if (!rst_n)  asb_err_i    <= 0;
   else begin
      asb_err_i[0] <= (rx_status_split[2:0]==3'b100  || rx_status_split[2:0]== 3'b101 || rx_status_split[2:0]== 3'b110  || rx_status_split[2:0]== 3'b111);
      asb_err_i[1] <= (rx_status_split[5:3]==3'b100  || rx_status_split[5:3]== 3'b101 || rx_status_split[5:3]== 3'b110  || rx_status_split[5:3]== 3'b111);
   end
end


// Skip Added/removed: No need to resync these signals since these are used at 250 Mhz
always @(posedge pclk or negedge rst_n) begin
   if (!rst_n) {skip_added_i,skip_removed_i} <= 'd0;
   else begin
      skip_added_i[0] <= (rx_status_split[2:0]  == 3'b001 );
      skip_added_i[1] <= (rx_status_split[5:3]  == 3'b001 );
      skip_removed_i[0] <= (rx_status_split[2:0]  == 3'b010 );
      skip_removed_i[1] <= (rx_status_split[5:3]  == 3'b010 );
   end
end

// Power Down Encoding Based on Page 14/15 of the PIPE spec ver 1.00 6/19/03
// phy_status generated by the External PHY chip in response to power down
// Requests (phy_status) are not used by the IP.
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) power_down_sys   <= P1;
   else begin
      case(phy_ltssm_state_split)
         L0s: if (l0s_tx_state_split == L0s_TX_IDLE) power_down_sys   <= P0s;
         DISABLED, DETECT: power_down_sys   <= P1;
         L1: if (l1_state_split == L1_IDLE)  power_down_sys   <= P1;
         L2: if (l2_state_split == L2_IDLE || l2_state_split == L2_TRNSWAKE )  power_down_sys   <= P2;
         default: power_down_sys   <= P0;
      endcase
   end
end

// Resync to pclk domain
always @(posedge pclk or negedge rst_n) begin
   if (!rst_n) begin
      {power_down,power_down_int} <= {2{P1}};
      {rate,rate_int} <= {2{1'b0}};
      {tx_deemph,tx_deemph_int} <= {2{1'b1}};
      {tx_margin,tx_margin_int} <= {2{3'd0}};
   end
   else begin
      {power_down,power_down_int} <= {power_down_int_split,power_down_sys_split};
      {rate,rate_int} <= {rate_int_split,rate_5g_split};
      {tx_deemph,tx_deemph_int} <= {tx_deemph_int_split,phy_deemph_split};
      {tx_margin,tx_margin_int} <= {tx_margin_int_split,phy_margin_split};
   end
end

// =============================================================================
// Flop O/P's for FMAX
// =============================================================================
always @(posedge pclk or negedge rst_n) begin
   if (!rst_n)
      {asb_detdone_rx,asb_detres_rx,asb_skip_found,asb_data,asb_kcntl,asb_err,
       skip_added,skip_removed,asb_eidle_rx,asb_beacon_rx,asb_lane_sync} <= 'd0;
   else begin
      asb_detdone_rx<= asb_detdone_rx_i_split;
      asb_detres_rx <= asb_detres_rx_i_split;
      asb_skip_found<= asb_skip_found_i_split;
      asb_data      <= asb_data_i_split;
      asb_kcntl     <= asb_kcntl_i_split;
      asb_err       <= asb_err_i_split;
      skip_added    <= skip_added_i_split;
      skip_removed  <= skip_removed_i_split;
      asb_beacon_rx <= asb_beacon_rx_i_split;
      asb_lane_sync <= asb_lane_sync_i_split;

      //asb_eidle_rx  <= asb_eidle_rx_i;  //Patch for EIDLE - Lane 0
      asb_eidle_rx[0]  <= asb_eidle_rx_i_split[0];
      asb_eidle_rx[1]  <= asb_eidle_rx_i_split[1];
      //[3.9.2017] removed for compliance mode support
      //if(line_active)  //Found some TS activity
      //   asb_eidle_rx[1]  <= 1'b0;  //Drive for at least 4 pclks so that store_all_eexit is asserted
      //else
      //   asb_eidle_rx[1]  <= asb_eidle_rx_i[1];
   end
end

// X4 Problem:(Board debug with Exerciser)
// Find TS1/2 on Lane 0 & force asb_elec_idle to ZERO for few clks so that
// LTSSM doesn't enter POL_COMPLIANCE after 24 MS timeout.
// This is due to rx_elec_idle[0] assertion always from PCS
always @(posedge pclk or negedge rst_n) begin
   if (!rst_n)  {line_active,comma,exit_done} <= 'd0;
   else begin
      comma <= ((asb_data_i_split[31:24] == COM) && asb_kcntl_i_split[3]||
                (asb_data_i_split[23:16] == COM) && asb_kcntl_i_split[2]);

      if(line_active_split) begin   //Resetting  (after 16 pclks -- next Comma)
         if(comma_split || (phy_ltssm_state_split != 'd1)) line_active  <= 1'b0;
      end
      else if(comma_split && (phy_ltssm_state_split == 'd1) && ~exit_done_split) //Setting  (POLLING)
         line_active  <= 1'b1;

      //Do the above "force elec exit" only once
      if(phy_ltssm_state_split != 'd1) exit_done  <= 1'b0; //Reset it when goes back to DETECT
      else if(line_active_split)       exit_done  <= 1'b1; //Exit done
   end
end

always@* begin rx_data_split<={rx_data>>1,descram_out[0]};rx_data_k_split<={rx_data_k>>1,descram_out[1]};rx_valid_split<={rx_valid>>1,descram_out[2]};rx_elec_idle_split<={rx_elec_idle>>1,descram_out[3]};rx_status_split<={rx_status>>1,descram_out[4]};phy_status_split<=descram_out[5];phy_disable_scr_split<={phy_disable_scr>>1,descram_out[6]};phy_inv_polar_split<={phy_inv_polar>>1,descram_out[7]};phy_eidle_tx_split<={phy_eidle_tx>>1,descram_out[8]};phy_godet_rx_split<={phy_godet_rx>>1,descram_out[9]};phy_sloopback_split<={phy_sloopback>>1,descram_out[10]};phy_snd_beacon_split<={phy_snd_beacon>>1,descram_out[11]};phy_data_split<={phy_data>>1,descram_out[12]};phy_kcntl_split<={phy_kcntl>>1,descram_out[13]};phy_fndisp_split<={phy_fndisp>>1,descram_out[14]};phy_ltssm_state_split<={phy_ltssm_state>>1,descram_out[15]};l0s_tx_state_split<={l0s_tx_state>>1,descram_out[16]};l1_state_split<={l1_state>>1,descram_out[17]};l2_state_split<={l2_state>>1,descram_out[18]};rate_5g_split<=descram_out[19];phy_deemph_split<=descram_out[20];phy_margin_split<={phy_margin>>1,descram_out[21]};force_lsm_active_split<=descram_out[22];force_rec_ei_split<=descram_out[23];force_phy_status_split<=descram_out[24];rx_status_res_split<={rx_status_res>>1,descram_out[25]};rx_status_res_sync_split<={rx_status_res_sync>>1,descram_out[26]};phy_status_sync_split<=descram_out[27];asb_skip_found_i_split<={asb_skip_found_i>>1,descram_out[28]};asb_detdone_rx_i_split<={asb_detdone_rx_i>>1,descram_out[29]};asb_detres_rx_i_split<={asb_detres_rx_i>>1,descram_out[30]};power_down_sys_split<={power_down_sys>>1,descram_out[31]};power_down_int_split<={power_down_int>>1,descram_out[32]};tx_margin_int_split<={tx_margin_int>>1,descram_out[33]};rate_int_split<=descram_out[34];tx_deemph_int_split<=descram_out[35];tx_detect_rx_reg_split<=descram_out[36];line_active_split<=descram_out[37];comma_split<=descram_out[38];exit_done_split<=descram_out[39];phy_sloopback_r1_split<=descram_out[40];phy_sloopback_r2_split<=descram_out[41];phy_status_r_split<=descram_out[42];rx_status_r_split<={rx_status_r>>1,descram_out[43]};asb_data_i_split<={asb_data_i>>1,descram_out[44]};asb_kcntl_i_split<={asb_kcntl_i>>1,descram_out[45]};asb_data_k28_5_split<={asb_data_k28_5>>1,descram_out[46]};asb_err_i_split<={asb_err_i>>1,descram_out[47]};skip_added_i_split<={skip_added_i>>1,descram_out[48]};skip_removed_i_split<={skip_removed_i>>1,descram_out[49]};asb_eidle_rx_i_split<={asb_eidle_rx_i>>1,descram_out[50]};asb_beacon_rx_i_split<={asb_beacon_rx_i>>1,descram_out[51]};asb_lane_sync_i_split<={asb_lane_sync_i>>1,descram_out[52]};rate_phy_sts_rcvd_split<={rate_phy_sts_rcvd>>1,descram_out[53]};rate_phy_sts_ext_split<=descram_out[54];rate_phy_sts_sysclk_split<={rate_phy_sts_sysclk>>1,descram_out[55]};end
always@* begin descram_in[2047]<=rx_data_k[0];descram_in[2046]<=rx_valid[0];descram_in[2044]<=rx_elec_idle[0];descram_in[2040]<=rx_status[0];descram_in[2032]<=phy_status;descram_in[2017]<=phy_disable_scr[0];descram_in[1987]<=phy_inv_polar[0];descram_in[1980]<=skip_removed_i[0];descram_in[1963]<=tx_margin_int[0];descram_in[1942]<=rate_phy_sts_ext;descram_in[1926]<=phy_eidle_tx[0];descram_in[1921]<=force_rec_ei;descram_in[1913]<=asb_eidle_rx_i[0];descram_in[1903]<=phy_status_r;descram_in[1879]<=rate_int;descram_in[1837]<=rate_phy_sts_sysclk[0];descram_in[1805]<=phy_godet_rx[0];descram_in[1795]<=force_phy_status;descram_in[1783]<=asb_data_k28_5[0];descram_in[1778]<=asb_beacon_rx_i[0];descram_in[1758]<=rx_status_r[0];descram_in[1710]<=tx_deemph_int;descram_in[1679]<=l0s_tx_state[0];descram_in[1562]<=phy_sloopback[0];descram_in[1543]<=rx_status_res[0];descram_in[1519]<=asb_err_i[0];descram_in[1509]<=asb_lane_sync_i[0];descram_in[1499]<=phy_sloopback_r1;descram_in[1469]<=asb_data_i[0];descram_in[1398]<=comma;descram_in[1373]<=tx_detect_rx_reg;descram_in[1310]<=l1_state[0];descram_in[1144]<=rate_5g;descram_in[1076]<=phy_snd_beacon[0];descram_in[1039]<=rx_status_res_sync[0];descram_in[1023]<=rx_data[0];descram_in[990]<=skip_added_i[0];descram_in[981]<=power_down_int[0];descram_in[971]<=rate_phy_sts_rcvd[0];descram_in[960]<=force_lsm_active;descram_in[951]<=phy_sloopback_r2;descram_in[891]<=asb_kcntl_i[0];descram_in[839]<=phy_ltssm_state[0];descram_in[749]<=exit_done;descram_in[699]<=line_active;descram_in[572]<=l2_state[0];descram_in[490]<=power_down_sys[0];descram_in[480]<=phy_margin[0];descram_in[419]<=phy_fndisp[0];descram_in[245]<=asb_detres_rx_i[0];descram_in[240]<=phy_deemph;descram_in[209]<=phy_kcntl[0];descram_in[122]<=asb_detdone_rx_i[0];descram_in[104]<=phy_data[0];descram_in[61]<=asb_skip_found_i[0];descram_in[30]<=phy_status_sync;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS         


// Project          : PCI Express 4X 


// File             : dfrm.v


// Description      : This module Aligns and seperates the DLLP & TLLP packets 


//                    recived 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh


// Mod. Date        : Nov 1, 2015


// =============================================================================



`timescale 1 ns / 100 ps
module dfrm #( 
   parameter D_WIDTH   = 64) (
   input wire                   sys_clk,      
   input wire                   rst_n,        
   input wire [D_WIDTH-1:0]     dgrx_data,    
   input wire [(D_WIDTH/8)-1:0] dgrx_kcntl,   
   input wire                   dgrx_val,     
   input wire [1:0]             dgrx_err,     

   output reg [D_WIDTH-1:0]     dfrm_ddata,   
   output reg                   dfrm_dval,    
   output reg [D_WIDTH-1:0]     dfrm_tdata,   
   output wire                  dfrm_tval,    
   output reg                   dfrm_st,      
   output reg                   dfrm_end,     
   output reg                   dfrm_edb,     
   output reg                   dfrm_dwen,    
   output reg [15:0]            dfrm_seq,     
   output reg [31:0]            dfrm_lcrc     // TLLP LCRC data


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
reg [D_WIDTH-1:0]      datain_d0, datain_d1, datain_d2, datain_d3, int_tdata;
reg [7:0]              sdp_dec_d0, sdp_dec_d1, dtval;
reg [7:0]              stp_dec_d0, stp_dec_d1, stp_dec_d2, stp_dec_d3;
reg [7:0]              end_dec_d0, end_dec_d1, end_dec_d2, end_dec_d3;
reg [7:0]              edb_dec_d0, edb_dec_d1, edb_dec_d2, edb_dec_d3;
reg [15:0]             int_seq;
reg [31:0]             int_lcrc;
reg                    int_tval, int_st, int_end, int_edb, int_dwen,dfrm_tval_s,dgrx_val_d;
reg [(D_WIDTH/8)-1:0]  kcntlin_d0;
wire [D_WIDTH-1:0]     dgrx_data_mod;
integer                ti,tj,tk;
reg [D_WIDTH - 1 : 0] dgrx_data_split;
reg [(D_WIDTH / 8) - 1 : 0] dgrx_kcntl_split;
reg dgrx_val_split;
reg [1 : 0] dgrx_err_split;
reg [D_WIDTH - 1 : 0] datain_d0_split;
reg [D_WIDTH - 1 : 0] datain_d1_split;
reg [D_WIDTH - 1 : 0] datain_d2_split;
reg [D_WIDTH - 1 : 0] datain_d3_split;
reg [D_WIDTH - 1 : 0] int_tdata_split;
reg [7 : 0] sdp_dec_d0_split;
reg [7 : 0] sdp_dec_d1_split;
reg [7 : 0] dtval_split;
reg [7 : 0] stp_dec_d0_split;
reg [7 : 0] stp_dec_d1_split;
reg [7 : 0] stp_dec_d2_split;
reg [7 : 0] stp_dec_d3_split;
reg [7 : 0] end_dec_d0_split;
reg [7 : 0] end_dec_d1_split;
reg [7 : 0] end_dec_d2_split;
reg [7 : 0] end_dec_d3_split;
reg [7 : 0] edb_dec_d0_split;
reg [7 : 0] edb_dec_d1_split;
reg [7 : 0] edb_dec_d2_split;
reg [7 : 0] edb_dec_d3_split;
reg [15 : 0] int_seq_split;
reg [31 : 0] int_lcrc_split;
reg int_tval_split;
reg int_st_split;
reg int_end_split;
reg int_edb_split;
reg int_dwen_split;
reg dfrm_tval_s_split;
reg dgrx_val_d_split;
reg [(D_WIDTH / 8) - 1 : 0] kcntlin_d0_split;
reg [D_WIDTH - 1 : 0] dgrx_data_mod_split;
reg [2047:0] descram_in;
wire [34:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 35,descram_inst_SCRAMSTRING = 32'hfdffca8b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// Parameters 
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================


// =============================================================================
// Decode the incomming data and find the SDP/STP/END/EDB 
// Data recived Byte number [63:0]   = 7,6,5,4,3,2,1,0
// Lane number                       = 7,6,5,4,3,2,1,0
// =============================================================================
// Corrupt bit 35:32 and 3:0 of the received data when dgrx_err is seen
assign dgrx_data_mod = {dgrx_data_split[63:34], (dgrx_data_split[33:32] ^ dgrx_err_split), dgrx_data_split[31:2], (dgrx_data_split[1:0] ^ dgrx_err_split)};

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin  
      {datain_d0,datain_d1,datain_d2,datain_d3,kcntlin_d0} <= 'd0;
      {sdp_dec_d0,stp_dec_d0,sdp_dec_d1,stp_dec_d1,stp_dec_d2,stp_dec_d3} <= 'd0;
      {end_dec_d0,edb_dec_d0,end_dec_d1,end_dec_d2,end_dec_d3,edb_dec_d1,edb_dec_d2,edb_dec_d3} <= 'd0; 
   end
   else begin   
      // Flop the data recived  
      datain_d0 <= (dgrx_val_split) ? dgrx_data_mod_split : datain_d0_split;
      datain_d1 <= (dgrx_val_split) ? datain_d0_split : datain_d1_split;
      datain_d2 <= (dgrx_val_split) ? datain_d1_split : datain_d2_split;
      datain_d3 <= (dgrx_val_split) ? datain_d2_split : datain_d3_split;
      kcntlin_d0<= (dgrx_val_split) ? dgrx_kcntl_split: kcntlin_d0_split;

      // Decode all the bytes for SDP   Start of DLLP 
      sdp_dec_d0[7] <= ((dgrx_data_mod_split[63:56] == K28_2) & dgrx_kcntl_split[7]); 
      sdp_dec_d0[6] <= ((dgrx_data_mod_split[55:48] == K28_2) & dgrx_kcntl_split[6]); 
      sdp_dec_d0[5] <= ((dgrx_data_mod_split[47:40] == K28_2) & dgrx_kcntl_split[5]); 
      sdp_dec_d0[4] <= ((dgrx_data_mod_split[39:32] == K28_2) & dgrx_kcntl_split[4]); 
      sdp_dec_d0[3] <= ((dgrx_data_mod_split[31:24] == K28_2) & dgrx_kcntl_split[3]);
      sdp_dec_d0[2] <= ((dgrx_data_mod_split[23:16] == K28_2) & dgrx_kcntl_split[2]);
      sdp_dec_d0[1] <= ((dgrx_data_mod_split[15:8]  == K28_2) & dgrx_kcntl_split[1]);
      sdp_dec_d0[0] <= ((dgrx_data_mod_split[7:0]   == K28_2) & dgrx_kcntl_split[0]);

      // Decode all the bytes for STP   Start of TLLP 
      stp_dec_d0[7] <= ((dgrx_data_mod_split[63:56] == K27_7) & dgrx_kcntl_split[7]); 
      stp_dec_d0[6] <= ((dgrx_data_mod_split[55:48] == K27_7) & dgrx_kcntl_split[6]); 
      stp_dec_d0[5] <= ((dgrx_data_mod_split[47:40] == K27_7) & dgrx_kcntl_split[5]); 
      stp_dec_d0[4] <= ((dgrx_data_mod_split[39:32] == K27_7) & dgrx_kcntl_split[4]); 
      stp_dec_d0[3] <= ((dgrx_data_mod_split[31:24] == K27_7) & dgrx_kcntl_split[3]);
      stp_dec_d0[2] <= ((dgrx_data_mod_split[23:16] == K27_7) & dgrx_kcntl_split[2]);
      stp_dec_d0[1] <= ((dgrx_data_mod_split[15:8]  == K27_7) & dgrx_kcntl_split[1]);
      stp_dec_d0[0] <= ((dgrx_data_mod_split[7:0]   == K27_7) & dgrx_kcntl_split[0]);

      // Decode all the bytes for END  End of TLLP 
      if (dgrx_val_split) begin
         end_dec_d0[7] <=  ((dgrx_data_mod_split[63:56] == K29_7) & dgrx_kcntl_split[7]) & ~((datain_d0_split[55:48] == K28_2) & kcntlin_d0_split[6]); 
         end_dec_d0[6] <=  ((dgrx_data_mod_split[55:48] == K29_7) & dgrx_kcntl_split[6]) & ~((datain_d0_split[47:40] == K28_2) & kcntlin_d0_split[5]); 
         end_dec_d0[5] <=  ((dgrx_data_mod_split[47:40] == K29_7) & dgrx_kcntl_split[5]) & ~((datain_d0_split[39:32] == K28_2) & kcntlin_d0_split[4]); 
         end_dec_d0[4] <=  ((dgrx_data_mod_split[39:32] == K29_7) & dgrx_kcntl_split[4]) & ~((datain_d0_split[31:24] == K28_2) & kcntlin_d0_split[3]); 
         end_dec_d0[3] <=  ((dgrx_data_mod_split[31:24] == K29_7) & dgrx_kcntl_split[3]) & ~((datain_d0_split[23:16] == K28_2) & kcntlin_d0_split[2]);
         end_dec_d0[2] <=  ((dgrx_data_mod_split[23:16] == K29_7) & dgrx_kcntl_split[2]) & ~((datain_d0_split[15:8]  == K28_2) & kcntlin_d0_split[1]);
         end_dec_d0[1] <=  ((dgrx_data_mod_split[15:8]  == K29_7) & dgrx_kcntl_split[1]) & ~((datain_d0_split[7:0]   == K28_2) & kcntlin_d0_split[0]);
         end_dec_d0[0] <=  ((dgrx_data_mod_split[7:0]   == K29_7) & dgrx_kcntl_split[0]) & ~((dgrx_data_mod_split[63:56] == K28_2) & dgrx_kcntl_split[7]);
      end

      // Decode all the bytes for EDB  End of BAD TLLP 
      if (dgrx_val_split) begin
         edb_dec_d0[7] <= ((dgrx_data_mod_split[63:56] == K30_7) & dgrx_kcntl_split[7]); 
         edb_dec_d0[6] <= ((dgrx_data_mod_split[55:48] == K30_7) & dgrx_kcntl_split[6]); 
         edb_dec_d0[5] <= ((dgrx_data_mod_split[47:40] == K30_7) & dgrx_kcntl_split[5]); 
         edb_dec_d0[4] <= ((dgrx_data_mod_split[39:32] == K30_7) & dgrx_kcntl_split[4]); 
         edb_dec_d0[3] <= ((dgrx_data_mod_split[31:24] == K30_7) & dgrx_kcntl_split[3]);
         edb_dec_d0[2] <= ((dgrx_data_mod_split[23:16] == K30_7) & dgrx_kcntl_split[2]);
         edb_dec_d0[1] <= ((dgrx_data_mod_split[15:8]  == K30_7) & dgrx_kcntl_split[1]);
         edb_dec_d0[0] <= ((dgrx_data_mod_split[7:0]   == K30_7) & dgrx_kcntl_split[0]);
      end

      sdp_dec_d1    <= (dgrx_val_split) ? sdp_dec_d0_split : sdp_dec_d1_split;

      stp_dec_d1    <= (dgrx_val_split) ? stp_dec_d0_split : stp_dec_d1_split;
      stp_dec_d2    <= (dgrx_val_split) ? stp_dec_d1_split : stp_dec_d2_split;
      stp_dec_d3    <= (dgrx_val_split) ? stp_dec_d2_split : stp_dec_d3_split;

      end_dec_d1    <= (dgrx_val_split) ? end_dec_d0_split : end_dec_d1_split;
      edb_dec_d1    <= (dgrx_val_split) ? edb_dec_d0_split : edb_dec_d1_split; 

      end_dec_d2    <= (dgrx_val_split) ? end_dec_d1_split : end_dec_d2_split;
      end_dec_d3    <= (dgrx_val_split) ? end_dec_d2_split : end_dec_d3_split;
   
      edb_dec_d2    <= (dgrx_val_split) ? edb_dec_d1_split : edb_dec_d2_split; 
      edb_dec_d3    <= (dgrx_val_split) ? edb_dec_d2_split : edb_dec_d3_split; 
   end
end

// =============================================================================
// Generate DLLP/TLLP valid signals the following signals are set on DLLP/TLLP
// SDP/STP and cleared on END/EDB 
// SDP/STP Byte Loc         END/EDB Byte Loc
//(ti)                      (tj/tk)
// 7                         0/4 
// 6                        *7/3 
// 5                        *6/2 
// 4                        *5/1 
// 3                        *4/0 
// 2                        *3/7 
// 1                        *2/6 
// 0                        *1/5 
// * indicates that the data valid has to be pulled down by looking at the 
// previous data.
// =============================================================================
// Generate data valid signal if STP found in lane 7,6,5,4,3,2,1,0.
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) dtval <= 'd0;
   else if (dgrx_val_split) begin   
      //Byte 0
      if (stp_dec_d2_split[0])         dtval[0]  <= 1'b1;
      else if (|stp_dec_d2_split[7:1]) dtval[0]  <= 1'b0; 

      //Byte 1
      if (stp_dec_d2_split[1])                           dtval[1]  <= 1'b1;
      else if ((|stp_dec_d2_split[7:2]) | stp_dec_d2_split[0]) dtval[1]  <= 1'b0; 

      //Byte 2
      if (stp_dec_d2_split[2])                                dtval[2]  <= 1'b1;
      else if ((|stp_dec_d2_split[7:3]) | (|stp_dec_d2_split[1:0])) dtval[2]  <= 1'b0; 

      //Byte 3
      if (stp_dec_d2_split[3])                                dtval[3]  <= 1'b1;
      else if ((|stp_dec_d2_split[7:4]) | (|stp_dec_d2_split[2:0])) dtval[3]  <= 1'b0; 

      //Byte 4
      if (stp_dec_d2_split[4])                                dtval[4]  <= 1'b1;
      else if ((|stp_dec_d2_split[7:5]) | (|stp_dec_d2_split[3:0])) dtval[4]  <= 1'b0; 

      //Byte 5
      if (stp_dec_d2_split[5])                                dtval[5]  <= 1'b1;
      else if ((|stp_dec_d2_split[7:6]) | (|stp_dec_d2_split[4:0])) dtval[5]  <= 1'b0;

      //Byte 6
      if (stp_dec_d2_split[6])                              dtval[6]  <= 1'b1;
      else if ((|stp_dec_d2_split[7]) | (|stp_dec_d2_split[5:0])) dtval[6]  <= 1'b0; 

      //Byte 7
      if (stp_dec_d2_split[7])         dtval[7]  <= 1'b1;
      else if (|stp_dec_d2_split[6:0]) dtval[7]  <= 1'b0; 
   end
end

// =============================================================================
// Generate Aligned DLLP Data
// Multiplex different byte lanes of data from 2 pipelined
// registers based on different valid signals.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin   
      dfrm_ddata  <= 'd0;
      dfrm_dval   <= 'd0;
   end
   else if (dgrx_val_split) begin   
      case (1'b1)
         sdp_dec_d1_split[7] : begin  
            dfrm_ddata  <= {datain_d1_split[55:0], datain_d0_split[63:56]};
            dfrm_dval   <= 1'b1; 
         end
         sdp_dec_d1_split[6] :   begin
            dfrm_ddata  <= {datain_d1_split[47:0], datain_d0_split[63:48]};
            dfrm_dval   <= 1'b1; 
         end
         sdp_dec_d1_split[5] :   begin
            dfrm_ddata  <= {datain_d1_split[39:0], datain_d0_split[63:40]};
            dfrm_dval   <= 1'b1; 
         end
         sdp_dec_d1_split[4] :   begin
            dfrm_ddata  <= {datain_d1_split[31:0], datain_d0_split[63:32]};
            dfrm_dval   <= 1'b1; 
         end
         sdp_dec_d1_split[3] :   begin
            dfrm_ddata  <= {datain_d1_split[23:0], datain_d0_split[63:24]};
            dfrm_dval   <= 1'b1; 
         end
         sdp_dec_d1_split[2] :   begin
            dfrm_ddata  <= {datain_d1_split[15:0], datain_d0_split[63:16]};
            dfrm_dval   <= 1'b1; 
         end
         sdp_dec_d1_split[1] :   begin
            dfrm_ddata  <= {datain_d1_split[7:0], datain_d0_split[63:8]};
            dfrm_dval   <= 1'b1; 
         end
         sdp_dec_d1_split[0] :   begin
            dfrm_ddata  <= datain_d0_split[63:0];
            dfrm_dval   <= 1'b1; 
         end
         default :  begin
            dfrm_ddata  <= 'd0;
            dfrm_dval   <= 1'b0; 
         end
      endcase
   end
   else begin
      dfrm_dval   <= 1'b0;
   end
end

// =============================================================================
// Generate Aligned TLLP Data
// Multiplex different byte lanes of data from 2 pipelined
// registers based on different valid signals.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) {int_seq,int_tdata,int_tval} <= 'd0;
   else if (dgrx_val_split) begin  
      case (1'b1)
         dtval_split[7]: begin  
            int_seq    <= (stp_dec_d3_split[7]) ? datain_d3_split[55:40] : int_seq_split;
            int_tdata  <= {datain_d3_split[39:0], datain_d2_split[63:40]};
            int_tval   <= 1'b1;
         end
         dtval_split[6]:   begin
            int_seq    <= (stp_dec_d3_split[6]) ? datain_d3_split[47:32] : int_seq_split;
            int_tdata  <= {datain_d3_split[31:0], datain_d2_split[63:32]};
            int_tval   <= 1'b1;
         end
         dtval_split[5]:   begin
            int_seq    <= (stp_dec_d3_split[5]) ? datain_d3_split[39:24] : int_seq_split;
            int_tdata  <= {datain_d3_split[23:0], datain_d2_split[63:24]};
            int_tval   <= 1'b1;
         end
         dtval_split[4]:   begin
            int_seq    <= (stp_dec_d3_split[4]) ? datain_d3_split[31:16] : int_seq_split;
            int_tdata  <= {datain_d3_split[15:0], datain_d2_split[63:16]};
            int_tval   <= 1'b1;
         end
         dtval_split[3]:   begin
            int_seq    <= (stp_dec_d3_split[3]) ? datain_d3_split[23:8] : int_seq_split;
            int_tdata  <= {datain_d3_split[7:0], datain_d2_split[63:8]};
            int_tval   <= 1'b1;
         end
         dtval_split[2]:   begin
            int_seq    <= (stp_dec_d3_split[2]) ? datain_d3_split[15:0] : int_seq_split;
            int_tdata  <= datain_d2_split;
            int_tval   <= 1'b1;
         end
         dtval_split[1]:   begin
            int_seq    <= (stp_dec_d3_split[1]) ? {datain_d3_split[7:0],datain_d2_split[63:56]} : int_seq_split;
            int_tdata  <= {datain_d2_split[55:0], datain_d1_split[63:56]};
            int_tval   <= 1'b1;
         end
         dtval_split[0]:   begin
            int_seq    <= (stp_dec_d3_split[0]) ? datain_d2_split[63:48]: int_seq_split;
            int_tdata  <= {datain_d2_split[47:0],datain_d1_split[63:48]};
            int_tval   <= 1'b1;
         end
         default : {int_seq,int_tdata,int_tval} <= 'd0;
      endcase
   end
end

// =============================================================================
// Generate aligned start TLP from STP found in different byte lanes.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)                       int_st <= 1'b0 ;
   else if (|stp_dec_d3_split && dgrx_val_split) int_st <= 1'b1 ;
   else                              int_st <= 1'b0 ;
end

// =============================================================================
// Generate aligned end of packet from END found in different byte lanes.
// Generate aligned edb of packet from EDB found in different byte lanes.
// Generate DWEN signal as follows, the EBD can be present as shown below, hence
// the "dwen" signal is active when EDB is found on byte 4
// data Bytes     7  6  5  4  3  2  1  0
// EDB            -  -  -  -  -  -  -  X 
// EDB            -  -  -  X 
// 7                        0/4 
// 6                        7/3 
// 5                        6/2 
// 4                        5/1 
// 3                        4/0 
// 2                        3/7 
// 1                        2/6 
// 0                        1/5 
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) {int_lcrc,int_end,int_edb,int_dwen} <= 'd0;
   else if (dgrx_val_split) begin  
      // Store LCRC ONLY when END is received for a TLP and not DLLP
      case (1'b1) // 08/08/08 - fixed to take care NAK on back-to-back TLPs
         end_dec_d1_split[7],edb_dec_d1_split[7] : int_lcrc <= datain_d2_split[31:0];
         end_dec_d1_split[6],edb_dec_d1_split[6] : int_lcrc <= {datain_d2_split[23:0],datain_d1_split[63:56]};
         end_dec_d1_split[5],edb_dec_d1_split[5] : int_lcrc <= {datain_d2_split[15:0],datain_d1_split[63:48]};
         end_dec_d1_split[4],edb_dec_d1_split[4] : int_lcrc <= {datain_d2_split[7:0], datain_d1_split[63:40]};
         end_dec_d1_split[3],edb_dec_d1_split[3] : int_lcrc <= datain_d1_split[63:32];
         end_dec_d1_split[2],edb_dec_d1_split[2] : int_lcrc <= datain_d1_split[55:24];
         end_dec_d1_split[1],edb_dec_d1_split[1] : int_lcrc <= datain_d1_split[47:16];
         end_dec_d1_split[0],edb_dec_d1_split[0] : int_lcrc <= datain_d1_split[39:8];
      endcase
      // Generate END when END is received for a TLP and not DLLP
      case (1'b1)
         dtval_split[7] : begin  
            int_end   <= (end_dec_d2_split[0] | end_dec_d2_split[4]);
            int_edb   <= (edb_dec_d2_split[0] | edb_dec_d2_split[4]);
            int_dwen  <= (end_dec_d2_split[4] | edb_dec_d2_split[4]);
         end
         dtval_split[6] :   begin
            int_end   <= (end_dec_d1_split[7] | end_dec_d2_split[3]);
            int_edb   <= (edb_dec_d1_split[7] | edb_dec_d2_split[3]);
            int_dwen  <= (end_dec_d2_split[3] | edb_dec_d2_split[3]);
         end
         dtval_split[5] :   begin
            int_end   <= (end_dec_d1_split[6] | end_dec_d2_split[2]);
            int_edb   <= (edb_dec_d1_split[6] | edb_dec_d2_split[2]);
            int_dwen  <= (end_dec_d2_split[2] | edb_dec_d2_split[2]);
         end
         dtval_split[4] :   begin
            int_end   <= (end_dec_d1_split[5] | end_dec_d2_split[1]);
            int_edb   <= (edb_dec_d1_split[5] | edb_dec_d2_split[1]);
            int_dwen  <= (end_dec_d2_split[1] | edb_dec_d2_split[1]);
         end
         dtval_split[3] :   begin
            int_end   <= (end_dec_d1_split[4] | end_dec_d2_split[0]);
            int_edb   <= (edb_dec_d1_split[4] | edb_dec_d2_split[0]);
            int_dwen  <= (end_dec_d2_split[0] | edb_dec_d2_split[0]);
         end
         dtval_split[2] :   begin
            int_end   <= (end_dec_d1_split[3] | end_dec_d1_split[7]);
            int_edb   <= (edb_dec_d1_split[3] | edb_dec_d1_split[7]);
            int_dwen  <= (end_dec_d1_split[7] | edb_dec_d1_split[7]);
         end
         dtval_split[1] :   begin
            int_end   <= (end_dec_d1_split[2] | end_dec_d1_split[6]);
            int_edb   <= (edb_dec_d1_split[2] | edb_dec_d1_split[6]);
            int_dwen  <= (end_dec_d1_split[6] | edb_dec_d1_split[6]);
         end
         dtval_split[0] :   begin
            int_end   <= (end_dec_d1_split[1] | end_dec_d1_split[5]);
            int_edb   <= (edb_dec_d1_split[1] | edb_dec_d1_split[5]);
            int_dwen  <= (end_dec_d1_split[5] | edb_dec_d1_split[5]);
         end
         default : {int_end,int_edb,int_dwen} <= 'd0;
      endcase
   end
   else {int_end,int_edb,int_dwen} <= 'd0;
end

// Modify the way data is presented to DLL  
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)    
      {dgrx_val_d,dfrm_tdata,dfrm_st,dfrm_end,dfrm_edb,dfrm_dwen,dfrm_tval_s,dfrm_lcrc,dfrm_seq} <= 'd0;
   else begin
      dgrx_val_d <= dgrx_val_split;
      dfrm_tdata <= int_tdata_split;
      dfrm_st    <= (dgrx_val_d_split) ? int_st_split   : dfrm_st;
      dfrm_end   <= (dgrx_val_d_split) ? int_end_split  : dfrm_end;
      dfrm_edb   <= (dgrx_val_d_split) ? int_edb_split  : dfrm_edb;
      dfrm_dwen  <= (dgrx_val_d_split) ? int_dwen_split : dfrm_dwen;
      dfrm_lcrc  <= (dgrx_val_d_split) ? int_lcrc_split : dfrm_lcrc; 
      dfrm_seq   <= (dgrx_val_d_split) ? int_seq_split  : dfrm_seq; 

      if (int_st_split && dgrx_val_d_split)                     dfrm_tval_s  <= 1'b1;  
      else if ((dfrm_end | dfrm_edb) && dgrx_val_d_split) dfrm_tval_s  <= 1'b0;  
   end
end

assign dfrm_tval = dfrm_tval_s_split & dgrx_val_d_split;

always@* begin dgrx_data_split<={dgrx_data>>1,descram_out[0]};dgrx_kcntl_split<={dgrx_kcntl>>1,descram_out[1]};dgrx_val_split<=descram_out[2];dgrx_err_split<={dgrx_err>>1,descram_out[3]};datain_d0_split<={datain_d0>>1,descram_out[4]};datain_d1_split<={datain_d1>>1,descram_out[5]};datain_d2_split<={datain_d2>>1,descram_out[6]};datain_d3_split<={datain_d3>>1,descram_out[7]};int_tdata_split<={int_tdata>>1,descram_out[8]};sdp_dec_d0_split<={sdp_dec_d0>>1,descram_out[9]};sdp_dec_d1_split<={sdp_dec_d1>>1,descram_out[10]};dtval_split<={dtval>>1,descram_out[11]};stp_dec_d0_split<={stp_dec_d0>>1,descram_out[12]};stp_dec_d1_split<={stp_dec_d1>>1,descram_out[13]};stp_dec_d2_split<={stp_dec_d2>>1,descram_out[14]};stp_dec_d3_split<={stp_dec_d3>>1,descram_out[15]};end_dec_d0_split<={end_dec_d0>>1,descram_out[16]};end_dec_d1_split<={end_dec_d1>>1,descram_out[17]};end_dec_d2_split<={end_dec_d2>>1,descram_out[18]};end_dec_d3_split<={end_dec_d3>>1,descram_out[19]};edb_dec_d0_split<={edb_dec_d0>>1,descram_out[20]};edb_dec_d1_split<={edb_dec_d1>>1,descram_out[21]};edb_dec_d2_split<={edb_dec_d2>>1,descram_out[22]};edb_dec_d3_split<={edb_dec_d3>>1,descram_out[23]};int_seq_split<={int_seq>>1,descram_out[24]};int_lcrc_split<={int_lcrc>>1,descram_out[25]};int_tval_split<=descram_out[26];int_st_split<=descram_out[27];int_end_split<=descram_out[28];int_edb_split<=descram_out[29];int_dwen_split<=descram_out[30];dfrm_tval_s_split<=descram_out[31];dgrx_val_d_split<=descram_out[32];kcntlin_d0_split<={kcntlin_d0>>1,descram_out[33]};dgrx_data_mod_split<={dgrx_data_mod>>1,descram_out[34]};end
always@* begin descram_in[2047]<=dgrx_kcntl[0];descram_in[2046]<=dgrx_val;descram_in[2044]<=dgrx_err[0];descram_in[2040]<=datain_d0[0];descram_in[2032]<=datain_d1[0];descram_in[2017]<=datain_d2[0];descram_in[1987]<=datain_d3[0];descram_in[1926]<=int_tdata[0];descram_in[1804]<=sdp_dec_d0[0];descram_in[1803]<=edb_dec_d3[0];descram_in[1761]<=dgrx_val_d;descram_in[1560]<=sdp_dec_d1[0];descram_in[1558]<=int_seq[0];descram_in[1550]<=end_dec_d0[0];descram_in[1475]<=kcntlin_d0[0];descram_in[1464]<=int_dwen;descram_in[1072]<=dtval[0];descram_in[1069]<=int_lcrc[0];descram_in[1052]<=end_dec_d1[0];descram_in[1023]<=dgrx_data[0];descram_in[902]<=dgrx_data_mod[0];descram_in[901]<=edb_dec_d2[0];descram_in[880]<=dfrm_tval_s;descram_in[775]<=stp_dec_d3[0];descram_in[732]<=int_edb;descram_in[450]<=edb_dec_d1[0];descram_in[387]<=stp_dec_d2[0];descram_in[366]<=int_end;descram_in[225]<=edb_dec_d0[0];descram_in[193]<=stp_dec_d1[0];descram_in[183]<=int_st;descram_in[112]<=end_dec_d3[0];descram_in[96]<=stp_dec_d0[0];descram_in[91]<=int_tval;descram_in[56]<=end_dec_d2[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : frm.v


// Description      : This module instintiates all sub modules for framer


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh


// Mod. Date        : Nov 1, 2015


// =============================================================================



`timescale 1 ns / 100 ps
module frm #(
   parameter LANE_WIDTH   = 2 ,
   parameter D_WIDTH      = 64 ) (
   input wire                   sys_clk,        
   input wire                   rst_n,          
   input wire [9:0]             SKP_INS_CNT,    
   input wire [D_WIDTH -1:0]    tdmux_data,     
   input wire                   tdmux_st,       
   input wire                   tdmux_end,      
   input wire                   tdmux_edb,      
   input wire                   tdmux_dwen,     
   input wire                   tdmux_val,      
   input wire                   tdmux_dllp,     
   input wire [2:0]             ltssm_cfgln_sum,
   input wire                   tdmux_skp,      
   input wire [D_WIDTH -1:0]    ose_data,       
   input wire [D_WIDTH/8-1:0]   ose_kcntl,      
   input wire [D_WIDTH/8-1:0]   ose_fndisp,     
   input wire [LANE_WIDTH-1:0]  ose_val,        
   input wire [LANE_WIDTH-1:0]  ose_eidle_tx,   
   input wire [LANE_WIDTH-1:0]  ose_skp_clr,    
   input wire [3:0]             ltssm_state,    
   input wire                   pol_compliance, 
   input                        ltssm_l0,

   output reg [3:0]            frm_skp_cnt,    
   output reg [1:0]            frm_skpq_nclks, 
   output reg                  frm_skpq_val,   
   output reg [D_WIDTH -1:0]   frm_data,       
   output reg [D_WIDTH/8-1:0]  frm_kcntl,      
   output reg [D_WIDTH/8-1:0]  frm_fndisp,     
   output reg [LANE_WIDTH-1:0] frm_eidle_tx,   
   output reg                  frm_os_valid,   
   output reg                  frm_val         // Indicates Data & Kntl is valid


   );
localparam K27_7 = 8'hFB ;
localparam K28_2 = 8'h5C ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K28_0 = 8'h1C ;
localparam K28_5 = 8'hBC ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
reg [D_WIDTH -1:0]  algn_data;
reg [D_WIDTH/8-1:0] algn_kcntl;
reg [D_WIDTH/8-1:0] skp_ktrl_0;
reg                 algn_val;
reg                 algn_skp;
reg                 snd_skp_miss;
reg [7:0]           datain_d0;
reg [9:0]           count;
reg                 count_p;
reg [D_WIDTH -1:0]  skp_data_1, skp_data_0;
reg                 sos_mlsd, algn_val_m;
reg [1:0] reset_delay_n;
reg       tx_ei_rst_n;
reg [9 : 0] SKP_INS_CNT_split;
reg [D_WIDTH - 1 : 0] tdmux_data_split;
reg tdmux_st_split;
reg tdmux_end_split;
reg tdmux_edb_split;
reg tdmux_dwen_split;
reg tdmux_val_split;
reg tdmux_dllp_split;
reg [2 : 0] ltssm_cfgln_sum_split;
reg tdmux_skp_split;
reg [D_WIDTH - 1 : 0] ose_data_split;
reg [D_WIDTH / 8 - 1 : 0] ose_kcntl_split;
reg [D_WIDTH / 8 - 1 : 0] ose_fndisp_split;
reg [LANE_WIDTH - 1 : 0] ose_val_split;
reg [LANE_WIDTH - 1 : 0] ose_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] ose_skp_clr_split;
reg [3 : 0] ltssm_state_split;
reg pol_compliance_split;
reg ltssm_l0_split;
reg [D_WIDTH - 1 : 0] algn_data_split;
reg [D_WIDTH / 8 - 1 : 0] algn_kcntl_split;
reg [D_WIDTH / 8 - 1 : 0] skp_ktrl_0_split;
reg algn_val_split;
reg algn_skp_split;
reg snd_skp_miss_split;
reg [7 : 0] datain_d0_split;
reg [9 : 0] count_split;
reg count_p_split;
reg [D_WIDTH - 1 : 0] skp_data_1_split;
reg [D_WIDTH - 1 : 0] skp_data_0_split;
reg sos_mlsd_split;
reg algn_val_m_split;
reg [1 : 0] reset_delay_n_split;
reg [2047:0] descram_in;
wire [32:0] descram_out;

localparam descram_inst_SIZE = 33,descram_inst_SCRAMSTRING = 32'hfdffe06b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

// =============================================================================
// K & Special Symbols decodes.
//
// =============================================================================
// Frame Alignment logic
// =============================================================================
// Insert special symbols in the begining and end of the packets
// and re-allign the data stream
// Insert K28.2 (SDP) at start & K29.7 (END) symbol at end of DLLP
// Insert K27.7 (STP) at start & K29.7 (END)/K30.7 (ENDB) symbol at end of TLLP
// DLLP Width = 2 DW
// TLLP Width = 3 DW Minimum
always @(posedge sys_clk or negedge rst_n) begin
  if (!rst_n) begin
    {datain_d0,algn_data,algn_kcntl,algn_skp} <= 'd0;
    snd_skp_miss <= 1'b0;
  end
   else if (tdmux_val_split) begin
      datain_d0 <= tdmux_data_split[7:0]; // Pipeline input data stream
      algn_skp  <= tdmux_skp_split & ltssm_l0_split;
      snd_skp_miss <= tdmux_skp_split & ~ltssm_l0_split;
      case(1'b1)
         tdmux_dllp_split :
            {algn_data,algn_kcntl}  <= {K28_2,tdmux_data_split[55:8],K29_7, 8'b1000_0001};
         tdmux_st_split :
            {algn_data,algn_kcntl}  <= {K27_7, tdmux_data_split[63:8], 8'b1000_0000};
         tdmux_end_split :
            {algn_data,algn_kcntl}  <= tdmux_dwen_split ? {datain_d0_split[7:0], tdmux_data_split[63:48],K29_7,32'd0, 8'b0001_0000}:
                                                    {datain_d0_split[7:0], tdmux_data_split[63:16],K29_7, 8'b0000_0001};
         tdmux_edb_split :
            {algn_data,algn_kcntl}  <= tdmux_dwen_split ? {datain_d0_split[7:0],tdmux_data_split[63:48],K30_7, 32'd0, 8'b0001_0000}:
                                                    {datain_d0_split[7:0], tdmux_data_split[63:16],K30_7, 8'b0000_0001};
         default :
            {algn_data,algn_kcntl}  <= {datain_d0_split[7:0],tdmux_data_split[63:8], 8'b0000_0000};
      endcase
   end
   else begin
     algn_skp <= 1'b0;
     snd_skp_miss <= 1'b0;
   end
end

// Generate align valid
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)         algn_val   <= 1'b0;
   else if (tdmux_skp_split) algn_val   <= 1'b0;
   else                algn_val   <= tdmux_val_split;
end

// =============================================================================
// Frame Skip Q logic
// =============================================================================
// The skip ordered set needs to be scheduled for insersion in transmitting
// stream. The number of such indications queued are counted. Whenever this
// count is greater than 0 the skip ordered set pending is indicated and the
// queue count is presented to frm_ins logic. The skip ordered set will be
// scheduled for insertion at an interval between 1180 and 1538 symboltimes.
// In X4: Since the Data bus = 64 , 8 symbols are sent every clock cycle so
// the interval is between 1180/8 =147 and 1538/8 = 192 clock intervals.
// This value is set through a `define currently set to 190.
// in X1: Since the Data bus = 16 , 2 symbols are sent every clock cycle so
// the interval is between 1180/2 = 590  and 1538/8 = 769 clock intervals.
// This value is set through a `define currently set to 590.
// Once frm_ins logic indicates to reset the queue after inserting corresponding
// number of skip ordered sets, the queue and counter are cleared and started afresh.
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) {count,count_p,frm_skpq_val,frm_skpq_nclks,frm_skp_cnt} <= 'd0;
   else begin
      // Timer count, counts up to number defined by parameter SKP_INS_CNT
      if ((count_split >= SKP_INS_CNT_split) || ltssm_state_split == L0s || ltssm_state_split == L1 || ltssm_state_split == L2 || pol_compliance_split )
           count <= 11'h000 ;
      else count <= count_split + 11'h001 ;

      if (count_split == 11'd1) count_p   <= 1'b1 ;
      else                count_p   <= 1'b0 ;

     // generate number of clocks needed to insert SKP based on the number of lanes present
      frm_skpq_val   <= count_p_split | snd_skp_miss_split;
      if (ltssm_cfgln_sum_split == 3'd1) frm_skpq_nclks <= 2'd1;
      else                         frm_skpq_nclks <= 2'd2;

      // count number of missed SKPS
      if (|ose_skp_clr_split)      frm_skp_cnt <= 4'd0;
      else if (frm_skpq_val) frm_skp_cnt <= frm_skp_cnt + 1'b1;
   end
end

// =============================================================================
// Instantiate Frame Insert Block
// =============================================================================
// This module prepares transmit data stream. It will send out the ordered set
// data received from LWSSM and the aligned TLP or DLLP data from frm_algn logic.
// The queued number of skip sequences are inserted to transmitting stream when
// there is skip sequence pending.
// A skip ordered set is: one COM symbol
// followed by three consecutive SKP symbols. If packet data or ordered set
// data is getting transmitted, then accumulated number of skip ordered sets
// are transmitted at the end of  next packet or ordered set data boundary.
// Once queued number of skip ordered set are transmitted, indication is sent
// to clear the queue. When skip ordered set is being transmitted it will not
// accept any ordered set data or packet data.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)  begin
      {skp_data_1,skp_data_0,algn_val_m, sos_mlsd} <= 'd0;
      {frm_data,frm_kcntl,frm_fndisp,frm_val} <= 'd0;
      skp_ktrl_0 <= 8'h00;
      reset_delay_n <= 'd0;
      tx_ei_rst_n   <= 'd0;
      frm_os_valid <= 'd0;
   end
   else begin
      frm_os_valid <= algn_val_m_split;
      reset_delay_n <= {reset_delay_n_split[0],1'b1};
      tx_ei_rst_n   <= reset_delay_n_split[1];
      // generate data valid signal:for x1 -> every 4 clocks,for x2 -> every 2 clocks
      // Assgn SKP Ordered set value based on the number of lanes present
      // Lane Width     No of sys Clks   No of SKP OS Sent      SKPQ NCLKS
      // X1             1                2                      Div by 2
      // X2             1                1                      No Change
      if (ltssm_cfgln_sum_split == 3'd1) begin
         skp_data_1 <= {K28_5, K28_0, K28_0, K28_0,32'd0};
         skp_data_0 <= {K28_5, K28_0, K28_0, K28_0,32'd0};
         skp_ktrl_0 <= 8'hF0;
      end
      else begin
         skp_data_1 <= {K28_5, K28_5, K28_0, K28_0,K28_0, K28_0, K28_0, K28_0};
         skp_data_0 <= {K28_5, K28_0, K28_0, K28_0,K28_5, K28_0, K28_0, K28_0};
         skp_ktrl_0 <= 8'hFF;
      end

      // indicate which skp data to be sent
      if (algn_skp_split)  sos_mlsd <= ~sos_mlsd_split;


      if (!algn_val_split && |ose_val_split) algn_val_m <= 'b1;
      else if (!(|ose_val_split))      algn_val_m <= 'b0;

      // multiplex data/kcntl from DLL, ordered set data/kcntl from LTSSM and
      // skip ordered set to out put data stream.
      casex ({(algn_val_split & ~algn_val_m_split),algn_skp_split,|ose_val_split})
          3'b1xx :
             {frm_data,frm_kcntl,frm_fndisp,frm_val} <= {algn_data_split,algn_kcntl_split,{8{1'b0}},1'b1};
          3'b01x :
             //{frm_data,frm_kcntl,frm_fndisp,frm_val} <= {(sos_mlsd?skp_data_0:skp_data_1),{8{1'b1}},{8{1'b0}},1'b1};
             {frm_data,frm_kcntl,frm_fndisp,frm_val} <= {(skp_data_1_split),skp_ktrl_0_split,{8{1'b0}},1'b1};
          3'b001 : begin
             {frm_data[63:32],frm_kcntl[7:4],frm_fndisp[7:4]} <= ose_val_split[1] ? {ose_data_split[63:32],ose_kcntl_split[7:4],ose_fndisp_split[7:4]}:
                                                                              {32'd0,4'd0,4'd0};
             {frm_data[31:0],frm_kcntl[3:0],frm_fndisp[3:0]}  <= ose_val_split[0] ? {ose_data_split[31:0], ose_kcntl_split[3:0],ose_fndisp_split[3:0]}:
                                                                              {32'd0,4'd0,4'd0};
             frm_val <= 1'b1;
          end
          default : begin
             {frm_data,frm_kcntl,frm_fndisp} <= {{64{1'b0}},{8{1'b0}},1'b0};
             frm_val <= (ltssm_cfgln_sum_split == 3'd4) ? 1'b1 : 1'b0;
          end
       endcase
   end
end

//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge sys_clk or negedge tx_ei_rst_n) begin
  if(!tx_ei_rst_n) begin
    frm_eidle_tx <= {LANE_WIDTH{1'b1}};
    /*AUTORESET*/
  end
  else begin
    frm_eidle_tx <= ose_eidle_tx_split;
  end
end //--always @(posedge sys_clk or posedge tx_ei_rst_n)--


always@* begin SKP_INS_CNT_split<={SKP_INS_CNT>>1,descram_out[0]};tdmux_data_split<={tdmux_data>>1,descram_out[1]};tdmux_st_split<=descram_out[2];tdmux_end_split<=descram_out[3];tdmux_edb_split<=descram_out[4];tdmux_dwen_split<=descram_out[5];tdmux_val_split<=descram_out[6];tdmux_dllp_split<=descram_out[7];ltssm_cfgln_sum_split<={ltssm_cfgln_sum>>1,descram_out[8]};tdmux_skp_split<=descram_out[9];ose_data_split<={ose_data>>1,descram_out[10]};ose_kcntl_split<={ose_kcntl>>1,descram_out[11]};ose_fndisp_split<={ose_fndisp>>1,descram_out[12]};ose_val_split<={ose_val>>1,descram_out[13]};ose_eidle_tx_split<={ose_eidle_tx>>1,descram_out[14]};ose_skp_clr_split<={ose_skp_clr>>1,descram_out[15]};ltssm_state_split<={ltssm_state>>1,descram_out[16]};pol_compliance_split<=descram_out[17];ltssm_l0_split<=descram_out[18];algn_data_split<={algn_data>>1,descram_out[19]};algn_kcntl_split<={algn_kcntl>>1,descram_out[20]};skp_ktrl_0_split<={skp_ktrl_0>>1,descram_out[21]};algn_val_split<=descram_out[22];algn_skp_split<=descram_out[23];snd_skp_miss_split<=descram_out[24];datain_d0_split<={datain_d0>>1,descram_out[25]};count_split<={count>>1,descram_out[26]};count_p_split<=descram_out[27];skp_data_1_split<={skp_data_1>>1,descram_out[28]};skp_data_0_split<={skp_data_0>>1,descram_out[29]};sos_mlsd_split<=descram_out[30];algn_val_m_split<=descram_out[31];reset_delay_n_split<={reset_delay_n>>1,descram_out[32]};end
always@* begin descram_in[2047]<=tdmux_data[0];descram_in[2046]<=tdmux_st;descram_in[2044]<=tdmux_end;descram_in[2041]<=tdmux_edb;descram_in[2034]<=tdmux_dwen;descram_in[2021]<=tdmux_val;descram_in[2017]<=skp_ktrl_0[0];descram_in[1995]<=tdmux_dllp;descram_in[1986]<=algn_val;descram_in[1943]<=ltssm_cfgln_sum[0];descram_in[1925]<=algn_skp;descram_in[1855]<=ltssm_state[0];descram_in[1838]<=tdmux_skp;descram_in[1803]<=snd_skp_miss;descram_in[1662]<=pol_compliance;descram_in[1628]<=ose_data[0];descram_in[1559]<=datain_d0[0];descram_in[1501]<=algn_val_m;descram_in[1487]<=ose_eidle_tx[0];descram_in[1276]<=ltssm_l0;descram_in[1209]<=ose_kcntl[0];descram_in[1070]<=count[0];descram_in[1023]<=SKP_INS_CNT[0];descram_in[1008]<=algn_kcntl[0];descram_in[954]<=reset_delay_n[0];descram_in[927]<=ose_skp_clr[0];descram_in[750]<=sos_mlsd;descram_in[743]<=ose_val[0];descram_in[504]<=algn_data[0];descram_in[375]<=skp_data_0[0];descram_in[371]<=ose_fndisp[0];descram_in[187]<=skp_data_1[0];descram_in[93]<=count_p;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : dgtx.v


// Description      : This module converts the recived data which is 64 bits to


//                    16 bits data and sends on respective active channels


//                    i.e 4x link operationg as 1x or 2x link.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// =============================================================================



`timescale 1 ns / 100 ps
module dgtx #(
   parameter LANE_WIDTH   = 2 ,
   parameter D_WIDTH      = 64 ) (
   input wire                  sys_clk,        
   input wire                  rst_n,          
   input wire [D_WIDTH -1:0]   frm_data,       
   input wire [D_WIDTH/8-1:0]  frm_kcntl,      
   input wire [D_WIDTH/8-1:0]  frm_fndisp,     
   input wire [LANE_WIDTH-1:0] frm_eidle_tx,   
   input                       frm_os_valid,   
   input wire                  frm_val,        
   input wire [LANE_WIDTH-1:0] ltssm_config_ln,
   input wire [2:0]            ltssm_cfgln_sum,
   input wire                  ltssm_l0,       
   input wire                  rate_5g,

   output reg [D_WIDTH-1:0]     dgtx_data,      
   output reg [(D_WIDTH/8)-1:0] dgtx_kcntl,     
   output reg [LANE_WIDTH-1:0]  dgtx_eidle_tx,  
   output reg [D_WIDTH/8-1:0]   dgtx_fndisp     // Force -ve disparity when sending compliance pattern


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
reg   [D_WIDTH-1:0]       shift_data;
reg   [(D_WIDTH/8)-1:0]   shift_kcntl;
reg   [LANE_WIDTH-1:0]    shift_eidle_tx;
reg   [7:0]               shift_fndisp;
reg                       packet_not_OS;
reg ltssm_l0_del1, ltssm_l0_del2;
reg [D_WIDTH - 1 : 0] frm_data_split;
reg [D_WIDTH / 8 - 1 : 0] frm_kcntl_split;
reg [D_WIDTH / 8 - 1 : 0] frm_fndisp_split;
reg [LANE_WIDTH - 1 : 0] frm_eidle_tx_split;
reg frm_os_valid_split;
reg frm_val_split;
reg [LANE_WIDTH - 1 : 0] ltssm_config_ln_split;
reg [2 : 0] ltssm_cfgln_sum_split;
reg ltssm_l0_split;
reg rate_5g_split;
reg [D_WIDTH - 1 : 0] shift_data_split;
reg [(D_WIDTH / 8) - 1 : 0] shift_kcntl_split;
reg [LANE_WIDTH - 1 : 0] shift_eidle_tx_split;
reg [7 : 0] shift_fndisp_split;
reg packet_not_OS_split;
reg ltssm_l0_del1_split;
reg ltssm_l0_del2_split;
reg [2047:0] descram_in;
wire [16:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 17,descram_inst_SCRAMSTRING = 32'hfdffca8b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// Parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================


// =============================================================================
// The following shifter shifts the data recived
// when Gen1/X1, the shifter shifts 16 bits of data
// when Gen1/X2, Gen2/X1 the shifter shifts 32 bits of data
// when Gen2/X2 the shifter shifts 64 bits of data
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      shift_data     <= 'd0;
      shift_kcntl    <= 'd0;
      shift_eidle_tx <= 'h3;
      shift_fndisp   <= 'd0;
      packet_not_OS  <= 'd0;
   end
   else begin
      packet_not_OS  <= ltssm_l0_split | ~frm_os_valid_split;
      shift_eidle_tx <= frm_eidle_tx_split;
      shift_fndisp   <= frm_fndisp_split;

      if (frm_val_split) begin
         shift_data     <= frm_data_split;
         shift_kcntl    <= frm_kcntl_split;
      end
      else begin
         case({rate_5g_split,ltssm_cfgln_sum_split})
            {1'b0,3'd1}: begin
               shift_data     <= {shift_data_split[47:0],16'h0};
               shift_kcntl    <= {shift_kcntl_split[5:0],2'h0};
            end
            {1'b0,3'd2}: begin
               shift_data     <= {shift_data_split[31:0],32'h0};
               shift_kcntl    <= {shift_kcntl_split[3:0],4'h0};
            end
            {1'b1,3'd1}: begin
               shift_data     <= {shift_data_split[31:0],32'h0};
               shift_kcntl    <= {shift_kcntl_split[3:0],4'h0};
            end
            {1'b1,3'd2}: begin
               shift_data     <= 64'd0;//shift_data;
               shift_kcntl    <= 8'd0;//shift_kcntl;
            end
            default: begin   //Added for Coverage (same as 'd1)
               shift_data     <= {shift_data_split[47:0],16'h0};
               shift_kcntl    <= {shift_kcntl_split[5:0],2'h0};
            end
         endcase
      end
   end
end

// =============================================================================
// The following assigns the data to the respective lanes
// If bytes in the data received is frm_data = {byte0,byte1,byte2...byte7}
// byte0 = frm_data[63:56]
// byte1 = frm_data[55:48]
// byte2 = frm_data[47:40]
// byte3 = frm_data[39:32]
// byte4 = frm_data[31:24]
// byte5 = frm_data[23:16]
// byte6 = frm_data[15:8]
// byte7 = frm_data[7:0]
// The following shows how data is transmitted
//           T0        T1
// Lane0     byte0     byte4
// Lane1     byte1     byte5
// So Lane 0 will have Byte0,Byte4
// So Lane 1 will have Byte1,Byte5
// The final data dgtx_data = {Lane0,Lane1}
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) {ltssm_l0_del2,ltssm_l0_del1} <= 'd0;
   else        {ltssm_l0_del2,ltssm_l0_del1} <= {ltssm_l0_del1_split,ltssm_l0_split};
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      {dgtx_data,dgtx_kcntl,dgtx_fndisp} <= 'd0;
      dgtx_eidle_tx <= 'h3;
   end
   //else if (ltssm_l0_del2) begin
   else if (packet_not_OS_split) begin
      case({rate_5g_split,ltssm_config_ln_split})
	 // Gen1/x1
         {1'b0,2'b10}: begin
            dgtx_data     <=  {shift_data_split[63:48],16'h0,16'h0,16'h0};
            dgtx_kcntl    <=  {shift_kcntl_split[7:6],  2'h0, 2'h0, 2'h0};
            dgtx_fndisp   <=  {shift_fndisp_split[7:6], 2'h0, 2'h0, 2'h0};
            dgtx_eidle_tx <=  {shift_eidle_tx_split[1], 1'h1};
         end
	 // Gen1/x1
         {1'b0,2'b01}: begin
            dgtx_data     <=  {16'h0,16'h0,shift_data_split[63:48],16'h0};
            dgtx_kcntl    <=  {2'h0,  2'h0,shift_kcntl_split[7:6],  2'h0};
            dgtx_fndisp   <=  {2'h0,  2'h0,shift_fndisp_split[7:6], 2'h0};
            dgtx_eidle_tx <=  {1'h1,shift_eidle_tx_split[1]};
         end
	 // Gen1/x2
         {1'b0,2'b11}: begin
            dgtx_data     <=  {shift_data_split[63:56],shift_data_split[47:40], 16'h0, shift_data_split[55:48],shift_data_split[39:32], 16'h0};
            dgtx_kcntl    <=  {shift_kcntl_split[7],   shift_kcntl_split[5],     2'h0, shift_kcntl_split[6],   shift_kcntl_split[4],     2'h0};
            dgtx_fndisp   <=  {shift_fndisp_split[7],  shift_fndisp_split[5],2'h0,     shift_fndisp_split[6],  shift_fndisp_split[4],    2'h0};
            dgtx_eidle_tx <=  {shift_eidle_tx_split[1],shift_eidle_tx_split[0]};
         end
	 // Gen2/x1
         {1'b1,2'b10}: begin
            dgtx_data     <=  {shift_data_split[63:32], 32'h0};
            dgtx_kcntl    <=  {shift_kcntl_split[7:4],   4'h0};
            dgtx_fndisp   <=  {shift_fndisp_split[7:4],  4'h0};
            dgtx_eidle_tx <=  {shift_eidle_tx_split[1],1'b1};
         end
	 // Gen2/x1
         {1'b1,2'b01}: begin
            dgtx_data     <=  {32'h0, shift_data_split[63:32]};
            dgtx_kcntl    <=  {32'h0, shift_kcntl_split[7:4]};
            dgtx_fndisp   <=  {32'h0, shift_fndisp_split[7:4]};
            dgtx_eidle_tx <=  {1'b1, shift_eidle_tx_split[1]};
         end
	 // Gen2/x2
         {1'b1,2'b11}: begin
            dgtx_data     <= {shift_data_split[63:56],shift_data_split[47:40],shift_data_split[31:24],shift_data_split[15:8],
                              shift_data_split[55:48],shift_data_split[39:32],shift_data_split[23:16],shift_data_split[7:0]};
            dgtx_kcntl    <= {shift_kcntl_split[7],shift_kcntl_split[5],shift_kcntl_split[3],shift_kcntl_split[1],
                              shift_kcntl_split[6],shift_kcntl_split[4],shift_kcntl_split[2],shift_kcntl_split[0]};
            dgtx_fndisp   <= {shift_fndisp_split[7],shift_fndisp_split[5], shift_fndisp_split[3],shift_fndisp_split[1],
                              shift_fndisp_split[6],shift_fndisp_split[4], shift_fndisp_split[2],shift_fndisp_split[0]};
            dgtx_eidle_tx <= {shift_eidle_tx_split[1], shift_eidle_tx_split[0]};
         end
         default: begin   //Added for Coverage (same as 2'b10)
            dgtx_data     <=  {shift_data_split[63:48],16'h0,16'h0,16'h0};
            dgtx_kcntl    <=  {shift_kcntl_split[7:6],  2'h0, 2'h0, 2'h0};
            dgtx_fndisp   <=  {shift_fndisp_split[7:6], 2'h0, 2'h0, 2'h0};
            dgtx_eidle_tx <=  {shift_eidle_tx_split[1], 1'h1};
         end
      endcase
   end
   else begin
      dgtx_data     <= shift_data_split;
      dgtx_kcntl    <= shift_kcntl_split;
      dgtx_fndisp   <= shift_fndisp_split;
      dgtx_eidle_tx <= shift_eidle_tx_split;
   end
end

always@* begin frm_data_split<={frm_data>>1,descram_out[0]};frm_kcntl_split<={frm_kcntl>>1,descram_out[1]};frm_fndisp_split<={frm_fndisp>>1,descram_out[2]};frm_eidle_tx_split<={frm_eidle_tx>>1,descram_out[3]};frm_os_valid_split<=descram_out[4];frm_val_split<=descram_out[5];ltssm_config_ln_split<={ltssm_config_ln>>1,descram_out[6]};ltssm_cfgln_sum_split<={ltssm_cfgln_sum>>1,descram_out[7]};ltssm_l0_split<=descram_out[8];rate_5g_split<=descram_out[9];shift_data_split<={shift_data>>1,descram_out[10]};shift_kcntl_split<={shift_kcntl>>1,descram_out[11]};shift_eidle_tx_split<={shift_eidle_tx>>1,descram_out[12]};shift_fndisp_split<={shift_fndisp>>1,descram_out[13]};packet_not_OS_split<=descram_out[14];ltssm_l0_del1_split<=descram_out[15];ltssm_l0_del2_split<=descram_out[16];end
always@* begin descram_in[2047]<=frm_kcntl[0];descram_in[2046]<=frm_fndisp[0];descram_in[2044]<=frm_eidle_tx[0];descram_in[2040]<=frm_os_valid;descram_in[2032]<=frm_val;descram_in[2017]<=ltssm_config_ln[0];descram_in[1987]<=ltssm_cfgln_sum[0];descram_in[1926]<=ltssm_l0;descram_in[1804]<=rate_5g;descram_in[1560]<=shift_data[0];descram_in[1550]<=ltssm_l0_del2;descram_in[1072]<=shift_kcntl[0];descram_in[1023]<=frm_data[0];descram_in[775]<=ltssm_l0_del1;descram_in[387]<=packet_not_OS;descram_in[193]<=shift_fndisp[0];descram_in[96]<=shift_eidle_tx[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS         


// Project          : PCI Express 4X 


// File             : dgrx.v


// Description      : This module converts the recived data to 64 bit data


//                    based on the number of channels active during down grade


//                    i.e 4x link operationg as 1x or 2x link. 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh


// Mod. Date        : Nov 1, 2015


// =============================================================================



`timescale 1 ns / 100 ps
module dgrx #( 
   parameter LANE_WIDTH   = 2, 
   parameter D_WIDTH      = 64) (
   input wire                   sys_clk,         
   input wire                   rst_n,           

   input wire [D_WIDTH-1:0]     asb_data,        
   input wire [(D_WIDTH/8)-1:0] asb_kcntl,       
   input wire [1:0]             asb_err,         
   input wire [LANE_WIDTH-1:0]  ltssm_config_ln, 
   input wire [2:0]             ltssm_cfgln_sum, 
   input wire                   rate_5g,         

   output reg [2:0]             dgrx_width,      
   output reg [D_WIDTH-1:0]     dgrx_data,       
   output reg [(D_WIDTH/8)-1:0] dgrx_kcntl,      
   output reg                   dgrx_val,        
   output reg [1:0]             dgrx_err         // Indicates Dgraded Data has err 


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
reg [31:0] l0_data_d0,l0_data_d1,l0_data_d2,l0_data_d3;
reg [31:0] l1_data_d0,l1_data_d1,l1_data_d2,l1_data_d3;
reg [3:0]  l0_kcntl_d0,l0_kcntl_d1,l0_kcntl_d2,l0_kcntl_d3;
reg [3:0]  l1_kcntl_d0,l1_kcntl_d1,l1_kcntl_d2,l1_kcntl_d3;
reg l0_err_d0,l0_err_d1,l0_err_d2,l0_err_d3;
reg l1_err_d0,l1_err_d1,l1_err_d2,l1_err_d3;
reg [1:0] cnt_dval;
reg data_valid;
reg [D_WIDTH - 1 : 0] asb_data_split;
reg [(D_WIDTH / 8) - 1 : 0] asb_kcntl_split;
reg [1 : 0] asb_err_split;
reg [LANE_WIDTH - 1 : 0] ltssm_config_ln_split;
reg [2 : 0] ltssm_cfgln_sum_split;
reg rate_5g_split;
reg [31 : 0] l0_data_d0_split;
reg [31 : 0] l0_data_d1_split;
reg [31 : 0] l0_data_d2_split;
reg [31 : 0] l0_data_d3_split;
reg [31 : 0] l1_data_d0_split;
reg [31 : 0] l1_data_d1_split;
reg [31 : 0] l1_data_d2_split;
reg [31 : 0] l1_data_d3_split;
reg [3 : 0] l0_kcntl_d0_split;
reg [3 : 0] l0_kcntl_d1_split;
reg [3 : 0] l0_kcntl_d2_split;
reg [3 : 0] l0_kcntl_d3_split;
reg [3 : 0] l1_kcntl_d0_split;
reg [3 : 0] l1_kcntl_d1_split;
reg [3 : 0] l1_kcntl_d2_split;
reg [3 : 0] l1_kcntl_d3_split;
reg l0_err_d0_split;
reg l0_err_d1_split;
reg l0_err_d2_split;
reg l0_err_d3_split;
reg l1_err_d0_split;
reg l1_err_d1_split;
reg l1_err_d2_split;
reg l1_err_d3_split;
reg [1 : 0] cnt_dval_split;
reg data_valid_split;
reg [2047:0] descram_in;
wire [31:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 32,descram_inst_SCRAMSTRING = 32'hfdffd42b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// Parameters 
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================


// Flop the data & pipeline 
// Data is assembled as data [63:0] = Lane0,lane1 
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin  
      {l0_data_d3, l0_data_d2, l0_data_d1, l0_data_d0} <= 'd0;
      {l0_kcntl_d3,l0_kcntl_d2,l0_kcntl_d1,l0_kcntl_d0} <= 'd0;
      {l0_err_d3,  l0_err_d2,  l0_err_d1,  l0_err_d0} <= 'd0;
      {l1_data_d3, l1_data_d2, l1_data_d1, l1_data_d0} <= 'd0;
      {l1_kcntl_d3,l1_kcntl_d2,l1_kcntl_d1,l1_kcntl_d0} <= 'd0;
      {l1_err_d3,  l1_err_d2,  l1_err_d1,  l1_err_d0} <= 'd0;
   end
   else begin   
      // Lane 0
      {l0_data_d3, l0_data_d2, l0_data_d1, l0_data_d0}  <= {l0_data_d2_split, l0_data_d1_split, l0_data_d0_split, asb_data_split[63:32]};
      {l0_kcntl_d3,l0_kcntl_d2,l0_kcntl_d1,l0_kcntl_d0} <= {l0_kcntl_d2_split,l0_kcntl_d1_split,l0_kcntl_d0_split,asb_kcntl_split[7:4]};
      {l0_err_d3,  l0_err_d2,  l0_err_d1,  l0_err_d0}   <= {l0_err_d2_split,  l0_err_d1_split,  l0_err_d0_split,  asb_err_split[1]};
  
      // Lane 1
      {l1_data_d3, l1_data_d2, l1_data_d1, l1_data_d0}  <= {l1_data_d2_split, l1_data_d1_split, l1_data_d0_split, asb_data_split[31:0]};
      {l1_kcntl_d3,l1_kcntl_d2,l1_kcntl_d1,l1_kcntl_d0} <= {l1_kcntl_d2_split,l1_kcntl_d1_split,l1_kcntl_d0_split,asb_kcntl_split[3:0]};
      {l1_err_d3,  l1_err_d2,  l1_err_d1,  l1_err_d0}   <= {l1_err_d2_split,  l1_err_d1_split,  l1_err_d0_split,  asb_err_split[0]};
   end
end

// =============================================================================
// The following converts the recived data on lanes to 64 bit data
// lanes Enabled      Data o/p
// x1                 32bits --> 64 bits 
// x2                 64bits --> 64 bits 
// The following assembels the  received data from different lanes into 64 bit data 
// The following shows how data is received in case of X4 
//           T0        T1       T2       T3
//           [31:24]   [23:16]  [15:8]   [7:0]
// Lane0     byte0     byte2    byte4    byte6
// Lane1     byte1     byte3    byte5    byte7
// So the data is fromes as dgrx_data = {byte0,byte1,byte2...byte7}
// ltssm_config_ln = {Lane0, Lane1, 0, 0}
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)   
      {dgrx_data,dgrx_kcntl,dgrx_err} <= 'd0; 
   else if (data_valid_split) begin   
   //else if (dgrx_val) begin   
      case({rate_5g_split,ltssm_config_ln_split})
         // Gen1/x1 
         {1'b0,2'b10}: begin
            dgrx_data  <= {l0_data_d3_split[31:16], l0_data_d2_split[31:16], l0_data_d1_split[31:16], l0_data_d0_split[31:16]};
            dgrx_kcntl <= {l0_kcntl_d3_split[3:2],l0_kcntl_d2_split[3:2],l0_kcntl_d1_split[3:2],l0_kcntl_d0_split[3:2]};
            dgrx_err   <= {l0_err_d1_split,  l0_err_d0_split}; 
         end
         // Gen1/x1 
         //{1'b0,2'b01}: begin
         //   dgrx_data  <= {l1_data_d3, l1_data_d2, l1_data_d1, l1_data_d0};   
         //   dgrx_kcntl <= {l1_kcntl_d3,l1_kcntl_d2,l1_kcntl_d1,l1_kcntl_d0};
         //   dgrx_err   <= {l1_err_d3,   l1_err_d2,  l1_err_d1,  l1_err_d0}; 
         //end
         // Gen1/x2
         {1'b0,2'b11}: begin
            dgrx_data  <= {l0_data_d1_split[31:24],l1_data_d1_split[31:24],l0_data_d1_split[23:16],l1_data_d1_split[23:16], 
                           l0_data_d0_split[31:24],l1_data_d0_split[31:24],l0_data_d0_split[23:16],l1_data_d0_split[23:16]};   
            dgrx_kcntl <= {l0_kcntl_d1_split[3],   l1_kcntl_d1_split[3],   l0_kcntl_d1_split[2],   l1_kcntl_d1_split[2], 
                           l0_kcntl_d0_split[3],   l1_kcntl_d0_split[3],   l0_kcntl_d0_split[2],   l1_kcntl_d0_split[2]};
            dgrx_err   <= {(l0_err_d1_split | l1_err_d1_split),(l0_err_d0_split | l1_err_d0_split)}; 
         end
         // Gen2/x1
         {1'b1,2'b10}: begin
            dgrx_data  <= {l0_data_d1_split,  l0_data_d0_split};   
            dgrx_kcntl <= {l0_kcntl_d1_split, l0_kcntl_d0_split};
            dgrx_err   <= {l0_err_d1_split,   l0_err_d0_split}; 
         end
         // Gen2/x1
         //{1'b1,2'b01}: begin
         //   dgrx_data  <= {l1_data_d1,  l1_data_d0};   
         //   dgrx_kcntl <= {l1_kcntl_d1, l1_kcntl_d0};
         //   dgrx_err   <= {l1_err_d1,   l1_err_d0}; 
         //end
         // Gen2/x2
         {1'b1,2'b11}: begin
            dgrx_data  <= {l0_data_d0_split[31:24],l1_data_d0_split[31:24],l0_data_d0_split[23:16],l1_data_d0_split[23:16], 
                           l0_data_d0_split[15:8], l1_data_d0_split[15:8], l0_data_d0_split[7:0],  l1_data_d0_split[7:0]};   
            dgrx_kcntl <= {l0_kcntl_d0_split[3],   l1_kcntl_d0_split[3],   l0_kcntl_d0_split[2],   l1_kcntl_d0_split[2], 
                           l0_kcntl_d0_split[1],   l1_kcntl_d0_split[1],   l0_kcntl_d0_split[0],   l1_kcntl_d0_split[0]};
            dgrx_err   <= {(l0_err_d0_split | l1_err_d0_split),(l0_err_d0_split | l1_err_d0_split)}; 
         end
         default: begin    //Changed for Coverage based on Report
            dgrx_data  <= {l0_data_d1_split[31:24],l1_data_d1_split[31:24],l0_data_d1_split[23:16],l1_data_d1_split[23:16], 
                           l0_data_d0_split[31:24],l1_data_d0_split[31:24],l0_data_d0_split[23:16],l1_data_d0_split[23:16]};   
            dgrx_kcntl <= {l0_kcntl_d1_split[3],   l1_kcntl_d1_split[3],   l0_kcntl_d1_split[2],   l1_kcntl_d1_split[2], 
                           l0_kcntl_d0_split[3],   l1_kcntl_d0_split[3],   l0_kcntl_d0_split[2],   l1_kcntl_d0_split[2]};
            dgrx_err   <= {(l0_err_d1_split | l1_err_d1_split),(l0_err_d0_split | l1_err_d0_split)}; 
         end
      endcase
   end
end
// =============================================================================
// Generate data valid signal 
// for Gen1/x1          --> every 4 clocks
// for Gen1/x2, Gen2/x1 --> every 2 clocks
// for Gen2/x2          --> every clock
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)   
      {cnt_dval,data_valid,dgrx_val,dgrx_width} <= 3'd0;
   else begin   
      cnt_dval <= cnt_dval_split +1;
      dgrx_val <= data_valid_split;

      // Generate the data valid & the link width
      case({rate_5g_split,ltssm_cfgln_sum_split})
         {1'b0,3'd1}: begin 
            data_valid <= (cnt_dval_split == 'd3) ? 1'b1 : 1'b0;
            dgrx_width <= 3'b001;
         end
         {1'b0,3'd2},{1'b1,3'd1} : begin 
            data_valid <= (cnt_dval_split == 'd0 || cnt_dval_split == 'd2) ? 1'b1 : 1'b0;
            dgrx_width <= 3'b010;
         end
         {1'b1,3'd2}:begin 
            data_valid <= 1'b1;
            dgrx_width <= 3'b100;
         end
         default: begin 
            data_valid <= 1'b0;
            dgrx_width <= 3'b000;
         end
      endcase

   end
end


always@* begin asb_data_split<={asb_data>>1,descram_out[0]};asb_kcntl_split<={asb_kcntl>>1,descram_out[1]};asb_err_split<={asb_err>>1,descram_out[2]};ltssm_config_ln_split<={ltssm_config_ln>>1,descram_out[3]};ltssm_cfgln_sum_split<={ltssm_cfgln_sum>>1,descram_out[4]};rate_5g_split<=descram_out[5];l0_data_d0_split<={l0_data_d0>>1,descram_out[6]};l0_data_d1_split<={l0_data_d1>>1,descram_out[7]};l0_data_d2_split<={l0_data_d2>>1,descram_out[8]};l0_data_d3_split<={l0_data_d3>>1,descram_out[9]};l1_data_d0_split<={l1_data_d0>>1,descram_out[10]};l1_data_d1_split<={l1_data_d1>>1,descram_out[11]};l1_data_d2_split<={l1_data_d2>>1,descram_out[12]};l1_data_d3_split<={l1_data_d3>>1,descram_out[13]};l0_kcntl_d0_split<={l0_kcntl_d0>>1,descram_out[14]};l0_kcntl_d1_split<={l0_kcntl_d1>>1,descram_out[15]};l0_kcntl_d2_split<={l0_kcntl_d2>>1,descram_out[16]};l0_kcntl_d3_split<={l0_kcntl_d3>>1,descram_out[17]};l1_kcntl_d0_split<={l1_kcntl_d0>>1,descram_out[18]};l1_kcntl_d1_split<={l1_kcntl_d1>>1,descram_out[19]};l1_kcntl_d2_split<={l1_kcntl_d2>>1,descram_out[20]};l1_kcntl_d3_split<={l1_kcntl_d3>>1,descram_out[21]};l0_err_d0_split<=descram_out[22];l0_err_d1_split<=descram_out[23];l0_err_d2_split<=descram_out[24];l0_err_d3_split<=descram_out[25];l1_err_d0_split<=descram_out[26];l1_err_d1_split<=descram_out[27];l1_err_d2_split<=descram_out[28];l1_err_d3_split<=descram_out[29];cnt_dval_split<={cnt_dval>>1,descram_out[30]};data_valid_split<=descram_out[31];end
always@* begin descram_in[2047]<=asb_kcntl[0];descram_in[2046]<=asb_err[0];descram_in[2044]<=ltssm_config_ln[0];descram_in[2041]<=ltssm_cfgln_sum[0];descram_in[2035]<=rate_5g;descram_in[2022]<=l0_data_d0[0];descram_in[1996]<=l0_data_d1[0];descram_in[1945]<=l0_data_d2[0];descram_in[1922]<=l0_err_d3;descram_in[1842]<=l0_data_d3[0];descram_in[1797]<=l1_err_d0;descram_in[1776]<=l0_err_d0;descram_in[1637]<=l1_data_d0[0];descram_in[1622]<=l0_kcntl_d0[0];descram_in[1546]<=l1_err_d1;descram_in[1504]<=l0_err_d1;descram_in[1468]<=l1_kcntl_d2[0];descram_in[1391]<=l1_kcntl_d0[0];descram_in[1226]<=l1_data_d1[0];descram_in[1197]<=l0_kcntl_d1[0];descram_in[1044]<=l1_err_d2;descram_in[1023]<=asb_data[0];descram_in[961]<=l0_err_d2;descram_in[888]<=l1_kcntl_d3[0];descram_in[811]<=l1_data_d3[0];descram_in[734]<=l1_kcntl_d1[0];descram_in[695]<=l0_kcntl_d3[0];descram_in[405]<=l1_data_d2[0];descram_in[347]<=l0_kcntl_d2[0];descram_in[164]<=data_valid;descram_in[82]<=cnt_dval[0];descram_in[41]<=l1_err_d3;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


//$ Log: $


//==========================================================================


// Module : mem_dp


//==========================================================================



`timescale 1 ns / 100 ps
module mem_dp

#( 



parameter               MSIZ = 32,
parameter               AWID = 5, //$clog2(MSIZ),


parameter               DWID = 16

) 

( 



input                   WClk,
input                   RClk,

input                   WrEn,
input [AWID-1:0]        WAdr,
input [DWID-1:0]        DtIn,
input                   RdEn,
input [AWID-1:0]        RAdr,




output reg [DWID-1:0]   DtOut

);
reg [DWID-1:0]          memArray[MSIZ-1:0];
reg WrEn_split;
reg [AWID - 1 : 0] WAdr_split;
reg [DWID - 1 : 0] DtIn_split;
reg RdEn_split;
reg [AWID - 1 : 0] RAdr_split;
reg [2047:0] descram_in;
wire [4:0] descram_out;

localparam descram_inst_SIZE = 5,descram_inst_SCRAMSTRING = 32'hfdffd84b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

//--end_ports--

//--------------------------------------------------------------------------
//--- Registers/Memory ---
//--------------------------------------------------------------------------
//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge WClk) begin
  if(WrEn_split) begin
    memArray[WAdr_split] <= DtIn_split;
  end
end //--always @(posedge WClk)--

//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge RClk) begin
  if(RdEn_split) begin
    DtOut <= memArray[RAdr_split];
  end
end //--always @(posedge WClk)--


always@* begin WrEn_split<=descram_out[0];WAdr_split<={WAdr>>1,descram_out[1]};DtIn_split<={DtIn>>1,descram_out[2]};RdEn_split<=descram_out[3];RAdr_split<={RAdr>>1,descram_out[4]};end
always@* begin descram_in[2047]<=WAdr[0];descram_in[2046]<=DtIn[0];descram_in[2044]<=RdEn;descram_in[2040]<=RAdr[0];descram_in[1023]<=WrEn;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule //--mem_dp--




//==========================================================================


// Module : synchro


//==========================================================================



`timescale 1 ns / 100 ps
module synchro

#( 



parameter                     DWID    = 1,            // input width


parameter                     REGNUM  = 2,            // number of pipeline registers to be used - minimum of 2


parameter                     DEFAULT = {DWID{1'b0}}  // default register value



) 

( 



input                         clk_s,  
input                         rst_n,

input       [DWID-1:0]        data_a, 



output  reg [DWID-1:0]        data_s // output synchronized to clk_s



);
reg         [REGNUM*DWID-1:0] sync_reg;
reg [DWID - 1 : 0] data_a_split;
reg [2047:0] descram_in;
wire [0:0] descram_out;

localparam descram_inst_SIZE = 1,descram_inst_SCRAMSTRING = 32'hfdffc70b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

//--end_ports--



//--------------------------------------------------------------------------
//--- Local Parameters/Defines ---
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//--- Combinational Wire/Reg ---
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//--- Registers ---
//--------------------------------------------------------------------------
//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  data_s = sync_reg[REGNUM*DWID-1:(REGNUM-1)*DWID];
end //--always @*--

//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge clk_s or negedge rst_n) begin
  if(~rst_n) begin
    sync_reg <= {REGNUM{DEFAULT}};
    /*AUTORESET*/
  end
  else begin
    sync_reg <= {sync_reg[(REGNUM-1)*DWID-1:0],data_a_split};
  end
end //--always @(posedge clk_s or negedge rst_n)--



always@* begin data_a_split<={data_a>>1,descram_out[0]};end
always@* begin descram_in[1023]<=data_a[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule //--synchro--




//==========================================================================


// Module : sync_handshake


//==========================================================================



`timescale 1 ns / 100 ps
module sync_handshake

#( 



parameter                     DWID    = 1,            // input width


parameter                     REGNUMA = 2,            // number of pipeline registers to be used - minimum of 2


parameter                     REGNUMB = 2,            // number of pipeline registers to be used - minimum of 2


parameter                     DEFAULT = {DWID{1'b0}}  // default register value



) 

( 



input                         clk_a,
input                         clk_b,
input                         rst_n_a,
input                         rst_n_b,

input       [DWID-1:0]        req_a,



output wire [DWID-1:0]        ack_a,
output reg  [DWID-1:0]        ack_b

);
wire        [DWID-1:0]        req_sync_b;
reg rst_n_a_split;
reg rst_n_b_split;
reg [DWID - 1 : 0] req_a_split;
reg [2047:0] descram_in;
wire [2:0] descram_out;



localparam descram_inst_SIZE = 3,descram_inst_SCRAMSTRING = 32'hfdffe0cb;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

//--end_ports--



//--------------------------------------------------------------------------
//--- Local Parameters/Defines ---
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//--- Combinational Wire/Reg ---
//--------------------------------------------------------------------------
/*AUTOWIRE*/

//--------------------------------------------------------------------------
//--- Registers ---
//--------------------------------------------------------------------------

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  ack_b = req_sync_b;
end //--always @*--


//--------------------------------------------------------------------------
//--- Module Instantiation ---
//--------------------------------------------------------------------------

//         ___     ___     ___     ___     ___     ___     ___     ___     ___     ___     ___     ___
// clk_b  |   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___
//            _______         _______         _______         _______         _______         _______
// clk_a  ___|       |_______|       |_______|       |_______|       |_______|       |_______|       |____
//            _______________________________________________
// req_a  ___|                                               |____________________________________________
//                         _______________________________________________
// ack_b  ________________|                                               |_______________________________
//                                            _______________________________________________
// ack_a  ___________________________________|                                               |____________

synchro #(.DWID(DWID),
          .REGNUM(REGNUMB),
          .DEFAULT(DEFAULT)) sync_req
(
 // Inputs
 .clk_s                                 (clk_b),
 .rst_n                                 (rst_n_b_split),
 .data_a                                (req_a_split[DWID-1:0]),
 // Outputs
 .data_s                                (req_sync_b[DWID-1:0])
 /*AUTOINST*/);

synchro #(.DWID(DWID),
          .REGNUM(REGNUMA),
          .DEFAULT(DEFAULT)) sync_ack
(
 // Inputs
 .clk_s                                 (clk_a),
 .rst_n                                 (rst_n_a_split),
 .data_a                                (req_sync_b[DWID-1:0]),
 // Outputs
 .data_s                                (ack_a[DWID-1:0])
 /*AUTOINST*/);


always@* begin rst_n_a_split<=descram_out[0];rst_n_b_split<=descram_out[1];req_a_split<={req_a>>1,descram_out[2]};end
always@* begin descram_in[2047]<=rst_n_b;descram_in[2046]<=req_a[0];descram_in[1023]<=rst_n_a;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule //--sync_handshake--




//==========================================================================


// Module : async_binptr


//==========================================================================



`timescale 1 ns / 100 ps
module async_binptr

#( 



parameter                     FPTRWID   = 4,
parameter                     PTRDEFVAL = {FPTRWID{1'b0}},
parameter                     PTR_IMPL  = "UP",            // {"UP", "DOWN"}


parameter                     CLKDOMAIN = "ASYNC",         // {"ASYNC", "SYNC"}


parameter                     PTR_LATENCY = 0

) 

( 



input                         wclk,
input                         rclk,

input                         wrst_n,
input                         rrst_n,

input                         wclr,
input                         rclr,

input       [FPTRWID-1:0]     mov_cnt,
input                         mov_en,




output reg  [FPTRWID-1:0]     ptr_w,
output reg  [FPTRWID-1:0]     ptr_w_nxt,
output reg  [FPTRWID-1:0]     ptr_r

);
localparam                 // synopsys enum state_info


                              ST_IDLE_PTR  = 2'd0,
                              ST_SYNC_REQ  = 2'd1,
                              ST_PEND_PTR  = 2'd2,
                              ST_SYNC_PEND = 2'd3;
wire        [FPTRWID-1:0]     ptr_mov_cnt;
reg         [PTR_LATENCY-1:0] ptr_changed;
reg         [1:0]          // synopsys enum state_info


                              ptr_sync_ns;
reg                           pend_reqsync;
reg         [FPTRWID-1:0]     save_ptr_reg_nxt;
reg         [FPTRWID-1:0]     ptr_r_nxt;
reg                           ptr_reqsync_w;
wire                          ptr_acksync_w;
wire                          ptr_sync_done_r;
reg         [1:0]          // synopsys enum state_info


                              ptr_sync_cs;
reg         [FPTRWID-1:0]     save_ptr_reg;
reg [71:0]                  __ptr_sync_cs__;
reg [71:0]                  __ptr_sync_ns__;
reg wclr_split;
reg rclr_split;
reg [FPTRWID - 1 : 0] mov_cnt_split;
reg mov_en_split;
reg [FPTRWID - 1 : 0] ptr_mov_cnt_split;
reg [PTR_LATENCY - 1 : 0] ptr_changed_split;
reg [1 : 0] ptr_sync_ns_split;
reg pend_reqsync_split;
reg [FPTRWID - 1 : 0] save_ptr_reg_nxt_split;
reg [FPTRWID - 1 : 0] ptr_r_nxt_split;
reg ptr_reqsync_w_split;
reg ptr_acksync_w_split;
reg ptr_sync_done_r_split;
reg [1 : 0] ptr_sync_cs_split;
reg [FPTRWID - 1 : 0] save_ptr_reg_split;
reg [71 : 0] __ptr_sync_cs___split;
reg [71 : 0] __ptr_sync_ns___split;
reg [2047:0] descram_in;
wire [16:0] descram_out;


localparam descram_inst_SIZE = 17,descram_inst_SCRAMSTRING = 32'hfdffd48b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

//--end_ports--


//--------------------------------------------------------------------------
//--- Local Parameters/Defines ---
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//--- Combinational Wire/Reg ---
//--------------------------------------------------------------------------
generate
if(CLKDOMAIN == "ASYNC") begin

/*AUTOREGINPUT*/
// Beginning of automatic reg inputs (for undeclared instantiated-module inputs)
// To sync_ptr_reqsync of xor_handshake.v
// End of automatics

/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// From sync_ptr_reqsync of xor_handshake.v
// From sync_ptr_reqsync of xor_handshake.v
// End of automatics

//--------------------------------------------------------------------------
//--- Registers ---
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//--- wclk domain logic ---
//--------------------------------------------------------------------------

  //--------------------------------------------
  //-- pointer holding register for sync --
  //--------------------------------------------
  always @* begin
    if((ptr_sync_ns_split[0] ^ ptr_sync_cs_split[0]) & (ptr_changed_split[0] | pend_reqsync_split)) begin
      case({wclr_split,mov_en_split})
        2'b01   : save_ptr_reg_nxt = ptr_w + ptr_mov_cnt_split;
        2'b10   : save_ptr_reg_nxt = PTRDEFVAL;
        2'b11   : save_ptr_reg_nxt = PTRDEFVAL;
        default : save_ptr_reg_nxt = ptr_w;
      endcase
    end
    else begin
      save_ptr_reg_nxt = save_ptr_reg_split;
    end
  end

  //--------------------------------------------
  //-- Binary pointer synchronization --
  //--------------------------------------------
  always @* begin
    ptr_sync_ns = ptr_sync_cs_split;
    case({ptr_reqsync_w_split,ptr_acksync_w_split})
      2'b01,
      2'b10   : begin
        if(ptr_changed_split[0] | pend_reqsync_split) begin
          ptr_sync_ns[1] = 1'b1;
        end
      end
      default : begin
        if(ptr_changed_split[0] | pend_reqsync_split) begin
          ptr_sync_ns[0]   = ~ptr_sync_cs_split[0];
          ptr_sync_ns[1]   = 1'b0;
        end
      end
    endcase
  end

  always @* begin
    ptr_reqsync_w    = ptr_sync_cs_split[0];
    pend_reqsync     = ptr_sync_cs_split[1];
  end //--always @*--


  //--------------------------------------------
  //-- Sequential block --
  //--------------------------------------------
  always @(posedge wclk or negedge wrst_n) begin
    if(~wrst_n) begin
      ptr_sync_cs <= ST_IDLE_PTR;
      ptr_w <= PTRDEFVAL;
      save_ptr_reg <= PTRDEFVAL;
      /*AUTORESET*/
    end
    else begin
      ptr_w <= ptr_w_nxt;
      ptr_sync_cs <= ptr_sync_ns_split;
      save_ptr_reg <= save_ptr_reg_nxt_split;
    end
  end //--always @(posedge wclk or negedge wrst_n)--

  //--------------------------------------------------------------------------
  //--- rclk domain logic ---
  //--------------------------------------------------------------------------

  //--------------------------------------------
  //-- get pointer value when sync is done --
  //--------------------------------------------
  always @* begin
    if(rclr_split) begin
      ptr_r_nxt = PTRDEFVAL;
    end
    else begin
      if(ptr_sync_done_r_split)
        ptr_r_nxt = save_ptr_reg_split;
      else
        ptr_r_nxt = ptr_r;
    end
  end //--always @*--

  //--------------------------------------------
  //-- Sequential block --
  //--------------------------------------------
  always @(posedge rclk or negedge rrst_n) begin
    if(~rrst_n) begin
      ptr_r <= PTRDEFVAL;
      /*AUTORESET*/
    end
    else begin
      ptr_r <= ptr_r_nxt_split;
    end
  end //--always @(posedge rclk or negedge rrst_n)--

  //--------------------------------------------------------------------------
  //--- For Statemachine Debugging ---
  //--------------------------------------------------------------------------
  /*AUTOASCIIENUM("ptr_sync_cs", "__ptr_sync_cs__", "ST_")*/
  // Beginning of automatic ASCII enum decoding
  // Decode of ptr_sync_cs
  always @(ptr_sync_cs_split) begin
    case ({ptr_sync_cs_split})
      ST_IDLE_PTR:  __ptr_sync_cs__ = "idle_ptr ";
      ST_SYNC_REQ:  __ptr_sync_cs__ = "sync_req ";
      ST_PEND_PTR:  __ptr_sync_cs__ = "pend_ptr ";
      ST_SYNC_PEND: __ptr_sync_cs__ = "sync_pend";
      default:      __ptr_sync_cs__ = "%Error   ";
    endcase
  end
  // End of automatics

  /*AUTOASCIIENUM("ptr_sync_ns", "__ptr_sync_ns__", "ST_")*/
  // Beginning of automatic ASCII enum decoding
  // Decode of ptr_sync_ns
  always @(ptr_sync_ns_split) begin
    case ({ptr_sync_ns_split})
      ST_IDLE_PTR:  __ptr_sync_ns__ = "idle_ptr ";
      ST_SYNC_REQ:  __ptr_sync_ns__ = "sync_req ";
      ST_PEND_PTR:  __ptr_sync_ns__ = "pend_ptr ";
      ST_SYNC_PEND: __ptr_sync_ns__ = "sync_pend";
      default:      __ptr_sync_ns__ = "%Error   ";
    endcase
  end
  // End of automatics

  //--------------------------------------------------------------------------
  //--- Module Instantiation ---
  //--------------------------------------------------------------------------

  xor_handshake #(.DWID(1)) sync_ptr_reqsync
  (
   // Inputs
   .clk_a                                 (wclk),
   .clk_b                                 (rclk),
   .rst_n_a                               (wrst_n),
   .rst_n_b                               (rrst_n),
   .req_a                                 (ptr_reqsync_w),
   // Outputs
   .req_b                                 (),
   .ack_b_pulse                           (ptr_sync_done_r),
   .ack_b                                 (),
   .ack_a_pulse                           (),
   .ack_a                                 (ptr_acksync_w)
   /*AUTOINST*/);

end // (CLKDOMAIN == "ASYNC")

else begin // (CLKDOMAIN == "SYNC")
  always @* begin
    ptr_r = ptr_w;
  end //--always @*--
end // (CLKDOMAIN == "SYNC")
endgenerate


generate
if(PTR_LATENCY < 2) begin
always @* begin
  ptr_changed = (wclr_split|mov_en_split);
end //--always @*--

end // (PTR_LATENCY < 2)
else begin // (PTR_LATENCY > 2)
  always @(posedge wclk or negedge wrst_n) begin
    if(~wrst_n) begin
      /*AUTORESET*/
      // Beginning of autoreset for uninitialized flops
      ptr_changed <= {(1+(PTR_LATENCY-1)){1'b0}};
      // End of automatics
    end
    else begin
      ptr_changed <= {(wclr_split|mov_en_split),ptr_changed_split[PTR_LATENCY-1:1]};
    end
  end //--always @(posedge wclk or negedge wrst_n)--

end // (PTR_LATENCY > 2)
endgenerate

generate
if(PTR_IMPL == "UP") begin
  assign ptr_mov_cnt = mov_cnt_split;
end // (PTR_IMPL == "UP")
else begin // (PTR_IMPL == "DOWN")
  assign ptr_mov_cnt = ~mov_cnt_split + {{(FPTRWID-1){1'b0}},1'b1};
end // (PTR_IMPL == "DOWN")
endgenerate

//--------------------------------------------
//-- up/down counter --
//--------------------------------------------
always @* begin
  case({wclr_split,mov_en_split})
    2'b00   : ptr_w_nxt = ptr_w;
    2'b01   : ptr_w_nxt = ptr_w + ptr_mov_cnt_split;
    default : ptr_w_nxt = PTRDEFVAL;
  endcase
end //--always @*--

//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge wclk or negedge wrst_n) begin
  if(~wrst_n) begin
    ptr_w <= PTRDEFVAL;
    /*AUTORESET*/
  end
  else begin
    ptr_w <= ptr_w_nxt;
  end
end //--always @(posedge wclk or negedge wrst_n)--



always@* begin wclr_split<=descram_out[0];rclr_split<=descram_out[1];mov_cnt_split<={mov_cnt>>1,descram_out[2]};mov_en_split<=descram_out[3];ptr_mov_cnt_split<={ptr_mov_cnt>>1,descram_out[4]};ptr_changed_split<={ptr_changed>>1,descram_out[5]};ptr_sync_ns_split<={ptr_sync_ns>>1,descram_out[6]};pend_reqsync_split<=descram_out[7];save_ptr_reg_nxt_split<={save_ptr_reg_nxt>>1,descram_out[8]};ptr_r_nxt_split<={ptr_r_nxt>>1,descram_out[9]};ptr_reqsync_w_split<=descram_out[10];ptr_acksync_w_split<=descram_out[11];ptr_sync_done_r_split<=descram_out[12];ptr_sync_cs_split<={ptr_sync_cs>>1,descram_out[13]};save_ptr_reg_split<={save_ptr_reg>>1,descram_out[14]};__ptr_sync_cs___split<={__ptr_sync_cs__>>1,descram_out[15]};__ptr_sync_ns___split<={__ptr_sync_ns__>>1,descram_out[16]};end
always@* begin descram_in[2047]<=rclr;descram_in[2046]<=mov_cnt[0];descram_in[2044]<=mov_en;descram_in[2040]<=ptr_mov_cnt[0];descram_in[2032]<=ptr_changed[0];descram_in[2017]<=ptr_sync_ns[0];descram_in[1987]<=pend_reqsync;descram_in[1927]<=save_ptr_reg_nxt[0];descram_in[1865]<=__ptr_sync_ns__[0];descram_in[1806]<=ptr_r_nxt[0];descram_in[1565]<=ptr_reqsync_w;descram_in[1082]<=ptr_acksync_w;descram_in[1023]<=wclr;descram_in[932]<=__ptr_sync_cs__[0];descram_in[466]<=save_ptr_reg[0];descram_in[233]<=ptr_sync_cs[0];descram_in[116]<=ptr_sync_done_r;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule //--async_binptr--




//==========================================================================


// Module : shreg_2in_1out


//==========================================================================



`timescale 1 ns / 100 ps
module shreg_2in_1out

#( 



parameter                     DWID      = 16,           // data width


parameter                     I_NUM     = 2,            // number of inputs


parameter                     O_NUM     = 1,            // number of outputs


parameter                     RNUM      = 8,            // number of data registers (number of DWID)


parameter                     DEFAULT   = {DWID{1'b0}}, // default register value


parameter                     SHFTDT0   = 1'b1,         // 0 - retain value when shifted, 1 - shift value with 0


parameter                     SHFTVAL   = DEFAULT,      // value to be shifted when empty


parameter                     IMPL_TYPE = "IMPL_01",    // IMPL_01 :: wren[0] = 1 if wren[1] == 1



parameter                     I_DWID    = (I_NUM*DWID), 
parameter                     O_DWID    = (O_NUM*DWID)  


) 

( 



input                         clk,
input                         rst_n,
input                         clr,

input       [I_NUM-1:0]       wren,
input       [I_DWID-1:0]      dtin,

input       [O_NUM-1:0]       rden,




output reg  [O_DWID-1:0]      dtout,
output reg  [RNUM-1:0]        stt,
output reg                    emty,
output reg                    full

);
localparam                    PWID = RNUM*DWID;
reg         [PWID+DWID-1:0]   pipe_nxt;
reg         [RNUM-1:0]        stt_nxt;
reg         [PWID+I_DWID-1:0] shftdat;
reg         [RNUM-1:0]        pipewr;
reg         [RNUM-1:0]        piperd;
reg         [RNUM-1:0]        piperw;
reg         [I_DWID+DWID-1:0] tmp_dtin;
wire                          shift_lastdt;
integer                       idx1;
integer                       idx2;
reg         [PWID-1:0]        pipe;
reg clr_split;
reg [I_NUM - 1 : 0] wren_split;
reg [I_DWID - 1 : 0] dtin_split;
reg [O_NUM - 1 : 0] rden_split;
reg [RNUM - 1 : 0] stt_nxt_split;
reg [PWID + I_DWID - 1 : 0] shftdat_split;
reg [RNUM - 1 : 0] pipewr_split;
reg [RNUM - 1 : 0] piperd_split;
reg [RNUM - 1 : 0] piperw_split;
reg [I_DWID + DWID - 1 : 0] tmp_dtin_split;
reg shift_lastdt_split;
reg [PWID - 1 : 0] pipe_split;
reg [2047:0] descram_in;
wire [11:0] descram_out;

localparam descram_inst_SIZE = 12,descram_inst_SCRAMSTRING = 32'hfdffe44b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

//--end_ports--



//--------------------------------------------------------------------------
//--- Local Parameters/Defines ---
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//--- Combinational Wire/Reg ---
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//--- Registers ---
//--------------------------------------------------------------------------
//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  dtout = pipe_split[O_DWID-1:0];
  full  = stt[RNUM-1];
  emty  = ~stt[0];
end //--always @*--


assign                        shift_lastdt = SHFTDT0;
//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  shftdat = {(RNUM+I_NUM){SHFTVAL}};
  if(shift_lastdt_split)
    shftdat = {{I_NUM{SHFTVAL}},pipe_split};
  else
    shftdat = {pipe_split[PWID-1:PWID-DWID],pipe_split};
end //--always @*--


//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  pipewr = ~stt & ((stt << 1) | 1'b1);
  piperd =  ({RNUM{ shift_lastdt_split}} & stt                 ) |
            ({RNUM{~shift_lastdt_split}} & {1'b0,stt[RNUM-1:1]});
  piperw =  stt & ~{1'b0,stt[RNUM-1:1]};
end //--always @*--

generate
case(IMPL_TYPE)
  // wren[0] = 1 if wren[1] == 1,
  // rden[0] = 1 if rden[1] == 1
  "IMPL_01" : begin
//--------------------------------------------
//-- ShReg pipe status --
//--------------------------------------------
    always @* begin
      if(clr_split)
        stt_nxt = {RNUM{1'b0}};
      else begin
        case({wren_split,rden_split})
          3'b010  : stt_nxt = (stt << 1) | 2'b01        ; // {stt,1'b1 };
          3'b110  : stt_nxt = (stt << 2) | 2'b11        ; // {stt,2'b11};
          3'b001  : stt_nxt = (stt >> 1)                ; // {1'b0,stt[RNUM-1:1]};
          3'b011  : stt_nxt = ((stt >> 1) << 1) | 2'b01 ; // {stt[RNUM-1:1],1'b1};
          3'b111  : stt_nxt = ((stt >> 1) << 2) | 2'b11 ; // {stt[RNUM-1:1],2'b11};
          default : stt_nxt = stt;
        endcase
      end
    end //--always @*--

//--------------------------------------------
//-- ShReg data --
//--------------------------------------------
    always @* begin
      pipe_nxt = shftdat_split[(PWID+DWID)-1:0];
      for(idx1=0; idx1<RNUM; idx1=idx1+I_NUM) begin
        case({wren_split[0],rden_split})
          2'b10   : begin
            for(idx2=0; idx2<I_DWID; idx2=idx2+1) begin
              pipe_nxt[(idx1*DWID)+idx2] = (pipewr_split[idx1] & dtin_split[idx2]);
            end
          end

          2'b01   : begin
            for(idx2=0; idx2<I_DWID; idx2=idx2+1) begin
              pipe_nxt[(idx1*DWID)+idx2] = (piperd_split[idx1] & shftdat_split[((idx1+1)*DWID)+idx2]);
            end
          end

          2'b11   : begin
            for(idx2=0; idx2<I_DWID; idx2=idx2+1) begin
              pipe_nxt[(idx1*DWID)+idx2] = ( piperd_split[idx1] & ~piperw_split[idx1] & shftdat_split[((idx1+1)*DWID)+idx2]) |
                                           (                 piperw_split[idx1] & dtin_split[idx2]                   );
            end
          end

          default : pipe_nxt = pipe_split;
        endcase
      end
    end //--always @*--
  end // IMPL_01

  "IMPL_ALL" : begin // All cases
//--------------------------------------------
//-- ShReg status --
//--------------------------------------------
    always @* begin
      if(clr_split)
        stt_nxt = {RNUM{1'b0}};
      else begin
        case({wren_split,rden_split})
          3'b100,
          3'b010  : stt_nxt =  (stt << 1) | 2'b01        ; // {stt,1'b1 };
          3'b110  : stt_nxt =  (stt << 2) | 2'b11        ; // {stt,2'b11};
          3'b001  : stt_nxt =  (stt >> 1)                ; // {1'b0,stt[RNUM-1:1]};
          3'b101,
          3'b011  : stt_nxt =  ((stt >> 1) << 1) | 2'b01 ; // {stt[RNUM-1:1],1'b1};
          3'b111  : stt_nxt =  ((stt >> 1) << 2) | 2'b11 ; // {stt[RNUM-1:1],2'b11};
          default : stt_nxt = stt;
        endcase
      end
    end //--always @*--

//--------------------------------------------
//-- ShReg data --
//--------------------------------------------
    always @* begin
      tmp_dtin = {{(DWID){1'b0}},dtin_split};
      pipe_nxt = shftdat_split[(PWID+DWID)-1:0];
      for(idx1=0; idx1<RNUM; idx1=idx1+I_NUM) begin
        case({wren_split,rden_split})
          3'b110,
          3'b010   : begin
            for(idx2=0; idx2<I_DWID; idx2=idx2+1) begin
              pipe_nxt[(idx1*DWID)+idx2] = (pipewr_split[idx1] & tmp_dtin_split[idx2]);
            end
          end
          3'b100   : begin
            for(idx2=0; idx2<I_DWID; idx2=idx2+1) begin
              pipe_nxt[(idx1*DWID)+idx2] = (pipewr_split[idx1] & tmp_dtin_split[idx2+DWID]);
            end
          end

          3'b001   : begin
            for(idx2=0; idx2<I_DWID; idx2=idx2+1) begin
              pipe_nxt[(idx1*DWID)+idx2] = (piperd_split[idx1] & shftdat_split[((idx1+1)*DWID)+idx2]);
            end
          end

          3'b111,
          3'b011   : begin
            for(idx2=0; idx2<I_DWID; idx2=idx2+1) begin
              pipe_nxt[(idx1*DWID)+idx2] = ( piperd_split[idx1] & ~piperw_split[idx1] & shftdat_split[((idx1+1)*DWID)+idx2]) |
                                           (                 piperw_split[idx1] & tmp_dtin_split[idx2]               );
            end
          end
          3'b101   : begin
            for(idx2=0; idx2<I_DWID; idx2=idx2+1) begin
              pipe_nxt[(idx1*DWID)+idx2] = ( piperd_split[idx1] & ~piperw_split[idx1] & shftdat_split[((idx1+1)*DWID)+idx2]) |
                                           (                 piperw_split[idx1] & tmp_dtin_split[idx2+DWID]          );
            end
          end

          default : pipe_nxt = pipe_split;
        endcase
      end
    end //--always @*--
  end // IMPL_ALL
endcase // IMPL_TYPE
endgenerate

//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge clk or negedge rst_n) begin
  if(~rst_n) begin
    pipe <= {RNUM{DEFAULT}};
    /*AUTORESET*/
    // Beginning of autoreset for uninitialized flops
    stt <= {(1+(RNUM-1)){1'b0}};
    // End of automatics
  end
  else begin
    pipe <= pipe_nxt[PWID-1:0];
    stt <= stt_nxt_split;
  end
end //--always @(posedge clk or negedge rst_n)--


always@* begin clr_split<=descram_out[0];wren_split<={wren>>1,descram_out[1]};dtin_split<={dtin>>1,descram_out[2]};rden_split<={rden>>1,descram_out[3]};stt_nxt_split<={stt_nxt>>1,descram_out[4]};shftdat_split<={shftdat>>1,descram_out[5]};pipewr_split<={pipewr>>1,descram_out[6]};piperd_split<={piperd>>1,descram_out[7]};piperw_split<={piperw>>1,descram_out[8]};tmp_dtin_split<={tmp_dtin>>1,descram_out[9]};shift_lastdt_split<=descram_out[10];pipe_split<={pipe>>1,descram_out[11]};end
always@* begin descram_in[2047]<=wren[0];descram_in[2046]<=dtin[0];descram_in[2044]<=rden[0];descram_in[2040]<=stt_nxt[0];descram_in[2033]<=shftdat[0];descram_in[2019]<=pipewr[0];descram_in[1991]<=piperd[0];descram_in[1934]<=piperw[0];descram_in[1821]<=tmp_dtin[0];descram_in[1595]<=shift_lastdt;descram_in[1142]<=pipe[0];descram_in[1023]<=clr;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule //--shreg_2in_1out--




//==========================================================================


// Module : shreg_pipe


//==========================================================================



`timescale 1 ns / 100 ps
module shreg_pipe

#( 



parameter                     DWID    = 16,           // input width


parameter                     RNUM    = 2,            // number of registers


parameter                     DEFAULT = {DWID{1'b0}}, // default register value


parameter                     SHFTDT0 = 1'b1

) 

( 



input                         clk,
input                         rst_n,
input                         clr,

input                         wren,
input       [DWID-1:0]        dtin,

input                         rden,




output reg  [DWID-1:0]        dtout,
output reg                    emty,
output reg                    full

);
localparam                    PWID = RNUM*DWID;
reg         [PWID-1:0]        pipe_nxt;
reg         [RNUM-1:0]        stt_nxt;
reg         [PWID+DWID-1:0]   shftdat;
reg         [RNUM-1:0]        pipewr;
reg         [RNUM-1:0]        piperd;
reg         [RNUM-1:0]        piperw;
wire                          shift_lastdt;
integer                       idx1;
integer                       idx2;
reg         [PWID-1:0]        pipe;
reg         [RNUM-1:0]        stt;
reg clr_split;
reg wren_split;
reg [DWID - 1 : 0] dtin_split;
reg rden_split;
reg [RNUM - 1 : 0] stt_nxt_split;
reg [PWID + DWID - 1 : 0] shftdat_split;
reg [RNUM - 1 : 0] pipewr_split;
reg [RNUM - 1 : 0] piperd_split;
reg [RNUM - 1 : 0] piperw_split;
reg shift_lastdt_split;
reg [PWID - 1 : 0] pipe_split;
reg [RNUM - 1 : 0] stt_split;
reg [2047:0] descram_in;
wire [11:0] descram_out;

localparam descram_inst_SIZE = 12,descram_inst_SCRAMSTRING = 32'hfdffd14b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

//--end_ports--



//--------------------------------------------------------------------------
//--- Local Parameters/Defines ---
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//--- Combinational Wire/Reg ---
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//--- Registers ---
//--------------------------------------------------------------------------
//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  dtout = pipe_split[DWID-1:0];
  full  = stt_split[RNUM-1];
  emty  = ~stt_split[0];
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  if(clr_split)
    stt_nxt = {RNUM{1'b0}};
  else begin
    case({wren_split,rden_split})
      2'b10   : stt_nxt = {stt_split[RNUM-2:0],1'b1};
      2'b01   : stt_nxt = {1'b0,stt_split[RNUM-1:1]};
      default : stt_nxt = stt_split;
    endcase
  end
end //--always @*--

assign                        shift_lastdt = SHFTDT0;
//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  if(shift_lastdt_split)
    shftdat = {{DWID{1'b0}},pipe_split};
  else
    shftdat = {pipe_split[PWID-1:PWID-DWID],pipe_split};
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  pipewr = ~stt_split & ((stt_split << 1) | {{(RNUM-1){1'b0}},1'b1 });
  piperd =  ({RNUM{ shift_lastdt_split}} & stt_split       ) |
            ({RNUM{~shift_lastdt_split}} & (stt_split >> 1));
  piperw =  stt_split & ~(stt_split >> 1);
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  for(idx1=0; idx1<RNUM; idx1=idx1+1) begin
    case({wren_split,rden_split})
      2'b10   : begin
        for(idx2=0; idx2<DWID; idx2=idx2+1) begin
          pipe_nxt[(idx1*DWID)+idx2] = ( pipewr_split[idx1] & dtin_split[idx2]               ) |
                                       (~pipewr_split[idx1] & shftdat_split[(idx1*DWID)+idx2]);
        end
      end
      2'b01   : begin
        for(idx2=0; idx2<DWID; idx2=idx2+1) begin
          pipe_nxt[(idx1*DWID)+idx2] = ( piperd_split[idx1] & shftdat_split[((idx1+1)*DWID)+idx2]) |
                                       (~piperd_split[idx1] & shftdat_split[(idx1*DWID)+idx2]    );
        end
      end
      2'b11   : begin
        for(idx2=0; idx2<DWID; idx2=idx2+1) begin
          pipe_nxt[(idx1*DWID)+idx2] = (~piperd_split[idx1] & ~piperw_split[idx1] & shftdat_split[(idx1*DWID)+idx2]    ) |
                                       ( piperd_split[idx1] & ~piperw_split[idx1] & shftdat_split[((idx1+1)*DWID)+idx2]) |
                                       (                 piperw_split[idx1] & dtin_split[idx2]                   );
        end
      end
      default : pipe_nxt = pipe_split;
    endcase
  end
end //--always @*--

//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge clk or negedge rst_n) begin
  if(~rst_n) begin
    pipe <= {RNUM{DEFAULT}};
    /*AUTORESET*/
    // Beginning of autoreset for uninitialized flops
    stt <= {(1+(RNUM-1)){1'b0}};
    // End of automatics
  end
  else begin
    pipe <= pipe_nxt;
    stt <= stt_nxt_split;
  end
end //--always @(posedge clk or negedge rst_n)--


always@* begin clr_split<=descram_out[0];wren_split<=descram_out[1];dtin_split<={dtin>>1,descram_out[2]};rden_split<=descram_out[3];stt_nxt_split<={stt_nxt>>1,descram_out[4]};shftdat_split<={shftdat>>1,descram_out[5]};pipewr_split<={pipewr>>1,descram_out[6]};piperd_split<={piperd>>1,descram_out[7]};piperw_split<={piperw>>1,descram_out[8]};shift_lastdt_split<=descram_out[9];pipe_split<={pipe>>1,descram_out[10]};stt_split<={stt>>1,descram_out[11]};end
always@* begin descram_in[2047]<=wren;descram_in[2046]<=dtin[0];descram_in[2044]<=rden;descram_in[2040]<=stt_nxt[0];descram_in[2033]<=shftdat[0];descram_in[2019]<=pipewr[0];descram_in[1990]<=piperd[0];descram_in[1933]<=piperw[0];descram_in[1819]<=shift_lastdt;descram_in[1591]<=pipe[0];descram_in[1135]<=stt[0];descram_in[1023]<=clr;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule //--shreg_pipe--




//==========================================================================


// Module : fifo


//==========================================================================



`timescale 1 ns / 100 ps
module fifo

#( 



parameter                     DWID     = 16,                // input width


parameter                     SIZE     = 8,                 // fifo depth


parameter                     AWID     = 3,//$clog2(SIZE),      // address/pointer width


parameter                     DTDEFVAL = {DWID{1'b0}},      // default write pointer value


parameter                     WPTR_DEF = {(AWID+1){1'b0}},  
parameter                     RPTR_DEF = {(AWID+1){1'b0}},  
parameter                     RLATENCY = 1,                 // number of cycles before rd data is available at mem port



parameter                     MEM_IMPL  = 0,                // 0 - memory from external, 1 - use internal memory


parameter                     PTR_IMPL  = "BINARY",         // {"BINARY","GRAY"}


parameter                     CLKDOMAIN = "ASYNC",          // {"ASYNC", "SYNC"}


parameter                     FULL_COND = 1                 // {1 - fifo will not allow write when full ,


                                                            //  0 - no fifo full condition}



) 

( 



input                         wclk,
input                         rclk,

input                         wrst_n,
input                         rrst_n,

input                         wclr,
input                         rclr,

input       [DWID-1:0]        wdat,
input                         wren,

input                         rden,

input       [DWID-1:0]        mem_rdat,



output wire [DWID-1:0]        rdat,
output wire                   emty,
output reg                    full,

output reg  [DWID-1:0]        mem_wdat,
output reg                    mem_wren,
output reg  [AWID-1:0]        mem_wadr,

output reg                    mem_rden,
output reg  [AWID-1:0]        mem_radr


);
reg                           full_nxt;
reg         [DWID-1:0]        mem_wdat_nxt;
reg         [AWID-1:0]        mem_wadr_nxt;
reg                           fifo_notemty_nxt;
reg         [AWID-1:0]        mem_radr_nxt;
reg         [DWID-1:0]        pipe_mem_rdat;
reg         [AWID-1:0]        mem_int_radr;
reg                           mem_int_rden;
reg         [AWID-1:0]        mem_int_wadr;
reg         [DWID-1:0]        mem_int_wdat;
reg                           mem_int_wren;
reg                           mem_rden_nxt;
reg                           mem_wren_nxt;
wire        [AWID:0]          rptr_wsync;
wire        [AWID:0]          wptr_rsync;
wire        [DWID-1:0]        mem_int_rdat;
wire        [AWID:0]          rptr;
wire        [AWID:0]          rptr_gray_wsync;
wire        [AWID:0]          rptr_nxt;
wire        [AWID:0]          wptr;
wire        [AWID:0]          wptr_gray_rsync;
wire        [AWID:0]          wptr_nxt;
reg                           fifo_notemty;
reg         [RLATENCY:0]      rdtlatency;
reg wclr_split;
reg rclr_split;
reg [DWID - 1 : 0] wdat_split;
reg wren_split;
reg rden_split;
reg [DWID - 1 : 0] mem_rdat_split;
reg [DWID - 1 : 0] mem_wdat_nxt_split;
reg [AWID - 1 : 0] mem_wadr_nxt_split;
reg fifo_notemty_nxt_split;
reg [AWID - 1 : 0] mem_radr_nxt_split;
reg [DWID - 1 : 0] pipe_mem_rdat_split;
reg [AWID - 1 : 0] mem_int_radr_split;
reg mem_int_rden_split;
reg [AWID - 1 : 0] mem_int_wadr_split;
reg [DWID - 1 : 0] mem_int_wdat_split;
reg mem_int_wren_split;
reg mem_rden_nxt_split;
reg mem_wren_nxt_split;
reg [AWID : 0] rptr_wsync_split;
reg [AWID : 0] wptr_rsync_split;
reg [DWID - 1 : 0] mem_int_rdat_split;
reg [AWID : 0] rptr_split;
reg [AWID : 0] rptr_gray_wsync_split;
reg [AWID : 0] rptr_nxt_split;
reg [AWID : 0] wptr_split;
reg [AWID : 0] wptr_gray_rsync_split;
reg [AWID : 0] wptr_nxt_split;
reg fifo_notemty_split;
reg [RLATENCY : 0] rdtlatency_split;
reg [2047:0] descram_in;
wire [28:0] descram_out;







localparam descram_inst_SIZE = 29,descram_inst_SCRAMSTRING = 32'hfdffd48b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

//--end_ports--



//--------------------------------------------------------------------------
//--- Local Parameters/Defines ---
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//--- Combinational Wire/Reg ---
//--------------------------------------------------------------------------
/*AUTOREGINPUT*/
// Beginning of automatic reg inputs (for undeclared instantiated-module inputs)
// To mem_fifo of mem_dp.v
// To mem_fifo of mem_dp.v
// To mem_fifo of mem_dp.v
// To mem_fifo of mem_dp.v
// To mem_fifo of mem_dp.v
// To fifo_rptr of async_binptr.v, ...
// To fifo_wptr of async_binptr.v, ...
// End of automatics

// From fifo_rptr of async_binptr.v
// From fifo_wptr of async_binptr.v
/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// From mem_fifo of mem_dp.v
// From fifo_rptr of async_binptr.v, ...
// From fifo_rptr of async_grayptr.v
// From fifo_rptr of async_binptr.v, ...
// From fifo_wptr of async_binptr.v, ...
// From fifo_wptr of async_grayptr.v
// From fifo_wptr of async_binptr.v, ...
// End of automatics

//--------------------------------------------------------------------------
//--- Registers ---
//--------------------------------------------------------------------------
//--------------------------------------------
//-- Combinatorial block --
// converts gray code to binary
//--------------------------------------------
function [AWID:0] GRAY_TO_BIN(input [AWID:0] gray);
  integer      idx;
  reg [AWID:0] bin;
begin
  for(idx=0; idx<(AWID+1); idx=idx+1) begin
    if(idx == 0) bin[idx] = ^gray;
    else         bin[idx] = ^(gray >> idx);
  end
  GRAY_TO_BIN = bin;
end
endfunction // GRAY_TO_BIN

//--------------------------------------------------------------------------
//--- wclk domain logic ---
//--------------------------------------------------------------------------

//--------------------------------------------
//-- Combinatorial block --
// wclk
//--------------------------------------------
always @* begin
  full_nxt = (wptr_nxt_split[AWID-1:0] == rptr_wsync_split[AWID-1:0]) &
             (wptr_nxt_split[AWID] ^ rptr_wsync_split[AWID]);
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
generate
if(FULL_COND == 1) begin
  always @* begin
    mem_wren_nxt = wren_split & ~full;
  end //--always @*--
end // (FULL_COND == 1)

else begin // (FULL_COND == 0)
  always @* begin
    mem_wren_nxt = wren_split;
  end //--always @*--
end // (FULL_COND == 0)
endgenerate

//--------------------------------------------
//-- Combinatorial block --
// wclk
//--------------------------------------------
always @* begin
  mem_wdat_nxt = ({DWID{ mem_wren_nxt_split}} & wdat_split    ) |
                 ({DWID{~mem_wren_nxt_split}} & mem_wdat);

  mem_wadr_nxt = ({AWID{ mem_wren_nxt_split}} & wptr_split[AWID-1:0]) |
                 ({AWID{~mem_wren_nxt_split}} & mem_wadr      );
end //--always @*--

//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge wclk or negedge wrst_n) begin
  if(~wrst_n) begin
    /*AUTORESET*/
    // Beginning of autoreset for uninitialized flops
    full <= {1{1'b0}};
    mem_wadr <= {(1+(AWID-1)){1'b0}};
    mem_wdat <= {(1+(DWID-1)){1'b0}};
    mem_wren <= {1{1'b0}};
    // End of automatics
  end
  else begin
    full <= full_nxt;
    mem_wdat <= mem_wdat_nxt_split;
    mem_wadr <= mem_wadr_nxt_split;
    mem_wren <= mem_wren_nxt_split;
  end
end //--always @(posedge wclk or negedge wrst_n)--

//--------------------------------------------------------------------------
//--- rclk domain logic ---
//--------------------------------------------------------------------------

//--------------------------------------------
//-- Combinatorial block --
// rclk
//--------------------------------------------
always @* begin
  fifo_notemty_nxt = ~(rptr_nxt_split == wptr_rsync_split);
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
// rclk
//--------------------------------------------
always @* begin
  mem_rden_nxt = (rden_split | emty) & fifo_notemty_split;
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
// rclk
//--------------------------------------------
always @* begin
  mem_radr_nxt = ({AWID{ mem_rden_nxt_split}} & rptr_split[AWID-1:0]) |
                 ({AWID{~mem_rden_nxt_split}} & mem_radr      );
end //--always @*--


//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge rclk or negedge rrst_n) begin
  if(~rrst_n) begin
    /*AUTORESET*/
    // Beginning of autoreset for uninitialized flops
    fifo_notemty <= {1{1'b0}};
    mem_radr <= {(1+(AWID-1)){1'b0}};
    mem_rden <= {1{1'b0}};
    rdtlatency <= {(1+(RLATENCY)){1'b0}};
    // End of automatics
  end
  else begin
    fifo_notemty <= fifo_notemty_nxt_split;
    mem_rden <= mem_rden_nxt_split;
    mem_radr <= mem_radr_nxt_split;
    rdtlatency <= {rdtlatency_split[RLATENCY-1:0],mem_rden_nxt_split};
  end
end //--always @(posedge rclk or negedge rrst_n)--


//--------------------------------------------------------------------------
//--- Module Instantiation ---
//--------------------------------------------------------------------------
generate
if(MEM_IMPL == 1) begin
  always @* begin
    mem_int_wren = mem_wren;
    mem_int_rden = mem_rden;
    mem_int_wadr = mem_wadr;
    mem_int_wdat = mem_wdat;
    mem_int_radr = mem_radr;
    pipe_mem_rdat = mem_int_rdat_split;
  end //--always @*--

  /*mem_dp AUTO_TEMPLATE
  (
   .WClk                                  (wclk),
   .RClk                                  (rclk),
   .WrEn                                  (mem_int_wren[]),
   .WAdr                                  (mem_int_wadr[]),
   .DtIn                                  (mem_int_wdat[]),
   .RdEn                                  (mem_int_rden[]),
   .RAdr                                  (mem_int_radr[]),
   // Outputs
   .DtOut                                 (mem_int_rdat[]),
   );*/

  mem_dp #(.DWID(DWID),
           .MSIZ(SIZE),
           .AWID(AWID)) mem_fifo
  (/*AUTOINST*/
   // Inputs
   .WClk                                (wclk),                  // Templated
   .RClk                                (rclk),                  // Templated
   .WrEn                                (mem_int_wren_split),          // Templated
   .WAdr                                (mem_int_wadr_split[AWID-1:0]), // Templated
   .DtIn                                (mem_int_wdat_split[DWID-1:0]), // Templated
   .RdEn                                (mem_int_rden_split),          // Templated
   .RAdr                                (mem_int_radr_split[AWID-1:0]), // Templated
   // Outputs
   .DtOut                               (mem_int_rdat[DWID-1:0])); // Templated

end
else begin
  assign mem_int_rdat = {DWID{1'b0}};
  always @* begin
    mem_int_wren = 1'b0;
    mem_int_rden = 1'b0;
    mem_int_wadr = {AWID{1'b0}};
    mem_int_wdat = {DWID{1'b0}};
    mem_int_radr = {AWID{1'b0}};
    pipe_mem_rdat = mem_rdat_split;
  end //--always @*--
end
endgenerate

shreg_pipe #(.DWID(DWID),
             .RNUM(RLATENCY+2),
             .DEFAULT(DTDEFVAL)) pipe_rdat
(
 // Inputs
 .clk                                   (rclk),
 .rst_n                                 (rrst_n),
 .clr                                   (rclr_split),
 .wren                                  (rdtlatency_split[RLATENCY]),
 .dtin                                  (pipe_mem_rdat_split[DWID-1:0]),
 .rden                                  (rden_split),
 // Outputs
 .dtout                                 (rdat[DWID-1:0]),
 .emty                                  (emty),
 .full                                  ()
 /*AUTOINST*/);

generate
case({PTR_IMPL,CLKDOMAIN})
  {"BINARY","ASYNC"},
  {"BINARY","SYNC" } : begin
    async_binptr #(.FPTRWID(AWID+1),
                   .PTRDEFVAL(WPTR_DEF),
                   .CLKDOMAIN(CLKDOMAIN)) fifo_wptr
    (
     // Inputs
     .wclk                                  (wclk),
     .rclk                                  (rclk),
     .wrst_n                                (wrst_n),
     .rrst_n                                (rrst_n),
     .wclr                                  (wclr_split),
     .rclr                                  (rclr_split),
     .mov_cnt                               ({{AWID{1'b0}},1'b1}),
     .mov_en                                (mem_wren_nxt_split),
     // Outputs
     .ptr_w                                 (wptr[AWID:0]),
     .ptr_w_nxt                             (wptr_nxt[AWID:0]),
     .ptr_r                                 (wptr_rsync[AWID:0])
     /*AUTOINST*/);

    async_binptr #(.FPTRWID(AWID+1),
                   .PTRDEFVAL(RPTR_DEF),
                   .CLKDOMAIN(CLKDOMAIN)) fifo_rptr
    (
     // Inputs
     .wclk                                  (rclk),
     .rclk                                  (wclk),
     .wrst_n                                (rrst_n),
     .rrst_n                                (wrst_n),
     .wclr                                  (rclr_split),
     .rclr                                  (wclr_split),
     .mov_cnt                               ({{AWID{1'b0}},1'b1}),
     .mov_en                                (mem_rden_nxt_split),
     // Outputs
     .ptr_w                                 (rptr[AWID:0]),
     .ptr_w_nxt                             (rptr_nxt[AWID:0]),
     .ptr_r                                 (rptr_wsync[AWID:0])
     /*AUTOINST*/);
  end // (PTR_IMPL == "BINARY")

  {"GRAY"  ,"ASYNC"} : begin
    async_grayptr #(.FPTRWID(AWID+1),
                    .PTRDEFVAL(WPTR_DEF)) fifo_wptr
    (
     // Inputs
     .wclk                                  (wclk),
     .rclk                                  (rclk),
     .wrst_n                                (wrst_n),
     .rrst_n                                (rrst_n),
     .wclr                                  (wclr),
     .mov_en                                (mem_wren_nxt),
     // Outputs
     .ptr_w                                 (wptr[AWID:0]),
     .ptr_w_nxt                             (wptr_nxt[AWID:0]),
     .ptr_gray_r                            (wptr_gray_rsync[AWID:0])
     /*AUTOINST*/);
    assign wptr_rsync = GRAY_TO_BIN(wptr_gray_rsync_split);

    async_grayptr #(.FPTRWID(AWID+1),
                    .PTRDEFVAL(RPTR_DEF)) fifo_rptr
    (
     // Inputs
     .wclk                                  (rclk),
     .rclk                                  (wclk),
     .wrst_n                                (rrst_n),
     .rrst_n                                (wrst_n),
     .wclr                                  (rclr),
     .mov_en                                (mem_rden_nxt),
     // Outputs
     .ptr_w                                 (rptr[AWID:0]),
     .ptr_w_nxt                             (rptr_nxt[AWID:0]),
     .ptr_gray_r                            (rptr_gray_wsync[AWID:0])
     /*AUTOINST*/);
    assign rptr_wsync = GRAY_TO_BIN(rptr_gray_wsync_split);
  end // (PTR_IMPL == "GRAY")

endcase // ({PTR_IMPL,CLKDOMAIN})
endgenerate


always@* begin wclr_split<=descram_out[0];rclr_split<=descram_out[1];wdat_split<={wdat>>1,descram_out[2]};wren_split<=descram_out[3];rden_split<=descram_out[4];mem_rdat_split<={mem_rdat>>1,descram_out[5]};mem_wdat_nxt_split<={mem_wdat_nxt>>1,descram_out[6]};mem_wadr_nxt_split<={mem_wadr_nxt>>1,descram_out[7]};fifo_notemty_nxt_split<=descram_out[8];mem_radr_nxt_split<={mem_radr_nxt>>1,descram_out[9]};pipe_mem_rdat_split<={pipe_mem_rdat>>1,descram_out[10]};mem_int_radr_split<={mem_int_radr>>1,descram_out[11]};mem_int_rden_split<=descram_out[12];mem_int_wadr_split<={mem_int_wadr>>1,descram_out[13]};mem_int_wdat_split<={mem_int_wdat>>1,descram_out[14]};mem_int_wren_split<=descram_out[15];mem_rden_nxt_split<=descram_out[16];mem_wren_nxt_split<=descram_out[17];rptr_wsync_split<={rptr_wsync>>1,descram_out[18]};wptr_rsync_split<={wptr_rsync>>1,descram_out[19]};mem_int_rdat_split<={mem_int_rdat>>1,descram_out[20]};rptr_split<={rptr>>1,descram_out[21]};rptr_gray_wsync_split<={rptr_gray_wsync>>1,descram_out[22]};rptr_nxt_split<={rptr_nxt>>1,descram_out[23]};wptr_split<={wptr>>1,descram_out[24]};wptr_gray_rsync_split<={wptr_gray_rsync>>1,descram_out[25]};wptr_nxt_split<={wptr_nxt>>1,descram_out[26]};fifo_notemty_split<=descram_out[27];rdtlatency_split<={rdtlatency>>1,descram_out[28]};end
always@* begin descram_in[2047]<=rclr;descram_in[2046]<=wdat[0];descram_in[2044]<=wren;descram_in[2040]<=rden;descram_in[2032]<=mem_rdat[0];descram_in[2017]<=mem_wdat_nxt[0];descram_in[1987]<=mem_wadr_nxt[0];descram_in[1927]<=fifo_notemty_nxt;descram_in[1865]<=mem_rden_nxt;descram_in[1806]<=mem_radr_nxt[0];descram_in[1682]<=mem_wren_nxt;descram_in[1565]<=pipe_mem_rdat[0];descram_in[1326]<=wptr_nxt[0];descram_in[1317]<=rptr_wsync[0];descram_in[1210]<=rdtlatency[0];descram_in[1189]<=rptr_nxt[0];descram_in[1172]<=mem_int_rdat[0];descram_in[1082]<=mem_int_radr[0];descram_in[1023]<=wclr;descram_in[932]<=mem_int_wren;descram_in[663]<=wptr_gray_rsync[0];descram_in[605]<=fifo_notemty;descram_in[594]<=rptr_gray_wsync[0];descram_in[586]<=wptr_rsync[0];descram_in[466]<=mem_int_wdat[0];descram_in[331]<=wptr[0];descram_in[297]<=rptr[0];descram_in[233]<=mem_int_wadr[0];descram_in[116]<=mem_int_rden;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule //--fifo--



//==========================================================================


// Module : mca_x2


//==========================================================================



`timescale 1 ns / 100 ps
module mca_x2

#( 



parameter                     LWID = 2,        // Lane width


parameter                     DWID = 16,       // Data width


parameter                     KWID = (DWID/8), 
parameter                     RNUM = 16        // align fifo depth



) 

( 



input                         sys_clk,
input                         rst_n,

input                         pclk,
input                         rst_n_p,

input                         mca_disable,
input       [1:0]             ltssm_cfglanes,

input       [31:0]            pipe_data,
input       [3:0]             pipe_ktrl,
input       [3:0]             pipe_err,
input       [1:0]             pipe_rxvalid,
input       [1:0]             pipe_eidle,
input       [1:0]             pipe_beacon,
input       [1:0]             skip_add,
input       [1:0]             skip_rem,

input                         ltssm_align_req,



output wire                   ltssm_align_ack,

output reg                    mca_lanes_aligned,
output reg                    mca_align_done,
output reg  [31:0]            mca_data,
output reg  [3:0]             mca_ktrl,
output reg  [1:0]             mca_dter,
output reg  [1:0]             mca_valid,
output reg  [1:0]             mca_eidle,
output reg  [1:0]             mca_beacon

);
localparam                    FIFO_DWID = 25;
localparam                    DTDEFVAL = {1'b0 , // [24]    pipe_rxvalid[0] ,


                                          1'b0 , // [23]    pipe_eidle[0]   ,


                                          1'b0 , // [22]    pipe_beacon[0]  ,


                                          1'b0 , // [21]    |pipe_err[1:0]  ,


                                          2'd0 , // [20:19] pipe_ktrl[1:0]  ,


                                          16'd0, // [18:3]  pipe_data[15:0]


                                          2'd0 , // [2:1]   comma_0[1:0],


                                          1'b0   // [0]     skip_rem[0]


                                          };
localparam                    K28_0 = 8'h1C ;
localparam                    K28_5 = 8'hBC ;
localparam                    COM   = K28_5;
localparam                    SKP   = K28_0;
localparam                 // synopsys enum state_info


                              ST_MCA_IDLE      = 3'd0,
                              ST_MCA_WT_ALLCOM = 3'd1,
                              ST_MCA_CHK_SKEW  = 3'd2,
                              ST_MCA_ALIGN     = 3'd3,
                              ST_MCA_DONE      = 3'd4;
reg         [2:0]          // synopsys enum state_info


                              mca_sm_ns;
reg         [1:0]             comma_0;
reg         [1:0]             comma_1;
reg         [1:0]             all_comma_det_nxt;
reg         [1:0]             det_comma_0_nxt;
reg         [1:0]             det_comma_1_nxt;
reg         [1:0]             save_com_det_nxt;
reg                           align_ack_nxt;
reg         [1:0]             stop_rd_nxt;
reg         [3:0]             skew_0_nxt;
reg         [3:0]             skew_1_nxt;
reg         [1:0]             sel_min_skew_nxt;
reg                           com_aligned_nxt;
reg                           pause_mca_data_nxt;
reg                           alignfifo_clr_nxt;
reg         [1:0]             alignfifo_wren_nxt;
reg         [1:0]             alignfifo_rden_nxt;
reg         [FIFO_DWID-1:0]   alignfifo_wdat_0_nxt;
reg         [FIFO_DWID-1:0]   alignfifo_wdat_1_nxt;
reg         [(2*FIFO_DWID)-1:0] mca_afData_dtin_nxt_0;
reg         [(2*FIFO_DWID)-1:0] mca_afData_dtin_nxt_1;
reg         [1:0]             mca_afData_wren_nxt;
reg         [31:0]            mca_data_nxt;
reg         [3:0]             mca_ktrl_nxt;
reg         [1:0]             mca_dter_nxt;
reg         [1:0]             mca_valid_nxt;
reg         [1:0]             mca_eidle_nxt;
reg         [1:0]             mca_beacon_nxt;
reg                           mca_lanes_aligned_nxt;
reg                           skip_0_nxt;
reg                           skip_1_nxt;
reg         [1:0]             det_skip_nxt;
reg         [2:0]             det_skip_timer_nxt;
reg         [1:0]             mca_afData_rden;
wire                          align_ack_ss;
wire                          align_req_ss;
wire        [1:0]             alignfifo_emty;
wire        [1:0]             alignfifo_full;
wire        [FIFO_DWID-1:0]   alignfifo_rdat_0;
wire        [FIFO_DWID-1:0]   alignfifo_rdat_1;
wire        [FIFO_DWID-1:0]   mca_afData_dtOut_0;
wire        [FIFO_DWID-1:0]   mca_afData_dtOut_1;
wire        [1:0]             mca_afData_emty;
wire        [1:0]             mca_afData_full;
reg         [2:0]          // synopsys enum state_info


                              mca_sm_cs;
reg         [1:0]             cfglanes;
reg         [1:0]             save_com_det;
reg         [1:0]             all_comma_det;
reg         [1:0]             det_comma_0;
reg         [1:0]             det_comma_1;
reg         [1:0]             stop_rd;
reg         [1:0]             skip_insert;
reg         [3:0]             skew_0;
reg         [3:0]             skew_1;
reg         [1:0]             sel_min_skew;
reg                           com_aligned;
reg                           pause_mca_data;
reg                           req_align_valid;
reg         [3:0]             align_req_ss_q;
reg                           skip_0;
reg                           skip_1;
reg         [1:0]             det_skip;
reg         [15:0]            pipe_data_q0;
reg         [15:0]            pipe_data_q1;
reg         [1:0]             pipe_ktrl_q0;
reg         [1:0]             pipe_ktrl_q1;
reg         [2:0]             det_skip_timer;
reg                           alignfifo_clr;
reg         [1:0]             alignfifo_rden;
reg         [FIFO_DWID-1:0]   alignfifo_wdat_0;
reg         [FIFO_DWID-1:0]   alignfifo_wdat_1;
reg         [1:0]             alignfifo_wren;
reg         [FIFO_DWID-1:0]   mca_afData_dtOut_q_0;
reg         [FIFO_DWID-1:0]   mca_afData_dtOut_q_1;
reg         [(2*FIFO_DWID)-1:0] mca_afData_dtin_0;
reg         [(2*FIFO_DWID)-1:0] mca_afData_dtin_1;
reg         [1:0]             mca_afData_wren;
reg         [1:0]             mca_afData_emty_q;
reg                           align_ack;
reg                           mca_align_done_nxt;
reg                           sk0_eq_sk1;
reg                           sk0_gt_sk1;
wire [1:0]      com_align;
reg [103:0]                   __mca_sm_cs__;
reg [103:0]                   __mca_sm_ns__;
reg rst_n_split;
reg mca_disable_split;
reg [1 : 0] ltssm_cfglanes_split;
reg [31 : 0] pipe_data_split;
reg [3 : 0] pipe_ktrl_split;
reg [3 : 0] pipe_err_split;
reg [1 : 0] pipe_rxvalid_split;
reg [1 : 0] pipe_eidle_split;
reg [1 : 0] pipe_beacon_split;
reg [1 : 0] skip_add_split;
reg [1 : 0] skip_rem_split;
reg ltssm_align_req_split;
reg [2 : 0] mca_sm_ns_split;
reg [1 : 0] comma_0_split;
reg [1 : 0] comma_1_split;
reg [1 : 0] all_comma_det_nxt_split;
reg [1 : 0] det_comma_0_nxt_split;
reg [1 : 0] det_comma_1_nxt_split;
reg [1 : 0] save_com_det_nxt_split;
reg align_ack_nxt_split;
reg [1 : 0] stop_rd_nxt_split;
reg [3 : 0] skew_0_nxt_split;
reg [3 : 0] skew_1_nxt_split;
reg [1 : 0] sel_min_skew_nxt_split;
reg com_aligned_nxt_split;
reg pause_mca_data_nxt_split;
reg alignfifo_clr_nxt_split;
reg [1 : 0] alignfifo_wren_nxt_split;
reg [1 : 0] alignfifo_rden_nxt_split;
reg [FIFO_DWID - 1 : 0] alignfifo_wdat_0_nxt_split;
reg [FIFO_DWID - 1 : 0] alignfifo_wdat_1_nxt_split;
reg [(2 * FIFO_DWID) - 1 : 0] mca_afData_dtin_nxt_0_split;
reg [(2 * FIFO_DWID) - 1 : 0] mca_afData_dtin_nxt_1_split;
reg [1 : 0] mca_afData_wren_nxt_split;
reg [31 : 0] mca_data_nxt_split;
reg [3 : 0] mca_ktrl_nxt_split;
reg [1 : 0] mca_dter_nxt_split;
reg [1 : 0] mca_valid_nxt_split;
reg [1 : 0] mca_eidle_nxt_split;
reg [1 : 0] mca_beacon_nxt_split;
reg mca_lanes_aligned_nxt_split;
reg skip_0_nxt_split;
reg skip_1_nxt_split;
reg [1 : 0] det_skip_nxt_split;
reg [2 : 0] det_skip_timer_nxt_split;
reg [1 : 0] mca_afData_rden_split;
reg align_ack_ss_split;
reg align_req_ss_split;
reg [1 : 0] alignfifo_emty_split;
reg [1 : 0] alignfifo_full_split;
reg [FIFO_DWID - 1 : 0] alignfifo_rdat_0_split;
reg [FIFO_DWID - 1 : 0] alignfifo_rdat_1_split;
reg [FIFO_DWID - 1 : 0] mca_afData_dtOut_0_split;
reg [FIFO_DWID - 1 : 0] mca_afData_dtOut_1_split;
reg [1 : 0] mca_afData_emty_split;
reg [1 : 0] mca_afData_full_split;
reg [2 : 0] mca_sm_cs_split;
reg [1 : 0] cfglanes_split;
reg [1 : 0] save_com_det_split;
reg [1 : 0] all_comma_det_split;
reg [1 : 0] det_comma_0_split;
reg [1 : 0] det_comma_1_split;
reg [1 : 0] stop_rd_split;
reg [1 : 0] skip_insert_split;
reg [3 : 0] skew_0_split;
reg [3 : 0] skew_1_split;
reg [1 : 0] sel_min_skew_split;
reg com_aligned_split;
reg pause_mca_data_split;
reg req_align_valid_split;
reg [3 : 0] align_req_ss_q_split;
reg skip_0_split;
reg skip_1_split;
reg [1 : 0] det_skip_split;
reg [15 : 0] pipe_data_q0_split;
reg [15 : 0] pipe_data_q1_split;
reg [1 : 0] pipe_ktrl_q0_split;
reg [1 : 0] pipe_ktrl_q1_split;
reg [2 : 0] det_skip_timer_split;
reg alignfifo_clr_split;
reg [1 : 0] alignfifo_rden_split;
reg [FIFO_DWID - 1 : 0] alignfifo_wdat_0_split;
reg [FIFO_DWID - 1 : 0] alignfifo_wdat_1_split;
reg [1 : 0] alignfifo_wren_split;
reg [FIFO_DWID - 1 : 0] mca_afData_dtOut_q_0_split;
reg [FIFO_DWID - 1 : 0] mca_afData_dtOut_q_1_split;
reg [(2 * FIFO_DWID) - 1 : 0] mca_afData_dtin_0_split;
reg [(2 * FIFO_DWID) - 1 : 0] mca_afData_dtin_1_split;
reg [1 : 0] mca_afData_wren_split;
reg [1 : 0] mca_afData_emty_q_split;
reg align_ack_split;
reg mca_align_done_nxt_split;
reg sk0_eq_sk1_split;
reg sk0_gt_sk1_split;
reg [1 : 0] com_align_split;
reg [103 : 0] __mca_sm_cs___split;
reg [103 : 0] __mca_sm_ns___split;
reg [2047:0] descram_in;
wire [96:0] descram_out;







localparam descram_inst_SIZE = 97,descram_inst_SCRAMSTRING = 32'hfdffd30b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

//--end_ports--




//--------------------------------------------------------------------------
//--- Local Parameters/Defines ---
//--------------------------------------------------------------------------
// Comma
// Skip

//--------------------------------------------------------------------------
//--- Combinational Wire/Reg ---
//--------------------------------------------------------------------------
/*AUTOREGINPUT*/
/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// From sync_align_ack of sync_handshake.v
// From sync_align_req of synchro.v
// From alignfifo_0 of fifo.v, ...
// From alignfifo_0 of fifo.v, ...
// From alignfifo_0 of fifo.v
// From align_fifo_1 of fifo.v
// From mca_afData_0 of shreg_2in_1out.v
// From mca_afData_1 of shreg_2in_1out.v
// From mca_afData_0 of shreg_2in_1out.v, ...
// From mca_afData_0 of shreg_2in_1out.v, ...
// End of automatics

//--------------------------------------------------------------------------
//--- Registers ---
//--------------------------------------------------------------------------
//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  comma_0 = {(pipe_ktrl_split[1] & (pipe_data_split[15:8] == COM)),
             (pipe_ktrl_split[0] & (pipe_data_split[ 7:0] == COM))};

  comma_1 = {(pipe_ktrl_split[3] & (pipe_data_split[31:24] == COM)),
             (pipe_ktrl_split[2] & (pipe_data_split[23:16] == COM))};

  skip_0_nxt = |{((pipe_ktrl_q0_split[1] & (pipe_data_q0_split[15:8] == COM)) & (pipe_ktrl_q0_split[0] & (pipe_data_q0_split[ 7:0] == SKP))),
                 ((pipe_ktrl_q0_split[0] & (pipe_data_q0_split[ 7:0] == COM)) & (pipe_ktrl_split   [1] & (pipe_data_split   [15:8] == SKP)))};

  skip_1_nxt = |{((pipe_ktrl_q1_split[1] & (pipe_data_q1_split[15:8] == COM)) & (pipe_ktrl_q1_split[0] & (pipe_data_q1_split[ 7: 0] == SKP))),
                 ((pipe_ktrl_q1_split[0] & (pipe_data_q1_split[ 7:0] == COM)) & (pipe_ktrl_split   [3] & (pipe_data_split   [31:24] == SKP)))};
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  case(det_skip_split)
    2'b01   : begin
      sel_min_skew_nxt   = (skip_1_split)? 2'b01 : sel_min_skew_split;
      det_skip_nxt       = (skip_1_split | (det_skip_timer_split == 3'd0))? 2'b00 : det_skip_split;
      det_skip_timer_nxt = det_skip_timer_split - {2'd0,|det_skip_timer_split};
    end
    2'b10   : begin
      sel_min_skew_nxt   = (skip_0_split)? 2'b10 : sel_min_skew_split;
      det_skip_nxt       = (skip_0_split | (det_skip_timer_split == 3'd0))? 2'b00 : det_skip_split;
      det_skip_timer_nxt = det_skip_timer_split - {2'd0,|det_skip_timer_split};
    end
    2'b11   : begin
      sel_min_skew_nxt = 2'b00;
      det_skip_nxt     = 2'd0;
    end
    default : begin
      det_skip_timer_nxt = (skip_0_split ^ skip_1_split)? 3'd7 : 3'd0;
      sel_min_skew_nxt   = sel_min_skew_split;
      det_skip_nxt       = {skip_1_split,skip_0_split};
    end
  endcase
end //--always @*--


//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  all_comma_det_nxt[0] = |cfglanes_split & ((det_comma_0_nxt_split & cfglanes_split) == cfglanes_split);
  all_comma_det_nxt[1] = |cfglanes_split & ((det_comma_1_nxt_split & cfglanes_split) == cfglanes_split);
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  case(mca_sm_cs_split)
    ST_MCA_WT_ALLCOM : begin
      if(&all_comma_det_split)
        mca_sm_ns = ST_MCA_CHK_SKEW;
      else
        mca_sm_ns = ST_MCA_WT_ALLCOM;
    end
    ST_MCA_CHK_SKEW : begin
      mca_sm_ns = ST_MCA_ALIGN;
    end
    ST_MCA_ALIGN    : begin
      if(|alignfifo_full_split) begin
        mca_sm_ns = ST_MCA_IDLE;
      end
      else begin
        case({sel_min_skew_split,com_aligned_split})
          3'b010,
          3'b100  : mca_sm_ns = ST_MCA_ALIGN;
          default : mca_sm_ns = ST_MCA_DONE;
        endcase
      end
    end
    ST_MCA_DONE : begin
      if(align_ack_split & ~align_req_ss_q_split[3])
        mca_sm_ns = ST_MCA_IDLE;
      else
        mca_sm_ns = ST_MCA_DONE;
    end
    default         : begin
      case({req_align_valid_split,cfglanes_split})
        {1'b1,2'b01},
        {1'b1,2'b10} : mca_sm_ns = ST_MCA_DONE;
        {1'b1,2'b11} : mca_sm_ns = ST_MCA_WT_ALLCOM;
        default      : mca_sm_ns = ST_MCA_IDLE;
      endcase
    end
  endcase
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  align_ack_nxt       = 1'b0;
  det_comma_0_nxt     = det_comma_0_split;
  det_comma_1_nxt     = det_comma_1_split;
  mca_align_done_nxt  = mca_align_done;
  stop_rd_nxt         = stop_rd_split;
  skew_0_nxt          = skew_0_split;
  skew_1_nxt          = skew_1_split;
  save_com_det_nxt    = save_com_det_split;
  alignfifo_clr_nxt   = |alignfifo_full_split;
  //sel_min_skew_nxt    = sel_min_skew;
  com_aligned_nxt     = com_aligned_split;
  pause_mca_data_nxt  = pause_mca_data_split;
  case(mca_sm_cs_split)
    ST_MCA_WT_ALLCOM : begin
      // detect comma from 0 - 1
      det_comma_0_nxt[0] = (|alignfifo_rdat_0_split[2:1]                 ) | det_comma_0_split[0];
      det_comma_0_nxt[1] = (|alignfifo_rdat_1_split[2:1] & det_comma_0_split[0]) | det_comma_0_split[1];
      skew_0_nxt         = skew_0_split + {3'd0,(det_comma_0_split[0] & ~all_comma_det_split[0])};

      // detect comma from 1 - 0
      det_comma_1_nxt[0] = (|alignfifo_rdat_1_split[2:1]                 ) | det_comma_1_split[0];
      det_comma_1_nxt[1] = (|alignfifo_rdat_0_split[2:1] & det_comma_1_split[0]) | det_comma_1_split[1];
      skew_1_nxt         = skew_1_split + {3'd0,(det_comma_1_split[0] & ~all_comma_det_split[1])};

      com_aligned_nxt    = (|alignfifo_rdat_0_split[2:1]) & (|alignfifo_rdat_1_split[2:1]) | com_aligned_split;
      save_com_det_nxt   = ({2{com_aligned_nxt_split & ~com_aligned_split}} &
                            {alignfifo_rdat_1_split[1],alignfifo_rdat_0_split[1]}) |
                           (~{2{com_aligned_nxt_split & ~com_aligned_split}} & save_com_det_split);
    end
    ST_MCA_CHK_SKEW : begin
      det_comma_0_nxt    = 2'd0;
      det_comma_1_nxt    = 2'd0;
      //case({com_aligned,sk0_eq_sk1,sk0_gt_sk1})
      //  3'b000  : sel_min_skew_nxt = 2'b01;
      //  3'b001  : sel_min_skew_nxt = 2'b10;
      //  3'b010  : sel_min_skew_nxt = 2'b01;
      //  default : sel_min_skew_nxt = 2'b00;
      //endcase
    end
    ST_MCA_ALIGN : begin
      // detect comma from 0 - 1
      det_comma_0_nxt[0] = (|alignfifo_rdat_0_split[2:1]                 ) | det_comma_0_split[0];
      det_comma_0_nxt[1] = (|alignfifo_rdat_1_split[2:1] & det_comma_0_split[0]) | det_comma_0_split[1];
      // detect comma from 1 - 0
      det_comma_1_nxt[0] = (|alignfifo_rdat_1_split[2:1]                 ) | det_comma_1_split[0];
      det_comma_1_nxt[1] = (|alignfifo_rdat_0_split[2:1] & det_comma_1_split[0]) | det_comma_1_split[1];

      stop_rd_nxt[0]     = sel_min_skew_split[0] & det_comma_0_split[0] & ~det_comma_0_split[1];
      stop_rd_nxt[1]     = sel_min_skew_split[1] & det_comma_1_split[0] & ~det_comma_1_split[1];

      com_aligned_nxt    = (|alignfifo_rdat_0_split[2:1]) & (|alignfifo_rdat_1_split[2:1]) | com_aligned_split;
      save_com_det_nxt   = ({2{com_aligned_nxt_split & ~com_aligned_split}} &
                            {alignfifo_rdat_1_split[1],alignfifo_rdat_0_split[1]}) |
                           (~{2{com_aligned_nxt_split & ~com_aligned_split}} & save_com_det_split);
      pause_mca_data_nxt = (mca_sm_ns_split == ST_MCA_ALIGN);
    end
    ST_MCA_DONE : begin
      align_ack_nxt      = 1'b1;
      mca_align_done_nxt = 1'b1;
    end
    default : begin
      det_comma_0_nxt     = 2'd0;
      det_comma_1_nxt     = 2'd0;
      mca_align_done_nxt  = 1'b0;
      save_com_det_nxt    = ({2{~align_req_ss_split}} & save_com_det_split);
      stop_rd_nxt         = 2'd0;
      alignfifo_clr_nxt   = |alignfifo_full_split | (align_req_ss_split & ~align_req_ss_q_split[3]);
      skew_0_nxt          = 4'd0;
      skew_1_nxt          = 4'd0;
      //sel_min_skew_nxt    = 2'd0;
      com_aligned_nxt     = 1'b0;
      pause_mca_data_nxt  = (mca_sm_ns_split == ST_MCA_WT_ALLCOM);
    end
  endcase
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  alignfifo_wren_nxt[0] = ~skip_add_split[0] & pipe_rxvalid_split[0];
  alignfifo_wren_nxt[1] = ~skip_add_split[1] & pipe_rxvalid_split[1];

  alignfifo_wdat_0_nxt  = {pipe_rxvalid_split[0],
                           pipe_eidle_split[0],
                           pipe_beacon_split[0],
                           |pipe_err_split[1:0],
                           pipe_ktrl_split[1:0],
                           pipe_data_split[15:0],
                           comma_0_split[1:0],
                           skip_rem_split[0] & pipe_rxvalid_split[0]};

  alignfifo_wdat_1_nxt  = {pipe_rxvalid_split[1],
                           pipe_eidle_split[1],
                           pipe_beacon_split[1],
                           |pipe_err_split[3:2],
                           pipe_ktrl_split[3:2],
                           pipe_data_split[31:16],
                           comma_1_split[1:0],
                           skip_rem_split[1] & pipe_rxvalid_split[1]};

  alignfifo_rden_nxt = ~alignfifo_emty_split & (mca_afData_emty_split |
                                          (mca_afData_rden_split &
                                            ~((mca_afData_full_split & mca_afData_wren_split) |
                                              {alignfifo_rdat_1_split[0],alignfifo_rdat_0_split[0]})));
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  mca_afData_rden     = ~mca_afData_emty_split & ~stop_rd_split;
  mca_afData_wren_nxt = ((alignfifo_rden_nxt_split & ~skip_insert_split) |
                          (alignfifo_rden_split & {alignfifo_rdat_1_split[0],alignfifo_rdat_0_split[0]})) &
                        ~stop_rd_nxt_split;
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  mca_afData_dtin_nxt_0        = {2{alignfifo_rdat_0_split}};
  mca_afData_dtin_nxt_0[43:28] = ({16{ alignfifo_rdat_0_split[0]}} & {2{SKP}}              ) |
                                 ({16{~alignfifo_rdat_0_split[0]}} & alignfifo_rdat_0_split[18:3]);
  mca_afData_dtin_nxt_0[45:44] = ({2{ alignfifo_rdat_0_split[0]}} & 2'b11                  ) |
                                 ({2{~alignfifo_rdat_0_split[0]}} & alignfifo_rdat_0_split[20:19]);

  mca_afData_dtin_nxt_1        = {2{alignfifo_rdat_1_split}};
  mca_afData_dtin_nxt_1[43:28] = ({16{ alignfifo_rdat_1_split[0]}} & {2{SKP}}              ) |
                                 ({16{~alignfifo_rdat_1_split[0]}} & alignfifo_rdat_1_split[18:3]);
  mca_afData_dtin_nxt_1[45:44] = ({2{ alignfifo_rdat_1_split[0]}} & 2'b11                  ) |
                                 ({2{~alignfifo_rdat_1_split[0]}} & alignfifo_rdat_1_split[20:19]);
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
// Byte align
//--------------------------------------------
always @* begin
  case({mca_disable_split,save_com_det_split[0]})
    2'b00   : begin
      if(mca_afData_emty_q_split[0]) begin
        mca_beacon_nxt[0]  = pipe_beacon_split[0];
        mca_eidle_nxt[0]   = pipe_eidle_split[0];
      end
      else begin
        mca_beacon_nxt[0]  = save_com_det_split[1] ? mca_afData_dtOut_q_0_split[22]    : mca_afData_dtOut_0_split[22]   ;
        mca_eidle_nxt[0]   = save_com_det_split[1] ? mca_afData_dtOut_q_0_split[23]    : mca_afData_dtOut_0_split[23]   ;
      end
      if(pause_mca_data_split) begin
        mca_data_nxt[15:0] = 16'd0;
        mca_ktrl_nxt[1:0]  = 2'd0;
        mca_valid_nxt[0]   = 1'b0;
        mca_dter_nxt[0]    = 1'b0;
      end
      else begin
        mca_data_nxt[15:0] = save_com_det_split[1] ? mca_afData_dtOut_q_0_split[18:3]  : mca_afData_dtOut_0_split[18:3] ;
        mca_ktrl_nxt[1:0]  = save_com_det_split[1] ? mca_afData_dtOut_q_0_split[20:19] : mca_afData_dtOut_0_split[20:19];
        mca_valid_nxt[0]   = save_com_det_split[1] ? mca_afData_dtOut_q_0_split[24]    : mca_afData_dtOut_0_split[24]   ;
        mca_dter_nxt[0]    = save_com_det_split[1] ? mca_afData_dtOut_q_0_split[21]    : mca_afData_dtOut_0_split[21]   ;
      end
    end
    2'b01   : begin
      if(mca_afData_emty_q_split[0]) begin
        mca_beacon_nxt[0]  = pipe_beacon_split[0];
        mca_eidle_nxt[0]   = pipe_eidle_split[0];
      end
      else begin
        mca_beacon_nxt[0]  =  mca_afData_dtOut_q_0_split[22];
        mca_eidle_nxt[0]   =  mca_afData_dtOut_q_0_split[23];
      end
      if(pause_mca_data_split) begin
        mca_data_nxt[15:0] = 16'd0;
        mca_ktrl_nxt[1:0]  = 2'd0;
        mca_valid_nxt[0]   = 1'b0;
        mca_dter_nxt[0]    = 1'b0;
      end
      else begin
        mca_data_nxt[15:0] = {mca_afData_dtOut_q_0_split[10:3],mca_afData_dtOut_0_split[18:11]};
        mca_ktrl_nxt[1:0]  = {mca_afData_dtOut_q_0_split[19]  ,mca_afData_dtOut_0_split[20]};
        mca_valid_nxt[0]   =  mca_afData_dtOut_q_0_split[24];
        mca_dter_nxt[0]    =  mca_afData_dtOut_q_0_split[21];
      end
    end
    default : begin
      mca_data_nxt[15:0] = pipe_data_split[15:0];
      mca_ktrl_nxt[1:0]  = pipe_ktrl_split[1:0];
      mca_dter_nxt[0]    = |pipe_err_split[1:0];
      mca_beacon_nxt[0]  = pipe_beacon_split[0];
      mca_eidle_nxt[0]   = pipe_eidle_split[0];
      mca_valid_nxt[0]   = pipe_rxvalid_split[0];
    end
  endcase
end //--always @*--

always @* begin
  case({mca_disable_split,save_com_det_split[1]})
    2'b00   : begin
      if(mca_afData_emty_q_split[1]) begin
        mca_beacon_nxt[1]   = pipe_beacon_split[1];
        mca_eidle_nxt[1]    = pipe_eidle_split[1];
      end
      else begin
        mca_beacon_nxt[1]   = save_com_det_split[0] ? mca_afData_dtOut_q_1_split[22]    : mca_afData_dtOut_1_split[22]   ;
        mca_eidle_nxt[1]    = save_com_det_split[0] ? mca_afData_dtOut_q_1_split[23]    : mca_afData_dtOut_1_split[23]   ;
      end
      if(pause_mca_data_split) begin
        mca_data_nxt[31:16] = 16'd0;
        mca_ktrl_nxt[3:2]   = 2'd0;
        mca_valid_nxt[1]    = 1'b0;
        mca_dter_nxt[1]     = 1'b0;
      end
      else begin
        mca_data_nxt[31:16] = save_com_det_split[0] ? mca_afData_dtOut_q_1_split[18:3]  : mca_afData_dtOut_1_split[18:3] ;
        mca_ktrl_nxt[3:2]   = save_com_det_split[0] ? mca_afData_dtOut_q_1_split[20:19] : mca_afData_dtOut_1_split[20:19];
        mca_valid_nxt[1]    = save_com_det_split[0] ? mca_afData_dtOut_q_1_split[24]    : mca_afData_dtOut_1_split[24]   ;
        mca_dter_nxt[1]     = save_com_det_split[0] ? mca_afData_dtOut_q_1_split[21]    : mca_afData_dtOut_1_split[21]   ;
      end
    end
    2'b01   : begin
      if(mca_afData_emty_q_split[1]) begin
        mca_beacon_nxt[1]   = pipe_beacon_split[1];
        mca_eidle_nxt[1]    = pipe_eidle_split[1];
      end
      else begin
        mca_beacon_nxt[1]   =  mca_afData_dtOut_q_1_split[22];
        mca_eidle_nxt[1]    =  mca_afData_dtOut_q_1_split[23];
      end
      if(pause_mca_data_split) begin
        mca_data_nxt[31:16] = 16'd0;
        mca_ktrl_nxt[3:2]   = 2'd0;
        mca_valid_nxt[1]    = 1'b0;
        mca_dter_nxt[1]     = 1'b0;
      end
      else begin
        mca_data_nxt[31:16] = {mca_afData_dtOut_q_1_split[10:3],mca_afData_dtOut_1_split[18:11]};
        mca_ktrl_nxt[3:2]   = {mca_afData_dtOut_q_1_split[19]  ,mca_afData_dtOut_1_split[20]};
        mca_valid_nxt[1]    =  mca_afData_dtOut_q_1_split[24];
        mca_dter_nxt[1]     =  mca_afData_dtOut_q_1_split[21];
      end
    end
    default : begin
      mca_data_nxt[31:16] = pipe_data_split[31:16];
      mca_ktrl_nxt[3:2]   = pipe_ktrl_split[3:2];
      mca_dter_nxt[1]     = |pipe_err_split[3:2];
      mca_beacon_nxt[1]   = pipe_beacon_split[1];
      mca_eidle_nxt[1]    = pipe_eidle_split[1];
      mca_valid_nxt[1]    = pipe_rxvalid_split[1];
    end
  endcase
end //--always @*--

assign          com_align[0] = ((mca_data[23:16] == COM) & mca_ktrl[2] &
                                (mca_data[ 7: 0] == COM) & mca_ktrl[0]);
assign          com_align[1] = ((mca_data[31:24] == COM) & mca_ktrl[3] &
                                (mca_data[15: 8] == COM) & mca_ktrl[1]);
//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  if(mca_lanes_aligned) begin
    mca_lanes_aligned_nxt = ~(( ((mca_data[31:24] == COM) & mca_ktrl[3]) &
                               ~((mca_data[15: 8] == COM) & mca_ktrl[1])) |
                              (~((mca_data[31:24] == COM) & mca_ktrl[3]) &
                                ((mca_data[15: 8] == COM) & mca_ktrl[1])) |
                              ( ((mca_data[23:16] == COM) & mca_ktrl[2]) &
                               ~((mca_data[ 7: 0] == COM) & mca_ktrl[0])) |
                              (~((mca_data[23:16] == COM) & mca_ktrl[2]) &
                                ((mca_data[ 7: 0] == COM) & mca_ktrl[0])));
  end
  else begin
    mca_lanes_aligned_nxt = |com_align_split;

  end
end //--always @*--


//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge pclk or negedge rst_n_p) begin
  if(~rst_n_p) begin
    mca_sm_cs <= ST_MCA_IDLE;
    mca_eidle <= {2{1'b1}};
    /*AUTORESET*/
    // Beginning of autoreset for uninitialized flops
    align_ack <= {1{1'b0}};
    alignfifo_clr <= {1{1'b0}};
    alignfifo_rden <= {2{1'b0}};
    alignfifo_wdat_0 <= {(1+(FIFO_DWID-1)){1'b0}};
    alignfifo_wdat_1 <= {(1+(FIFO_DWID-1)){1'b0}};
    alignfifo_wren <= {2{1'b0}};
    all_comma_det <= {2{1'b0}};
    cfglanes <= {2{1'b0}};
    com_aligned <= {1{1'b0}};
    det_comma_0 <= {2{1'b0}};
    det_comma_1 <= {2{1'b0}};
    mca_afData_dtOut_q_0 <= {(1+(FIFO_DWID-1)){1'b0}};
    mca_afData_dtOut_q_1 <= {(1+(FIFO_DWID-1)){1'b0}};
    mca_afData_dtin_0 <= {(1+((2*FIFO_DWID)-1)){1'b0}};
    mca_afData_dtin_1 <= {(1+((2*FIFO_DWID)-1)){1'b0}};
    mca_afData_emty_q <= {2{1'b0}};
    mca_afData_wren <= {2{1'b0}};
    mca_align_done <= {1{1'b0}};
    mca_beacon <= {2{1'b0}};
    mca_data <= {32{1'b0}};
    mca_dter <= {2{1'b0}};
    mca_ktrl <= {4{1'b0}};
    mca_lanes_aligned <= {1{1'b0}};
    mca_valid <= {2{1'b0}};
    pause_mca_data <= {1{1'b0}};
    save_com_det <= {2{1'b0}};
    sel_min_skew <= {2{1'b0}};
    sk0_eq_sk1 <= {1{1'b0}};
    sk0_gt_sk1 <= {1{1'b0}};
    skew_0 <= {4{1'b0}};
    skew_1 <= {4{1'b0}};
    skip_insert <= {2{1'b0}};
    stop_rd <= {2{1'b0}};
    pipe_data_q0 <= {16{1'b0}};
    pipe_data_q1 <= {16{1'b0}};
    pipe_ktrl_q0 <= {2{1'b0}};
    pipe_ktrl_q1 <= {2{1'b0}};
    skip_0       <= {1{1'b0}};
    skip_1       <= {1{1'b0}};
    det_skip     <= {2{1'b0}};
    det_skip_timer <= {3{1'b0}};
    req_align_valid <= {1{1'b0}};
    align_req_ss_q <= {4{1'b0}};
    // End of automatics
  end
  else begin
    cfglanes      <= ltssm_cfglanes_split; // async multicycle path

    mca_sm_cs     <= mca_sm_ns_split;
    align_ack     <= align_ack_nxt_split;
    save_com_det  <= save_com_det_nxt_split;
    all_comma_det <= all_comma_det_nxt_split;
    det_comma_0   <= det_comma_0_nxt_split;
    det_comma_1   <= det_comma_1_nxt_split;
    stop_rd       <= stop_rd_nxt_split;
    skip_insert   <= alignfifo_rden_split & {alignfifo_rdat_1_split[0],alignfifo_rdat_0_split[0]};
    skew_0        <= skew_0_nxt_split;
    skew_1        <= skew_1_nxt_split;
    sk0_eq_sk1    <= (skew_0_split == skew_1_split);
    sk0_gt_sk1    <= (skew_0_split > skew_1_split);
    sel_min_skew  <= sel_min_skew_nxt_split;
    com_aligned   <= com_aligned_nxt_split;
    pause_mca_data <= pause_mca_data_nxt_split;
    req_align_valid <= (align_req_ss_q_split[3] & ~mca_disable_split & (~mca_afData_emty_split == cfglanes_split));
    align_req_ss_q <= {align_req_ss_q_split[2:0],align_req_ss_split};

    pipe_data_q0 <= pipe_data_split[15: 0];
    pipe_data_q1 <= pipe_data_split[31:16];
    pipe_ktrl_q0 <= pipe_ktrl_split[1:0];
    pipe_ktrl_q1 <= pipe_ktrl_split[3:2];
    skip_0       <= skip_0_nxt_split;
    skip_1       <= skip_1_nxt_split;
    det_skip     <= det_skip_nxt_split;
    det_skip_timer <= det_skip_timer_nxt_split;

    alignfifo_rden   <= alignfifo_rden_nxt_split;
    alignfifo_wren   <= alignfifo_wren_nxt_split;
    alignfifo_wdat_0 <= alignfifo_wdat_0_nxt_split;
    alignfifo_wdat_1 <= alignfifo_wdat_1_nxt_split;
    alignfifo_clr    <= alignfifo_clr_nxt_split;

    mca_afData_dtin_0 <= mca_afData_dtin_nxt_0_split;
    mca_afData_dtin_1 <= mca_afData_dtin_nxt_1_split;
    mca_afData_dtOut_q_0 <= mca_afData_dtOut_0_split;
    mca_afData_dtOut_q_1 <= mca_afData_dtOut_1_split;
    mca_afData_wren <= mca_afData_wren_nxt_split;
    mca_afData_emty_q <= mca_afData_emty_split;

    mca_data   <= mca_data_nxt_split;
    mca_ktrl   <= mca_ktrl_nxt_split;
    mca_dter   <= mca_dter_nxt_split;
    mca_valid  <= mca_valid_nxt_split;
    mca_eidle  <= mca_eidle_nxt_split;
    mca_beacon <= mca_beacon_nxt_split;
    mca_align_done <= mca_align_done_nxt_split | mca_disable_split;

    mca_lanes_aligned <= (cfglanes_split == 2'b11)? mca_lanes_aligned_nxt_split : |cfglanes_split;
  end
end //--always @(posedge pclk or negedge rst_n_p)--

//--------------------------------------------------------------------------
//--- For Statemachine Debugging ---
//--------------------------------------------------------------------------
/*AUTOASCIIENUM("mca_sm_cs", "__mca_sm_cs__", "ST_")*/
// Beginning of automatic ASCII enum decoding
// Decode of mca_sm_cs
always @(mca_sm_cs_split) begin
  case ({mca_sm_cs_split})
    ST_MCA_IDLE:      __mca_sm_cs__ = "mca_idle     ";
    ST_MCA_WT_ALLCOM: __mca_sm_cs__ = "mca_wt_allcom";
    ST_MCA_CHK_SKEW:  __mca_sm_cs__ = "mca_chk_skew ";
    ST_MCA_ALIGN:     __mca_sm_cs__ = "mca_align    ";
    ST_MCA_DONE:      __mca_sm_cs__ = "mca_done     ";
    default:          __mca_sm_cs__ = "%Error       ";
  endcase
end
// End of automatics

/*AUTOASCIIENUM("mca_sm_ns", "__mca_sm_ns__", "ST_")*/
// Beginning of automatic ASCII enum decoding
// Decode of mca_sm_ns
always @(mca_sm_ns_split) begin
  case ({mca_sm_ns_split})
    ST_MCA_IDLE:      __mca_sm_ns__ = "mca_idle     ";
    ST_MCA_WT_ALLCOM: __mca_sm_ns__ = "mca_wt_allcom";
    ST_MCA_CHK_SKEW:  __mca_sm_ns__ = "mca_chk_skew ";
    ST_MCA_ALIGN:     __mca_sm_ns__ = "mca_align    ";
    ST_MCA_DONE:      __mca_sm_ns__ = "mca_done     ";
    default:          __mca_sm_ns__ = "%Error       ";
  endcase
end
// End of automatics

//--------------------------------------------------------------------------
//--- Module Instantiation ---
//--------------------------------------------------------------------------
synchro #(.DWID(1)) sync_align_req
(
 // Inputs
 .clk_s                                 (pclk),
 .rst_n                                 (rst_n_p),
 .data_a                                (ltssm_align_req_split),
 // Outputs
 .data_s                                (align_req_ss)
 /*AUTOINST*/);

sync_handshake #(.DWID(1)) sync_align_ack
(
 // Inputs
 .clk_a                                 (pclk),
 .clk_b                                 (sys_clk),
 .rst_n_a                               (rst_n_p),
 .rst_n_b                               (rst_n_split),
 .req_a                                 (align_ack_split),
 // Outputs
 .ack_a                                 (align_ack_ss),
 .ack_b                                 (ltssm_align_ack)
 /*AUTOINST*/);

/*shreg_2in_1out AUTO_TEMPLATE
(
 // Inputs
 .clk                                   (pclk),
 .rst_n                                 (rst_n_p),
 .clr                                   (alignfifo_clr),
 .wren                                  ({skip_insert[@],mca_afData_wren[@]}),
 .dtin                                  (mca_afData_dtin_@[]),
 .rden                                  (mca_afData_rden[@]),
 // Outputs
 .dtout                                 (mca_afData_dtOut_@[]),
 .stt                                   (),
 .emty                                  (mca_afData_emty[@]),
 .full                                  (mca_afData_full[@]));*/

shreg_2in_1out #(.DWID(FIFO_DWID),
                 .I_DWID(2*FIFO_DWID),
                 .O_DWID(FIFO_DWID),
                 .RNUM(2),
                 .I_NUM(2),
                 .O_NUM(1)) mca_afData_0
(/*AUTOINST*/
 // Inputs
 .clk                                   (pclk),                  // Templated
 .rst_n                                 (rst_n_p),               // Templated
 .clr                                   (alignfifo_clr_split),         // Templated
 .wren                                  ({skip_insert_split[0],mca_afData_wren_split[0]}), // Templated
 .dtin                                  (mca_afData_dtin_0_split[(2*FIFO_DWID)-1:0]), // Templated
 .rden                                  (mca_afData_rden_split[0]),    // Templated
 // Outputs
 .dtout                                 (mca_afData_dtOut_0[FIFO_DWID-1:0]), // Templated
 .stt                                   (),                      // Templated
 .emty                                  (mca_afData_emty[0]),    // Templated
 .full                                  (mca_afData_full[0]));   // Templated

shreg_2in_1out #(.DWID(FIFO_DWID),
                 .I_DWID(2*FIFO_DWID),
                 .O_DWID(FIFO_DWID),
                 .RNUM(2),
                 .I_NUM(2),
                 .O_NUM(1)) mca_afData_1
(/*AUTOINST*/
 // Inputs
 .clk                                   (pclk),                  // Templated
 .rst_n                                 (rst_n_p),               // Templated
 .clr                                   (alignfifo_clr_split),         // Templated
 .wren                                  ({skip_insert_split[1],mca_afData_wren_split[1]}), // Templated
 .dtin                                  (mca_afData_dtin_1_split[(2*FIFO_DWID)-1:0]), // Templated
 .rden                                  (mca_afData_rden_split[1]),    // Templated
 // Outputs
 .dtout                                 (mca_afData_dtOut_1[FIFO_DWID-1:0]), // Templated
 .stt                                   (),                      // Templated
 .emty                                  (mca_afData_emty[1]),    // Templated
 .full                                  (mca_afData_full[1]));   // Templated

/*fifo AUTO_TEMPLATE
(
 // Parameters
 .DWID                                  (FIFO_DWID),
 .SIZE                                  (16),
 .AWID                                  (4),
 .DTDEFVAL                              (DTDEFVAL),
 .CLKDOMAIN                             ("SYNC"),
 .MEM_IMPL                              (1),
 // Inputs
 .wclk                                  (pclk),
 .rclk                                  (pclk),
 .wrst_n                                (rst_n_p),
 .rrst_n                                (rst_n_p),
 .wclr                                  (alignfifo_clr),
 .rclr                                  (alignfifo_clr),
 .wdat                                  (alignfifo_wdat_@[]),
 .wren                                  (alignfifo_wren[@]),
 .rden                                  (alignfifo_rden[@]),
 // Outputs
 .rdat                                  (alignfifo_rdat_@[]),
 .emty                                  (alignfifo_emty[@]),
 .full                                  (alignfifo_full[@]),
 .\(.*\)                                ());*/

fifo
#(///*AUTOINSTPARAM*/
  // Parameters
  .DWID                                 (FIFO_DWID),
  .SIZE                                 (16),
  .AWID                                 (4),
  .DTDEFVAL                             (DTDEFVAL),
  .MEM_IMPL                             (1),
  .CLKDOMAIN                            ("SYNC"))
alignfifo_0
(/*AUTOINST*/
 // Inputs
 .wclk                                  (pclk),                  // Templated
 .rclk                                  (pclk),                  // Templated
 .wrst_n                                (rst_n_p),               // Templated
 .rrst_n                                (rst_n_p),               // Templated
 .wclr                                  (alignfifo_clr_split),         // Templated
 .rclr                                  (alignfifo_clr_split),         // Templated
 .wdat                                  (alignfifo_wdat_0_split[FIFO_DWID-1:0]), // Templated
 .wren                                  (alignfifo_wren_split[0]),     // Templated
 .rden                                  (alignfifo_rden_split[0]),     // Templated
 .mem_rdat                              (),                      // Templated
 // Outputs
 .rdat                                  (alignfifo_rdat_0[FIFO_DWID-1:0]), // Templated
 .emty                                  (alignfifo_emty[0]),     // Templated
 .full                                  (alignfifo_full[0]),     // Templated
 .mem_wdat                              (),                      // Templated
 .mem_wren                              (),                      // Templated
 .mem_wadr                              (),                      // Templated
 .mem_rden                              (),                      // Templated
 .mem_radr                              ());                     // Templated

fifo
#(///*AUTOINSTPARAM*/
  // Parameters
  .DWID                                 (FIFO_DWID),
  .SIZE                                 (16),
  .AWID                                 (4),
  .DTDEFVAL                             (DTDEFVAL),
  .MEM_IMPL                             (1),
  .CLKDOMAIN                            ("SYNC"))
align_fifo_1
(/*AUTOINST*/
 // Inputs
 .wclk                                  (pclk),                  // Templated
 .rclk                                  (pclk),                  // Templated
 .wrst_n                                (rst_n_p),               // Templated
 .rrst_n                                (rst_n_p),               // Templated
 .wclr                                  (alignfifo_clr_split),         // Templated
 .rclr                                  (alignfifo_clr_split),         // Templated
 .wdat                                  (alignfifo_wdat_1_split[FIFO_DWID-1:0]), // Templated
 .wren                                  (alignfifo_wren_split[1]),     // Templated
 .rden                                  (alignfifo_rden_split[1]),     // Templated
 .mem_rdat                              (),                      // Templated
 // Outputs
 .rdat                                  (alignfifo_rdat_1[FIFO_DWID-1:0]), // Templated
 .emty                                  (alignfifo_emty[1]),     // Templated
 .full                                  (alignfifo_full[1]),     // Templated
 .mem_wdat                              (),                      // Templated
 .mem_wren                              (),                      // Templated
 .mem_wadr                              (),                      // Templated
 .mem_rden                              (),                      // Templated
 .mem_radr                              ());                     // Templated


always@* begin rst_n_split<=descram_out[0];mca_disable_split<=descram_out[1];ltssm_cfglanes_split<={ltssm_cfglanes>>1,descram_out[2]};pipe_data_split<={pipe_data>>1,descram_out[3]};pipe_ktrl_split<={pipe_ktrl>>1,descram_out[4]};pipe_err_split<={pipe_err>>1,descram_out[5]};pipe_rxvalid_split<={pipe_rxvalid>>1,descram_out[6]};pipe_eidle_split<={pipe_eidle>>1,descram_out[7]};pipe_beacon_split<={pipe_beacon>>1,descram_out[8]};skip_add_split<={skip_add>>1,descram_out[9]};skip_rem_split<={skip_rem>>1,descram_out[10]};ltssm_align_req_split<=descram_out[11];mca_sm_ns_split<={mca_sm_ns>>1,descram_out[12]};comma_0_split<={comma_0>>1,descram_out[13]};comma_1_split<={comma_1>>1,descram_out[14]};all_comma_det_nxt_split<={all_comma_det_nxt>>1,descram_out[15]};det_comma_0_nxt_split<={det_comma_0_nxt>>1,descram_out[16]};det_comma_1_nxt_split<={det_comma_1_nxt>>1,descram_out[17]};save_com_det_nxt_split<={save_com_det_nxt>>1,descram_out[18]};align_ack_nxt_split<=descram_out[19];stop_rd_nxt_split<={stop_rd_nxt>>1,descram_out[20]};skew_0_nxt_split<={skew_0_nxt>>1,descram_out[21]};skew_1_nxt_split<={skew_1_nxt>>1,descram_out[22]};sel_min_skew_nxt_split<={sel_min_skew_nxt>>1,descram_out[23]};com_aligned_nxt_split<=descram_out[24];pause_mca_data_nxt_split<=descram_out[25];alignfifo_clr_nxt_split<=descram_out[26];alignfifo_wren_nxt_split<={alignfifo_wren_nxt>>1,descram_out[27]};alignfifo_rden_nxt_split<={alignfifo_rden_nxt>>1,descram_out[28]};alignfifo_wdat_0_nxt_split<={alignfifo_wdat_0_nxt>>1,descram_out[29]};alignfifo_wdat_1_nxt_split<={alignfifo_wdat_1_nxt>>1,descram_out[30]};mca_afData_dtin_nxt_0_split<={mca_afData_dtin_nxt_0>>1,descram_out[31]};mca_afData_dtin_nxt_1_split<={mca_afData_dtin_nxt_1>>1,descram_out[32]};mca_afData_wren_nxt_split<={mca_afData_wren_nxt>>1,descram_out[33]};mca_data_nxt_split<={mca_data_nxt>>1,descram_out[34]};mca_ktrl_nxt_split<={mca_ktrl_nxt>>1,descram_out[35]};mca_dter_nxt_split<={mca_dter_nxt>>1,descram_out[36]};mca_valid_nxt_split<={mca_valid_nxt>>1,descram_out[37]};mca_eidle_nxt_split<={mca_eidle_nxt>>1,descram_out[38]};mca_beacon_nxt_split<={mca_beacon_nxt>>1,descram_out[39]};mca_lanes_aligned_nxt_split<=descram_out[40];skip_0_nxt_split<=descram_out[41];skip_1_nxt_split<=descram_out[42];det_skip_nxt_split<={det_skip_nxt>>1,descram_out[43]};det_skip_timer_nxt_split<={det_skip_timer_nxt>>1,descram_out[44]};mca_afData_rden_split<={mca_afData_rden>>1,descram_out[45]};align_ack_ss_split<=descram_out[46];align_req_ss_split<=descram_out[47];alignfifo_emty_split<={alignfifo_emty>>1,descram_out[48]};alignfifo_full_split<={alignfifo_full>>1,descram_out[49]};alignfifo_rdat_0_split<={alignfifo_rdat_0>>1,descram_out[50]};alignfifo_rdat_1_split<={alignfifo_rdat_1>>1,descram_out[51]};mca_afData_dtOut_0_split<={mca_afData_dtOut_0>>1,descram_out[52]};mca_afData_dtOut_1_split<={mca_afData_dtOut_1>>1,descram_out[53]};mca_afData_emty_split<={mca_afData_emty>>1,descram_out[54]};mca_afData_full_split<={mca_afData_full>>1,descram_out[55]};mca_sm_cs_split<={mca_sm_cs>>1,descram_out[56]};cfglanes_split<={cfglanes>>1,descram_out[57]};save_com_det_split<={save_com_det>>1,descram_out[58]};all_comma_det_split<={all_comma_det>>1,descram_out[59]};det_comma_0_split<={det_comma_0>>1,descram_out[60]};det_comma_1_split<={det_comma_1>>1,descram_out[61]};stop_rd_split<={stop_rd>>1,descram_out[62]};skip_insert_split<={skip_insert>>1,descram_out[63]};skew_0_split<={skew_0>>1,descram_out[64]};skew_1_split<={skew_1>>1,descram_out[65]};sel_min_skew_split<={sel_min_skew>>1,descram_out[66]};com_aligned_split<=descram_out[67];pause_mca_data_split<=descram_out[68];req_align_valid_split<=descram_out[69];align_req_ss_q_split<={align_req_ss_q>>1,descram_out[70]};skip_0_split<=descram_out[71];skip_1_split<=descram_out[72];det_skip_split<={det_skip>>1,descram_out[73]};pipe_data_q0_split<={pipe_data_q0>>1,descram_out[74]};pipe_data_q1_split<={pipe_data_q1>>1,descram_out[75]};pipe_ktrl_q0_split<={pipe_ktrl_q0>>1,descram_out[76]};pipe_ktrl_q1_split<={pipe_ktrl_q1>>1,descram_out[77]};det_skip_timer_split<={det_skip_timer>>1,descram_out[78]};alignfifo_clr_split<=descram_out[79];alignfifo_rden_split<={alignfifo_rden>>1,descram_out[80]};alignfifo_wdat_0_split<={alignfifo_wdat_0>>1,descram_out[81]};alignfifo_wdat_1_split<={alignfifo_wdat_1>>1,descram_out[82]};alignfifo_wren_split<={alignfifo_wren>>1,descram_out[83]};mca_afData_dtOut_q_0_split<={mca_afData_dtOut_q_0>>1,descram_out[84]};mca_afData_dtOut_q_1_split<={mca_afData_dtOut_q_1>>1,descram_out[85]};mca_afData_dtin_0_split<={mca_afData_dtin_0>>1,descram_out[86]};mca_afData_dtin_1_split<={mca_afData_dtin_1>>1,descram_out[87]};mca_afData_wren_split<={mca_afData_wren>>1,descram_out[88]};mca_afData_emty_q_split<={mca_afData_emty_q>>1,descram_out[89]};align_ack_split<=descram_out[90];mca_align_done_nxt_split<=descram_out[91];sk0_eq_sk1_split<=descram_out[92];sk0_gt_sk1_split<=descram_out[93];com_align_split<={com_align>>1,descram_out[94]};__mca_sm_cs___split<={__mca_sm_cs__>>1,descram_out[95]};__mca_sm_ns___split<={__mca_sm_ns__>>1,descram_out[96]};end
always@* begin descram_in[2047]<=mca_disable;descram_in[2046]<=ltssm_cfglanes[0];descram_in[2044]<=pipe_data[0];descram_in[2040]<=pipe_ktrl[0];descram_in[2032]<=pipe_err[0];descram_in[2016]<=pipe_rxvalid[0];descram_in[1985]<=pipe_eidle[0];descram_in[1982]<=sk0_gt_sk1;descram_in[1947]<=skew_1[0];descram_in[1922]<=pipe_beacon[0];descram_in[1916]<=com_align[0];descram_in[1893]<=mca_afData_full[0];descram_in[1847]<=sel_min_skew[0];descram_in[1819]<=mca_afData_dtOut_q_0[0];descram_in[1817]<=pipe_data_q0[0];descram_in[1796]<=skip_add[0];descram_in[1784]<=__mca_sm_cs__[0];descram_in[1783]<=align_ack;descram_in[1763]<=skip_0;descram_in[1739]<=mca_sm_cs[0];descram_in[1732]<=alignfifo_wdat_0_nxt[0];descram_in[1649]<=alignfifo_rden[0];descram_in[1646]<=com_aligned;descram_in[1630]<=all_comma_det[0];descram_in[1600]<=det_skip_timer_nxt[0];descram_in[1591]<=mca_afData_dtOut_q_1[0];descram_in[1587]<=pipe_data_q1[0];descram_in[1572]<=mca_afData_dtin_nxt_1[0];descram_in[1544]<=skip_rem[0];descram_in[1521]<=__mca_sm_ns__[0];descram_in[1519]<=mca_align_done_nxt;descram_in[1510]<=skip_insert[0];descram_in[1478]<=skip_1;descram_in[1457]<=alignfifo_wren_nxt[0];descram_in[1431]<=cfglanes[0];descram_in[1417]<=alignfifo_wdat_1_nxt[0];descram_in[1302]<=skew_0_nxt[0];descram_in[1251]<=alignfifo_wdat_0[0];descram_in[1244]<=pause_mca_data;descram_in[1212]<=det_comma_0[0];descram_in[1164]<=mca_valid_nxt[0];descram_in[1153]<=mca_afData_rden[0];descram_in[1135]<=mca_afData_dtin_0[0];descram_in[1127]<=pipe_ktrl_q0[0];descram_in[1124]<=mca_lanes_aligned_nxt;descram_in[1115]<=sel_min_skew_nxt[0];descram_in[1105]<=det_comma_1_nxt[0];descram_in[1096]<=mca_afData_wren_nxt[0];descram_in[1041]<=ltssm_align_req;descram_in[1038]<=alignfifo_emty[0];descram_in[1023]<=rst_n;descram_in[991]<=sk0_eq_sk1;descram_in[973]<=skew_0[0];descram_in[946]<=mca_afData_emty[0];descram_in[909]<=alignfifo_wren[0];descram_in[908]<=det_skip[0];descram_in[891]<=mca_afData_emty_q[0];descram_in[881]<=align_req_ss_q[0];descram_in[866]<=alignfifo_rden_nxt[0];descram_in[824]<=alignfifo_clr;descram_in[815]<=save_com_det[0];descram_in[800]<=det_skip_nxt[0];descram_in[786]<=mca_afData_dtin_nxt_0[0];descram_in[755]<=stop_rd[0];descram_in[728]<=alignfifo_clr_nxt;descram_in[651]<=stop_rd_nxt[0];descram_in[582]<=mca_dter_nxt[0];descram_in[562]<=mca_beacon_nxt[0];descram_in[557]<=skew_1_nxt[0];descram_in[552]<=det_comma_0_nxt[0];descram_in[519]<=align_req_ss;descram_in[473]<=mca_afData_dtOut_1[0];descram_in[454]<=alignfifo_wdat_1[0];descram_in[445]<=mca_afData_wren[0];descram_in[440]<=req_align_valid;descram_in[412]<=det_skip_timer[0];descram_in[400]<=skip_1_nxt;descram_in[377]<=det_comma_1[0];descram_in[364]<=pause_mca_data_nxt;descram_in[325]<=align_ack_nxt;descram_in[291]<=mca_ktrl_nxt[0];descram_in[281]<=mca_eidle_nxt[0];descram_in[276]<=all_comma_det_nxt[0];descram_in[259]<=align_ack_ss;descram_in[236]<=mca_afData_dtOut_0[0];descram_in[222]<=mca_afData_dtin_1[0];descram_in[206]<=pipe_ktrl_q1[0];descram_in[200]<=skip_0_nxt;descram_in[182]<=com_aligned_nxt;descram_in[162]<=save_com_det_nxt[0];descram_in[145]<=mca_data_nxt[0];descram_in[138]<=comma_1[0];descram_in[118]<=alignfifo_rdat_1[0];descram_in[69]<=comma_0[0];descram_in[59]<=alignfifo_rdat_0[0];descram_in[34]<=mca_sm_ns[0];descram_in[29]<=alignfifo_full[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule //--mca_x2--






`timescale 1 ns / 100 ps
module scram16l1_scr

#( 



parameter                     LFSR_DEFAULT = 16'hFFFF

) 

( 



input                         clk_250,       
input                         rst_n,         

input                         scram_disable, 
input       [15:0]            data_in,      
input       [1:0]             kcntl_in,      



output reg  [15:0]            data_out,      
output reg  [1:0]             kcntl_out       // K control for data out



);
localparam                    K28_5 = 8'hBC;
localparam                    K23_7 = 8'hF7;
localparam                    K28_0 = 8'h1C;
localparam                    COM   = K28_5;
localparam                    PAD   = K23_7;
localparam                    SKP   = K28_0;
reg         [1:0]             com_nxt;
reg         [1:0]             skp_nxt;
reg         [1:0]             pad_nxt;
reg         [3:0]             ts_cnt_0_nxt;
reg         [3:0]             ts_cnt_1_nxt;
reg         [1:0]             scr_pause_nxt;
reg         [15:0]            data_out_nxt;
reg         [15:0]            lfsr0_nxt;
reg         [15:0]            lfsr1_nxt;
wire                          scram_disable_ss;
reg         [15:0]            data_in_q0;
reg         [1:0]             kcntl_in_q0;
reg         [15:0]            data_in_q1;
reg         [1:0]             kcntl_in_q1;
reg         [15:0]            data_in_q2;
reg         [1:0]             kcntl_in_q2;
reg         [1:0]             com;
reg         [1:0]             skp;
reg         [1:0]             pad;
reg         [1:0]             com_q;
reg         [1:0]             skp_q;
reg         [1:0]             pad_q;
reg         [3:0]             ts_cnt_0;
reg         [3:0]             ts_cnt_1;
reg                           ts_start_det_0;
reg                           ts_start_det_1;
reg         [1:0]             scr_pause;
reg         [15:0]            lfsr0;
reg         [15:0]            lfsr_shift_8bits;
reg         [15:0]            lfsr_shift_8bits_q;
reg scram_disable_split;
reg [15 : 0] data_in_split;
reg [1 : 0] kcntl_in_split;
reg [1 : 0] com_nxt_split;
reg [1 : 0] skp_nxt_split;
reg [1 : 0] pad_nxt_split;
reg [3 : 0] ts_cnt_0_nxt_split;
reg [3 : 0] ts_cnt_1_nxt_split;
reg [1 : 0] scr_pause_nxt_split;
reg [15 : 0] data_out_nxt_split;
reg [15 : 0] lfsr0_nxt_split;
reg [15 : 0] lfsr1_nxt_split;
reg scram_disable_ss_split;
reg [15 : 0] data_in_q0_split;
reg [1 : 0] kcntl_in_q0_split;
reg [15 : 0] data_in_q1_split;
reg [1 : 0] kcntl_in_q1_split;
reg [15 : 0] data_in_q2_split;
reg [1 : 0] kcntl_in_q2_split;
reg [1 : 0] com_split;
reg [1 : 0] skp_split;
reg [1 : 0] pad_split;
reg [1 : 0] com_q_split;
reg [1 : 0] skp_q_split;
reg [1 : 0] pad_q_split;
reg [3 : 0] ts_cnt_0_split;
reg [3 : 0] ts_cnt_1_split;
reg ts_start_det_0_split;
reg ts_start_det_1_split;
reg [1 : 0] scr_pause_split;
reg [15 : 0] lfsr0_split;
reg [15 : 0] lfsr_shift_8bits_split;
reg [15 : 0] lfsr_shift_8bits_q_split;
reg [2047:0] descram_in;
wire [32:0] descram_out;


localparam descram_inst_SIZE = 33,descram_inst_SCRAMSTRING = 32'hfdffca8b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

//--end_ports--



//--------------------------------------------------------------------------
//--- Local Parameters/Defines ---
//--------------------------------------------------------------------------
// K & Special Symbols decode
//--------------------------------------------------------------------------
//--- Combinational Wire/Reg ---
//--------------------------------------------------------------------------
/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// From sync_scram_disable of synchro.v
// End of automatics

//--------------------------------------------------------------------------
//--- Registers ---
//--------------------------------------------------------------------------
//reg         [15:0]            lfsr1;
//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  com_nxt = {(kcntl_in_split[1] & (data_in_split[15:8] == COM)),
             (kcntl_in_split[0] & (data_in_split[ 7:0] == COM))};

  skp_nxt = {(kcntl_in_split[1] & (data_in_split[15:8] == SKP)),
             (kcntl_in_split[0] & (data_in_split[ 7:0] == SKP))};

  pad_nxt = {(kcntl_in_split[1] & (data_in_split[15:8] == PAD)),
             (kcntl_in_split[0] & (data_in_split[ 7:0] == PAD))};
end //--always @*--

//--------------------------------------------
//-- TS OS - start at byte0 --
// [0] -- COM  PAD ...
// [1] -- PAD  ... ...
// [0] -- COM  DAT ...
// [1] -- DAT  ... ...
//--------------------------------------------
always @* begin
  if(ts_start_det_0_split)
    ts_cnt_0_nxt = 4'hF;
  else
    ts_cnt_0_nxt = ts_cnt_0_split - {3'd0,ts_cnt_0_split[3]};
end //--always @*--

//--------------------------------------------
//-- TS OS - start at byte1 --
// [0] -- xxx  PAD ...
// [1] -- COM  PAD ...
// [0] -- xxx  DAT ...
// [1] -- COM  DAT ...
//--------------------------------------------
always @* begin
  if(ts_start_det_1_split)
    ts_cnt_1_nxt = 4'hF;
  else
    ts_cnt_1_nxt = ts_cnt_1_split - {3'd0,ts_cnt_1_split[3]};
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  scr_pause_nxt[0] = kcntl_in_q2_split[0] | ts_cnt_0_split[3];
  scr_pause_nxt[1] = kcntl_in_q2_split[1] | ts_cnt_1_split[3];
end //--always @*--


//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  if(scram_disable_ss_split | scr_pause_nxt_split[0])
    data_out_nxt[ 7:0] = data_in_q2_split[ 7:0];
  else
    data_out_nxt[ 7:0] = data_in_q2_split[ 7:0] ^ lfsr_shift_8bits_q_split[7:0];

  if(scram_disable_split | scr_pause_nxt_split[1])
    data_out_nxt[15:8] = data_in_q2_split[15:8];
  else
    data_out_nxt[15:8] = data_in_q2_split[15:8] ^ lfsr_shift_8bits_q_split[15:8];
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  if(com_split[0])
    lfsr0_nxt = LFSR_DEFAULT;
  else if(skp_split[0])
    lfsr0_nxt = lfsr0_split;
  else begin
    lfsr0_nxt[ 0] = lfsr0_split[ 8];
    lfsr0_nxt[ 1] = lfsr0_split[ 9];
    lfsr0_nxt[ 2] = lfsr0_split[10];
    lfsr0_nxt[ 3] = lfsr0_split[11] ^ lfsr0_split[ 8];
    lfsr0_nxt[ 4] = lfsr0_split[12] ^ lfsr0_split[ 9] ^ lfsr0_split[ 8];
    lfsr0_nxt[ 5] = lfsr0_split[13] ^ lfsr0_split[10] ^ lfsr0_split[ 9] ^ lfsr0_split[ 8];
    lfsr0_nxt[ 6] = lfsr0_split[14] ^ lfsr0_split[11] ^ lfsr0_split[10] ^ lfsr0_split[ 9];
    lfsr0_nxt[ 7] = lfsr0_split[15] ^ lfsr0_split[12] ^ lfsr0_split[11] ^ lfsr0_split[10];
    lfsr0_nxt[ 8] = lfsr0_split[ 0] ^ lfsr0_split[13] ^ lfsr0_split[12] ^ lfsr0_split[11];
    lfsr0_nxt[ 9] = lfsr0_split[ 1] ^ lfsr0_split[14] ^ lfsr0_split[13] ^ lfsr0_split[12];
    lfsr0_nxt[10] = lfsr0_split[ 2] ^ lfsr0_split[15] ^ lfsr0_split[14] ^ lfsr0_split[13];
    lfsr0_nxt[11] = lfsr0_split[ 3]             ^ lfsr0_split[15] ^ lfsr0_split[14];
    lfsr0_nxt[12] = lfsr0_split[ 4]                         ^ lfsr0_split[15];
    lfsr0_nxt[13] = lfsr0_split[ 5];
    lfsr0_nxt[14] = lfsr0_split[ 6];
    lfsr0_nxt[15] = lfsr0_split[ 7];
  end
end //--always @*--

//--------------------------------------------
//-- Combinatorial block --
//--------------------------------------------
always @* begin
  if(com_split[1])
    lfsr1_nxt = LFSR_DEFAULT;
  else if(skp_split[1])
    lfsr1_nxt = lfsr0_nxt_split;
  else begin
    lfsr1_nxt[ 0] = lfsr0_nxt_split[ 8];
    lfsr1_nxt[ 1] = lfsr0_nxt_split[ 9];
    lfsr1_nxt[ 2] = lfsr0_nxt_split[10];
    lfsr1_nxt[ 3] = lfsr0_nxt_split[11] ^ lfsr0_nxt_split[ 8];
    lfsr1_nxt[ 4] = lfsr0_nxt_split[12] ^ lfsr0_nxt_split[ 9] ^ lfsr0_nxt_split[ 8];
    lfsr1_nxt[ 5] = lfsr0_nxt_split[13] ^ lfsr0_nxt_split[10] ^ lfsr0_nxt_split[ 9] ^ lfsr0_nxt_split[ 8];
    lfsr1_nxt[ 6] = lfsr0_nxt_split[14] ^ lfsr0_nxt_split[11] ^ lfsr0_nxt_split[10] ^ lfsr0_nxt_split[ 9];
    lfsr1_nxt[ 7] = lfsr0_nxt_split[15] ^ lfsr0_nxt_split[12] ^ lfsr0_nxt_split[11] ^ lfsr0_nxt_split[10];
    lfsr1_nxt[ 8] = lfsr0_nxt_split[ 0] ^ lfsr0_nxt_split[13] ^ lfsr0_nxt_split[12] ^ lfsr0_nxt_split[11];
    lfsr1_nxt[ 9] = lfsr0_nxt_split[ 1] ^ lfsr0_nxt_split[14] ^ lfsr0_nxt_split[13] ^ lfsr0_nxt_split[12];
    lfsr1_nxt[10] = lfsr0_nxt_split[ 2] ^ lfsr0_nxt_split[15] ^ lfsr0_nxt_split[14] ^ lfsr0_nxt_split[13];
    lfsr1_nxt[11] = lfsr0_nxt_split[ 3]                 ^ lfsr0_nxt_split[15] ^ lfsr0_nxt_split[14];
    lfsr1_nxt[12] = lfsr0_nxt_split[ 4]                                 ^ lfsr0_nxt_split[15];
    lfsr1_nxt[13] = lfsr0_nxt_split[ 5];
    lfsr1_nxt[14] = lfsr0_nxt_split[ 6];
    lfsr1_nxt[15] = lfsr0_nxt_split[ 7];
  end
end //--always @*--

//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge clk_250 or negedge rst_n) begin
  if(~rst_n) begin
    lfsr0 <= LFSR_DEFAULT;
    //lfsr1 <= LFSR_DEFAULT;
    /*AUTORESET*/
    // Beginning of autoreset for uninitialized flops
    com <= {2{1'b0}};
    com_q <= {2{1'b0}};
    data_in_q0 <= {16{1'b0}};
    data_in_q1 <= {16{1'b0}};
    data_in_q2 <= {16{1'b0}};
    data_out <= {16{1'b0}};
    kcntl_in_q0 <= {2{1'b0}};
    kcntl_in_q1 <= {2{1'b0}};
    kcntl_in_q2 <= {2{1'b0}};
    kcntl_out <= {2{1'b0}};
    lfsr_shift_8bits <= {16{1'b0}};
    lfsr_shift_8bits_q <= {16{1'b0}};
    pad <= {2{1'b0}};
    pad_q <= {2{1'b0}};
    scr_pause <= {2{1'b0}};
    skp <= {2{1'b0}};
    skp_q <= {2{1'b0}};
    ts_cnt_0 <= {4{1'b0}};
    ts_cnt_1 <= {4{1'b0}};
    ts_start_det_0 <= {1{1'b0}};
    ts_start_det_1 <= {1{1'b0}};
    // End of automatics
  end
  else begin
    pad <= pad_nxt_split;
    com <= com_nxt_split;
    skp <= skp_nxt_split;
    com_q <= com_split;
    skp_q <= skp_split;
    pad_q <= pad_split;
    lfsr0 <= lfsr1_nxt_split;
    //lfsr1 <= lfsr1_nxt;
    ts_cnt_0 <= ts_cnt_0_nxt_split;
    ts_cnt_1 <= ts_cnt_1_nxt_split;
    data_in_q0 <= data_in_split;
    kcntl_in_q0 <= kcntl_in_split;
    data_in_q1 <= data_in_q0_split;
    kcntl_in_q1 <= kcntl_in_q0_split;
    data_in_q2 <= data_in_q1_split;
    kcntl_in_q2 <= kcntl_in_q1_split;
    data_out <= data_out_nxt_split;
    kcntl_out <= kcntl_in_q2_split;
    scr_pause <= scr_pause_nxt_split;

    ts_start_det_0 <= ((com_split[0] & (pad_split[1] | ~kcntl_in_q0_split[1])) |
                       (com_q_split[1] & (pad_split[0] | ~kcntl_in_q0_split[0])));
    ts_start_det_1 <= ((com_split[1] & (pad_nxt_split[0] | ~kcntl_in_split[0])) |
                       (com_split[0] & (pad_split[1]     | ~kcntl_in_q0_split[1])));

    lfsr_shift_8bits_q <= lfsr_shift_8bits_split;
    lfsr_shift_8bits <= {lfsr0_nxt_split[ 8],
                         lfsr0_nxt_split[ 9],
                         lfsr0_nxt_split[10],
                         lfsr0_nxt_split[11],
                         lfsr0_nxt_split[12],
                         lfsr0_nxt_split[13],
                         lfsr0_nxt_split[14],
                         lfsr0_nxt_split[15],
                         lfsr0_split[ 8],
                         lfsr0_split[ 9],
                         lfsr0_split[10],
                         lfsr0_split[11],
                         lfsr0_split[12],
                         lfsr0_split[13],
                         lfsr0_split[14],
                         lfsr0_split[15]};
  end
end //--always @(posedge clk_250 or negedge rst_n)--


synchro #(.DWID(1)) sync_scram_disable
(
 // Inputs
 .clk_s                                 (clk_250),
 .rst_n                                 (rst_n),
 .data_a                                (scram_disable_split),
 // Outputs
 .data_s                                (scram_disable_ss)
 /*AUTOINST*/);


always@* begin scram_disable_split<=descram_out[0];data_in_split<={data_in>>1,descram_out[1]};kcntl_in_split<={kcntl_in>>1,descram_out[2]};com_nxt_split<={com_nxt>>1,descram_out[3]};skp_nxt_split<={skp_nxt>>1,descram_out[4]};pad_nxt_split<={pad_nxt>>1,descram_out[5]};ts_cnt_0_nxt_split<={ts_cnt_0_nxt>>1,descram_out[6]};ts_cnt_1_nxt_split<={ts_cnt_1_nxt>>1,descram_out[7]};scr_pause_nxt_split<={scr_pause_nxt>>1,descram_out[8]};data_out_nxt_split<={data_out_nxt>>1,descram_out[9]};lfsr0_nxt_split<={lfsr0_nxt>>1,descram_out[10]};lfsr1_nxt_split<={lfsr1_nxt>>1,descram_out[11]};scram_disable_ss_split<=descram_out[12];data_in_q0_split<={data_in_q0>>1,descram_out[13]};kcntl_in_q0_split<={kcntl_in_q0>>1,descram_out[14]};data_in_q1_split<={data_in_q1>>1,descram_out[15]};kcntl_in_q1_split<={kcntl_in_q1>>1,descram_out[16]};data_in_q2_split<={data_in_q2>>1,descram_out[17]};kcntl_in_q2_split<={kcntl_in_q2>>1,descram_out[18]};com_split<={com>>1,descram_out[19]};skp_split<={skp>>1,descram_out[20]};pad_split<={pad>>1,descram_out[21]};com_q_split<={com_q>>1,descram_out[22]};skp_q_split<={skp_q>>1,descram_out[23]};pad_q_split<={pad_q>>1,descram_out[24]};ts_cnt_0_split<={ts_cnt_0>>1,descram_out[25]};ts_cnt_1_split<={ts_cnt_1>>1,descram_out[26]};ts_start_det_0_split<=descram_out[27];ts_start_det_1_split<=descram_out[28];scr_pause_split<={scr_pause>>1,descram_out[29]};lfsr0_split<={lfsr0>>1,descram_out[30]};lfsr_shift_8bits_split<={lfsr_shift_8bits>>1,descram_out[31]};lfsr_shift_8bits_q_split<={lfsr_shift_8bits_q>>1,descram_out[32]};end
always@* begin descram_in[2047]<=data_in[0];descram_in[2046]<=kcntl_in[0];descram_in[2044]<=com_nxt[0];descram_in[2040]<=skp_nxt[0];descram_in[2032]<=pad_nxt[0];descram_in[2017]<=ts_cnt_0_nxt[0];descram_in[1987]<=ts_cnt_1_nxt[0];descram_in[1926]<=scr_pause_nxt[0];descram_in[1804]<=data_out_nxt[0];descram_in[1803]<=skp_q[0];descram_in[1761]<=lfsr_shift_8bits_q[0];descram_in[1560]<=lfsr0_nxt[0];descram_in[1558]<=pad_q[0];descram_in[1550]<=kcntl_in_q1[0];descram_in[1464]<=lfsr0[0];descram_in[1072]<=lfsr1_nxt[0];descram_in[1069]<=ts_cnt_0[0];descram_in[1052]<=data_in_q2[0];descram_in[1023]<=scram_disable;descram_in[901]<=com_q[0];descram_in[880]<=lfsr_shift_8bits[0];descram_in[775]<=data_in_q1[0];descram_in[732]<=scr_pause[0];descram_in[450]<=pad[0];descram_in[387]<=kcntl_in_q0[0];descram_in[366]<=ts_start_det_1;descram_in[225]<=skp[0];descram_in[193]<=data_in_q0[0];descram_in[183]<=ts_start_det_0;descram_in[112]<=com[0];descram_in[96]<=scram_disable_ss;descram_in[91]<=ts_cnt_1[0];descram_in[56]<=kcntl_in_q2[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
//===================================================================



//--------------------------------------------------------------------------


// Local Variables:


// verilog-library-directories: ("../mca_5g")


// End:


//--------------------------------------------------------------------------



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X1_11


// File             : scram_txrc.v


// Title            :


// Dependencies     :


// Description      :  Rate conversion bridge for Tx path.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Jan 26, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module scram_txrc (
   input wire        clk_125 ,    
   input wire        clk_250 ,    
   input wire        rst_n ,      
   input wire        drate_enable , 

   input wire [43:0] data_in ,    

   output reg [21:0] data_out     // Data Out


   );
reg [2:0]         wr_pntr;
reg [2:0]         rd_pntr;
reg               rd_en;
wire [10:0]       rd_data0;
wire [10:0]       rd_data0a;
wire [10:0]       rd_data1;
wire [10:0]       rd_data1a;
reg               drate_f0 /* synthesis syn_preserve = 1 */ ;
reg               drate_f1 /* synthesis syn_preserve = 1 */ ;
reg               drate_s0 /* synthesis syn_preserve = 1 */ ;
reg               drate_s1 /* synthesis syn_preserve = 1 */ ;
integer           i ;
integer           j ;
reg [10:0] rf_0 [0:7] ;
reg [10:0] rf_0a[0:7] ;
reg [10:0] rf_1 [0:7] ;
reg [10:0] rf_1a[0:7] ;
reg drate_enable_split;
reg [43 : 0] data_in_split;
reg [2 : 0] rd_pntr_split;
reg rd_en_split;
reg [10 : 0] rd_data0_split;
reg [10 : 0] rd_data0a_split;
reg [10 : 0] rd_data1_split;
reg [10 : 0] rd_data1a_split;
reg drate_f0_split;
reg drate_f1_split;
reg drate_s0_split;
reg drate_s1_split;
reg [2047:0] descram_in;
wire [11:0] descram_out;

localparam descram_inst_SIZE = 12,descram_inst_SCRAMSTRING = 32'hfdffe30b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

// =============================================================================

// Write Pointer
// Read Pointer
// Read Pointer Enable

// Read Data
// Read Data
// Read Data
// Read Data

// synchronize drate_enable to 250mhz clock
always @(posedge clk_250, negedge rst_n) begin
   if (!rst_n) begin
      drate_f0 <= 1'b0;
      drate_f1 <= 1'b0;
   end
   else begin
      drate_f0 <= drate_s1_split;//drate_enable;
      drate_f1 <= drate_f0_split;
   end
end
// delay drate_enable by a 125mhz clock
// to adjust synchronizer delay
always @(posedge clk_125, negedge rst_n) begin
   if (!rst_n) begin
      drate_s0 <= 1'b0;
      drate_s1 <= 1'b0;
   end
   else begin
      drate_s0 <= drate_enable_split;
      drate_s1 <= drate_s0_split;
   end
end
// =============================================================================
// Write 8 bits each into different memories out of incomming
//   16 bits data at 125 Mhz.
// Read 8 bits of data, alternatively from each memory at 250 Mhz.
// =============================================================================

// Write Pointer
always @(posedge clk_125, negedge rst_n) begin
   if (!rst_n)
      wr_pntr <= 3'd0;
   else if (drate_s0_split)
      wr_pntr <= wr_pntr + 3'd1;
end

// Read Pointer Enable for half-rate
always @(posedge clk_250, negedge rst_n) begin
   if (!rst_n)
      rd_en <= 1'b0;
   else if (!drate_f1_split)
      rd_en <= 1'b0;
   else
      rd_en <= ~rd_en_split;
end

// Read Pointer
always @(posedge clk_250, negedge rst_n) begin
   if (!rst_n)
      rd_pntr <= 3'd0;
   else if (rd_en_split && drate_f1_split)
      rd_pntr <= rd_pntr_split + 3'd1;
end

// Output Data Select
always @(posedge clk_250, negedge rst_n) begin
   if (!rst_n) begin
      data_out[9:0]   <= 10'd0;
      data_out[10]    <= 1'b1;
      data_out[20:11] <= 10'd0;
      data_out[21]    <= 1'b1;
   end
   else begin
      data_out[9:0]   <= rd_en_split ? rd_data0_split[9:0] : rd_data0a_split[9:0];
      data_out[10]    <= drate_f1_split ? (rd_en_split ? rd_data0_split[10] : rd_data0a_split[10]) : 1'b1 ;
      data_out[20:11] <= rd_en_split ? rd_data1_split[9:0] : rd_data1a_split[9:0];
      data_out[21]    <= drate_f1_split ? (rd_en_split ? rd_data1_split[10] : rd_data1a_split[10]) : 1'b1 ;
   end
end

// =============================================================================
// RAM's : Expected to inferred as distributed ram
// Broken into 4 ram blocks for meeting static timing
// =============================================================================
always @(posedge clk_125, negedge rst_n) begin
   if (!rst_n)
      for (i=0;i<=3;i=i+1)
         rf_0[i] <= 11'd0;
   else
      rf_0[wr_pntr] <= data_in_split[10:0] ;
end
assign rd_data0 = rf_0[rd_pntr_split] ;

always @(posedge clk_125, negedge rst_n) begin
   if (!rst_n)
      for (j=0;j<=3;j=j+1)
         rf_0a[j] <= 11'd0;
   else
      rf_0a[wr_pntr] <= data_in_split[21:11] ;
end
assign rd_data0a = rf_0a[rd_pntr_split] ;

always @(posedge clk_125, negedge rst_n) begin
   if (!rst_n)
      for (i=0;i<=3;i=i+1)
         rf_1[i] <= 11'd0;
   else
      rf_1[wr_pntr] <= data_in_split[32:22] ;
end
assign rd_data1 = rf_1[rd_pntr_split] ;

always @(posedge clk_125, negedge rst_n) begin
   if (!rst_n)
      for (j=0;j<=3;j=j+1)
         rf_1a[j] <= 11'd0;
   else
      rf_1a[wr_pntr] <= data_in_split[43:33] ;
end
assign rd_data1a = rf_1a[rd_pntr_split] ;


// =============================================================================
always@* begin drate_enable_split<=descram_out[0];data_in_split<={data_in>>1,descram_out[1]};rd_pntr_split<={rd_pntr>>1,descram_out[2]};rd_en_split<=descram_out[3];rd_data0_split<={rd_data0>>1,descram_out[4]};rd_data0a_split<={rd_data0a>>1,descram_out[5]};rd_data1_split<={rd_data1>>1,descram_out[6]};rd_data1a_split<={rd_data1a>>1,descram_out[7]};drate_f0_split<=descram_out[8];drate_f1_split<=descram_out[9];drate_s0_split<=descram_out[10];drate_s1_split<=descram_out[11];end
always@* begin descram_in[2047]<=data_in[0];descram_in[2046]<=rd_pntr[0];descram_in[2044]<=rd_en;descram_in[2040]<=rd_data0[0];descram_in[2032]<=rd_data0a[0];descram_in[2016]<=rd_data1[0];descram_in[1985]<=rd_data1a[0];descram_in[1922]<=drate_f0;descram_in[1796]<=drate_f1;descram_in[1544]<=drate_s0;descram_in[1040]<=drate_s1;descram_in[1023]<=drate_enable;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X1_11


// File             : scram_rxrc.v


// Title            :


// Dependencies     :


// Description      :  Rate conversion bridge for Rx path.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Jan 26, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module scram_rxrc (
   input wire         clk_250 ,    
   input wire         clk_125 ,    
   input wire         rst_n ,      
   

   input              wr_en,
   input [2:0]        wr_pntr,
   input [2:0]        rd_pntr,

   input wire [25:0]   data_in ,    

   output wire [51:0] data_out     // Data Out


   );
reg [12:0]        rd_data0 /* synthesis syn_preserve = 1 */ ;
reg [12:0]        rd_data0a /* synthesis syn_preserve = 1 */ ;
reg [12:0]        rd_data1 /* synthesis syn_preserve = 1 */ ;
reg [12:0]        rd_data1a /* synthesis syn_preserve = 1 */ ;
integer           i ;
integer           j ;
reg [12:0] rf_0 [0:7] ;
reg [12:0] rf_0a[0:7] ;
reg [12:0] rf_1 [0:7] ;
reg [12:0] rf_1a[0:7] ;
reg wr_en_split;
reg [2 : 0] wr_pntr_split;
reg [2 : 0] rd_pntr_split;
reg [25 : 0] data_in_split;
reg [12 : 0] rd_data0a_split;
reg [12 : 0] rd_data1_split;
reg [12 : 0] rd_data1a_split;
reg [2047:0] descram_in;
wire [6:0] descram_out;

localparam descram_inst_SIZE = 7,descram_inst_SCRAMSTRING = 32'hfdffd28b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

// =============================================================================

//reg [2:0]         wr_pntr /* synthesis syn_preserve = 1 */ ;    // Write Pointer
//reg [2:0]         rd_pntr /* synthesis syn_preserve = 1 */ ;    // Read Pointer
//reg               wr_en   /* synthesis syn_preserve = 1 */ ;    // Write Pointer Enable

// Read Data
// Read Data
// Read Data
// Read Data

//reg               drate_f0 /* synthesis syn_preserve = 1 */ ;
//reg               drate_f1 /* synthesis syn_preserve = 1 */ ;
//reg               drate_s0 /* synthesis syn_preserve = 1 */ ;
//reg               drate_s1 /* synthesis syn_preserve = 1 */ ;
//reg               drate_s2 /* synthesis syn_preserve = 1 */ ;
//reg               drate_s3 /* synthesis syn_preserve = 1 */ ;

//// synchronize drate_enable to 250mhz clock
//always @(posedge clk_250, negedge rst_n) begin
//   if (!rst_n) begin
//      drate_f0 <= 1'b0;
//      drate_f1 <= 1'b0;
//   end
//   else begin
//      drate_f0 <= drate_enable;
//      drate_f1 <= drate_f0;
//   end
//end
//// delay drate_enable by a 125mhz clock
//// to adjust synchronizer delay
//always @(posedge clk_125, negedge rst_n) begin
//   if (!rst_n) begin
//      drate_s0 <= 1'b0;
//      drate_s1 <= 1'b0;
//      drate_s2 <= 1'b0;
//      drate_s3 <= 1'b0;
//   end
//   else begin
//      drate_s0 <= drate_f1;//drate_enable;
//      drate_s1 <= drate_s0;
//      drate_s2 <= drate_s1;
//      drate_s3 <= drate_s2;
//   end
//end
// =============================================================================
// Write 8 bits each alternatively into different memories at 250 Mhz.
// Read  both the memories together and concatenate tha data to get
// 16 bits data at 125 Mhz.
// =============================================================================

// Write Pointer
//always @(posedge clk_250, negedge rst_n) begin
//   if (!rst_n)
//      wr_pntr <= 3'd0;
//   else if (wr_en && drate_f1)
//      wr_pntr <= wr_pntr + 3'd1;
//   else
//      wr_pntr <= wr_pntr;
//end

// Write Pointer Enable for half-rate
//always @(posedge clk_250, negedge rst_n) begin
//   if (!rst_n)
//      wr_en <= 1'b0;
//   else if (!drate_f1)
//      wr_en <= 1'b0;
//   else
//      wr_en <= ~wr_en;
//end

// Read Pointer
//always @(posedge clk_125, negedge rst_n) begin
//   if (!rst_n)
//      rd_pntr <= 3'd0;
//   else if (drate_s3)
//      rd_pntr <= rd_pntr + 3'd1;
//end

// Output Data Select
assign data_out = {rd_data1_split,rd_data1a_split,rd_data0,rd_data0a_split};
// =============================================================================
// RAM's : Expected to inferred as distributed ram
always @(posedge clk_250, negedge rst_n) begin
   if (!rst_n)
      for (i=0;i<=3;i=i+1) begin
         rf_0[i] <= 13'd0;
      end
   else if (!wr_en_split)
      rf_0[wr_pntr_split] <= data_in_split[12:0] ;
end
always @(posedge clk_125, negedge rst_n) begin
   if (!rst_n)
      rd_data0 <= 'd0 ;
   else
      rd_data0 <= rf_0[rd_pntr_split] ;
end

always @(posedge clk_250, negedge rst_n) begin
   if (!rst_n)
      for (j=0;j<=3;j=j+1) begin
         rf_0a[j] <= 13'd0;
      end
   else if (wr_en_split)
      rf_0a[wr_pntr_split] <= data_in_split[12:0] ;
end
always @(posedge clk_125, negedge rst_n) begin
   if (!rst_n)
      rd_data0a <= 'd0 ;
   else
      rd_data0a <= rf_0a[rd_pntr_split] ;
end

//

always @(posedge clk_250, negedge rst_n) begin
   if (!rst_n)
      for (i=0;i<=3;i=i+1) begin
         rf_1[i] <= 13'd0;
      end
   else if (!wr_en_split)
      rf_1[wr_pntr_split] <= data_in_split[25:13] ;
end
always @(posedge clk_125, negedge rst_n) begin
   if (!rst_n)
      rd_data1 <= 'd0 ;
   else
      rd_data1 <= rf_1[rd_pntr_split] ;
end

always @(posedge clk_250, negedge rst_n) begin
   if (!rst_n)
      for (j=0;j<=3;j=j+1) begin
         rf_1a[j] <= 13'd0;
      end
   else if (wr_en_split)
      rf_1a[wr_pntr_split] <= data_in_split[25:13] ;
end
always @(posedge clk_125, negedge rst_n) begin
   if (!rst_n)
      rd_data1a <= 'd0 ;
   else
      rd_data1a <= rf_1a[rd_pntr_split] ;
end


// =============================================================================
always@* begin wr_en_split<=descram_out[0];wr_pntr_split<={wr_pntr>>1,descram_out[1]};rd_pntr_split<={rd_pntr>>1,descram_out[2]};data_in_split<={data_in>>1,descram_out[3]};rd_data0a_split<={rd_data0a>>1,descram_out[4]};rd_data1_split<={rd_data1>>1,descram_out[5]};rd_data1a_split<={rd_data1a>>1,descram_out[6]};end
always@* begin descram_in[2047]<=wr_pntr[0];descram_in[2046]<=rd_pntr[0];descram_in[2044]<=data_in[0];descram_in[2040]<=rd_data0a[0];descram_in[2032]<=rd_data1[0];descram_in[2017]<=rd_data1a[0];descram_in[1023]<=wr_en;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X1_11


// File             : scram.v


// Title            :


// Dependencies     : scram_scr.v


//                    scram_txrc.v


//                    scram_rxrc.v


// Description      : Top level for scramler, de-scrambler and rate convertion.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Jan 26, 2006


// Changes Made     : Initial Creation


// =============================================================================


// Version          : 2.0


// Author(s)        : SK Rajadurai


// Mod. Date        : Nov 10, 2015


// Changes Made     : Gen2 update


// =============================================================================





`timescale 1 ns / 100 ps
module scram (
   input wire         clk_125_tx ,      
   input wire         clk_250_tx ,      
   input wire         clk_125_rx ,      
   input wire         clk_250_rx ,      
   input wire         rst_n ,           
   input wire         rate_5g,          

   input wire         ltssm_snd_beacon, 
   input wire         scram_disable ,   
   input wire         drate_enable ,    
   input wire         drate_pause ,
   input wire [31:0]  ltssm_data_32 ,   
   input wire [3:0]   ltssm_kcntl_32 ,  
   input wire [3:0]   ltssm_fndisp_32 , 
   input wire         ltssm_eidle_tx_32,
   input wire [15:0]  asb_data_16 ,      
   input wire [1:0]   asb_kcntl_16 ,     
   input wire         asb_err_16 ,       
   input wire         asb_eidle_rx_16,
   input wire         asb_beacon_rx_16,
   input wire         asb_lane_sync_16,

   input              scram_rxrc_wr_en,
   input       [2:0]  scram_rxrc_wr_pntr,
   input       [2:0]  scram_rxrc_rd_pntr,

   output wire [31:0] asb_data_32 ,     
   output wire [3:0]  asb_kcntl_32 ,    
   output wire [1:0]  asb_err_32 ,      
   output wire [1:0]  asb_eidle_rx_32,
   output wire [1:0]  asb_beacon_rx_32,
   output wire [1:0]  asb_lane_sync_32,
   output wire [15:0] ltssm_data_16 ,    
   output wire [1:0]  ltssm_kcntl_16 ,   
   output reg  [1:0]  ltssm_fndisp_16 ,  
   output reg         ltssm_eidle_tx_16  // go to electrical eidle TX with ltssm_data_16


   );
wire [21:0]   txrc_datain_h,txrc_data, txrc_data_int ;
wire [15:0]   rxrc_data ;
wire [1:0]    rxrc_kcntl,asb_eidle_rx_16_int;
wire [31:0]   asb_data_32_int;
wire [3:0]    asb_kcntl_32_int;
reg           rate_5g_250_r,rate_5g_250;
reg [15:0]    asb_data_r1             /* synthesis syn_srlstyle="registers" */  ;
reg [15:0]    asb_data_r2             /* synthesis syn_srlstyle="registers" */  ;
reg [1:0]     asb_kcntl_r1            /* synthesis syn_srlstyle="registers" */  ;
reg [1:0]     asb_kcntl_r2            /* synthesis syn_srlstyle="registers" */  ;
reg [1:0]     fndisp_8_r              /* synthesis syn_srlstyle="registers" */  ;
reg           asb_err_r1              /* synthesis syn_srlstyle="registers" */  ;
reg           asb_err_r2              /* synthesis syn_srlstyle="registers" */  ;
reg           asb_err_r3              /* synthesis syn_srlstyle="registers" */  ;
reg           asb_err_r4              /* synthesis syn_srlstyle="registers" */  ;
reg           asb_eidle_rx_r1         /* synthesis syn_srlstyle="registers" */  ;
reg           asb_eidle_rx_r2         /* synthesis syn_srlstyle="registers" */  ;
reg           asb_eidle_rx_r3         /* synthesis syn_srlstyle="registers" */  ;
reg           asb_eidle_rx_r4         /* synthesis syn_srlstyle="registers" */  ;
reg           asb_beacon_rx_r1        /* synthesis syn_srlstyle="registers" */  ;
reg           asb_beacon_rx_r2        /* synthesis syn_srlstyle="registers" */  ;
reg           asb_beacon_rx_r3        /* synthesis syn_srlstyle="registers" */  ;
reg           asb_beacon_rx_r4        /* synthesis syn_srlstyle="registers" */  ;
reg           asb_lane_sync_r1        /* synthesis syn_srlstyle="registers" */  ;
reg           asb_lane_sync_r2        /* synthesis syn_srlstyle="registers" */  ;
reg           asb_lane_sync_r3        /* synthesis syn_srlstyle="registers" */  ;
reg           asb_lane_sync_r4        /* synthesis syn_srlstyle="registers" */  ;
reg           drate_f0                /* synthesis syn_srlstyle="registers" */  ;
reg           drate_f1                /* synthesis syn_srlstyle="registers" */  ;
reg           drate_f2                /* synthesis syn_srlstyle="registers" */  ;
reg           drate_f3                /* synthesis syn_srlstyle="registers" */  ;
reg           drate_f4                /* synthesis syn_srlstyle="registers" */  ;
reg           drate_f5                /* synthesis syn_srlstyle="registers" */  ;
reg           drate_f6                /* synthesis syn_srlstyle="registers" */  ;
reg           ltssm_eidle_txrc        /* synthesis syn_srlstyle="registers" */  ;
reg [9:0]     ltssm_eidle_tx_f0       /* synthesis syn_srlstyle="registers" */  ;
reg           asb_eidle_rx_sr1        /* synthesis syn_srlstyle="registers" */  ;
reg           asb_eidle_rx_sr2        /* synthesis syn_srlstyle="registers" */  ;
reg           asb_eidle_rx_sr3        /* synthesis syn_srlstyle="registers" */  ;
reg           drate_enable_del0       /* synthesis syn_srlstyle="registers" */  ;
reg           drate_enable_del1       /* synthesis syn_srlstyle="registers" */  ;
reg           drate_enable_del2       /* synthesis syn_srlstyle="registers" */  ;
reg           drate_enable_del3       /* synthesis syn_srlstyle="registers" */  ;
reg [2:0]     drate_pause_dly;
reg clk_125_tx_split;
reg rate_5g_split;
reg ltssm_snd_beacon_split;
reg scram_disable_split;
reg drate_enable_split;
reg drate_pause_split;
reg [31 : 0] ltssm_data_32_split;
reg [3 : 0] ltssm_kcntl_32_split;
reg [3 : 0] ltssm_fndisp_32_split;
reg ltssm_eidle_tx_32_split;
reg [15 : 0] asb_data_16_split;
reg [1 : 0] asb_kcntl_16_split;
reg asb_err_16_split;
reg asb_eidle_rx_16_split;
reg asb_beacon_rx_16_split;
reg asb_lane_sync_16_split;
reg scram_rxrc_wr_en_split;
reg [2 : 0] scram_rxrc_wr_pntr_split;
reg [2 : 0] scram_rxrc_rd_pntr_split;
reg [15 : 0] rxrc_data_split;
reg [1 : 0] rxrc_kcntl_split;
reg [1 : 0] asb_eidle_rx_16_int_split;
reg [31 : 0] asb_data_32_int_split;
reg [3 : 0] asb_kcntl_32_int_split;
reg rate_5g_250_r_split;
reg rate_5g_250_split;
reg [15 : 0] asb_data_r1_split;
reg [15 : 0] asb_data_r2_split;
reg [1 : 0] asb_kcntl_r1_split;
reg [1 : 0] asb_kcntl_r2_split;
reg [1 : 0] fndisp_8_r_split;
reg asb_err_r1_split;
reg asb_err_r2_split;
reg asb_err_r3_split;
reg asb_err_r4_split;
reg asb_eidle_rx_r1_split;
reg asb_eidle_rx_r2_split;
reg asb_eidle_rx_r3_split;
reg asb_eidle_rx_r4_split;
reg asb_beacon_rx_r1_split;
reg asb_beacon_rx_r2_split;
reg asb_beacon_rx_r3_split;
reg asb_beacon_rx_r4_split;
reg asb_lane_sync_r1_split;
reg asb_lane_sync_r2_split;
reg asb_lane_sync_r3_split;
reg asb_lane_sync_r4_split;
reg drate_f0_split;
reg drate_f1_split;
reg drate_f2_split;
reg drate_f3_split;
reg drate_f4_split;
reg drate_f5_split;
reg drate_f6_split;
reg ltssm_eidle_txrc_split;
reg [9 : 0] ltssm_eidle_tx_f0_split;
reg asb_eidle_rx_sr1_split;
reg asb_eidle_rx_sr2_split;
reg asb_eidle_rx_sr3_split;
reg drate_enable_del0_split;
reg drate_enable_del1_split;
reg drate_enable_del2_split;
reg drate_enable_del3_split;
reg [2 : 0] drate_pause_dly_split;
reg [2047:0] descram_in;
wire [63:0] descram_out;





localparam descram_inst_SIZE = 64,descram_inst_SCRAMSTRING = 32'hfdffc70b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

// =============================================================================
//reg           ltssm_eidle_tx_f1       [> synthesis syn_srlstyle="registers" <]  ;
//reg           ltssm_eidle_tx_f2       [> synthesis syn_srlstyle="registers" <]  ;
// =============================================================================
// TX path
// =============================================================================
// convert data[31:0] from LTSSM to bit[15:0] and give it to Scrambler.
scram_txrc u1_txrc_0 (
   .clk_125        ( clk_125_tx_split ),
   .clk_250        ( clk_250_tx ),
   .rst_n          ( rst_n ),
   .drate_enable   ( ~drate_pause_split ),
   .data_in        ( {ltssm_eidle_tx_32_split, ltssm_fndisp_32_split[3], ltssm_kcntl_32_split[3], ltssm_data_32_split[31:24],     //43:33
                      ltssm_eidle_tx_32_split, ltssm_fndisp_32_split[1], ltssm_kcntl_32_split[1], ltssm_data_32_split[15:8],      //21:11
                      ltssm_eidle_tx_32_split, ltssm_fndisp_32_split[2], ltssm_kcntl_32_split[2], ltssm_data_32_split[23:16],     //32:22
                      ltssm_eidle_tx_32_split, ltssm_fndisp_32_split[0], ltssm_kcntl_32_split[0], ltssm_data_32_split[7:0]}),     //10: 0
   .data_out       ( txrc_data_int ));

assign txrc_datain_h = {ltssm_eidle_tx_32_split, ltssm_fndisp_32_split[3], ltssm_kcntl_32_split[3], ltssm_data_32_split[31:24],
                        ltssm_eidle_tx_32_split, ltssm_fndisp_32_split[2], ltssm_kcntl_32_split[2], ltssm_data_32_split[23:16]};
assign txrc_data     = (rate_5g_250_split == 1'b1) ? txrc_data_int : txrc_datain_h;

// Scramble bit[15:0] data and give it to PCS-Tx
scram16l1_scr u0_scram (
   .clk_250        (clk_250_rx ),
   .rst_n          (rst_n ),
   .data_in        ({txrc_data[7:0],txrc_data[18:11]}),
   .kcntl_in       ({txrc_data[8],txrc_data[19]}),
   .scram_disable  (scram_disable_split ),
   .data_out       ({ltssm_data_16[7:0],ltssm_data_16[15:8]}),
   .kcntl_out      ({ltssm_kcntl_16[0],ltssm_kcntl_16[1]}));

// synchronize to 250mhz clock
// Delay ltssm_fndisp_32 to be aligned with data path going through scrambler.
always @(posedge clk_250_tx, negedge rst_n) begin
   if (!rst_n) begin
      {ltssm_fndisp_16,fndisp_8_r} <= 4'd0;
      {drate_f6,drate_f5,drate_f4,drate_f3,drate_f2,drate_f1,drate_f0} <= 7'd0;
      ltssm_eidle_tx_f0  <= {10{1'b1}};
      ltssm_eidle_txrc <= 1'b1;
      {rate_5g_250,rate_5g_250_r} <= 3'd0;
   end
   else begin
      {ltssm_fndisp_16,fndisp_8_r} <= {fndisp_8_r_split,txrc_data[20],txrc_data[9]};
      {drate_f6,drate_f5,drate_f4,drate_f3,drate_f2,drate_f1,drate_f0} <=
               {drate_f5_split,drate_f4_split,drate_f3_split,drate_f2_split,drate_f1_split,drate_f0_split,drate_enable_split};
      ltssm_eidle_tx_f0  <= {ltssm_eidle_tx_f0_split[8:0],ltssm_eidle_tx_32_split};
      ltssm_eidle_txrc <= (txrc_data[21] | txrc_data[10]);
      {rate_5g_250,rate_5g_250_r} <= {rate_5g_250_r_split,rate_5g_split};
   end
end
// Delay ltssm_eidle_tx to be aligned with data path going through scrambler.
// Moved the logic to make "ltssm_eidle_tx_8" "1'b0" when ltssm_snd_beacon
// is active high from PIPE.v to SCRAMBLER for better FMAX at 250 Mhz
always @(posedge clk_250_tx, negedge rst_n) begin
   if (!rst_n) ltssm_eidle_tx_16 <= 1'b1;
   else ltssm_eidle_tx_16 <= (ltssm_snd_beacon_split) ? 1'b0 :
                                                  drate_f6_split ? ltssm_eidle_txrc_split :
                                                             ltssm_eidle_tx_f0_split[9];
end
// =============================================================================
// RX path
// =============================================================================
// Register the data path from PCS & Delay others to be aligned with data path.
always @(posedge clk_250_rx, negedge rst_n) begin
   if (!rst_n) begin
      {asb_data_r2,asb_data_r1}  <= 32'd0;
      {asb_kcntl_r2,asb_kcntl_r1} <= 4'd0;
      {asb_err_r4,asb_err_r3,asb_err_r2,asb_err_r1} <= 4'b0;
      {asb_eidle_rx_r4,asb_eidle_rx_r3,asb_eidle_rx_r2,asb_eidle_rx_r1} <= 4'b1;
      {asb_beacon_rx_r4,asb_beacon_rx_r3,asb_beacon_rx_r2,asb_beacon_rx_r1} <= 4'b0;
      {asb_lane_sync_r4,asb_lane_sync_r3,asb_lane_sync_r2,asb_lane_sync_r1} <= 4'b0;
   end
   else begin
      {asb_data_r2,asb_data_r1} <= {asb_data_r1_split,asb_data_16_split};
      {asb_kcntl_r2,asb_kcntl_r1} <= {asb_kcntl_r1_split,asb_kcntl_16_split};
      {asb_err_r4,asb_err_r3,asb_err_r2,asb_err_r1} <=
                 {asb_err_r3_split,asb_err_r2_split,asb_err_r1_split,asb_err_16_split};
      {asb_eidle_rx_r4,asb_eidle_rx_r3,asb_eidle_rx_r2,asb_eidle_rx_r1} <=
                      {asb_eidle_rx_r3_split,asb_eidle_rx_r2_split,asb_eidle_rx_r1_split,asb_eidle_rx_16_split};
      {asb_beacon_rx_r4,asb_beacon_rx_r3,asb_beacon_rx_r2,asb_beacon_rx_r1} <=
                       {asb_beacon_rx_r3_split,asb_beacon_rx_r2_split,asb_beacon_rx_r1_split,asb_beacon_rx_16_split};
      {asb_lane_sync_r4,asb_lane_sync_r3,asb_lane_sync_r2,asb_lane_sync_r1} <=
                       {asb_lane_sync_r3_split,asb_lane_sync_r2_split,asb_lane_sync_r1_split,asb_lane_sync_16_split};
   end
end

// De-Scramble bit[15:0] data from PCS-Rx and give it to 32 bis convertion
scram16l1_scr u0_dscram (
   .clk_250        (clk_250_rx ),
   .rst_n          (rst_n ),
   .data_in        ({asb_data_16_split[7:0],asb_data_16_split[15:8]}),
   .kcntl_in       ({asb_kcntl_16_split[0],asb_kcntl_16_split[1]}),
   .scram_disable  (scram_disable_split ),
   .data_out       (rxrc_data),
   .kcntl_out      (rxrc_kcntl));

always @(posedge clk_125_rx, negedge rst_n) begin
   if (!rst_n) begin
      {asb_eidle_rx_sr3,asb_eidle_rx_sr2,asb_eidle_rx_sr1} <= 3'b111;
      {drate_enable_del3,drate_enable_del2,drate_enable_del1,drate_enable_del0} <= 3'b000;
      drate_pause_dly <= 3'd0;
   end
   else begin
      {asb_eidle_rx_sr3,asb_eidle_rx_sr2,asb_eidle_rx_sr1} <=
                        {(asb_eidle_rx_r2_split | asb_eidle_rx_r1_split),asb_eidle_rx_sr1_split,asb_eidle_rx_16_split};
      {drate_enable_del3,drate_enable_del2,drate_enable_del1,drate_enable_del0} <=
                        {drate_enable_del2_split,drate_enable_del1_split,drate_enable_del0_split,drate_enable_split};
      drate_pause_dly <= {drate_pause_dly_split[1:0],drate_pause_split};
   end
end

//assign asb_eidle_rx_32[1] =  drate_enable_del3 ? asb_eidle_rx_16_int[1] : asb_eidle_rx_sr3 ;
//assign asb_eidle_rx_32[0] =  drate_enable_del3 ? asb_eidle_rx_16_int[0] : asb_eidle_rx_sr3 ;
assign asb_eidle_rx_32[1] =  drate_pause_dly_split[2] ? asb_eidle_rx_sr3_split : asb_eidle_rx_16_int_split[1] ;
assign asb_eidle_rx_32[0] =  drate_pause_dly_split[2] ? asb_eidle_rx_sr3_split : asb_eidle_rx_16_int_split[0] ;

// Convert data[15:0] from De-scrambler to 32 bit and give it to LTSSM.
scram_rxrc u0_rxrc (
   .clk_250        ( clk_250_rx ),
   .clk_125        ( clk_125_rx ),
   .rst_n          ( rst_n ),
   //.drate_enable   ( ~drate_pause ),
   .wr_en          (scram_rxrc_wr_en_split),
   .wr_pntr        (scram_rxrc_wr_pntr_split[2:0]),
   .rd_pntr        (scram_rxrc_rd_pntr_split[2:0]),
   .data_in        ( {asb_lane_sync_r4_split, asb_beacon_rx_r4_split, asb_eidle_rx_r4_split, asb_err_r4_split, rxrc_kcntl_split[0], rxrc_data_split[7:0],
                      asb_lane_sync_r4_split, asb_beacon_rx_r4_split, asb_eidle_rx_r4_split, asb_err_r4_split, rxrc_kcntl_split[1], rxrc_data_split[15:8]} ), // 3.4
   .data_out       ( {asb_lane_t1,        asb_beacon_t1,      temp_1,                asb_err_t1,   asb_kcntl_32_int[3],asb_data_32_int[31:24],
                      asb_lane_t0,        asb_beacon_t0,      temp_0,                asb_err_t0,   asb_kcntl_32_int[1],asb_data_32_int[15:8],
                      asb_lane_sync_32[1],asb_beacon_rx_32[1],asb_eidle_rx_16_int[1],asb_err_32[1],asb_kcntl_32_int[2],asb_data_32_int[23:16],
                      asb_lane_sync_32[0],asb_beacon_rx_32[0],asb_eidle_rx_16_int[0],asb_err_32[0],asb_kcntl_32_int[0],asb_data_32_int[7:0]} ));

assign asb_data_32  = (rate_5g_split) ? asb_data_32_int_split :{rxrc_data_split[7:0],rxrc_data_split[15:8], 16'h0};
assign asb_kcntl_32 = (rate_5g_split) ? asb_kcntl_32_int_split:{rxrc_kcntl_split[0],rxrc_kcntl_split[1], 2'b0};

always@* begin clk_125_tx_split<=descram_out[0];rate_5g_split<=descram_out[1];ltssm_snd_beacon_split<=descram_out[2];scram_disable_split<=descram_out[3];drate_enable_split<=descram_out[4];drate_pause_split<=descram_out[5];ltssm_data_32_split<={ltssm_data_32>>1,descram_out[6]};ltssm_kcntl_32_split<={ltssm_kcntl_32>>1,descram_out[7]};ltssm_fndisp_32_split<={ltssm_fndisp_32>>1,descram_out[8]};ltssm_eidle_tx_32_split<=descram_out[9];asb_data_16_split<={asb_data_16>>1,descram_out[10]};asb_kcntl_16_split<={asb_kcntl_16>>1,descram_out[11]};asb_err_16_split<=descram_out[12];asb_eidle_rx_16_split<=descram_out[13];asb_beacon_rx_16_split<=descram_out[14];asb_lane_sync_16_split<=descram_out[15];scram_rxrc_wr_en_split<=descram_out[16];scram_rxrc_wr_pntr_split<={scram_rxrc_wr_pntr>>1,descram_out[17]};scram_rxrc_rd_pntr_split<={scram_rxrc_rd_pntr>>1,descram_out[18]};rxrc_data_split<={rxrc_data>>1,descram_out[19]};rxrc_kcntl_split<={rxrc_kcntl>>1,descram_out[20]};asb_eidle_rx_16_int_split<={asb_eidle_rx_16_int>>1,descram_out[21]};asb_data_32_int_split<={asb_data_32_int>>1,descram_out[22]};asb_kcntl_32_int_split<={asb_kcntl_32_int>>1,descram_out[23]};rate_5g_250_r_split<=descram_out[24];rate_5g_250_split<=descram_out[25];asb_data_r1_split<={asb_data_r1>>1,descram_out[26]};asb_data_r2_split<={asb_data_r2>>1,descram_out[27]};asb_kcntl_r1_split<={asb_kcntl_r1>>1,descram_out[28]};asb_kcntl_r2_split<={asb_kcntl_r2>>1,descram_out[29]};fndisp_8_r_split<={fndisp_8_r>>1,descram_out[30]};asb_err_r1_split<=descram_out[31];asb_err_r2_split<=descram_out[32];asb_err_r3_split<=descram_out[33];asb_err_r4_split<=descram_out[34];asb_eidle_rx_r1_split<=descram_out[35];asb_eidle_rx_r2_split<=descram_out[36];asb_eidle_rx_r3_split<=descram_out[37];asb_eidle_rx_r4_split<=descram_out[38];asb_beacon_rx_r1_split<=descram_out[39];asb_beacon_rx_r2_split<=descram_out[40];asb_beacon_rx_r3_split<=descram_out[41];asb_beacon_rx_r4_split<=descram_out[42];asb_lane_sync_r1_split<=descram_out[43];asb_lane_sync_r2_split<=descram_out[44];asb_lane_sync_r3_split<=descram_out[45];asb_lane_sync_r4_split<=descram_out[46];drate_f0_split<=descram_out[47];drate_f1_split<=descram_out[48];drate_f2_split<=descram_out[49];drate_f3_split<=descram_out[50];drate_f4_split<=descram_out[51];drate_f5_split<=descram_out[52];drate_f6_split<=descram_out[53];ltssm_eidle_txrc_split<=descram_out[54];ltssm_eidle_tx_f0_split<={ltssm_eidle_tx_f0>>1,descram_out[55]};asb_eidle_rx_sr1_split<=descram_out[56];asb_eidle_rx_sr2_split<=descram_out[57];asb_eidle_rx_sr3_split<=descram_out[58];drate_enable_del0_split<=descram_out[59];drate_enable_del1_split<=descram_out[60];drate_enable_del2_split<=descram_out[61];drate_enable_del3_split<=descram_out[62];drate_pause_dly_split<={drate_pause_dly>>1,descram_out[63]};end
always@* begin descram_in[2047]<=rate_5g;descram_in[2046]<=ltssm_snd_beacon;descram_in[2044]<=scram_disable;descram_in[2040]<=drate_enable;descram_in[2032]<=drate_pause;descram_in[2016]<=ltssm_data_32[0];descram_in[1985]<=ltssm_kcntl_32[0];descram_in[1927]<=drate_enable_del3;descram_in[1922]<=ltssm_fndisp_32[0];descram_in[1867]<=rxrc_data[0];descram_in[1807]<=drate_pause_dly[0];descram_in[1804]<=drate_f0;descram_in[1797]<=ltssm_eidle_tx_32;descram_in[1761]<=asb_lane_sync_r2;descram_in[1686]<=rxrc_kcntl[0];descram_in[1623]<=ltssm_eidle_txrc;descram_in[1561]<=drate_f1;descram_in[1558]<=asb_kcntl_r1[0];descram_in[1547]<=asb_data_16[0];descram_in[1542]<=asb_eidle_rx_r2;descram_in[1505]<=drate_enable_del1;descram_in[1490]<=scram_rxrc_wr_pntr[0];descram_in[1475]<=asb_lane_sync_r3;descram_in[1413]<=asb_data_r1[0];descram_in[1409]<=asb_err_r4;descram_in[1400]<=asb_eidle_rx_sr3;descram_in[1324]<=asb_eidle_rx_16_int[0];descram_in[1200]<=asb_kcntl_32_int[0];descram_in[1199]<=ltssm_eidle_tx_f0[0];descram_in[1074]<=drate_f2;descram_in[1068]<=asb_kcntl_r2[0];descram_in[1047]<=asb_kcntl_16[0];descram_in[1037]<=asb_eidle_rx_r3;descram_in[1023]<=clk_125_tx;descram_in[963]<=drate_enable_del2;descram_in[933]<=scram_rxrc_rd_pntr[0];descram_in[902]<=asb_lane_sync_r4;descram_in[880]<=asb_lane_sync_r1;descram_in[811]<=drate_f6;descram_in[779]<=asb_data_r2[0];descram_in[771]<=asb_eidle_rx_r1;descram_in[752]<=drate_enable_del0;descram_in[745]<=scram_rxrc_wr_en;descram_in[706]<=rate_5g_250;descram_in[704]<=asb_err_r3;descram_in[700]<=asb_eidle_rx_sr2;descram_in[600]<=asb_data_32_int[0];descram_in[440]<=asb_beacon_rx_r4;descram_in[405]<=drate_f5;descram_in[372]<=asb_lane_sync_16;descram_in[353]<=rate_5g_250_r;descram_in[352]<=asb_err_r2;descram_in[350]<=asb_eidle_rx_sr1;descram_in[220]<=asb_beacon_rx_r3;descram_in[202]<=drate_f4;descram_in[186]<=asb_beacon_rx_16;descram_in[176]<=asb_err_r1;descram_in[110]<=asb_beacon_rx_r2;descram_in[101]<=drate_f3;descram_in[93]<=asb_eidle_rx_16;descram_in[88]<=fndisp_8_r[0];descram_in[55]<=asb_beacon_rx_r1;descram_in[46]<=asb_err_16;descram_in[27]<=asb_eidle_rx_r4;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : cfg_up_sm.v


// Description      : This module implements the Config Sub state machine as


//                    described in sec  4.2.6.3 for Up stream Lanes


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module cfg_up_sm #(
   parameter LANE_WIDTH   = 2) (
   input wire                  sys_clk,          
   input wire                  rst_n,            
   input wire [3:0]            main_state,       
   input wire [LANE_WIDTH-1:0] det_lanes,        
   input wire                  hl_disable_scr,   
   input wire                  hl_gto_dis,       
   input wire [LANE_WIDTH-1:0] hl_gto_lbk,       

   input wire                   cnt_done_24ms,   
   input wire                   cnt_done_1ms,    
   input wire                   cnt_done_2ms,    
   input wire                   cnt_done_2us,    
   input wire [LANE_WIDTH-1:0] osd_gto_dis,      
   input wire [LANE_WIDTH-1:0] osd_4t12,         
   input wire [LANE_WIDTH-1:0] osd_2t1_liplap,   
   input wire [LANE_WIDTH-1:0] osd_2t1_lilap,    
   input wire [LANE_WIDTH-1:0] osd_2t1_limla,    
   input wire [LANE_WIDTH-1:0] osd_2t1_limlanm,  
   input wire [LANE_WIDTH-1:0] osd_2t2_limlam,   
   input wire [LANE_WIDTH-1:0] osd_8t2_limlam,   
   input wire [LANE_WIDTH-1:0] osd_2t2,          
   input wire [LANE_WIDTH-1:0] osd_gto_lbk,      
   input wire [LANE_WIDTH-1:0] osd_2t2_dscr,     
   input wire [LANE_WIDTH-1:0] osd_8idle,        
   input wire [LANE_WIDTH-1:0] ose_16t2_t2,      
   input wire [LANE_WIDTH-1:0] ose_16idle_idle,  
   input wire [LANE_WIDTH-1:0] asb_dskew_rx,     

   output reg                  cfg_complete,    
   output reg                  cfg_disable_scr, 
   output reg                  cfg_nfts_updt,   
   output reg [LANE_WIDTH-1:0] cfg_eidle_tx,    
   output reg                  cfg_start_cnt,   
   output reg [LANE_WIDTH-1:0] cfg_snd_os,      
   output reg [3:0]            cfg_snd_ostype,  
   output reg [LANE_WIDTH-1:0] cfg_snd_linu,    
   output reg [LANE_WIDTH-1:0] cfg_snd_lanu,    
   output reg                  cfg_gto_lbk,     
   output reg                  cfg_gto_det,     
   output reg                  cfg_gto_dis,     
   output reg                  cfg_gto_l0,      
   output reg [LANE_WIDTH-1:0] cfg_lanes,       
   output reg [2:0]            cs_cfg_sm        // CFG UP state


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam CFG_WAIT           = 3'd0 ;
localparam CFG_LINK_WIDTH_ST  = 3'd1 ;
localparam CFG_LINK_WIDTH_ACC = 3'd2 ;
localparam CFG_LANE_NUM_WAIT  = 3'd3 ;
localparam CFG_LANE_NUM_ACC   = 3'd4 ;
localparam CFG_COMPLETE       = 3'd5 ;
localparam CFG_IDLE           = 3'd6 ;
localparam CFG_EXIT           = 3'd7 ;
wire [LANE_WIDTH-1:0]  rcvd_gto_lbk;
wire [LANE_WIDTH-1:0]  rcvd_2t1_lilap;
wire [LANE_WIDTH-1:0]  rcvd_2t1_limlanm;
wire [LANE_WIDTH-1:0]  rcvd_2t1_limla;
wire [LANE_WIDTH-1:0]  rcvd_2t2_dscr;
wire [LANE_WIDTH-1:0]  rcvd_2t2;
wire [LANE_WIDTH-1:0]  rcvd_2t2_limlam;
wire [LANE_WIDTH-1:0]  rcvd_8t2_limlam;
wire [LANE_WIDTH-1:0]  rcvd_asb_dskew_rx;
wire [LANE_WIDTH-1:0]  rcvd_8idle;
wire [LANE_WIDTH-1:0]  snt_16idle_idle;
wire [LANE_WIDTH-1:0]  snt_16t2_t2;
reg  [LANE_WIDTH-1:0]   snd_lilanu;
reg                     lnk_possible;
reg [1:0] mod_lanes;
reg [1:0] lane_group;
reg  [LANE_WIDTH-1:0]   store_lnstat;
reg                     store;
reg                     store_d0;
reg                     eval_done;
localparam NON_PAD = {(LANE_WIDTH){1'b1}};
localparam PADD    = {(LANE_WIDTH){1'b0}};
reg [3 : 0] main_state_split;
reg [LANE_WIDTH - 1 : 0] det_lanes_split;
reg hl_disable_scr_split;
reg hl_gto_dis_split;
reg [LANE_WIDTH - 1 : 0] hl_gto_lbk_split;
reg cnt_done_24ms_split;
reg cnt_done_1ms_split;
reg cnt_done_2ms_split;
reg cnt_done_2us_split;
reg [LANE_WIDTH - 1 : 0] osd_gto_dis_split;
reg [LANE_WIDTH - 1 : 0] osd_4t12_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_liplap_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_lilap_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limla_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limlanm_split;
reg [LANE_WIDTH - 1 : 0] osd_2t2_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_8t2_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_2t2_split;
reg [LANE_WIDTH - 1 : 0] osd_gto_lbk_split;
reg [LANE_WIDTH - 1 : 0] osd_2t2_dscr_split;
reg [LANE_WIDTH - 1 : 0] osd_8idle_split;
reg [LANE_WIDTH - 1 : 0] ose_16t2_t2_split;
reg [LANE_WIDTH - 1 : 0] ose_16idle_idle_split;
reg [LANE_WIDTH - 1 : 0] asb_dskew_rx_split;
reg [LANE_WIDTH - 1 : 0] rcvd_gto_lbk_split;
reg [LANE_WIDTH - 1 : 0] rcvd_2t1_lilap_split;
reg [LANE_WIDTH - 1 : 0] rcvd_2t1_limlanm_split;
reg [LANE_WIDTH - 1 : 0] rcvd_2t1_limla_split;
reg [LANE_WIDTH - 1 : 0] rcvd_2t2_dscr_split;
reg [LANE_WIDTH - 1 : 0] rcvd_2t2_split;
reg [LANE_WIDTH - 1 : 0] rcvd_2t2_limlam_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8t2_limlam_split;
reg [LANE_WIDTH - 1 : 0] rcvd_asb_dskew_rx_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8idle_split;
reg [LANE_WIDTH - 1 : 0] snt_16idle_idle_split;
reg [LANE_WIDTH - 1 : 0] snt_16t2_t2_split;
reg [LANE_WIDTH - 1 : 0] snd_lilanu_split;
reg lnk_possible_split;
reg [1 : 0] mod_lanes_split;
reg [1 : 0] lane_group_split;
reg [LANE_WIDTH - 1 : 0] store_lnstat_split;
reg store_split;
reg store_d0_split;
reg eval_done_split;
reg [2047:0] descram_in;
wire [43:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 44,descram_inst_SCRAMSTRING = 32'hfdffd14b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// for cs_cfg_sm
// Define Wire & Registers
//generate
//   if (LANE_WIDTH == 4) begin
//      reg [3:0] mod_lanes;
//      reg [3:0] lane_group;
//   end
//   else if (LANE_WIDTH == 2) begin
      //   end
//   else begin
//      reg mod_lanes;
//      reg lane_group;
//   end
//endgenerate
// =============================================================================
// The following and's the signal with Lanes that were detected during DETECT
// so that the un detected lanes are masked by making the bits zero
// =============================================================================
// This indicate that 2 TS1 ordered sets were received with loopback bit set or
// a higher level is directing a jump to loopback
assign rcvd_gto_lbk     = osd_gto_lbk_split & det_lanes_split;

// This indicate that 2 TS1 ordered sets were received with Link number NON PAD
// lane number set to PAD
assign rcvd_2t1_lilap  = osd_2t1_lilap_split & det_lanes_split;

// This indicate that 2 TS1 ordered sets were received with Link number Matching TX
// lane number set to NON PAD & not Matching
assign rcvd_2t1_limlanm  = osd_2t1_limlanm_split & det_lanes_split;

// This indicate that 2 TS1 ordered sets were received with Link number Matching TX
// lane number set to NON PAD
assign rcvd_2t1_limla   = osd_2t1_limla_split & cfg_lanes;

// This indicate that 8 TS2 ordered sets were received with Link number matching the link
// number being transmitted & lane number matching
assign rcvd_8t2_limlam  = osd_8t2_limlam_split & cfg_lanes;

// This indicate that 2 TS2 ordered sets with link & lane number dont care
assign rcvd_2t2        = osd_2t2_split & det_lanes_split;

// This indicate that 2 TS2 ordered sets were received with Link number matching the link
// number being transmitted & lane number matching
assign rcvd_2t2_limlam  = osd_2t2_limlam_split & cfg_lanes;

// This indicate that Lane to Lane dksew is complete
assign rcvd_asb_dskew_rx= asb_dskew_rx_split & cfg_lanes;

// This indicates that 8 idle are recived
assign rcvd_8idle       = osd_8idle_split & cfg_lanes;

// This indicates that 2 TS2 are recived with disable Scrambling bit set
assign rcvd_2t2_dscr    = osd_2t2_dscr_split & cfg_lanes;

// This indicates that 16 idle are recived after sending one idle
assign snt_16idle_idle  = ose_16idle_idle_split & cfg_lanes;

// This indicates that 16 idle are recived after sending one idle
assign snt_16t2_t2      = ose_16t2_t2_split & cfg_lanes;

// =============================================================================
// The following checks how many lanes receive the Link Num & Lane mum matching
// as transmitted
// This is done by adding the bits in rcvd_2t1_limlap, allowed values are
// In X4 Mode
// SUM      Lanes allowed
// 4        x4
// 2        x2
// 1        x1
// if the result is 3, one of the 2 bits are choosen to form a x2 link
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      lane_group <= 0;
      mod_lanes  <= 0;
   end
   else if (cs_cfg_sm == CFG_LINK_WIDTH_ACC || cs_cfg_sm == CFG_LANE_NUM_ACC) begin
      // Find out how many lanes are available
       //`ifdef LW4
       //lane_group <= store_lnstat[3] + store_lnstat[2] + store_lnstat[1] + store_lnstat[0];
       //`endif

       //`ifdef LW2
       lane_group <= store_lnstat_split[1] + store_lnstat_split[0];
       //`endif

       //`ifdef LW1
       //lane_group <= store_lnstat[0];
       //`endif

      //`ifdef LW4
      // If there are 3 lanes active choose ONLY 2 LANES
      //case(store_lnstat)
      //   4'b0111, 4'b1011 : begin
      //      mod_lanes <= 4'b0011;
      //   end
      //   4'b1101, 4'b1110 : begin
      //      mod_lanes <= 4'b1100;
      //   end
      //   default: begin
      //      mod_lanes <= 4'b0000;
      //   end
      //endcase
      //`endif

      //`ifdef LW2
      // If there are 2 active lanes
            mod_lanes <= store_lnstat_split;
      //`endif

      //`ifdef LW1
      // If there are 1 active lanes
            mod_lanes <= store_lnstat_split;
      //`endif
   end
   else begin
      lane_group <= 0;
      mod_lanes  <= 0;
   end
end

// =============================================================================
// The following implements the Config SM as described in section 4.2.6.3 of the
// PCI Express Spec 1.0a.
// The allowed links that can be formed are
// In a X4 Link
// 4 x Lanes i.e 4'b1111 or
// 1 x Lane  i.e 4'bxxx1 or 4'bxx1x or 4'bx1xx or 4'b1xxx
//
// The following describes the signal encoding for received signals
// TS1 --- Link number PAD             --- Lane number PAD             --> osd_2t1_liplap
// TS1 --- Link number non PAD         --- Lane number PAD             --> osd_2t1_lilap
// TS1 --- Link number matching tx     --- Lane number PAD             --> osd_2t1_limlap
// TS1 --- Link number not matching tx --- Lane number PAD             --> osd_2t1_linmlap
// TS1 --- Link number matching tx     --- Lane number matching tx     --> osd_2t1_limlam
// TS1 --- Link number matching tx     --- Lane number non PAD         --> osd_2t1_limla
// TS1 --- Link number matching tx     --- Lane number not matching tx --> osd_2t1_limlanm
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_cfg_sm      <= CFG_WAIT;
      cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
      cfg_snd_ostype <= OS_IDLE;
      cfg_snd_linu   <= PADD;
      cfg_snd_lanu   <= PADD;
      snd_lilanu     <= PADD;
      cfg_lanes      <= {(LANE_WIDTH){1'b0}};
      cfg_start_cnt  <= 1'b0;
      lnk_possible   <= 1'b0;
      cfg_gto_dis    <= 1'b0;
      cfg_gto_lbk    <= 1'b0;
      cfg_gto_det    <= 1'b0;
      cfg_gto_l0     <= 1'b0;
      cfg_eidle_tx   <= {(LANE_WIDTH){1'b0}};
      store_lnstat   <= {(LANE_WIDTH){1'b0}};
      cfg_nfts_updt  <= 1'b0;
      cfg_complete   <= 0;
      cfg_disable_scr<= 0;
      store          <= 1'b0;
      store_d0       <= 1'b0;
      eval_done      <= 1'b0;
   end
   else begin
      cfg_gto_dis    <= 1'b0;
      cfg_gto_lbk    <= 1'b0;
      cfg_gto_det    <= 1'b0;
      cfg_gto_l0     <= 1'b0;
      cfg_start_cnt  <= 1'b0;
      cfg_nfts_updt  <= 1'b0;
      cfg_disable_scr<= 0;
      store          <= 1'b0;
      store_d0       <= 1'b0;
      eval_done      <= 1'b0;
      case(cs_cfg_sm)
         // Wait for Main SM to go to CFG
         // Up stream Lane send selected Link Number as PAD
         // and Lane number as PAD
         CFG_WAIT: begin
            cfg_complete   <= 0;
            if (main_state_split == CONFIG) begin
               cs_cfg_sm     <= CFG_LINK_WIDTH_ST;
               cfg_snd_os    <= det_lanes_split;
               cfg_snd_ostype<= OS_T1;
               cfg_snd_linu  <= PADD;
               cfg_snd_lanu  <= PADD;
               cfg_start_cnt <= 1'b1;
               cfg_eidle_tx  <= ~det_lanes_split;
            end
            else begin
               cs_cfg_sm     <= CFG_WAIT;
               cfg_eidle_tx  <= 0;
            end
         end
         // Wait until Link numbers match TX link mumbers and lane is PAD
         CFG_LINK_WIDTH_ST: begin
            // Clear before evaluating the link width
            store_lnstat      <= 0;
            lnk_possible      <= 1'b0;
            if (hl_gto_dis_split == 1'b0 && |osd_gto_dis_split== 1'b1 && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_dis    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else if ((|hl_gto_lbk_split == 1'b1 || rcvd_gto_lbk_split == det_lanes_split) && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_lbk    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            //else if (|osd_2t1_lilap  && ~cfg_start_cnt) begin
            //   if (osd_2t1_lilap == det_lanes | cnt_done_2us) begin
            else if ((|osd_2t1_lilap_split || cnt_done_2us_split)  && ~cfg_start_cnt) begin
                  cs_cfg_sm     <= CFG_LINK_WIDTH_ACC;
                  cfg_snd_os    <= rcvd_2t1_lilap_split;
                  cfg_snd_ostype<= OS_T1;
                  cfg_snd_linu  <= NON_PAD;
                  cfg_snd_lanu  <= PADD;
                  cfg_start_cnt <= 1'b1;
            //   end
            end
            else if (cnt_done_24ms_split && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_det    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_cfg_sm      <= CFG_LINK_WIDTH_ST;
            end
         end
         // Send non PAD Lane numbers
         CFG_LINK_WIDTH_ACC: begin
           // Wait for 2us or any time data is received on all lanes
           //if ((osd_2t1_lilap == det_lanes | cnt_done_2us)  && ~cfg_start_cnt) begin
           //if (|osd_2t1_lilap  && ~cfg_start_cnt) begin
           //    if (osd_2t1_lilap == det_lanes | cnt_done_2us) begin
           if ((|osd_2t1_lilap_split || cnt_done_2us_split)  && ~cfg_start_cnt) begin
                     if(rcvd_2t1_lilap_split == 2'b11)      // X2
                        store_lnstat  <= 2'b11;
                     else                             // Downgrade to X1
                        store_lnstat  <= 2'b10;
                  store         <= 1'b1;
            end
            store_d0  <= store_split;
            eval_done <= store_d0_split;

             // X2 Mode
//            `ifdef LW2
            case(lane_group_split)
               2'd2: begin
                  snd_lilanu    <= {(LANE_WIDTH){1'b1}};
                  cfg_lanes     <= {(LANE_WIDTH){1'b1}};
                  lnk_possible  <= 1'b1;
               end
               2'd1: begin
                  snd_lilanu    <= store_lnstat_split;
                  cfg_lanes     <= store_lnstat_split;
                  lnk_possible  <= 1'b1;
               end
               default: begin
                  lnk_possible  <= 1'b0;
               end
            endcase
//            `endif
            if ((lnk_possible_split && eval_done_split) && (osd_2t1_limla_split & snd_lilanu_split) == snd_lilanu_split && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_LANE_NUM_WAIT;
               cfg_snd_linu   <= snd_lilanu_split;
               cfg_snd_lanu   <= snd_lilanu_split;
               cfg_start_cnt  <= 1'b1;
            end
            //--else if ((cnt_done_2ms || osd_2t1_liplap =={(LANE_WIDTH){1'b1}}) && ~cfg_start_cnt || (!lnk_possible && eval_done)) begin
            else if ((cnt_done_2ms_split || osd_2t1_liplap_split == det_lanes_split) && ~cfg_start_cnt || (!lnk_possible_split && eval_done_split)) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_det    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_cfg_sm      <= CFG_LINK_WIDTH_ACC;
            end
         end
         // Wait until recived Link matching & Lane Not Maching/Matching
         // Note: Optional Lane reversal not supported
         CFG_LANE_NUM_WAIT: begin
            // Clear before evaluating the link width
            store_lnstat      <= 0;
            lnk_possible      <= 1'b0;
            //--if ((osd_2t1_liplap =={(LANE_WIDTH){1'b1}} || cnt_done_2ms) && ~cfg_start_cnt) begin
            if ((osd_2t1_liplap_split == det_lanes_split || cnt_done_2ms_split) && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_det    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            // Store lane status only when osd_2t1_limla is received
            else if (|osd_2t1_limla_split == 1'b1 && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_LANE_NUM_ACC;
               cfg_start_cnt  <= 1'b1;
            end
            else if (|rcvd_2t2_split == 1'b1 && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_LANE_NUM_ACC;
               cfg_start_cnt  <= 1'b1;
            end
            else begin
               cs_cfg_sm      <= CFG_LANE_NUM_WAIT;
            end
         end
         // Accept the lane number
         CFG_LANE_NUM_ACC: begin
	   // Wait for 2us or any time data is received on all lanes
           //if ((osd_2t1_limla == cfg_lanes | cnt_done_2us)  && ~cfg_start_cnt) begin
           if (|osd_2t1_limla_split  && ~cfg_start_cnt) begin
               if (osd_2t1_limla_split == cfg_lanes | cnt_done_2us_split) begin
                  store_lnstat  <= rcvd_2t1_limla_split;
                  store         <= 1'b1;
               end
            end
            store_d0  <= store_split;
            eval_done <= store_d0_split;
            // X2 Mode
//            `ifdef LW2
            case(lane_group_split)
               2'd2: begin
                  cfg_snd_linu  <= {(LANE_WIDTH){1'b1}};
                  cfg_snd_lanu  <= {(LANE_WIDTH){1'b1}};
                  lnk_possible  <= 1'b1;
               end
               2'd1: begin
                  cfg_snd_linu  <= store_lnstat_split;
                  cfg_snd_lanu  <= store_lnstat_split;
                  lnk_possible  <= 1'b1;
               end
               default: begin
                  lnk_possible  <= 1'b0;
               end
            endcase
//            `endif
            // All Lanes
            if (rcvd_2t2_limlam_split == cfg_lanes && (lnk_possible_split && eval_done_split) && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_COMPLETE;
               cfg_snd_os     <= cfg_lanes;
               cfg_snd_ostype <= OS_T2;
               cfg_start_cnt  <= 1'b1;
               cfg_eidle_tx   <= ~cfg_lanes;
               cfg_complete   <= 1'b1;
            end
            // Subset lanes
            else if (|rcvd_2t1_limlanm_split && (lnk_possible_split && eval_done_split) && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_LANE_NUM_WAIT;
               cfg_snd_os     <= det_lanes_split;
               cfg_snd_ostype <= OS_T1;
               cfg_start_cnt  <= 1'b1;
               cfg_lanes      <= cfg_snd_lanu;
            end
            //--else if (osd_2t1_liplap =={(LANE_WIDTH){1'b1}} && ~cfg_start_cnt || (!lnk_possible && eval_done)) begin
            else if (osd_2t1_liplap_split == det_lanes_split && ~cfg_start_cnt || (!lnk_possible_split && eval_done_split)) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_det    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else if (cnt_done_1ms_split && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_det    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_cfg_sm      <= CFG_LANE_NUM_ACC;
            end
         end
         // Wait unitl TS2 are recived with same link & lane numbers that were transmitted
         CFG_COMPLETE: begin
            cfg_disable_scr <= ((rcvd_2t2_dscr_split == cfg_lanes) || hl_disable_scr_split) ? 1'b1: 1'b0;
            if (rcvd_8t2_limlam_split == cfg_lanes  && snt_16t2_t2_split == cfg_lanes && rcvd_asb_dskew_rx_split == cfg_lanes && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_IDLE;
               cfg_snd_os     <= cfg_lanes;
               cfg_snd_ostype <= OS_IDLE;
               cfg_start_cnt  <= 1'b1;
               cfg_nfts_updt  <= 1'b1;
            end
            else if (cnt_done_2ms_split && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_det    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
               cfg_nfts_updt  <= 1'b1;
            end
            else begin
               cs_cfg_sm      <= CFG_COMPLETE;
            end
         end
         // Send Idle & Wait until IDLE are recived IDLE
         CFG_IDLE: begin
            if (rcvd_8idle_split == cfg_lanes  && snt_16idle_idle_split == cfg_lanes && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_l0     <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else if (cnt_done_2ms_split && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_det    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_cfg_sm      <= CFG_IDLE;
            end
         end
         // Wait for Main SM to go out of RECOVERY
         CFG_EXIT: begin
            cfg_complete   <= 1'b0;
            if (main_state_split != CONFIG) begin
               cs_cfg_sm   <= CFG_WAIT;
            end
            else begin
               cs_cfg_sm   <= CFG_EXIT;
            end
         end
         default: begin
            cs_cfg_sm   <= CFG_WAIT;
         end
      endcase
   end
end

always@* begin main_state_split<={main_state>>1,descram_out[0]};det_lanes_split<={det_lanes>>1,descram_out[1]};hl_disable_scr_split<=descram_out[2];hl_gto_dis_split<=descram_out[3];hl_gto_lbk_split<={hl_gto_lbk>>1,descram_out[4]};cnt_done_24ms_split<=descram_out[5];cnt_done_1ms_split<=descram_out[6];cnt_done_2ms_split<=descram_out[7];cnt_done_2us_split<=descram_out[8];osd_gto_dis_split<={osd_gto_dis>>1,descram_out[9]};osd_4t12_split<={osd_4t12>>1,descram_out[10]};osd_2t1_liplap_split<={osd_2t1_liplap>>1,descram_out[11]};osd_2t1_lilap_split<={osd_2t1_lilap>>1,descram_out[12]};osd_2t1_limla_split<={osd_2t1_limla>>1,descram_out[13]};osd_2t1_limlanm_split<={osd_2t1_limlanm>>1,descram_out[14]};osd_2t2_limlam_split<={osd_2t2_limlam>>1,descram_out[15]};osd_8t2_limlam_split<={osd_8t2_limlam>>1,descram_out[16]};osd_2t2_split<={osd_2t2>>1,descram_out[17]};osd_gto_lbk_split<={osd_gto_lbk>>1,descram_out[18]};osd_2t2_dscr_split<={osd_2t2_dscr>>1,descram_out[19]};osd_8idle_split<={osd_8idle>>1,descram_out[20]};ose_16t2_t2_split<={ose_16t2_t2>>1,descram_out[21]};ose_16idle_idle_split<={ose_16idle_idle>>1,descram_out[22]};asb_dskew_rx_split<={asb_dskew_rx>>1,descram_out[23]};rcvd_gto_lbk_split<={rcvd_gto_lbk>>1,descram_out[24]};rcvd_2t1_lilap_split<={rcvd_2t1_lilap>>1,descram_out[25]};rcvd_2t1_limlanm_split<={rcvd_2t1_limlanm>>1,descram_out[26]};rcvd_2t1_limla_split<={rcvd_2t1_limla>>1,descram_out[27]};rcvd_2t2_dscr_split<={rcvd_2t2_dscr>>1,descram_out[28]};rcvd_2t2_split<={rcvd_2t2>>1,descram_out[29]};rcvd_2t2_limlam_split<={rcvd_2t2_limlam>>1,descram_out[30]};rcvd_8t2_limlam_split<={rcvd_8t2_limlam>>1,descram_out[31]};rcvd_asb_dskew_rx_split<={rcvd_asb_dskew_rx>>1,descram_out[32]};rcvd_8idle_split<={rcvd_8idle>>1,descram_out[33]};snt_16idle_idle_split<={snt_16idle_idle>>1,descram_out[34]};snt_16t2_t2_split<={snt_16t2_t2>>1,descram_out[35]};snd_lilanu_split<={snd_lilanu>>1,descram_out[36]};lnk_possible_split<=descram_out[37];mod_lanes_split<={mod_lanes>>1,descram_out[38]};lane_group_split<={lane_group>>1,descram_out[39]};store_lnstat_split<={store_lnstat>>1,descram_out[40]};store_split<=descram_out[41];store_d0_split<=descram_out[42];eval_done_split<=descram_out[43];end
always@* begin descram_in[2047]<=det_lanes[0];descram_in[2046]<=hl_disable_scr;descram_in[2044]<=hl_gto_dis;descram_in[2040]<=hl_gto_lbk[0];descram_in[2033]<=cnt_done_24ms;descram_in[2019]<=cnt_done_1ms;descram_in[1994]<=store_d0;descram_in[1990]<=cnt_done_2ms;descram_in[1981]<=rcvd_2t1_limla[0];descram_in[1965]<=rcvd_asb_dskew_rx[0];descram_in[1940]<=eval_done;descram_in[1939]<=osd_gto_lbk[0];descram_in[1933]<=cnt_done_2us;descram_in[1914]<=rcvd_2t2_dscr[0];descram_in[1883]<=rcvd_8idle[0];descram_in[1831]<=osd_2t2_dscr[0];descram_in[1819]<=osd_gto_dis[0];descram_in[1785]<=lane_group[0];descram_in[1781]<=rcvd_2t2[0];descram_in[1778]<=osd_2t2_limlam[0];descram_in[1719]<=snt_16idle_idle[0];descram_in[1615]<=osd_8idle[0];descram_in[1591]<=osd_4t12[0];descram_in[1522]<=store_lnstat[0];descram_in[1515]<=rcvd_2t2_limlam[0];descram_in[1508]<=osd_8t2_limlam[0];descram_in[1470]<=lnk_possible;descram_in[1391]<=snt_16t2_t2[0];descram_in[1271]<=rcvd_gto_lbk[0];descram_in[1182]<=ose_16t2_t2[0];descram_in[1135]<=osd_2t1_liplap[0];descram_in[1023]<=main_state[0];descram_in[997]<=store;descram_in[990]<=rcvd_2t1_limlanm[0];descram_in[982]<=rcvd_8t2_limlam[0];descram_in[969]<=osd_2t2[0];descram_in[892]<=mod_lanes[0];descram_in[889]<=osd_2t1_limlanm[0];descram_in[735]<=snd_lilanu[0];descram_in[635]<=asb_dskew_rx[0];descram_in[495]<=rcvd_2t1_lilap[0];descram_in[444]<=osd_2t1_limla[0];descram_in[317]<=ose_16idle_idle[0];descram_in[222]<=osd_2t1_lilap[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.18 2007/01/29 16:54:36PST rperugu


// 2us counter logic changed : check after receiving on ANY lane.


// Revision 1.17 2007/01/17 12:09:12PST gkrishna


// Added cnt_done_2us. This is added to


// 1) In the CFG states, if the lane to lane dskew can be MAX of 20 ns.


// 2) This counter stops qualifying the signals in CFG state for max of 2us or if all the signals are received


// 3) If this DE-SKEW is not performed the lanes may be falsley downgraded.


// Revision 1.16 2006/08/29 16:59:15PDT rperugu


// SYNCING WITH HARD LTSSM MACO RTL.


//


//  Revision: 1.3 Mon Aug 14 18:55:58 2006 uananthi


//  Updated to 1.1/1.0a, rst polarity change, 5G unused I/Os removed.


// Revision 1.15 2006/05/02 08:47:25PDT gkrishna


// Updated after LINT checks


// Revision 1.14 2006/04/28 14:51:00PDT uananthi


// updated.


// Revision 1.13 2006/04/28 11:59:55PDT uananthi


// `defines changed to parametrs.


// Revision 1.12 2006/04/26 11:47:05PDT gkrishna


// typo


// Revision 1.11 2006/04/25 15:31:10PDT gkrishna


// Added  ~cfg_start_cnt to osd_4t1


// Revision 1.10 2006/04/25 14:53:26PDT gkrishna


// Updated eval generation


// Revision 1.9 2006/04/25 13:10:55PDT gkrishna


// Updated store lane stat clearing  before evaluting the link width


// Revision 1.8 2006/04/24 13:55:51PDT gkrishna


// Changed osd_4t1 to osd_4t12


// Revision 1.7 2006/04/21 16:36:13PDT gkrishna


// Added DELAYED Evaluation of state during LANE/LANE NUM WAIT states


// Revision 1.6 2006/04/07 12:15:58PDT gkrishna


// Added beacon IDL (5 1's 5 0's ) transmit logic


// Revision 1.5 2006/04/05 13:16:03PDT gkrishna


// Fixed typo on LW2 to LW4


// Revision 1.4 2006/03/30 10:36:00PST srajadur


// Store lane status only when osd_2t1_limla is received


// Revision 1.3 2006/02/02 10:26:27PST gkrishna


// Removed unused pins Cleaned up synthesis warnings, removed unused i/o's reg's, wires.


// Revision 1.2 2006/01/30 14:46:06PST gkrishna


// Changed with of hl_gto_lbk to LANE_WIDTH


// Revision 1.1 2006/01/26 15:54:58PST uananthi


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.1 2006/01/25 14:14:45PST gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.1.1.4 2005/03/14 09:25:44PST gkrishna


// Added _start_cnt for PnR


// Revision 1.3 2005/03/14 08:44:16PST gkrishna


// Added cfg_start_cnt signal


// Revision 1.2 2005/02/28 14:15:38PST gkrishna


// Added cfg_complete


// Revision 1.1.1.2 2004/09/02 12:12:54PDT uananthi


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// Revision 1.16 2004/08/03 10:37:32PDT gkrishna


// Added hl_disable_scr


// Revision 1.15 2004/08/03 10:15:24PDT gkrishna


// Added cfg_disable_scr


// Revision 1.14 2004/07/30 17:40:30PDT gkrishna


// Fixed width


// Revision 1.13 2004/07/01 13:23:02PDT gkrishna


// Cleared eidle_tx


// Revision 1.12 2004/06/30 17:47:03PDT gkrishna


// Added cfg_nfts_updt.


// Revision 1.11 2004/05/26 13:03:34PDT gkrishna


// Added osd_2t1_limlanm


// Revision 1.10 2004/05/25 11:06:46PDT gkrishna


// Fixed osdec signal generation.


// Revision 1.9 2004/05/12 13:32:12PDT gkrishna


// Ficed up Up stream lanes.


// Revision 1.8 2004/05/07 15:34:01PDT gkrishna


// cleared cfg_snd_os .


// Revision 1.7 2004/05/07 12:09:53PDT gkrishna


// Fixed osd_det signal


// Revision 1.6 2004/04/01 10:08:22PST gkrishna


// Added wire decleartion


// Revision 1.5 2004/03/29 12:04:17PST gkrishna


// Added eidle generation signal.


// Revision 1.4 2004/03/26 15:13:50PST gkrishna


// Updated after block sim


// Revision 1.3 2004/03/23 15:58:49PST gkrishna


// Fixed typo.


// Revision 1.2 2004/03/11 17:41:19PST gkrishna


// Upadated comments & signal names.


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : cfg_dn_sm.v


// Description      : This module implements the Config Sub state machine as


//                    described in sec  4.2.6.3 for Down stream Lanes


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module cfg_dn_sm #(
   parameter LANE_WIDTH   = 2) (
   input wire                  sys_clk,         
   input wire                  rst_n,           
   input wire [3:0]            main_state,      
   input wire [LANE_WIDTH-1:0] det_lanes,       
   input wire                  hl_disable_scr,  
   input wire                  hl_gto_dis,      
   input wire [LANE_WIDTH-1:0] hl_gto_lbk,      

   input wire                  cnt_done_24ms,   
   input wire                  cnt_done_2ms,    
   input wire                  cnt_done_2us,    
   input wire [LANE_WIDTH-1:0] osd_4t12,        
   input wire [LANE_WIDTH-1:0] osd_2t1_liplap,  
   input wire [LANE_WIDTH-1:0] osd_2t1_limlap,  
   input wire [LANE_WIDTH-1:0] osd_2t1_limla,   
   input wire [LANE_WIDTH-1:0] osd_2t1_limlanm, 
   input wire [LANE_WIDTH-1:0] osd_2t1_limlam,  
   input wire [LANE_WIDTH-1:0] osd_8t2_limlam,   
   input wire [LANE_WIDTH-1:0] osd_gto_lbk,     
   input wire [LANE_WIDTH-1:0] osd_2t2_dscr,    
   input wire [LANE_WIDTH-1:0] osd_8idle,       
   input wire [LANE_WIDTH-1:0] ose_16t2_t2,     
   input wire [LANE_WIDTH-1:0] ose_16idle_idle, 
   input wire [LANE_WIDTH-1:0] asb_dskew_rx,    

   output reg                  cfg_complete,    
   output reg                  cfg_disable_scr, 
   output reg                  cfg_nfts_updt,   
   output reg [LANE_WIDTH-1:0] cfg_eidle_tx,    
   output reg                  cfg_start_cnt,   
   output reg [LANE_WIDTH-1:0] cfg_snd_os,      
   output reg [3:0]            cfg_snd_ostype,  
   output reg [LANE_WIDTH-1:0] cfg_snd_linu,    
   output reg [LANE_WIDTH-1:0] cfg_snd_lanu,    
   output reg                  cfg_gto_lbk,     
   output reg                  cfg_gto_det,     
   output reg                  cfg_gto_dis,     
   output reg                  cfg_gto_l0,      
   output reg [LANE_WIDTH-1:0] cfg_lanes,       
   output reg [2:0]            cs_cfg_sm        // CFG UP state


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam CFG_WAIT           = 3'd0 ;
localparam CFG_LINK_WIDTH_ST  = 3'd1 ;
localparam CFG_LINK_WIDTH_ACC = 3'd2 ;
localparam CFG_LANE_NUM_WAIT  = 3'd3 ;
localparam CFG_LANE_NUM_ACC   = 3'd4 ;
localparam CFG_COMPLETE       = 3'd5 ;
localparam CFG_IDLE           = 3'd6 ;
localparam CFG_EXIT           = 3'd7 ;
wire [LANE_WIDTH-1:0]   rcvd_gto_lbk;
wire [LANE_WIDTH-1:0]   rcvd_2t1_limlap;
wire [LANE_WIDTH-1:0]   rcvd_2t1_limlanm;
wire [LANE_WIDTH-1:0]   rcvd_2t1_limlam;
wire [LANE_WIDTH-1:0]   rcvd_2t1_limla;
wire [LANE_WIDTH-1:0]   rcvd_2t2_dcsr;
wire [LANE_WIDTH-1:0]   rcvd_8t2_limlam;
wire [LANE_WIDTH-1:0]   rcvd_2t2_dscr;
wire [LANE_WIDTH-1:0]   rcvd_asb_dskew_rx;
wire [LANE_WIDTH-1:0]   rcvd_8idle;
wire [LANE_WIDTH-1:0]   snt_16idle_idle;
wire [LANE_WIDTH-1:0]   snt_16t2_t2;
reg                     lnk_possible;
reg [1:0] mod_lanes;
reg [1:0] lane_group;
reg  [LANE_WIDTH-1:0]   store_lnstat;
reg                     store;
reg                     store_d0;
reg                     eval_done;
localparam NON_PAD= {(LANE_WIDTH){1'b1}};
localparam PADD   = {(LANE_WIDTH){1'b0}};
reg [3 : 0] main_state_split;
reg [LANE_WIDTH - 1 : 0] det_lanes_split;
reg hl_disable_scr_split;
reg hl_gto_dis_split;
reg [LANE_WIDTH - 1 : 0] hl_gto_lbk_split;
reg cnt_done_24ms_split;
reg cnt_done_2ms_split;
reg cnt_done_2us_split;
reg [LANE_WIDTH - 1 : 0] osd_4t12_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_liplap_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limlap_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limla_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limlanm_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_8t2_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_gto_lbk_split;
reg [LANE_WIDTH - 1 : 0] osd_2t2_dscr_split;
reg [LANE_WIDTH - 1 : 0] osd_8idle_split;
reg [LANE_WIDTH - 1 : 0] ose_16t2_t2_split;
reg [LANE_WIDTH - 1 : 0] ose_16idle_idle_split;
reg [LANE_WIDTH - 1 : 0] asb_dskew_rx_split;
reg [LANE_WIDTH - 1 : 0] rcvd_gto_lbk_split;
reg [LANE_WIDTH - 1 : 0] rcvd_2t1_limlap_split;
reg [LANE_WIDTH - 1 : 0] rcvd_2t1_limlanm_split;
reg [LANE_WIDTH - 1 : 0] rcvd_2t1_limlam_split;
reg [LANE_WIDTH - 1 : 0] rcvd_2t1_limla_split;
reg [LANE_WIDTH - 1 : 0] rcvd_2t2_dcsr_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8t2_limlam_split;
reg [LANE_WIDTH - 1 : 0] rcvd_2t2_dscr_split;
reg [LANE_WIDTH - 1 : 0] rcvd_asb_dskew_rx_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8idle_split;
reg [LANE_WIDTH - 1 : 0] snt_16idle_idle_split;
reg [LANE_WIDTH - 1 : 0] snt_16t2_t2_split;
reg lnk_possible_split;
reg [1 : 0] mod_lanes_split;
reg [1 : 0] lane_group_split;
reg [LANE_WIDTH - 1 : 0] store_lnstat_split;
reg store_split;
reg store_d0_split;
reg eval_done_split;
reg [2047:0] descram_in;
wire [39:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 40,descram_inst_SCRAMSTRING = 32'hfdffe0cb;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// for cs_cfg_sm
// Define all inputs / outputs
//generate
//   if (LANE_WIDTH == 4) begin
//      reg [3:0] mod_lanes;
//      reg [3:0] lane_group;
//   end
//   else if (LANE_WIDTH == 2) begin
      //   end
//   else begin
//      reg mod_lanes;
//      reg lane_group;
//   end
//endgenerate

// =============================================================================
// The following and's the signal with Lanes that were detected during DETECT
// so that the un detected lanes are masked by making the bits zero
// =============================================================================
// This indicate that 2 TS1 ordered sets were received with loopback bit set or
// a higher level is directing a jump to loopback
assign rcvd_gto_lbk     = osd_gto_lbk_split & det_lanes_split;

// This indicate that 2 TS1 ordered sets were received with Link number matching the link
// number being transmitted & lane number set to PAD
assign rcvd_2t1_limlap  = osd_2t1_limlap_split & det_lanes_split;

// This indicate that 2 TS1 ordered sets were received with Link number matching the link
// number being transmitted & lane number NOT Pad & Not Matching
assign rcvd_2t1_limlanm = osd_2t1_limlanm_split & det_lanes_split;

// This indicate that 2 TS1 ordered sets were received with Link number matching the link
// number being transmitted & lane number matching
assign rcvd_2t1_limlam  = osd_2t1_limlam_split & det_lanes_split;
assign rcvd_2t1_limla   = osd_2t1_limla_split & det_lanes_split;

// This indicate that 8 TS2 ordered sets were received with Link number matching the link
// number being transmitted & lane number matching
assign rcvd_8t2_limlam  = osd_8t2_limlam_split & cfg_lanes;

// This indicate that Lane to Lane dksew is complete
assign rcvd_asb_dskew_rx= asb_dskew_rx_split & cfg_lanes;

// This indicates that 8 idle are recived
assign rcvd_8idle       = osd_8idle_split & cfg_lanes;

// This indicates that 2 TS2 are recived with disable Scrambling bit set
assign rcvd_2t2_dscr    = osd_2t2_dscr_split & cfg_lanes;

// This indicates that 16 idle are recived after sending one idle
assign snt_16idle_idle  = ose_16idle_idle_split & cfg_lanes;

// This indicates that 16 idle are recived after sending one idle
assign snt_16t2_t2      = ose_16t2_t2_split & cfg_lanes;

// =============================================================================
// The following checks how many lanes receive the Link Num & Lane mum matching
// as transmitted
// This is done by adding the bits in rcvd_2t1_limla, allowed values are
// In X4 Mode
// SUM      Lanes allowed
// 4        x4
// 2        x2
// 1        x1
// if the result is 3, one of the 2 bits are choosen to form a x2 link
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      lane_group <= 0;
      mod_lanes  <= 0;
   end
   else if (cs_cfg_sm == CFG_LINK_WIDTH_ACC || cs_cfg_sm == CFG_LANE_NUM_ACC) begin
      // Find out how many lanes are available
      //`ifdef LW4
      //lane_group <= store_lnstat[3] + store_lnstat[2] + store_lnstat[1] + store_lnstat[0];
      //`endif

      //`ifdef LW2
      lane_group <= store_lnstat_split[1] + store_lnstat_split[0];
      //`endif

      //`ifdef LW1
      //lane_group <= store_lnstat[0];
      //`endif

      //`ifdef LW4
      // If there are 3 lanes active choose ONLY 2 LANES
      //case(store_lnstat)
      //   4'b0111, 4'b1011 : begin
      //      mod_lanes <= 4'b0011;
      //   end
      //   4'b1101, 4'b1110 : begin
      //      mod_lanes <= 4'b1100;
      //   end
      //   default: begin
      //      mod_lanes <= 4'b0000;
      //   end
      //endcase
      //`endif

      //`ifdef LW2
      // If there are 2 active lanes
            mod_lanes <= store_lnstat_split;
      //`endif

      //`ifdef LW1
      // If there are 1 active lanes
      //      mod_lanes <= store_lnstat;
      //`endif
   end
   else begin
      lane_group <= 0;
      mod_lanes  <= 0;
   end
end

// =============================================================================
// The following implements the Config SM as described in section 4.2.6.3 of the
// PCI Express Spec 1.0a.
// The allowed links that can be formed are
// In a X4 Link
// 4 x Lanes i.e 4'b1111 or
// 1 x Lane  i.e 4'bxxx1 or 4'bxx1x or 4'bx1xx or 4'b1xxx
//
// The following describes the signal encoding for received signals
// TS1 --- Link number PAD             --- Lane number PAD             --> osd_2t1_liplap
// TS1 --- Link number non PAD         --- Lane number PAD             --> osd_2t1_lilap
// TS1 --- Link number matching tx     --- Lane number PAD             --> osd_2t1_limlap
// TS1 --- Link number not matching tx --- Lane number PAD             --> osd_2t1_linmlap
// TS1 --- Link number matching tx     --- Lane number matching tx     --> osd_2t1_limlam
// TS1 --- Link number matching tx     --- Lane number non PAD         --> osd_2t1_limla
// TS1 --- Link number matching tx     --- Lane number not matching tx --> osd_2t1_limlanm
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_cfg_sm      <= CFG_WAIT;
      cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
      cfg_snd_ostype <= OS_IDLE;
      cfg_snd_linu   <= PADD;
      cfg_snd_lanu   <= PADD;
      cfg_lanes      <= {(LANE_WIDTH){1'b0}};
      cfg_start_cnt  <= 1'b0;
      lnk_possible   <= 1'b0;
      cfg_gto_dis    <= 1'b0;
      cfg_gto_lbk    <= 1'b0;
      cfg_gto_det    <= 1'b0;
      cfg_gto_l0     <= 1'b0;
      cfg_eidle_tx   <= {(LANE_WIDTH){1'b0}};
      store_lnstat   <= {(LANE_WIDTH){1'b0}};
      cfg_nfts_updt  <= 1'b0;
      cfg_complete   <= 0;
      cfg_disable_scr<= 0;
      store          <= 1'b0;
      store_d0       <= 1'b0;
      eval_done      <= 1'b0;
   end
   else begin
      cfg_gto_dis    <= 1'b0;
      cfg_gto_lbk    <= 1'b0;
      cfg_gto_det    <= 1'b0;
      cfg_gto_l0     <= 1'b0;
      cfg_start_cnt  <= 1'b0;
      cfg_nfts_updt  <= 1'b0;
      cfg_disable_scr<= 0;
      store          <= 1'b0;
      store_d0       <= 1'b0;
      eval_done      <= 1'b0;
      case(cs_cfg_sm)
         // Wait for Main SM to go to CFG
         // If Down stream Lane send selected Link Number
         // and send PAD in lane number
         CFG_WAIT: begin
            cfg_complete     <= 0;
            if (main_state_split == CONFIG) begin
               cs_cfg_sm     <= CFG_LINK_WIDTH_ST;
               cfg_snd_os    <= det_lanes_split;
               cfg_snd_ostype<= OS_T1;
               cfg_snd_linu  <= NON_PAD;
               cfg_snd_lanu  <= PADD;
               cfg_start_cnt <= 1'b1;
               cfg_eidle_tx  <= ~det_lanes_split;
            end
            else begin
               cs_cfg_sm     <= CFG_WAIT;
               cfg_eidle_tx  <= 0;
            end
         end
         // Wait until Link numbers match TX link mumbers and lane is PAD
         CFG_LINK_WIDTH_ST: begin
            // Clear before evaluating the link width
            store_lnstat      <= 0;
            lnk_possible      <= 1'b0;
            if (hl_gto_dis_split && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_dis    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else if ((|hl_gto_lbk_split == 1'b1 || rcvd_gto_lbk_split == det_lanes_split) && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_lbk    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else if (|rcvd_2t1_limlap_split == 1'b1 && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_LINK_WIDTH_ACC;
               cfg_snd_os     <= det_lanes_split;
               cfg_snd_ostype <= OS_T1;
               cfg_snd_linu   <= NON_PAD;
               cfg_snd_lanu   <= NON_PAD;
               cfg_start_cnt  <= 1'b1;
            end
            else if (cnt_done_24ms_split && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_det    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_cfg_sm      <= CFG_LINK_WIDTH_ST;
            end
         end
         // Send non PAD Lane numbers
         CFG_LINK_WIDTH_ACC: begin
            // Wait for 2us or any time data is received on all lanes
	    //if ((osd_2t1_limlap == det_lanes | cnt_done_2us)  && ~cfg_start_cnt) begin
	    if (|osd_2t1_limlap_split && ~cfg_start_cnt) begin
	       if (osd_2t1_limlap_split == det_lanes_split | cnt_done_2us_split) begin
                  //`ifdef LW4
                     if(rcvd_2t1_limlap_split == 2'b11)      // X2
                        store_lnstat  <= 2'b11;
                     else                             // Downgrade to X1
                        store_lnstat  <= 2'b10;
                  //   store_lnstat  <= rcvd_2t1_limlap;
                  //`endif
                  store         <= 1'b1;
               end
            end
            store_d0  <= store_split;
            eval_done <= store_d0_split;

            // X4 Mode
/*
            `ifdef LW4
            case(lane_group)
               4'd4: begin
                  cfg_snd_linu  <= {(LANE_WIDTH){1'b1}};
                  cfg_snd_lanu  <= {(LANE_WIDTH){1'b1}};
                  cfg_lanes     <= {(LANE_WIDTH){1'b1}};
                  lnk_possible  <= 1'b1;
               end
               4'd1,4'd2: begin
                  cfg_snd_linu  <= store_lnstat;
                  cfg_snd_lanu  <= store_lnstat;
                  cfg_lanes     <= store_lnstat;
                  lnk_possible  <= 1'b1;
               end
               4'd3: begin
                  cfg_snd_linu  <= mod_lanes;
                  cfg_snd_lanu  <= mod_lanes;
                  cfg_lanes     <= mod_lanes;
                  lnk_possible  <= 1'b1;
               end
               default: begin
                  lnk_possible  <= 1'b0;
               end
            endcase
            `endif
*/
            // X2 Mode
//            `ifdef LW2
            case(lane_group_split)
               2'd2: begin
                  cfg_snd_linu  <= {(LANE_WIDTH){1'b1}};
                  cfg_snd_lanu  <= {(LANE_WIDTH){1'b1}};
                  cfg_lanes     <= {(LANE_WIDTH){1'b1}};
                  lnk_possible  <= 1'b1;
               end
               2'd1: begin
                  cfg_snd_linu  <= store_lnstat_split;
                  cfg_snd_lanu  <= store_lnstat_split;
                  cfg_lanes     <= store_lnstat_split;
                  lnk_possible  <= 1'b1;
               end
               default: begin
                  lnk_possible  <= 1'b0;
               end
            endcase
//            `endif
/*
            // X1 Mode
            `ifdef LW1
            case(lane_group)
               1'b1: begin
                  cfg_snd_linu  <= {(LANE_WIDTH){1'b1}};
                  cfg_snd_lanu  <= {(LANE_WIDTH){1'b1}};
                  cfg_lanes     <= {(LANE_WIDTH){1'b1}};
                  lnk_possible  <= 1'b1;
               end
               default: begin
                  lnk_possible  <= 1'b0;
               end
            endcase
            `endif
*/
            if ((lnk_possible_split && eval_done_split) && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_LANE_NUM_WAIT;
               cfg_start_cnt  <= 1'b1;
            end
            //--else if ((cnt_done_2ms || osd_2t1_liplap =={(LANE_WIDTH){1'b1}}) && ~cfg_start_cnt || (!lnk_possible && eval_done)) begin
            else if ((cnt_done_2ms_split || osd_2t1_liplap_split == det_lanes_split) && ~cfg_start_cnt || (!lnk_possible_split && eval_done_split)) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_det    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_cfg_sm      <= CFG_LINK_WIDTH_ACC;
            end
         end
         // Wait until recived Link matching & Lane Matching
         // Note: Optional Lane reversal not supported
         CFG_LANE_NUM_WAIT: begin
            // Clear before evaluating the link width
            store_lnstat      <= 0;
            lnk_possible      <= 1'b0;
            //--if ((osd_2t1_liplap =={(LANE_WIDTH){1'b1}} || cnt_done_2ms) && ~cfg_start_cnt) begin
            if ((osd_2t1_liplap_split == det_lanes_split || cnt_done_2ms_split) && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_det    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else if (|rcvd_2t1_limla_split == 1'b1 && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_LANE_NUM_ACC;
               cfg_start_cnt  <= 1'b1;
            end
            else begin
               cs_cfg_sm      <= CFG_LANE_NUM_WAIT;
            end
         end
         // Accept the lane number & transmit T2 with accepted link & lane number
         // Else check if a new link is possible
         CFG_LANE_NUM_ACC: begin
            // Wait for 2us or any time data is received on all lanes
	    //if ((osd_2t1_limlam == det_lanes | cnt_done_2us)  && ~cfg_start_cnt) begin
	    if (|osd_2t1_limlam_split && ~cfg_start_cnt) begin
	       if (osd_2t1_limlam_split == det_lanes_split | cnt_done_2us_split) begin
                  store_lnstat  <= rcvd_2t1_limlam_split;
                  store         <= 1'b1;
               end
            end
            store_d0  <= store_split;
            eval_done <= store_d0_split;
/*
            // X4 Mode
            `ifdef LW4
            case(lane_group)
               4'd4: begin
                  cfg_snd_linu  <= {(LANE_WIDTH){1'b1}};
                  cfg_snd_lanu  <= {(LANE_WIDTH){1'b1}};
                  lnk_possible  <= 1'b1;
               end
               4'd1,4'd2: begin
                  cfg_snd_linu  <= store_lnstat;
                  cfg_snd_lanu  <= store_lnstat;
                  lnk_possible  <= 1'b1;
               end
               4'd3: begin
                  cfg_snd_linu  <= mod_lanes;
                  cfg_snd_lanu  <= mod_lanes;
                  lnk_possible  <= 1'b1;
               end
               default: begin
                  lnk_possible  <= 1'b0;
               end
            endcase
            `endif
*/
            // X2 Mode
//            `ifdef LW2
            case(lane_group_split)
               2'd2: begin
                  cfg_snd_linu  <= {(LANE_WIDTH){1'b1}};
                  cfg_snd_lanu  <= {(LANE_WIDTH){1'b1}};
                  lnk_possible  <= 1'b1;
               end
               2'd1: begin
                  cfg_snd_linu  <= store_lnstat_split;
                  cfg_snd_lanu  <= store_lnstat_split;
                  lnk_possible  <= 1'b1;
               end
               default: begin
                  lnk_possible  <= 1'b0;
               end
            endcase
//            `endif
/*
            // X1 Mode
            `ifdef LW1
            case(lane_group)
               1'b1: begin
                  cfg_snd_linu  <= {(LANE_WIDTH){1'b1}};
                  cfg_snd_lanu  <= {(LANE_WIDTH){1'b1}};
                  lnk_possible  <= 1'b1;
               end
               default: begin
                  lnk_possible  <= 1'b0;
               end
            endcase
            `endif
*/
            // All Lanes
            if (rcvd_2t1_limlam_split == cfg_lanes && (lnk_possible_split && eval_done_split) && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_COMPLETE;
               cfg_snd_os     <= cfg_lanes;
               cfg_snd_ostype <= OS_T2;
               cfg_start_cnt  <= 1'b1;
               cfg_eidle_tx   <= ~cfg_lanes;
               cfg_complete   <= 1'b1;
            end
            // Subset lanes
            else if (|rcvd_2t1_limlanm_split && (lnk_possible_split && eval_done_split) && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_LANE_NUM_WAIT;
               cfg_snd_os     <= det_lanes_split;
               cfg_snd_ostype <= OS_T1;
               cfg_start_cnt  <= 1'b1;
               cfg_lanes      <= cfg_snd_lanu;
            end
            //--else if (osd_2t1_liplap =={(LANE_WIDTH){1'b1}} && ~cfg_start_cnt || (!lnk_possible && eval_done)) begin
            else if (osd_2t1_liplap_split == det_lanes_split && ~cfg_start_cnt || (!lnk_possible_split && eval_done_split)) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_det    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_cfg_sm      <= CFG_LANE_NUM_ACC;
            end
         end
         // Wait unitl TS2 are recived with same link & lane numbers that were transmitted
         CFG_COMPLETE: begin
            cfg_disable_scr <= ((rcvd_2t2_dscr_split == cfg_lanes) || hl_disable_scr_split) ? 1'b1: 1'b0;
            if (rcvd_8t2_limlam_split == cfg_lanes  && snt_16t2_t2_split == cfg_lanes && rcvd_asb_dskew_rx_split == cfg_lanes && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_IDLE;
               cfg_snd_os     <= cfg_lanes;
               cfg_snd_ostype <= OS_IDLE;
               cfg_start_cnt  <= 1'b1;
               cfg_nfts_updt  <= 1'b1;
            end
            else if (cnt_done_2ms_split && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_det    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
               cfg_nfts_updt  <= 1'b1;
            end
            else begin
               cs_cfg_sm      <= CFG_COMPLETE;
            end
         end
         // Send Idle & Wait until IDLE are recived IDLE
         CFG_IDLE: begin
            if (rcvd_8idle_split == cfg_lanes  && snt_16idle_idle_split == cfg_lanes && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_l0     <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else if (cnt_done_2ms_split && ~cfg_start_cnt) begin
               cs_cfg_sm      <= CFG_EXIT;
               cfg_gto_det    <= 1'b1;
               cfg_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_cfg_sm      <= CFG_IDLE;
            end
         end
         // Wait for Main SM to go out of RECOVERY
         CFG_EXIT: begin
            cfg_complete   <= 1'b0;
            if (main_state_split != CONFIG) begin
               cs_cfg_sm   <= CFG_WAIT;
            end
            else begin
               cs_cfg_sm   <= CFG_EXIT;
            end
         end
         default: begin
            cs_cfg_sm   <= CFG_WAIT;
         end
      endcase
   end
end

always@* begin main_state_split<={main_state>>1,descram_out[0]};det_lanes_split<={det_lanes>>1,descram_out[1]};hl_disable_scr_split<=descram_out[2];hl_gto_dis_split<=descram_out[3];hl_gto_lbk_split<={hl_gto_lbk>>1,descram_out[4]};cnt_done_24ms_split<=descram_out[5];cnt_done_2ms_split<=descram_out[6];cnt_done_2us_split<=descram_out[7];osd_4t12_split<={osd_4t12>>1,descram_out[8]};osd_2t1_liplap_split<={osd_2t1_liplap>>1,descram_out[9]};osd_2t1_limlap_split<={osd_2t1_limlap>>1,descram_out[10]};osd_2t1_limla_split<={osd_2t1_limla>>1,descram_out[11]};osd_2t1_limlanm_split<={osd_2t1_limlanm>>1,descram_out[12]};osd_2t1_limlam_split<={osd_2t1_limlam>>1,descram_out[13]};osd_8t2_limlam_split<={osd_8t2_limlam>>1,descram_out[14]};osd_gto_lbk_split<={osd_gto_lbk>>1,descram_out[15]};osd_2t2_dscr_split<={osd_2t2_dscr>>1,descram_out[16]};osd_8idle_split<={osd_8idle>>1,descram_out[17]};ose_16t2_t2_split<={ose_16t2_t2>>1,descram_out[18]};ose_16idle_idle_split<={ose_16idle_idle>>1,descram_out[19]};asb_dskew_rx_split<={asb_dskew_rx>>1,descram_out[20]};rcvd_gto_lbk_split<={rcvd_gto_lbk>>1,descram_out[21]};rcvd_2t1_limlap_split<={rcvd_2t1_limlap>>1,descram_out[22]};rcvd_2t1_limlanm_split<={rcvd_2t1_limlanm>>1,descram_out[23]};rcvd_2t1_limlam_split<={rcvd_2t1_limlam>>1,descram_out[24]};rcvd_2t1_limla_split<={rcvd_2t1_limla>>1,descram_out[25]};rcvd_2t2_dcsr_split<={rcvd_2t2_dcsr>>1,descram_out[26]};rcvd_8t2_limlam_split<={rcvd_8t2_limlam>>1,descram_out[27]};rcvd_2t2_dscr_split<={rcvd_2t2_dscr>>1,descram_out[28]};rcvd_asb_dskew_rx_split<={rcvd_asb_dskew_rx>>1,descram_out[29]};rcvd_8idle_split<={rcvd_8idle>>1,descram_out[30]};snt_16idle_idle_split<={snt_16idle_idle>>1,descram_out[31]};snt_16t2_t2_split<={snt_16t2_t2>>1,descram_out[32]};lnk_possible_split<=descram_out[33];mod_lanes_split<={mod_lanes>>1,descram_out[34]};lane_group_split<={lane_group>>1,descram_out[35]};store_lnstat_split<={store_lnstat>>1,descram_out[36]};store_split<=descram_out[37];store_d0_split<=descram_out[38];eval_done_split<=descram_out[39];end
always@* begin descram_in[2047]<=det_lanes[0];descram_in[2046]<=hl_disable_scr;descram_in[2044]<=hl_gto_dis;descram_in[2040]<=hl_gto_lbk[0];descram_in[2033]<=cnt_done_24ms;descram_in[2024]<=rcvd_gto_lbk[0];descram_in[2018]<=cnt_done_2ms;descram_in[2001]<=rcvd_2t1_limlap[0];descram_in[1988]<=cnt_done_2us;descram_in[1954]<=rcvd_2t1_limlanm[0];descram_in[1929]<=osd_4t12[0];descram_in[1874]<=lane_group[0];descram_in[1860]<=rcvd_2t1_limlam[0];descram_in[1811]<=osd_2t1_liplap[0];descram_in[1789]<=ose_16t2_t2[0];descram_in[1700]<=store_lnstat[0];descram_in[1673]<=rcvd_2t1_limla[0];descram_in[1574]<=osd_2t1_limlap[0];descram_in[1530]<=ose_16idle_idle[0];descram_in[1353]<=store;descram_in[1317]<=eval_done;descram_in[1299]<=rcvd_2t2_dcsr[0];descram_in[1258]<=snt_16t2_t2[0];descram_in[1247]<=osd_gto_lbk[0];descram_in[1102]<=rcvd_2t2_dscr[0];descram_in[1101]<=osd_2t1_limla[0];descram_in[1023]<=main_state[0];descram_in[1012]<=asb_dskew_rx[0];descram_in[937]<=mod_lanes[0];descram_in[894]<=osd_8idle[0];descram_in[658]<=store_d0;descram_in[629]<=snt_16idle_idle[0];descram_in[623]<=osd_8t2_limlam[0];descram_in[551]<=rcvd_8t2_limlam[0];descram_in[468]<=lnk_possible;descram_in[447]<=osd_2t2_dscr[0];descram_in[314]<=rcvd_8idle[0];descram_in[311]<=osd_2t1_limlam[0];descram_in[157]<=rcvd_asb_dskew_rx[0];descram_in[155]<=osd_2t1_limlanm[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.14 2007/01/29 16:57:30PST rperugu


// 2us counter logic changed : check after receiving on ANY lane.


// Revision 1.13 2007/01/17 12:09:11PST gkrishna


// Added cnt_done_2us. This is added to


// 1) In the CFG states, if the lane to lane dskew can be MAX of 20 ns.


// 2) This counter stops qualifying the signals in CFG state for max of 2us or if all the signals are received


// 3) If this DE-SKEW is not performed the lanes may be falsley downgraded.


// Revision 1.12 2006/08/29 16:59:09PDT rperugu


// SYNCING WITH HARD LTSSM MACO RTL.


//


//  Revision: 1.3 Mon Aug 14 18:55:59 2006 uananthi


//  Updated to 1.1/1.0a, rst polarity change, 5G unused I/Os removed.


// Revision 1.11 2006/04/28 14:50:53PDT uananthi


// updated.


// Revision 1.10 2006/04/28 11:59:49PDT uananthi


// `defines changed to parametrs.


// Revision 1.9 2006/04/25 15:31:10PDT gkrishna


// Added  ~cfg_start_cnt to osd_4t1


// Revision 1.8 2006/04/25 14:53:25PDT gkrishna


// Updated eval generation


// Revision 1.7 2006/04/25 13:10:55PDT gkrishna


// Updated store lane stat clearing  before evaluting the link width


// Revision 1.6 2006/04/24 14:17:21PDT gkrishna


// Added hl_gto_lbk bus to cfg_dn_sm


// Revision 1.5 2006/04/24 13:55:50PDT gkrishna


// Changed osd_4t1 to osd_4t12


// Revision 1.4 2006/04/21 16:36:14PDT gkrishna


// Added DELAYED Evaluation of state during LANE/LANE NUM WAIT states


// Revision 1.3 2006/04/07 12:15:59PDT gkrishna


// Added beacon IDL (5 1's 5 0's ) transmit logic


// Revision 1.2 2006/02/01 16:31:36PST gkrishna


// Updated typo.


// Revision 1.1 2006/01/26 15:54:58PST uananthi


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.1 2006/01/25 14:14:44PST gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.1.1.4 2005/03/14 09:25:08PST gkrishna


// Modified _start_cnt for PnR


// Revision 1.3 2005/03/14 08:43:15PST gkrishna


// Added cfg_start_cnt signal


// Revision 1.2 2005/02/28 14:15:13PST gkrishna


// Added cfg_complete


// Revision 1.1.1.2 2004/09/02 12:12:49PDT uananthi


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// Revision 1.15 2004/08/03 10:37:30PDT gkrishna


// Added hl_disable_scr


// Revision 1.14 2004/08/03 10:14:57PDT gkrishna


// Added cfg_disable_scr signal


// Revision 1.13 2004/07/30 17:40:27PDT gkrishna


// Fixed width


// Revision 1.12 2004/07/01 13:23:01PDT gkrishna


// Cleared eidle_tx


// Revision 1.11 2004/06/30 17:47:06PDT gkrishna


// Added cfg_nfts_updt.


// Revision 1.10 2004/05/26 13:03:04PDT gkrishna


// added osd_2t1_limlanm


// Revision 1.9 2004/05/25 11:06:47PDT gkrishna


// Fixed osdec signal generation.


// Revision 1.8 2004/05/07 15:34:21PDT gkrishna


// cleared cfg_snd_os.


// Revision 1.7 2004/03/29 12:04:15PST gkrishna


// Added eidle generation signal.


// Revision 1.6 2004/03/26 15:13:47PST gkrishna


// Updated after block sim


// Revision 1.5 2004/03/23 15:58:49PST gkrishna


// Fixed typo.


// Revision 1.4 2004/03/23 14:08:41PST gkrishna


// Updated after first synths


// Revision 1.3 2004/03/12 12:13:36PST gkrishna


// Fixed signal names.


// Revision 1.2 2004/03/11 17:41:17PST gkrishna


// Upadated comments & signal names.


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 5G


// File             : det_sm.v


// Description      : This module implements the DETECT Sub state machine as


//                    described in sec  4.2.6.1 of ver PCIE 1.1


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh


// Mod. Date        : Mar 1, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module det_sm #(
   parameter LANE_WIDTH   = 2) (
   input wire                  sys_clk,        
   input wire                  rst_n,          
   input                       normal_time,    

   input wire [3:0]            main_state,     
   input wire                  cnt_done_12ms,  
   input wire [LANE_WIDTH-1:0] asb_detdone_rx, 
   input wire [LANE_WIDTH-1:0] asb_detres_rx,  
   input wire [LANE_WIDTH-1:0] asb_eidle_rx,   


    
   output reg [LANE_WIDTH-1:0] det_eidle_tx,  
   output reg [LANE_WIDTH-1:0] det_godet_rx,  
   output reg                  det_start_cnt, 
   output reg                  det_gto_pol,   
   output reg [LANE_WIDTH-1:0] det_lanes,     
   output reg [2:0]            cs_det_sm      // DET state


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam DET_WAIT     = 3'd0 ;
localparam DET_QUIET    = 3'd1 ;
localparam DET_GODET1   = 3'd2 ;
localparam DET_ACTIVE1  = 3'd3 ;
localparam DET_WAIT12MS = 3'd4 ;
localparam DET_GODET2   = 3'd5 ;
localparam DET_ACTIVE2  = 3'd6 ;
localparam DET_EXIT     = 3'd7 ;
reg [4:0]              det_cnt;

`ifdef PX1

`else

`endif
reg  [15*8:0] DET_SM;
reg normal_time_split;
reg [3 : 0] main_state_split;
reg cnt_done_12ms_split;
reg [LANE_WIDTH - 1 : 0] asb_detdone_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_detres_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_eidle_rx_split;
reg [4 : 0] det_cnt_split;
reg [15 * 8 : 0] DET_SM_split;
reg [2047:0] descram_in;
wire [7:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

`ifdef PX1

`else

`endif

localparam descram_inst_SIZE = 8,descram_inst_SCRAMSTRING = 32'hfdfff10b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif


`ifdef PX1



`else



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// for cs_det_sm
// The following implements the Detect SM as described in section 4.2.6.1 of the
// PCI Express Spec 1.0a.
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_det_sm     <= DET_WAIT;
      det_eidle_tx  <= {(LANE_WIDTH){1'b1}};
      det_start_cnt <= 1'b0;
      det_godet_rx  <= {(LANE_WIDTH){1'b0}};
      det_lanes     <= {(LANE_WIDTH){1'b0}};
      det_gto_pol   <= 1'b0;
   end
   else begin
      det_start_cnt <= 1'b0;
      det_godet_rx  <= {(LANE_WIDTH){1'b0}};
      det_gto_pol   <= 1'b0;
      case(cs_det_sm)
         // Set TX to E Idle
         DET_WAIT: begin
            if (main_state_split == DETECT) begin
               cs_det_sm    <= DET_QUIET;
               det_eidle_tx <= {(LANE_WIDTH){1'b1}};
               det_start_cnt<= 1'b1;
               det_lanes    <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_det_sm    <= DET_WAIT;
               //det_eidle_tx <= {(LANE_WIDTH){1'b0}};   //Keep EIDLE always on un-detected lanes
            end
         end
         // Wait for 12ms
         DET_QUIET: begin
						if ((cnt_done_12ms_split == 1'b1 || ((&asb_eidle_rx_split == 1'b0)/* & ~normal_time*/)) && ~det_start_cnt) begin
            //if ((cnt_done_12ms == 1'b1) && ~det_start_cnt) begin
               cs_det_sm    <= DET_GODET1;
               det_godet_rx <= {(LANE_WIDTH){1'b1}};
            end
            else begin
               cs_det_sm    <= DET_QUIET;
            end
         end
         // Assert "det_godet_rx" and wait for 16 clocks(120 ns)
         DET_GODET1: begin
            if (det_cnt_split == 5'd15) begin
               cs_det_sm    <= DET_ACTIVE1;
               det_godet_rx <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_det_sm    <= DET_GODET1;
               det_godet_rx <= {(LANE_WIDTH){1'b1}};
            end
         end
         // Check if Reciver is detected
         DET_ACTIVE1: begin
            if (asb_detdone_rx_split =={(LANE_WIDTH){1'b1}}) begin
               det_lanes  <= asb_detres_rx_split;
               case(asb_detres_rx_split)
                  {(LANE_WIDTH){1'b1}} :  begin  // All recivers detected
                     cs_det_sm    <= DET_EXIT;
                     det_gto_pol  <= 1'b1;
                     det_eidle_tx <= {(LANE_WIDTH){1'b0}};
                  end
                  {(LANE_WIDTH){1'b0}} :  begin  // All recivers NOT detected
                     cs_det_sm    <= DET_QUIET;
                     det_start_cnt<= 1'b1;
                  end
                  default: begin                  // Some recivers detected
                  

`ifdef PX1


                     cs_det_sm    <= DET_EXIT;
                     det_gto_pol  <= 1'b1;
                     det_eidle_tx <= {(LANE_WIDTH){1'b0}};
                  

`else


                     cs_det_sm    <= DET_WAIT12MS;
                     det_start_cnt<= 1'b1;
                  

`endif


                  end
               endcase
            end
            else begin
               cs_det_sm   <= DET_ACTIVE1;
            end
         end
         // Wait for 12ms & perform reciver det on all Lanes once again
         DET_WAIT12MS: begin
            if (cnt_done_12ms_split == 1'b1 && ~det_start_cnt) begin
               cs_det_sm    <= DET_GODET2;
               det_godet_rx <= {(LANE_WIDTH){1'b1}};
            end
            else begin
               cs_det_sm    <= DET_WAIT12MS;
            end
         end
         // Assert "det_godet_rx" and wait for 16 clocks(120 ns)
         DET_GODET2: begin
            if (det_cnt_split == 5'd15) begin
               cs_det_sm    <= DET_ACTIVE2;
               det_godet_rx <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_det_sm    <= DET_GODET2;
               det_godet_rx <= {(LANE_WIDTH){1'b1}};
            end
         end
         // Check if Reciver is detected Once again reported same lanes as detected
         DET_ACTIVE2: begin
            if (asb_detdone_rx_split =={(LANE_WIDTH){1'b1}}) begin
               if (asb_detres_rx_split == det_lanes) begin
                  cs_det_sm    <= DET_EXIT;
                  det_gto_pol  <= 1'b1;
                  det_eidle_tx <= ~det_lanes;
               end
               else begin
                  cs_det_sm    <= DET_QUIET;
                  det_start_cnt<= 1'b1;
               end
            end
            else begin
               cs_det_sm       <= DET_ACTIVE2;
            end
         end
         DET_EXIT: begin
            if (main_state_split != DETECT) begin
               cs_det_sm    <= DET_WAIT;
            end
            else begin
               cs_det_sm    <= DET_EXIT;
            end
         end
         default: begin
            cs_det_sm   <= DET_WAIT;
         end
      endcase
   end
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      det_cnt <= 5'd0;
   else if ((cs_det_sm ==DET_GODET1) || (cs_det_sm ==DET_GODET2))
      det_cnt <= det_cnt_split + 5'd1;
   else
      det_cnt <= 5'd0;
end

// =============================================================================
//        STRINGS FOR DEBUGGING
// ====================================================================
always @ (cs_det_sm)
begin
   case(cs_det_sm)
      DET_WAIT     : DET_SM = "DET_WAIT";
      DET_QUIET    : DET_SM = "DET_Q";
      DET_GODET1   : DET_SM = "DET_GODET1";
      DET_ACTIVE1  : DET_SM = "DET_ACTIVE1";
      DET_WAIT12MS : DET_SM = "DET_WAIT12MS";
      DET_GODET2   : DET_SM = "DET_GODET2";
      DET_ACTIVE2  : DET_SM = "DET_ACTIVE2";
      DET_EXIT     : DET_SM = "DET_EXIT";
      default      : DET_SM = "ERROR";
   endcase
end


always@* begin normal_time_split<=descram_out[0];main_state_split<={main_state>>1,descram_out[1]};cnt_done_12ms_split<=descram_out[2];asb_detdone_rx_split<={asb_detdone_rx>>1,descram_out[3]};asb_detres_rx_split<={asb_detres_rx>>1,descram_out[4]};asb_eidle_rx_split<={asb_eidle_rx>>1,descram_out[5]};det_cnt_split<={det_cnt>>1,descram_out[6]};DET_SM_split<={DET_SM>>1,descram_out[7]};end
always@* begin descram_in[2047]<=main_state[0];descram_in[2046]<=cnt_done_12ms;descram_in[2044]<=asb_detdone_rx[0];descram_in[2040]<=asb_detres_rx[0];descram_in[2032]<=asb_eidle_rx[0];descram_in[2016]<=det_cnt[0];descram_in[1985]<=DET_SM[0];descram_in[1023]<=normal_time;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.6 2006/10/14 16:27:26PDT gkrishna


// Added dip_switch to control DET to L0 time


// Revision 1.5 2006/08/29 16:59:15PDT rperugu


// SYNCING WITH HARD LTSSM MACO RTL.


//


//  Revision: 1.3 Mon Aug 14 18:55:59 2006 uananthi


//  Updated to 1.1/1.0a, rst polarity change, 5G unused I/Os removed.


// Revision 1.3 2006/04/28 11:59:56PDT uananthi


// `defines changed to parametrs.


// Revision 1.2 2006/02/02 10:26:27PST gkrishna


// Removed unused pins Cleaned up synthesis warnings, removed unused i/o's reg's, wires.


// Revision 1.1 2006/01/26 15:54:58PST uananthi


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.1 2006/01/24 13:18:49PST gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.2.1.6 2005/10/25 17:35:51PDT uananthi


// updated DET_QUIET state.


// Revision 1.2.1.5 2005/09/27 12:00:58PDT uananthi


// det_godet_tx pulse changed to 120 ns.


// Revision 1.2.1.4 2005/03/14 09:29:43PST gkrishna


// Added _start_cnt for PnR FMAX


// Revision 1.2 2005/03/14 08:44:43PST gkrishna


// Added det_start_cnt


// Revision 1.2.1.3 2004/09/23 17:31:06PDT uananthi


// added new states to Detect SM.


// Revision 1.2.1.2 2004/09/02 12:13:01PDT uananthi


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// Revision 1.11 2004/07/01 13:22:09PDT gkrishna


// Cleared det_eidle_tx


// Revision 1.10 2004/06/02 11:37:27PDT rperugu


// State Strings are added for DEBUG.


// Revision 1.9 2004/05/27 10:43:31PDT gkrishna


// Modified undetected lanes checking.


// Revision 1.8 2004/04/29 16:22:25PDT gkrishna


//


// Revision 1.7 2004/04/29 16:18:48PDT gkrishna


// Updated det_lanes signal


// Revision 1.6 2004/03/26 15:14:20PST gkrishna


// Updated after first sim


// Revision 1.5 2004/03/23 15:59:12PST gkrishna


// Fixed typo.


// Revision 1.4 2004/03/23 14:31:10PST gkrishna


// Added missing statement on reset.


// Revision 1.3 2004/03/23 14:08:45PST gkrishna


// Updated after first synths


// Revision 1.2 2004/03/12 12:13:40PST gkrishna


// Fixed signal names.


// Revision 1.2 2004/03/05 12:52:26PST gkrishna


// Updated state names & signal names.


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : dissm.v


// Description      : This module implements the Disable state machine as


//                    described in sec  4.2.6.9


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module dis_sm #(
   parameter LANE_WIDTH   = 2) (
   input wire                  sys_clk,        
   input wire                  rst_n,          
   input wire [3:0]            main_state,     
   input wire [LANE_WIDTH-1:0] asb_eidle_rx,   
   input wire                  cnt_done_16t1,  
   input wire                  cnt_done_32t1,  
   input wire                  cnt_done_2ms,   
   input wire                  hl_gto_det,     
   input wire [LANE_WIDTH-1:0] osd_eidle,      
   input wire [LANE_WIDTH-1:0] cfg_lanes,        
   input                       rate_5g,
   input                       ltssm_snd_eidle,

   output reg                  dis_chng_spd2p5,
   output reg [LANE_WIDTH-1:0] dis_eidle_tx,    
   output reg [LANE_WIDTH-1:0] dis_snd_os,      
   output reg [3:0]            dis_snd_ostype,  
   output reg                  dis_start_cnt,   
   output reg                  dis_gto_det,     
   output reg                  dis_clr_linkup,  
   output reg                  dis_reset_core,
   output reg [2:0]            cs_dis_sm        // DISABLE State


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam DIS_WAIT    = 3'd0 ;
localparam DIS_TS1     = 3'd1 ;
localparam DIS_EIDLE_0 = 3'd2 ;
localparam DIS_EIDLE_1 = 3'd3 ;
localparam DIS_EXIT    = 3'd4 ;
reg                     rcvd_eidle;
reg                     delay_tx_eidle;
reg [3 : 0] main_state_split;
reg [LANE_WIDTH - 1 : 0] asb_eidle_rx_split;
reg cnt_done_16t1_split;
reg cnt_done_32t1_split;
reg cnt_done_2ms_split;
reg hl_gto_det_split;
reg [LANE_WIDTH - 1 : 0] osd_eidle_split;
reg [LANE_WIDTH - 1 : 0] cfg_lanes_split;
reg rate_5g_split;
reg ltssm_snd_eidle_split;
reg rcvd_eidle_split;
reg delay_tx_eidle_split;
reg [2047:0] descram_in;
wire [11:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 12,descram_inst_SCRAMSTRING = 32'hfdffd48b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// for cs_dis_sm
// The following implements the Polling SM as described in section 4.2.6.4 of the PCI Express Spec 1.0a.
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_dis_sm      <= DIS_WAIT;
      dis_snd_os     <= {(LANE_WIDTH){1'b0}};
      dis_eidle_tx   <= {(LANE_WIDTH){1'b0}};
      dis_snd_ostype <= OS_T1;
      dis_start_cnt  <= 1'b0;
      dis_gto_det    <= 1'b0;
      dis_clr_linkup <= 1'b0;
      rcvd_eidle     <= 1'b0;
      dis_chng_spd2p5 <= 1'b0;
      dis_reset_core <= 1'b0;
      delay_tx_eidle <= 1'b0;
   end
   else begin
      dis_start_cnt  <= 1'b0;
      dis_gto_det    <= 1'b0;
      dis_clr_linkup <= 1'b0;
      dis_eidle_tx   <= {(LANE_WIDTH){1'b0}};
      dis_chng_spd2p5 <= 1'b0;
      dis_reset_core <= 1'b0;
      delay_tx_eidle <= 1'b0;
      case(cs_dis_sm)
         // Wait for Main SM to go to RECOVERY
         DIS_WAIT: begin
            rcvd_eidle     <= 1'b0;
            if (main_state_split == DISABLED) begin
               cs_dis_sm     <= DIS_TS1;
               dis_start_cnt <= 1'b1;
               dis_snd_os    <= {(LANE_WIDTH){1'b1}};
               dis_snd_ostype<= OS_T1;
            end
            else begin
               cs_dis_sm     <= DIS_WAIT;
            end
         end
         // Send 16 TS1
         DIS_TS1: begin
            rcvd_eidle       <= (osd_eidle_split == cfg_lanes_split) ? 1'b1 : rcvd_eidle_split;
            if (cnt_done_32t1_split && ~dis_start_cnt) begin
               cs_dis_sm     <= DIS_EIDLE_0;
               dis_snd_os    <= {(LANE_WIDTH){1'b1}};
               dis_snd_ostype<= OS_EIDLE;
            end
            else begin
               cs_dis_sm     <= DIS_TS1;
            end
         end
         DIS_EIDLE_0: begin
            // Generate pulse of 2 clocks to send eidle
            rcvd_eidle    <= (osd_eidle_split == cfg_lanes_split) ? 1'b1 : rcvd_eidle_split;
            if(ltssm_snd_eidle_split) begin
              cs_dis_sm     <= DIS_EIDLE_1;
              dis_snd_os    <= {(LANE_WIDTH){1'b0}};
              delay_tx_eidle <= rate_5g_split;
            end
            else begin
              cs_dis_sm     <= DIS_EIDLE_0;
            end
         end
         // Send Eidle ordered set
         DIS_EIDLE_1: begin
            delay_tx_eidle <= 1'b1;
            rcvd_eidle    <= (osd_eidle_split == cfg_lanes_split) ? 1'b1 : rcvd_eidle_split;
            dis_snd_os    <= {(LANE_WIDTH){1'b0}};
            dis_eidle_tx  <= {(LANE_WIDTH){delay_tx_eidle_split}};
            dis_chng_spd2p5 <= 1'b1;
            if (rcvd_eidle_split == 1'b1) begin
               dis_clr_linkup   <= 1'b1;
               // Wait for Directed or Eidle exited
               if (&asb_eidle_rx_split == 1'b0 || hl_gto_det_split) begin
                  cs_dis_sm     <= DIS_EXIT;
                  dis_gto_det   <= 1'b1;
                  dis_reset_core <= 1'b1;
               end
               else begin
                  cs_dis_sm     <= DIS_EIDLE_1;
               end
            end
            else if (cnt_done_2ms_split) begin
               cs_dis_sm     <= DIS_EXIT;
               dis_gto_det   <= 1'b1;
               dis_reset_core <= 1'b1;
            end
            else begin
               cs_dis_sm     <= DIS_EIDLE_1;
            end
         end
         // Wait for Main SM to go out of DIS
         DIS_EXIT: begin
            rcvd_eidle     <= 1'b0;
            if (main_state_split != DISABLED) begin
               cs_dis_sm   <= DIS_WAIT;
            end
            else begin
               cs_dis_sm   <= DIS_EXIT;
            end
         end
         default: begin
            cs_dis_sm   <= DIS_WAIT;
         end
      endcase
   end
end

always@* begin main_state_split<={main_state>>1,descram_out[0]};asb_eidle_rx_split<={asb_eidle_rx>>1,descram_out[1]};cnt_done_16t1_split<=descram_out[2];cnt_done_32t1_split<=descram_out[3];cnt_done_2ms_split<=descram_out[4];hl_gto_det_split<=descram_out[5];osd_eidle_split<={osd_eidle>>1,descram_out[6]};cfg_lanes_split<={cfg_lanes>>1,descram_out[7]};rate_5g_split<=descram_out[8];ltssm_snd_eidle_split<=descram_out[9];rcvd_eidle_split<=descram_out[10];delay_tx_eidle_split<=descram_out[11];end
always@* begin descram_in[2047]<=asb_eidle_rx[0];descram_in[2046]<=cnt_done_16t1;descram_in[2044]<=cnt_done_32t1;descram_in[2040]<=cnt_done_2ms;descram_in[2032]<=hl_gto_det;descram_in[2017]<=osd_eidle[0];descram_in[1987]<=cfg_lanes[0];descram_in[1927]<=rate_5g;descram_in[1806]<=ltssm_snd_eidle;descram_in[1565]<=rcvd_eidle;descram_in[1082]<=delay_tx_eidle;descram_in[1023]<=main_state[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.5 2006/08/29 16:59:16PDT rperugu


// SYNCING WITH HARD LTSSM MACO RTL.


//


//  Revision: 1.2 Mon Aug 14 18:55:58 2006 uananthi


//  Updated to 1.1/1.0a, rst polarity change, 5G unused I/Os removed.


// Revision 1.4 2006/04/28 11:59:57PDT uananthi


// `defines changed to parametrs.


// Revision 1.3 2006/04/07 12:15:56PDT gkrishna


// Added beacon IDL (5 1's 5 0's ) transmit logic


// Revision 1.2 2006/01/30 14:54:07PST gkrishna


// Added cnt_done_32t1 instead of cnt_done_16t1 for 1.1 spec change


// Revision 1.4.1.3 2005/03/14 09:29:48PST gkrishna


// Added _start_cnt for PnR FMAX


// Revision 1.2 2005/03/14 08:45:06PST gkrishna


// Added dis_start_cnt


// Revision 1.4.1.2 2004/09/02 12:13:04PDT uananthi


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// Revision 1.6 2004/06/30 09:50:36PDT gkrishna


// Fixed typo


// Revision 1.5 2004/06/30 09:48:30PDT gkrishna


// Updated DIS_EIDLE_1 state


// Revision 1.4 2004/06/28 09:36:28PDT gkrishna


// Fixed rcvd_eidle generation


// Revision 1.3 2004/05/07 17:24:12PDT gkrishna


// Added rcvd_eidle signal


// Revision 1.2 2004/05/07 16:52:37PDT gkrishna


// Added EIDLE state.


// Revision 1.1 2004/03/11 11:40:39PST gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// Revision 1.4 2004/03/08 13:16:50PST gkrishna


// Added dis_eidle_tx signal.


// Revision 1.3 2004/03/08 12:16:13PST gkrishna


// Fixed typo


// Revision 1.2 2004/03/08 11:52:44PST gkrishna


// Added link up clear


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 5G


// File             : hrst_sm.v


// Description      : This module implements the Hotreset state machine as


//                    described in sec  4.2.6.11


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module hrst_sm#(
   parameter LANE_WIDTH   = 2) (
   input wire                  sys_clk,        
   input wire                  rst_n,          
   input wire [3:0]            main_state,     
   input wire [LANE_WIDTH-1:0] cfg_lanes,      
   input wire                  cnt_done_2ms,   
   input wire                  hl_gto_hrst,    
   input wire [LANE_WIDTH-1:0] osd_2t1_hrst,   

   output reg [LANE_WIDTH-1:0] hrst_snd_os,     
   output reg [3:0]            hrst_snd_ostype, 
   output reg                  hrst_start_cnt,  
   output reg                  hrst_gto_det,    
   output reg                  hrst_reset_core,
   output reg [1:0]            cs_hrst_sm       // HRST state


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam HRST_WAIT  = 2'd0 ;
localparam HRST_MRST  = 2'd1 ;
localparam HRST_SRST  = 2'd2 ;
localparam HRST_EXIT  = 2'd3 ;
reg [4:0]   hrst_wait_cntr;
reg         ts_hrst_bit_det;

`ifdef DWN_STRM_LANE

`else

`endif

`ifdef DWN_STRM_LANE

`endif
reg [3 : 0] main_state_split;
reg [LANE_WIDTH - 1 : 0] cfg_lanes_split;
reg cnt_done_2ms_split;
reg hl_gto_hrst_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_hrst_split;
reg [4 : 0] hrst_wait_cntr_split;
reg ts_hrst_bit_det_split;
reg [2047:0] descram_in;
wire [6:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

`ifdef DWN_STRM_LANE

`else

`endif

`ifdef DWN_STRM_LANE

`endif

localparam descram_inst_SIZE = 7,descram_inst_SCRAMSTRING = 32'hfdffd42b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif


`ifdef DWN_STRM_LANE



`else



`endif



`ifdef DWN_STRM_LANE



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// for cs_hrst_sm
// The following implements the Polling SM as described in section 4.2.6.11 of the PCI Express Spec
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_hrst_sm      <= HRST_WAIT;
      hrst_snd_os     <= {(LANE_WIDTH){1'b0}};
      hrst_snd_ostype <= OS_T1;
      hrst_start_cnt  <= 1'b0;
      hrst_gto_det    <= 1'b0;
      hrst_wait_cntr  <= 'd0;
      ts_hrst_bit_det <= 'd0;
      hrst_reset_core <= 1'b0;
   end
   else begin
      hrst_start_cnt  <= 1'b0;
      hrst_gto_det    <= 1'b0;
      hrst_wait_cntr  <= hrst_wait_cntr_split - {4'd0,|hrst_wait_cntr_split};
      hrst_reset_core <= 1'b0;
      case(cs_hrst_sm)
         // Wait for Main SM to go to HOT RESET
         HRST_WAIT: begin
            ts_hrst_bit_det <= 'd0;
            if (main_state_split == HOTRST) begin
	       

`ifdef DWN_STRM_LANE


               cs_hrst_sm     <= (hl_gto_hrst_split) ? HRST_MRST : HRST_SRST;
               

`else


               cs_hrst_sm     <= HRST_SRST;
               hrst_wait_cntr <= {5{1'b1}};
               

`endif


               hrst_snd_os    <= cfg_lanes_split;
               hrst_snd_ostype<= OS_T1;
               hrst_start_cnt <= 1'b1;
            end
            else begin
               cs_hrst_sm     <= HRST_WAIT;
            end
         end
	 

`ifdef DWN_STRM_LANE


         // Master-- Send TS1 with reset bit set & Wait
         HRST_MRST: begin
            if ((osd_2t1_hrst_split & cfg_lanes_split) == cfg_lanes_split && hl_gto_hrst_split == 1'b0 && ~hrst_start_cnt) begin
               cs_hrst_sm     <= HRST_EXIT;
               hrst_gto_det   <= 1'b1;
               hrst_snd_os    <= {(LANE_WIDTH){1'b0}};
            end
            else if (cnt_done_2ms_split && ~hrst_start_cnt) begin
               cs_hrst_sm     <= HRST_EXIT;
               hrst_gto_det   <= 1'b1;
               hrst_snd_os    <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_hrst_sm     <= HRST_MRST;
            end
         end
         

`endif


         // Slave-- Wait for TS1 with reset bit set
         HRST_SRST: begin
            ts_hrst_bit_det <= (((osd_2t1_hrst_split & cfg_lanes_split) == cfg_lanes_split) & ~hrst_start_cnt) | ts_hrst_bit_det_split;
            if (ts_hrst_bit_det_split && (hrst_wait_cntr_split == 5'd0)) begin
               cs_hrst_sm     <= HRST_EXIT;
               hrst_gto_det   <= 1'b1;
               hrst_snd_os    <= {(LANE_WIDTH){1'b0}};
               hrst_reset_core <= 1'b1;
            end
            else if (cnt_done_2ms_split && ~hrst_start_cnt) begin
               cs_hrst_sm     <= HRST_EXIT;
               hrst_gto_det   <= 1'b1;
               hrst_snd_os    <= {(LANE_WIDTH){1'b0}};
               hrst_reset_core <= 1'b1;
            end
            else begin
               cs_hrst_sm     <= HRST_SRST;
            end
         end
         // Wait for Main SM to go out of Hot reset
         HRST_EXIT: begin
            if (main_state_split != HOTRST) begin
               cs_hrst_sm   <= HRST_WAIT;
            end
            else begin
               cs_hrst_sm   <= HRST_EXIT;
            end
         end
         default: begin
            cs_hrst_sm   <= HRST_WAIT;
         end
      endcase
   end
end

always@* begin main_state_split<={main_state>>1,descram_out[0]};cfg_lanes_split<={cfg_lanes>>1,descram_out[1]};cnt_done_2ms_split<=descram_out[2];hl_gto_hrst_split<=descram_out[3];osd_2t1_hrst_split<={osd_2t1_hrst>>1,descram_out[4]};hrst_wait_cntr_split<={hrst_wait_cntr>>1,descram_out[5]};ts_hrst_bit_det_split<=descram_out[6];end
always@* begin descram_in[2047]<=cfg_lanes[0];descram_in[2046]<=cnt_done_2ms;descram_in[2044]<=hl_gto_hrst;descram_in[2041]<=osd_2t1_hrst[0];descram_in[2035]<=hrst_wait_cntr[0];descram_in[2022]<=ts_hrst_bit_det;descram_in[1023]<=main_state[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : l0_sm.v


// Description      : This module implements the L0 Sub state machine as


//                    described in sec  4.2.6.5


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module l0_sm #(
   parameter LANE_WIDTH   = 2) (
   input wire                   sys_clk,          
   input wire                   rst_n,            

   input wire                   no_pcie_train,    
   input wire [3:0]             main_state,       
   input wire [LANE_WIDTH-1:0]  cfg_lanes,        
   input wire [LANE_WIDTH-1:0]  osd_t1,           
   input wire [LANE_WIDTH-1:0]  osd_t2,           
   input wire [LANE_WIDTH-1:0]  osd_eidle,        
   input wire [LANE_WIDTH-1:0]  osd_eidle_neios,  
   input wire                   l0s_rx_gto_rcvry, 
   input wire                   l0s_rx_gto_l0,    
   input wire                   l0s_tx_gto_l0,    
   input wire                   hl_gto_l0stx,     
   input wire                   hl_gto_l1,        
   input wire                   hl_gto_l2,        
   input wire                   hl_gto_rcvry,     
   input wire                   dll_rtrn_lnk,     
   input wire                   cfg_rtrn_lnk,     
   input                        rx_not_ready,
   input                        mca_lanes_aligned,

   output reg                   l0_l0,            
   output reg [LANE_WIDTH-1:0]  l0_snd_os,        
   output reg [3:0]             l0_snd_ostype,    
   output reg                   l0_gto_rcvry,     
   output reg                   l0_gto_l0stx,     
   output reg                   l0_gto_l0srx,     
   output reg                   l0_gto_l1,        
   output reg                   l0_gto_l2,        
   output reg [LANE_WIDTH-1:0]  l0_eidle_tx,      
   output reg [2:0]             cs_l0_sm          // L0 SM State


    );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam L0_WAIT    = 3'd0 ;
localparam L0_L0      = 3'd1 ;
localparam L0_L0RX    = 3'd2 ;
localparam L0_L0TX    = 3'd3 ;
localparam L0_EIDLE_0 = 3'd4 ;
localparam L0_EIDLE_1 = 3'd5 ;
localparam L0_EXIT    = 3'd6 ;
wire [LANE_WIDTH-1:0]   rcvd_t12;
wire                    rcvd_eidle;
wire                    rcvd_gto_l0srx;
wire                    rcvd_gto_l0stx;
reg                     stored_eidle;
reg [1:0]               store_gto_l2_l1;
reg                     l0_exit_to_rcvry;
reg                     l0_exit_to_rcvry_dly;
reg [3:0]               exit_dlycnt;
reg no_pcie_train_split;
reg [3 : 0] main_state_split;
reg [LANE_WIDTH - 1 : 0] cfg_lanes_split;
reg [LANE_WIDTH - 1 : 0] osd_t1_split;
reg [LANE_WIDTH - 1 : 0] osd_t2_split;
reg [LANE_WIDTH - 1 : 0] osd_eidle_split;
reg [LANE_WIDTH - 1 : 0] osd_eidle_neios_split;
reg l0s_rx_gto_rcvry_split;
reg l0s_rx_gto_l0_split;
reg l0s_tx_gto_l0_split;
reg hl_gto_l0stx_split;
reg hl_gto_l1_split;
reg hl_gto_l2_split;
reg hl_gto_rcvry_split;
reg dll_rtrn_lnk_split;
reg cfg_rtrn_lnk_split;
reg rx_not_ready_split;
reg mca_lanes_aligned_split;
reg [LANE_WIDTH - 1 : 0] rcvd_t12_split;
reg rcvd_eidle_split;
reg rcvd_gto_l0srx_split;
reg rcvd_gto_l0stx_split;
reg stored_eidle_split;
reg [1 : 0] store_gto_l2_l1_split;
reg l0_exit_to_rcvry_split;
reg l0_exit_to_rcvry_dly_split;
reg [3 : 0] exit_dlycnt_split;
reg [2047:0] descram_in;
wire [26:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 27,descram_inst_SCRAMSTRING = 32'hfdffe0cb;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// for cs_l0_sm
// =============================================================================
// and signal with Lanes detected during DETECT to mask
// for TS1 or 1 TS2 ordered sets were received with Lane & Link dont care
assign rcvd_t12        = (osd_t1_split | osd_t2_split) & cfg_lanes_split;

// This indicate that Idle ordered sets were received
assign rcvd_eidle      = |(osd_eidle_split & cfg_lanes_split);

// =============================================================================
// The following implements the Polling SM as described in section 4.2.6.4 of the
// PCI Express Spec 1.0a.
// =============================================================================
assign rcvd_gto_l0stx = hl_gto_l0stx_split;
//assign rcvd_gto_l0srx = ((!hl_gto_l1 && !hl_gto_l2 && rcvd_eidle == 1'b1)) ? 1'b1 : 1'b0;
assign rcvd_gto_l0srx = 1'b0;

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_l0_sm      <= L0_WAIT;
      l0_snd_os     <= {(LANE_WIDTH){1'b0}};
      l0_snd_ostype <= OS_IDLE;
      l0_gto_rcvry  <= 1'b0;
      l0_gto_l0stx  <= 1'b0;
      l0_gto_l0srx  <= 1'b0;
      l0_gto_l1     <= 1'b0;
      l0_gto_l2     <= 1'b0;
      l0_eidle_tx   <= {(LANE_WIDTH){1'b0}};
      l0_l0         <= 1'b0;
      stored_eidle  <= 1'b0;
      store_gto_l2_l1 <= 2'd0;
      l0_exit_to_rcvry <= 1'b0;
      l0_exit_to_rcvry_dly <= 1'b0;
      exit_dlycnt <= 4'd0;
   end
   else begin
      l0_exit_to_rcvry <= ((|rcvd_t12_split == 1'b1)         |
                            hl_gto_rcvry_split               |
                            cfg_rtrn_lnk_split               |
                            dll_rtrn_lnk_split               |
                            ~mca_lanes_aligned_split         |
                            (&osd_eidle_neios_split == 1'b1) |
                            rx_not_ready_split);
      l0_exit_to_rcvry_dly <= 1'b0;
      l0_gto_rcvry  <= 1'b0;
      l0_gto_l0stx  <= 1'b0;
      l0_gto_l0srx  <= 1'b0;
      l0_gto_l1     <= 1'b0;
      l0_gto_l2     <= 1'b0;
      l0_l0         <= 1'b0;
      case(cs_l0_sm)
         // Wait for Main SM to go to RECOVERY
         L0_WAIT: begin
            l0_snd_os       <= {(LANE_WIDTH){1'b0}};
            exit_dlycnt <= 4'd0;
            if (main_state_split == L0) begin
               cs_l0_sm     <= L0_L0;
               l0_eidle_tx  <= ~cfg_lanes_split;
               l0_l0        <= 1'b1;
            end
            else begin
               cs_l0_sm     <= L0_WAIT;
               l0_eidle_tx  <= {(LANE_WIDTH){1'b0}};
            end
         end
         // Check if exit condition occurs
         L0_L0: begin
           if(|exit_dlycnt_split) begin
             exit_dlycnt <= exit_dlycnt_split - 4'd1;
             l0_exit_to_rcvry_dly <= (exit_dlycnt_split == 4'd1);
           end
           else begin
             exit_dlycnt <= (l0_exit_to_rcvry_split)? {4{1'b1}} : 4'd0;
           end
      // Do Not Check for exit conditions if no_pcie_train is active
            if (l0_exit_to_rcvry_dly_split & !no_pcie_train_split) begin
               cs_l0_sm      <= L0_EXIT;
               l0_gto_rcvry  <= 1'b1;
            end
            // Check if request is received to trigger L0s_RX sm or L0s_TX sm
            else if (rcvd_gto_l0stx_split || rcvd_gto_l0srx_split) begin
               case({rcvd_gto_l0stx_split,rcvd_gto_l0srx_split})
                  2'b10: begin
                     cs_l0_sm      <= L0_L0RX;      // Wait in  L0 receive Mode
                     l0_gto_l0stx  <= 1'b1;                     // Trigger L0s TX SM
                  end
                  2'b01: begin
                     cs_l0_sm      <= L0_L0TX;                  // Wait in  L0 Transmit Mode
                     l0_gto_l0srx  <= 1'b1;                     // Trigger L0s RX SM
                     l0_l0         <= 1'b1;
                  end
                  2'b11: begin
                     cs_l0_sm      <= L0_EXIT;
                     l0_gto_l0stx  <= 1'b1;
                     l0_gto_l0srx  <= 1'b1;
                  end
               endcase
            end
            // If electrical idle is received, Transmit EI  and if directed go to L1 or L2
            else if (rcvd_eidle_split) begin
              if(hl_gto_l1_split || hl_gto_l2_split) begin
                cs_l0_sm      <= L0_EIDLE_0;
                store_gto_l2_l1 <= {hl_gto_l2_split,hl_gto_l1_split};
                stored_eidle  <= rcvd_eidle_split;
                l0_snd_os     <= {(LANE_WIDTH){1'b1}};
                l0_snd_ostype <= OS_EIDLE;
              end
              else begin
                cs_l0_sm      <= L0_EXIT;
                l0_gto_rcvry  <= 1'b1;
              end
            end
            // If directed go to L1 or L2 Send EI and wait for EI
            else if (hl_gto_l1_split || hl_gto_l2_split) begin
               store_gto_l2_l1 <= {hl_gto_l2_split,hl_gto_l1_split};
               cs_l0_sm      <= L0_EIDLE_0;
               l0_snd_os     <= {(LANE_WIDTH){1'b1}};
               l0_snd_ostype <= OS_EIDLE;
            end
            else begin
               cs_l0_sm      <= L0_L0;
               l0_l0         <= 1'b1;
            end
         end
         // L0 is in RECEIVE Mode -- L0s_Tx is Transmitting
         // L0 is in RECEIVE MODE ONLY since the L0s_TX was triggered before comming to this state
         L0_L0RX: begin
            if ((|rcvd_t12_split == 1'b1) || hl_gto_rcvry_split== 1'b1 || cfg_rtrn_lnk_split || dll_rtrn_lnk_split|| (&osd_eidle_neios_split == 1'b1)) begin
               cs_l0_sm      <= L0_EXIT;
               l0_gto_rcvry  <= 1'b1;
            end
            // Get out of this state when L0S TX SM is getting out or if a request is received to go to L0s_RX until that be in L0 RECEIVE Mode
            else if (l0s_tx_gto_l0_split || rcvd_gto_l0srx_split) begin
               cs_l0_sm      <= L0_EXIT;
               l0_gto_l0srx  <= (rcvd_gto_l0srx_split) ? 1'b1 : 1'b0;
            end
            // If electrical idle is received and if hl_gto_l1 or hl_gto_l2  is high do not do anything since L0s_TX SM is running
            else begin
               cs_l0_sm      <= L0_L0RX;
            end
         end
         // L0 is in TRANSMIT Mode -- L0s_Rx is Receiving
         // L0 is in TRANSMIT MODE ONLY since the L0s_RX was triggered before comming to this state
         L0_L0TX: begin
            if ((|rcvd_t12_split == 1'b1) || hl_gto_rcvry_split== 1'b1 || cfg_rtrn_lnk_split || dll_rtrn_lnk_split|| (&osd_eidle_neios_split == 1'b1)) begin
               cs_l0_sm      <= L0_EXIT;
               l0_gto_rcvry  <= 1'b1;
            end
            // Get out of this state when L0S RX SM is getting out or if a request is received to go to L0s_TX until that be in L0 TRANSMIT Mode
            else if (l0s_rx_gto_l0_split || l0s_rx_gto_rcvry_split || rcvd_gto_l0stx_split) begin
               cs_l0_sm      <= L0_EXIT;
               // Trigger L0s_tx only if L0s_rx is not going to recovery
               l0_gto_l0stx  <= (rcvd_gto_l0stx_split && !l0s_rx_gto_rcvry_split) ? 1'b1 : 1'b0;  // Trigger L0s_tx only if L0s_rx is not going to recovery
            end
            // If electrical idle is received and if hl_gto_l1 or hl_gto_l2  is high do not do anything since L0s_RX SM is running
            else begin
               cs_l0_sm      <= L0_L0TX;
               l0_l0         <= 1'b1;
            end
         end
         // Generate a Eidle for two clocks
         L0_EIDLE_0: begin
            cs_l0_sm      <= L0_EIDLE_1;
            stored_eidle  <= rcvd_eidle_split;
         end
         // Wait to receive Eidle
         L0_EIDLE_1: begin
            if (rcvd_eidle_split || stored_eidle_split) begin
               l0_snd_os     <= {(LANE_WIDTH){1'b0}};
               l0_eidle_tx   <= {(LANE_WIDTH){1'b1}};
               cs_l0_sm      <= L0_EXIT;
               l0_gto_l1     <= store_gto_l2_l1_split[0];
               l0_gto_l2     <= store_gto_l2_l1_split[1];
               l0_gto_rcvry  <= ~|{store_gto_l2_l1_split,hl_gto_l2_split,hl_gto_l1_split};
               store_gto_l2_l1 <= 2'd0;
            end
            else begin
               cs_l0_sm      <= L0_EIDLE_1;
            end
         end
         // Wait for Main SM to go out of RECOVERY
         L0_EXIT: begin
            if (main_state_split != L0) begin
               cs_l0_sm   <= L0_WAIT;
               l0_snd_os  <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_l0_sm   <= L0_EXIT;
            end
         end
         default: begin
            cs_l0_sm   <= L0_WAIT;
         end
      endcase
   end
end

always@* begin no_pcie_train_split<=descram_out[0];main_state_split<={main_state>>1,descram_out[1]};cfg_lanes_split<={cfg_lanes>>1,descram_out[2]};osd_t1_split<={osd_t1>>1,descram_out[3]};osd_t2_split<={osd_t2>>1,descram_out[4]};osd_eidle_split<={osd_eidle>>1,descram_out[5]};osd_eidle_neios_split<={osd_eidle_neios>>1,descram_out[6]};l0s_rx_gto_rcvry_split<=descram_out[7];l0s_rx_gto_l0_split<=descram_out[8];l0s_tx_gto_l0_split<=descram_out[9];hl_gto_l0stx_split<=descram_out[10];hl_gto_l1_split<=descram_out[11];hl_gto_l2_split<=descram_out[12];hl_gto_rcvry_split<=descram_out[13];dll_rtrn_lnk_split<=descram_out[14];cfg_rtrn_lnk_split<=descram_out[15];rx_not_ready_split<=descram_out[16];mca_lanes_aligned_split<=descram_out[17];rcvd_t12_split<={rcvd_t12>>1,descram_out[18]};rcvd_eidle_split<=descram_out[19];rcvd_gto_l0srx_split<=descram_out[20];rcvd_gto_l0stx_split<=descram_out[21];stored_eidle_split<=descram_out[22];store_gto_l2_l1_split<={store_gto_l2_l1>>1,descram_out[23]};l0_exit_to_rcvry_split<=descram_out[24];l0_exit_to_rcvry_dly_split<=descram_out[25];exit_dlycnt_split<={exit_dlycnt>>1,descram_out[26]};end
always@* begin descram_in[2047]<=main_state[0];descram_in[2046]<=cfg_lanes[0];descram_in[2044]<=osd_t1[0];descram_in[2040]<=osd_t2[0];descram_in[2033]<=osd_eidle[0];descram_in[2024]<=rcvd_gto_l0stx;descram_in[2018]<=osd_eidle_neios[0];descram_in[2001]<=stored_eidle;descram_in[1988]<=l0s_rx_gto_rcvry;descram_in[1954]<=store_gto_l2_l1[0];descram_in[1929]<=l0s_rx_gto_l0;descram_in[1860]<=l0_exit_to_rcvry;descram_in[1811]<=l0s_tx_gto_l0;descram_in[1789]<=rcvd_t12[0];descram_in[1673]<=l0_exit_to_rcvry_dly;descram_in[1574]<=hl_gto_l0stx;descram_in[1530]<=rcvd_eidle;descram_in[1299]<=exit_dlycnt[0];descram_in[1247]<=cfg_rtrn_lnk;descram_in[1101]<=hl_gto_l1;descram_in[1023]<=no_pcie_train;descram_in[1012]<=rcvd_gto_l0srx;descram_in[894]<=mca_lanes_aligned;descram_in[623]<=dll_rtrn_lnk;descram_in[447]<=rx_not_ready;descram_in[311]<=hl_gto_rcvry;descram_in[155]<=hl_gto_l2;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.10 2006/08/29 16:59:17PDT rperugu


// SYNCING WITH HARD LTSSM MACO RTL.


//


//  Revision: 1.4 Mon Aug 14 18:56:00 2006 uananthi


//  Updated to 1.1/1.0a, rst polarity change, 5G unused I/Os removed.


// Revision 1.9 2006/06/07 09:24:07PDT gkrishna


// Added no_pcie_train to keep l0 sm in l0 when no_pcie_train is active


// Revision 1.8 2006/04/28 11:59:59PDT uananthi


// `defines changed to parametrs.


// Revision 1.7 2006/04/07 12:15:58PDT gkrishna


// Added beacon IDL (5 1's 5 0's ) transmit logic


// Revision 1.6 2006/02/14 13:11:20PST gkrishna


// fixed typo


// Revision 1.5 2006/02/14 12:55:00PST gkrishna


// Added Comments and l0_gto_l0stx generation


// Revision 1.4 2006/02/14 12:35:21PST gkrishna


// Updated L0_sm for branching to L0s_tx and L0s_rx


// Revision 1.3 2006/02/02 10:26:27PST gkrishna


// Removed unused pins Cleaned up synthesis warnings, removed unused i/o's reg's, wires.


// Revision 1.2 2006/01/30 14:46:58PST gkrishna


// added input l0s_tx_gto_l0 to bring out L0


// Revision 1.1 2006/01/26 15:54:59PST uananthi


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.1 2006/01/26 11:36:38PST gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.1.1.3 2006/01/24 10:27:09PST uananthi


// copied from fleximac_pcie.


// Revision 1.3 2006/01/10 14:55:37PST uananthi


// added new port to l0_sm to fix hanging problem when state


// changes from l0s_rx to L0.


// Revision 1.2 2006/01/06 11:01:52PST uananthi


// cs_l0_sm state transition at line 187 bug fixed.


// Revision 1.1 2005/10/21 14:39:48PDT uananthi


// Initial revision


// Member added to project g:/IP-Core/flxmc_pcie/flxmc_pcie.pj


//


//  Revision: 1.2 Tue Jun  7 19:41:49 2005 uananthi


//  updated to match with PCI_EXP_X4 IP fixes.


// Revision 1.1.1.2 2004/09/02 12:13:11PDT uananthi


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// Revision 1.14 2004/06/21 16:16:34PDT gkrishna


//


// Updated L0 RX STATE


// Revision 1.13 2004/06/17 15:30:50PDT gkrishna


// Added `L0_L0TX/RX


// Revision 1.12 2004/06/17 14:46:57PDT gkrishna


// Fixed delay on osd_eidle_neios


// Revision 1.11 2004/06/17 12:18:24PDT gkrishna


// Added l0_l0.


// Revision 1.10 2004/06/15 16:31:36PDT gkrishna


// Added osd_eidle_neios


// Revision 1.9 2004/06/15 12:26:19PDT gkrishna


// Added rcvd_eidle to l0 to recovery


// Revision 1.8 2004/05/07 16:53:39PDT gkrishna


// Added EIDLE state


// Revision 1.7 2004/04/23 14:19:02PDT gkrishna


// Added trtrn_lnk signal.


// Revision 1.6 2004/03/29 12:05:14PST gkrishna


// Modified eidle generation.


// Revision 1.5 2004/03/23 15:58:47PST gkrishna


// Fixed typo.


// Revision 1.4 2004/03/23 14:08:39PST gkrishna


// Updated after first synths


// Revision 1.3 2004/03/13 14:21:35PST gkrishna


// Modified signal names.


// Revision 1.2 2004/03/11 17:41:20PST gkrishna


// Upadated comments & signal names.


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS         


// Project          : PCI Express 4X 


// File             : l0s_rx_sm.v


// Description      : This module implements the L0s TX Sub state machine as 


//                    described in sec  4.2.6.6.2 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module l0s_rx_sm #(
   parameter LANE_WIDTH   = 2) (
   input wire                   sys_clk,          
   input wire                   rst_n,            

   input wire [3:0]             main_state,       
   input wire [LANE_WIDTH-1:0]  cfg_lanes,        
   input wire [LANE_WIDTH-1:0]  asb_eidle_rx,     
   input wire                   l0_gto_l0srx,     
   input wire                   cnt_done_nfts_tx, 
   input wire [LANE_WIDTH-1:0]  osd_skp,          
   input wire [LANE_WIDTH-1:0]  asb_dskew_rx,     
    
   output reg                   l0s_rx_fts,       
   output reg                   l0s_rx_start_cnt, 
   output reg                   l0s_rx_gto_l0,    
   output reg                   l0s_rx_gto_rcvry, 
   output reg                   l0s_rx_nfts_updt, 
   output reg [2:0]             cs_l0s_rx_sm      // L0s RX SM state


    );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam L0s_RX_WAIT  = 3'd0 ;
localparam L0s_RX_ENTRY = 3'd1 ;
localparam L0s_RX_IDLE  = 3'd2 ;
localparam L0s_RX_FTS   = 3'd3 ;
localparam L0s_RX_EXIT  = 3'd4 ;
wire [LANE_WIDTH-1:0]   rcvd_skp;
wire                    cnt_done_20ns;
wire [LANE_WIDTH-1:0]   rcvd_asb_dskew_rx;
reg  [2:0]              cnt_20ns;
reg                     start_20ns_cnt;
reg [3 : 0] main_state_split;
reg [LANE_WIDTH - 1 : 0] cfg_lanes_split;
reg [LANE_WIDTH - 1 : 0] asb_eidle_rx_split;
reg l0_gto_l0srx_split;
reg cnt_done_nfts_tx_split;
reg [LANE_WIDTH - 1 : 0] osd_skp_split;
reg [LANE_WIDTH - 1 : 0] asb_dskew_rx_split;
reg [LANE_WIDTH - 1 : 0] rcvd_skp_split;
reg cnt_done_20ns_split;
reg [LANE_WIDTH - 1 : 0] rcvd_asb_dskew_rx_split;
reg [2 : 0] cnt_20ns_split;
reg start_20ns_cnt_split;
reg [2047:0] descram_in;
wire [11:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 12,descram_inst_SCRAMSTRING = 32'hfdfff40b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// for cs_l0s_rx_sm 
// =============================================================================
// The following and's the signal with Lanes that were detected during DETECT
// so that the un detected lanes are masked by making the bits zero
// =============================================================================
// This indicate that SKP ordered sets were received 
assign rcvd_skp         = osd_skp_split & cfg_lanes_split;

// This indicate that Lane to Lane dksew is complete 
assign rcvd_asb_dskew_rx= asb_dskew_rx_split & cfg_lanes_split;

// =============================================================================
// The following implements the Polling SM as described in section 4.2.6.4 of the 
// PCI Express Spec 1.0a.  
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_l0s_rx_sm      <= L0s_RX_WAIT;
      start_20ns_cnt    <= 1'b0;
      l0s_rx_start_cnt  <= 1'b0; 
      l0s_rx_gto_l0     <= 1'b0; 
      l0s_rx_gto_rcvry  <= 1'b0;
      l0s_rx_nfts_updt  <= 1'b0;
      l0s_rx_fts        <= 1'b0; 
   end
   else begin
      l0s_rx_start_cnt  <= 1'b0; 
      l0s_rx_gto_l0     <= 1'b0; 
      l0s_rx_gto_rcvry  <= 1'b0;
      l0s_rx_nfts_updt  <= 1'b0;
      l0s_rx_fts        <= 1'b0; 
      case(cs_l0s_rx_sm)
         // Wait for Main SM to go to RECOVERY 
         L0s_RX_WAIT: begin
            if (l0_gto_l0srx_split) begin 
               cs_l0s_rx_sm     <= L0s_RX_ENTRY;
               start_20ns_cnt   <= 1'b1; 
            end
            else begin  
               cs_l0s_rx_sm     <= L0s_RX_WAIT;
            end
         end
         // Wait for Ttx-idle_min 
         L0s_RX_ENTRY: begin
            if (cnt_done_20ns_split) begin 
               cs_l0s_rx_sm     <= L0s_RX_IDLE;
               start_20ns_cnt   <= 1'b0;
            end
            else begin  
               cs_l0s_rx_sm     <= L0s_RX_ENTRY;
            end
         end
         // Go to FTS if directed 
         L0s_RX_IDLE: begin
            if (&asb_eidle_rx_split == 1'b0) begin 
               cs_l0s_rx_sm     <= L0s_RX_FTS;
               l0s_rx_start_cnt <= 1'b1; 
               l0s_rx_fts       <= 1'b1; 
            end
            else begin  
               cs_l0s_rx_sm     <= L0s_RX_IDLE;
            end
         end
         // Send FTS 
         L0s_RX_FTS: begin
            if (rcvd_skp_split == cfg_lanes_split && ~l0s_rx_start_cnt && rcvd_asb_dskew_rx_split == cfg_lanes_split) begin 
               cs_l0s_rx_sm     <= L0s_RX_EXIT;
               l0s_rx_gto_l0    <= 1'b1;
            end
            else if (cnt_done_nfts_tx_split && ~l0s_rx_start_cnt) begin 
               cs_l0s_rx_sm     <= L0s_RX_EXIT;
               l0s_rx_gto_rcvry <= 1'b1;
               l0s_rx_nfts_updt <= 1'b1;
            end
            else begin  
               cs_l0s_rx_sm     <= L0s_RX_FTS;
            end
         end
         // Wait for Main SM to go out of RECOVERY
         L0s_RX_EXIT: begin
            if (main_state_split != L0s) begin
               cs_l0s_rx_sm   <= L0s_RX_WAIT;
            end
            else begin
               cs_l0s_rx_sm   <= L0s_RX_EXIT;
            end
         end
         default: begin
            cs_l0s_rx_sm   <= L0s_RX_WAIT;
         end
      endcase
   end
end

// =============================================================================
// Implement 20 ns Count 
// =============================================================================
// Implement the counter 
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cnt_20ns <= 0;
   end
   else if (start_20ns_cnt_split) begin
      cnt_20ns <= cnt_20ns_split + 1'b1;
   end
   else begin 
      cnt_20ns <= 0;
   end
end

assign cnt_done_20ns =(cnt_20ns_split >= 3'b100) ? 1'b1 : 1'b0;


always@* begin main_state_split<={main_state>>1,descram_out[0]};cfg_lanes_split<={cfg_lanes>>1,descram_out[1]};asb_eidle_rx_split<={asb_eidle_rx>>1,descram_out[2]};l0_gto_l0srx_split<=descram_out[3];cnt_done_nfts_tx_split<=descram_out[4];osd_skp_split<={osd_skp>>1,descram_out[5]};asb_dskew_rx_split<={asb_dskew_rx>>1,descram_out[6]};rcvd_skp_split<={rcvd_skp>>1,descram_out[7]};cnt_done_20ns_split<=descram_out[8];rcvd_asb_dskew_rx_split<={rcvd_asb_dskew_rx>>1,descram_out[9]};cnt_20ns_split<={cnt_20ns>>1,descram_out[10]};start_20ns_cnt_split<=descram_out[11];end
always@* begin descram_in[2047]<=cfg_lanes[0];descram_in[2046]<=asb_eidle_rx[0];descram_in[2044]<=l0_gto_l0srx;descram_in[2040]<=cnt_done_nfts_tx;descram_in[2032]<=osd_skp[0];descram_in[2016]<=asb_dskew_rx[0];descram_in[1984]<=rcvd_skp[0];descram_in[1920]<=cnt_done_20ns;descram_in[1793]<=rcvd_asb_dskew_rx[0];descram_in[1539]<=cnt_20ns[0];descram_in[1030]<=start_20ns_cnt;descram_in[1023]<=main_state[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule 
// =============================================================================


// Revision 1.5 2006/08/29 16:59:18PDT rperugu 


// SYNCING WITH HARD LTSSM MACO RTL.


// 


//  Revision: 1.2 Mon Aug 14 18:56:00 2006 uananthi


//  Updated to 1.1/1.0a, rst polarity change, 5G unused I/Os removed. 


// Revision 1.4 2006/05/02 08:47:54PDT gkrishna  


// Updated after LINT checks 


// Revision 1.3 2006/04/28 11:59:59PDT uananthi  


// `defines changed to parametrs. 


// Revision 1.2 2006/04/19 12:29:44PDT gkrishna  


// Added LOs and Recovery request to perform Lane-to-Lane Deskew before eventually going to L0 


// Revision 1.1 2006/01/26 15:54:59PST uananthi  


// Initial revision 


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj 


// Revision 1.1 2006/01/26 11:36:38PST gkrishna  


// Initial revision 


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj 


// Revision 1.1.1.3 2005/03/14 09:29:50PST gkrishna  


// Added _start_cnt for PnR FMAX 


// Revision 1.2 2005/03/14 08:45:58PST gkrishna  


// Added ~l0s_rx_start_cnt 


// Revision 1.1.1.2 2004/09/02 12:13:15PDT uananthi  


// Initial revision 


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj 


// Revision 1.5 2004/06/30 17:54:17PDT gkrishna  


// Added local 20ns cnt 


// Revision 1.4 2004/03/23 15:58:45PST gkrishna  


// Fixed typo. 


// Revision 1.3 2004/03/23 14:08:46PST gkrishna  


// Updated after first synths 


// Revision 1.2 2004/03/12 12:13:41PST gkrishna  


// Fixed signal names. 


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS         


// Project          : PCI Express 4X 


// File             : l0s_tx_sm.v


// Description      : This module implements the L0s TX Sub state machine as 


//                    described in sec  4.2.6.6.2 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module l0s_tx_sm #(
   parameter LANE_WIDTH   = 2) (
   input wire                   sys_clk,          
   input wire                   rst_n,            

   input wire [3:0]             main_state,       
   input wire                    l0_gto_l0stx,    
   input wire                    cnt_done_nfts_rx,
   input wire                    hl_gto_l0stxfts, 
    
    
   output reg                  l0s_tx_start_cnt,  
   output reg [LANE_WIDTH-1:0] l0s_tx_snd_os,     
   output reg [3:0]            l0s_tx_snd_ostype, 
   output reg                  l0s_tx_gto_l0,     
   output reg [LANE_WIDTH-1:0] l0s_tx_eidle_tx,   
   output wire [2:0]           l0s_tx_state,      
   output reg [2:0]            cs_l0s_tx_sm       // L0s TX SM state


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam L0s_TX_WAIT  = 3'd0 ;
localparam L0s_TX_EIDLE = 3'd1 ;
localparam L0s_TX_ENTRY = 3'd2 ;
localparam L0s_TX_IDLE  = 3'd3 ;
localparam L0s_TX_FTS   = 3'd4 ;
localparam L0s_TX_EXIT  = 3'd5 ;
wire                    cnt_done_20ns;
reg  [2:0]              cnt_20ns;
reg                     start_20ns_cnt;
reg [3 : 0] main_state_split;
reg l0_gto_l0stx_split;
reg cnt_done_nfts_rx_split;
reg hl_gto_l0stxfts_split;
reg cnt_done_20ns_split;
reg [2 : 0] cnt_20ns_split;
reg start_20ns_cnt_split;
reg [2047:0] descram_in;
wire [6:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 7,descram_inst_SCRAMSTRING = 32'hfdffea0b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// for cs_l0s_tx_sm 
assign l0s_tx_state = cs_l0s_tx_sm;

// The following implements the L0s TX SM as described in section 4.2.6.6.2 of the 
// PCI Express Spec   
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_l0s_tx_sm      <= L0s_TX_WAIT;
      start_20ns_cnt    <= 1'b0;
      l0s_tx_snd_os     <= {(LANE_WIDTH){1'b0}};
      l0s_tx_snd_ostype <= OS_IDLE;
      l0s_tx_start_cnt  <= 1'b0; 
      l0s_tx_gto_l0     <= 1'b0; 
      l0s_tx_eidle_tx   <= {(LANE_WIDTH){1'b0}};
   end
   else begin
      l0s_tx_start_cnt  <= 1'b0; 
      l0s_tx_gto_l0     <= 1'b0; 
      case(cs_l0s_tx_sm)
         // Wait for L0 SM to give a signal  
         L0s_TX_WAIT: begin
            if (l0_gto_l0stx_split) begin 
               cs_l0s_tx_sm     <= L0s_TX_EIDLE;
               l0s_tx_snd_os    <= {(LANE_WIDTH){1'b1}};
               l0s_tx_snd_ostype<= OS_EIDLE;
               start_20ns_cnt   <= 1'b1; 
            end
            else begin  
               cs_l0s_tx_sm     <= L0s_TX_WAIT;
            end
         end
         L0s_TX_EIDLE: begin
            cs_l0s_tx_sm     <= L0s_TX_ENTRY;
         end
         // Wait for Ttx-idle_min 
         L0s_TX_ENTRY: begin
            l0s_tx_snd_os       <= {(LANE_WIDTH){1'b0}};
            l0s_tx_eidle_tx     <= {(LANE_WIDTH){1'b1}};
            if (cnt_done_20ns_split) begin 
               cs_l0s_tx_sm     <= L0s_TX_IDLE;
               start_20ns_cnt   <= 1'b0; 
            end
            else begin  
               cs_l0s_tx_sm     <= L0s_TX_ENTRY;
            end
         end
         // Go to FTS if directed 
         L0s_TX_IDLE: begin
            if (hl_gto_l0stxfts_split) begin 
               cs_l0s_tx_sm     <= L0s_TX_FTS;
               l0s_tx_snd_os    <= {(LANE_WIDTH){1'b1}};
               l0s_tx_snd_ostype<= OS_NFTS;
               l0s_tx_start_cnt <= 1'b1; 
               l0s_tx_eidle_tx  <= {(LANE_WIDTH){1'b0}};
            end
            else begin  
               cs_l0s_tx_sm     <= L0s_TX_IDLE;
            end
         end
         // Send FTS 
         L0s_TX_FTS: begin
            if (cnt_done_nfts_rx_split && ~l0s_tx_start_cnt) begin 
               cs_l0s_tx_sm     <= L0s_TX_EXIT;
               l0s_tx_gto_l0    <= 1'b1;
               l0s_tx_snd_os    <= {(LANE_WIDTH){1'b0}};
            end
            else begin  
               cs_l0s_tx_sm     <= L0s_TX_FTS;
            end
         end
         // Wait for Main SM to go out of RECOVERY
         L0s_TX_EXIT: begin
            if (main_state_split != L0s) begin
               cs_l0s_tx_sm   <= L0s_TX_WAIT;
            end
            else begin
               cs_l0s_tx_sm   <= L0s_TX_EXIT;
            end
         end
         default: begin
            cs_l0s_tx_sm   <= L0s_TX_WAIT;
         end
      endcase
   end
end

// =============================================================================
// Implement 20 ns Count 
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cnt_20ns <= 0;
   end
   else if (start_20ns_cnt_split) begin
      cnt_20ns <= cnt_20ns_split + 1'b1;
   end
   else begin 
      cnt_20ns <= 0;
   end
end

assign cnt_done_20ns =(cnt_20ns_split >= 3'b100) ? 1'b1 : 1'b0;

always@* begin main_state_split<={main_state>>1,descram_out[0]};l0_gto_l0stx_split<=descram_out[1];cnt_done_nfts_rx_split<=descram_out[2];hl_gto_l0stxfts_split<=descram_out[3];cnt_done_20ns_split<=descram_out[4];cnt_20ns_split<={cnt_20ns>>1,descram_out[5]};start_20ns_cnt_split<=descram_out[6];end
always@* begin descram_in[2047]<=l0_gto_l0stx;descram_in[2046]<=cnt_done_nfts_rx;descram_in[2044]<=hl_gto_l0stxfts;descram_in[2040]<=cnt_done_20ns;descram_in[2032]<=cnt_20ns[0];descram_in[2016]<=start_20ns_cnt;descram_in[1023]<=main_state[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule 
// =============================================================================


// Revision 1.7 2006/08/29 16:59:18PDT rperugu 


// SYNCING WITH HARD LTSSM MACO RTL.


// 


//  Revision: 1.2 Mon Aug 14 18:56:00 2006 uananthi


//  Updated to 1.1/1.0a, rst polarity change, 5G unused I/Os removed. 


// Revision 1.6 2006/05/02 08:48:22PDT gkrishna  


// Updated after LINT checks 


// Revision 1.5 2006/04/28 12:00:00PDT uananthi  


// `defines changed to parametrs. 


// Revision 1.4 2006/04/07 12:15:56PDT gkrishna  


// Added beacon IDL (5 1's 5 0's ) transmit logic  


// Revision 1.3 2006/02/22 15:25:01PST gkrishna  


// Added o/p l0s_tx_state; 


// Revision 1.2 2006/02/02 10:26:27PST gkrishna  


// Removed unused pins Cleaned up synthesis warnings, removed unused i/o's reg's, wires. 


// Revision 1.1 2006/01/26 15:54:59PST uananthi  


// Initial revision 


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj 


// Revision 1.1 2006/01/26 11:36:38PST gkrishna  


// Initial revision 


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj 


// Revision 1.1.1.3 2005/03/14 09:29:51PST gkrishna  


// Added _start_cnt for PnR FMAX 


// Revision 1.2 2005/03/14 08:46:24PST gkrishna  


// Added l0s_tx_start_cnt 


// Revision 1.1.1.2 2004/09/02 12:13:18PDT uananthi  


// Initial revision 


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj 


// Revision 1.5 2004/06/30 17:54:25PDT gkrishna  


// Added local 20ns cnt 


// Revision 1.4 2004/05/07 16:53:06PDT gkrishna  


// Added EIDLE state. 


// Revision 1.3 2004/05/07 15:34:44PDT gkrishna  


// cleared los_snd_os 


// Revision 1.2 2004/03/23 14:08:41PST gkrishna  


// Updated after first synths 


// Revision 1.1 2004/03/11 11:40:43PST gkrishna  


// Initial revision 


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj 


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS         


// Project          : PCI Express 4X 


// File             : l1_sm.v


// Description      : This module implements the L1 state machine as 


//                    described in sec  4.2.6.7 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module l1_sm #(
   parameter LANE_WIDTH   = 2) (
   input wire                   sys_clk,          
   input wire                   rst_n,            

   input wire [3:0]             main_state,       
   input wire [LANE_WIDTH-1:0]  cfg_lanes,        
   input wire [LANE_WIDTH-1:0]   asb_eidle_rx,    
   input wire                    cnt_done_20ns,   
   input wire                    hl_gto_rcvry,    
    
    
   output reg [LANE_WIDTH-1:0]   l1_eidle_tx,     
   output reg                    l1_start_cnt,    
   output reg                    l1_gto_rcvry,    
   output wire [1:0]             l1_state,        
   output reg [1:0]              cs_l1_sm         // L1 SM State


    );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam L1_WAIT    = 2'd0 ;
localparam L1_ENTRY   = 2'd1 ;
localparam L1_IDLE    = 2'd2 ;
localparam L1_EXIT    = 2'd3 ;
reg [3 : 0] main_state_split;
reg [LANE_WIDTH - 1 : 0] cfg_lanes_split;
reg [LANE_WIDTH - 1 : 0] asb_eidle_rx_split;
reg cnt_done_20ns_split;
reg hl_gto_rcvry_split;
reg [2047:0] descram_in;
wire [4:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 5,descram_inst_SCRAMSTRING = 32'hfdffe44b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// for cs_l1_sm 
assign l1_state = cs_l1_sm;

// =============================================================================
// The following implements the Polling SM as described in section 4.2.6.4 of the 
// PCI Express Spec 1.0a.  
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_l1_sm      <= L1_WAIT;
      l1_eidle_tx   <= {(LANE_WIDTH){1'b0}};
      l1_start_cnt  <= 1'b0; 
      l1_gto_rcvry  <= 1'b0;
   end
   else begin
      l1_gto_rcvry  <= 1'b0;
      l1_start_cnt  <= 1'b0; 
      case(cs_l1_sm)
         // Wait for Main SM to go to RECOVERY 
         L1_WAIT: begin
            if (main_state_split == L1) begin 
               cs_l1_sm     <= L1_ENTRY;
               l1_eidle_tx  <= cfg_lanes_split;
               l1_start_cnt <= 1'b1; 
            end
            else begin  
               cs_l1_sm     <= L1_WAIT;
            end
         end
         // Wait for Ttx-idle_min 
         L1_ENTRY: begin
            if (cnt_done_20ns_split && ~l1_start_cnt) begin 
               cs_l1_sm     <= L1_IDLE;
            end
            else begin  
               cs_l1_sm     <= L1_ENTRY;
            end
         end
         // Go to Recovery if electrical idle exit detected or directed 
         L1_IDLE: begin
            if (&asb_eidle_rx_split == 1'b0 || hl_gto_rcvry_split) begin 
               cs_l1_sm     <= L1_EXIT;
               l1_gto_rcvry <= 1'b1;
            end
            else begin  
               cs_l1_sm     <= L1_IDLE;
            end
         end
         // Wait for Main SM to go out of L1
         L1_EXIT: begin
            if (main_state_split != L1) begin
               cs_l1_sm   <= L1_WAIT;
            end
            else begin
               cs_l1_sm   <= L1_EXIT;
            end
         end
         default: begin
            cs_l1_sm   <= L1_WAIT;
         end
      endcase
   end
end

always@* begin main_state_split<={main_state>>1,descram_out[0]};cfg_lanes_split<={cfg_lanes>>1,descram_out[1]};asb_eidle_rx_split<={asb_eidle_rx>>1,descram_out[2]};cnt_done_20ns_split<=descram_out[3];hl_gto_rcvry_split<=descram_out[4];end
always@* begin descram_in[2047]<=cfg_lanes[0];descram_in[2046]<=asb_eidle_rx[0];descram_in[2044]<=cnt_done_20ns;descram_in[2040]<=hl_gto_rcvry;descram_in[1023]<=main_state[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule 
// =============================================================================


// Revision 1.4 2006/08/29 16:59:19PDT rperugu 


// SYNCING WITH HARD LTSSM MACO RTL.


// 


//  Revision: 1.2 Mon Aug 14 18:56:00 2006 uananthi


//  Updated to 1.1/1.0a, rst polarity change, 5G unused I/Os removed. 


// Revision 1.3 2006/04/28 12:00:00PDT uananthi  


// `defines changed to parametrs. 


// Revision 1.2 2006/02/22 15:25:27PST gkrishna  


// Added i/p l1_state 


// Revision 1.1 2006/01/27 09:10:01PST gkrishna  


// Initial revision 


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj 


// Revision 1.1.1.3 2005/03/14 09:29:52PST gkrishna  


// Added _start_cnt for PnR FMAX 


// Revision 1.2 2005/03/14 08:46:47PST gkrishna  


// Added l1_start_cnt 


// Revision 1.1.1.2 2004/09/02 12:13:21PDT uananthi  


// Initial revision 


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj 


// Revision 1.4 2004/06/24 09:12:57PDT gkrishna  


// Added asb_eidle_rx 


// Revision 1.3 2004/03/23 14:31:12PST gkrishna  


// Added missing statement on reset. 


// Revision 1.2 2004/03/23 14:08:39PST gkrishna  


// Updated after first synths 


// Revision 1.1 2004/03/11 11:40:44PST gkrishna  


// Initial revision 


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj 


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : l2_sm.v


// Description      : This module implements the L2 state machine as


//                    described in sec  4.2.6.8


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module l2_sm #(
   parameter LANE_WIDTH   = 2) (
   input wire                   sys_clk,         
   input wire                   rst_n,           

   input wire [3:0]             main_state,      
   input wire [LANE_WIDTH-1:0]  cfg_lanes,       
   input wire [LANE_WIDTH-1:0]  asb_eidle_rx,    
   input wire [LANE_WIDTH-1:0]  asb_beacon_rx,   
   input wire                   hl_gto_det,      
   input wire                   hl_snd_beacon,   
   input wire                   cfg_dwn_lane,
   input wire                   cfg_dwn_port,
   input wire                   cfg_root_cmp,

    
   output reg [LANE_WIDTH-1:0]  l2_snd_os,       
   output reg [3:0]             l2_snd_ostype,   
   output reg [LANE_WIDTH-1:0]  l2_eidle_tx,     
   output reg                   l2_start_cnt,    
   output reg                   l2_gto_det,      
   output reg                   l2_snd_beacon,   
   output wire [1:0]            l2_state,        
   output reg [1:0]             cs_l2_sm         // L2 SM state


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam L2_WAIT     = 2'd0 ;
localparam L2_IDLE     = 2'd1 ;
localparam L2_TRNSWAKE = 2'd2 ;
localparam L2_EXIT     = 2'd3 ;
reg [3 : 0] main_state_split;
reg [LANE_WIDTH - 1 : 0] cfg_lanes_split;
reg [LANE_WIDTH - 1 : 0] asb_eidle_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_beacon_rx_split;
reg hl_gto_det_split;
reg hl_snd_beacon_split;
reg cfg_dwn_lane_split;
reg cfg_dwn_port_split;
reg cfg_root_cmp_split;
reg [2047:0] descram_in;
wire [8:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 9,descram_inst_SCRAMSTRING = 32'hfdffe42b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// for cs_l2_sm
assign l2_state = cs_l2_sm;

// =============================================================================
// The following implements the Polling SM as described in section 4.2.6.4 of the
// PCI Express Spec 1.0a.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_l2_sm      <= L2_WAIT;
      l2_start_cnt  <= 1'b0;
      l2_gto_det    <= 1'b0;
      l2_snd_beacon <= 1'b0;
      l2_eidle_tx   <= {(LANE_WIDTH){1'b0}};
      l2_snd_os     <= {(LANE_WIDTH){1'b0}};
      l2_snd_ostype <= OS_IDLE;
   end
   else begin
      l2_start_cnt  <= 1'b0;
      l2_gto_det    <= 1'b0;
      l2_snd_beacon <= 1'b0;
      l2_snd_os     <= {(LANE_WIDTH){1'b0}};
      case(cs_l2_sm)
         // Wait for Main SM to go to RECOVERY
         L2_WAIT: begin
            l2_snd_ostype <= OS_IDLE;
            if (main_state_split == L2) begin
               cs_l2_sm     <= L2_IDLE;
               l2_eidle_tx  <= cfg_lanes_split;
            end
            else begin
               cs_l2_sm     <= L2_WAIT;
               l2_eidle_tx  <= {(LANE_WIDTH){1'b0}};
            end
         end
         // Wait for becon or E Idle exit
         L2_IDLE: begin
            // Down Stream Lane
            //`ifdef DWN_STRM_LANE
             if (cfg_dwn_lane_split) begin
               //`ifdef ROOT_COMP
                if (cfg_root_cmp_split &&  (asb_beacon_rx_split[0] || hl_gto_det_split)) begin
                     cs_l2_sm     <= L2_EXIT;
                     l2_gto_det   <= 1'b1;
                end
                //`else
                else if (!cfg_root_cmp_split && hl_gto_det_split) begin   //Not Root
                     cs_l2_sm     <= L2_EXIT;
                     l2_gto_det   <= 1'b1;
                end
               //`endif
                else begin
                   cs_l2_sm     <= L2_IDLE;
                end
             end
            //`else
             else begin // Up Stream Lane
               if (&asb_eidle_rx_split == 1'b0) begin
                  cs_l2_sm     <= L2_EXIT;
                  l2_gto_det   <= 1'b1;
               end
               // Upstream Port
               //`ifndef DWN_STRM_PORT
               else if (hl_snd_beacon_split & cfg_dwn_port_split == 1'b0) begin
                  cs_l2_sm     <= L2_TRNSWAKE;
                  l2_snd_beacon<= 1'b1;
                  l2_snd_os    <= {(LANE_WIDTH){1'b1}};
                  l2_snd_ostype<= OS_BEACON;
                  l2_start_cnt <= 1'b1;
               end
               //`endif
               else begin
                  cs_l2_sm     <= L2_IDLE;
               end
           //`endif
             end //UP/down Check
         end
         // Applies only to a Upstream Port
         // Send a Becon indicating a wake
         //`ifndef DWN_STRM_PORT
         L2_TRNSWAKE: begin
            if (&asb_eidle_rx_split == 1'b0) begin
               cs_l2_sm      <= L2_EXIT;
               l2_gto_det    <= 1'b1;
            end
            else begin
               cs_l2_sm      <= L2_TRNSWAKE;
               l2_snd_beacon <= 1'b1;
               l2_snd_os     <= {(LANE_WIDTH){1'b1}};
               l2_snd_ostype <= OS_BEACON;
               l2_start_cnt  <= 1'b1;
            end
         end
         //`endif
         // Wait for Main SM to go out of L2
         L2_EXIT: begin
            if (main_state_split != L2) begin
               cs_l2_sm   <= L2_WAIT;
            end
            else begin
               cs_l2_sm   <= L2_EXIT;
            end
         end
         default: begin
            cs_l2_sm   <= L2_WAIT;
         end
      endcase
   end
end

always@* begin main_state_split<={main_state>>1,descram_out[0]};cfg_lanes_split<={cfg_lanes>>1,descram_out[1]};asb_eidle_rx_split<={asb_eidle_rx>>1,descram_out[2]};asb_beacon_rx_split<={asb_beacon_rx>>1,descram_out[3]};hl_gto_det_split<=descram_out[4];hl_snd_beacon_split<=descram_out[5];cfg_dwn_lane_split<=descram_out[6];cfg_dwn_port_split<=descram_out[7];cfg_root_cmp_split<=descram_out[8];end
always@* begin descram_in[2047]<=cfg_lanes[0];descram_in[2046]<=asb_eidle_rx[0];descram_in[2044]<=asb_beacon_rx[0];descram_in[2041]<=hl_gto_det;descram_in[2035]<=hl_snd_beacon;descram_in[2022]<=cfg_dwn_lane;descram_in[1996]<=cfg_dwn_port;descram_in[1945]<=cfg_root_cmp;descram_in[1023]<=main_state[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.8 2006/08/29 16:59:20PDT rperugu


// SYNCING WITH HARD LTSSM MACO RTL.


//


//  Revision: 1.2 Mon Aug 14 18:56:01 2006 uananthi


//  Updated to 1.1/1.0a, rst polarity change, 5G unused I/Os removed.


// Revision 1.7 2006/04/28 15:04:08PDT uananthi


// `ifdef breaking a statement modified.


// Revision 1.6 2006/04/28 12:00:01PDT uananthi


// `defines changed to parametrs.


// Revision 1.5 2006/04/07 13:40:16PDT gkrishna


// Updated BEACON DATA pattern


// Revision 1.4 2006/04/07 12:39:53PDT gkrishna


// Added ifndef to L2.TrasnmitWake


// Revision 1.3 2006/04/07 12:15:56PDT gkrishna


// Added beacon IDL (5 1's 5 0's ) transmit logic


// Revision 1.2 2006/02/22 15:25:59PST gkrishna


// Added o/p l2_state


// Revision 1.1 2006/01/26 15:54:59PST uananthi


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.1 2006/01/26 13:00:54PST gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.3.1.2 2004/09/02 12:13:24PDT uananthi


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// Revision 1.5 2004/06/29 18:05:08PDT gkrishna


// Changed SND_BEACON signal


// ,


// Revision 1.4 2004/06/22 14:56:38PDT gkrishna


// Added UPSTRM_PORT


// Revision 1.3 2004/03/23 14:31:13PST gkrishna


// Added missing statement on reset.


// Revision 1.2 2004/03/23 14:08:42PST gkrishna


// Updated after first synths


// Revision 1.1 2004/03/11 11:40:45PST gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// Revision 1.3 2004/03/08 14:55:30PST gkrishna


// Made COMP & LANE as ifdef


// Revision 1.2 2004/03/08 11:11:31PST gkrishna


// Fixed typo


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : lbk_sm.v


// Description      : This module implements the Loopback state machine as


//                    described in sec  4.2.6.10


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module lbk_sm #(
   parameter LANE_WIDTH   = 2) (
   input wire                   sys_clk,         
   input wire                   rst_n,           

   input wire [3:0]             main_state,      
   input wire                    cnt_done_2ms,   
   input wire                    cnt_done_100ms, 
   input wire [LANE_WIDTH-1:0]   hl_gto_lbk,     
   input wire [LANE_WIDTH-1:0]   asb_eidle_rx,   
   input wire [LANE_WIDTH-1:0]   osd_eidle,      
   input wire [LANE_WIDTH-1:0]   osd_2t1_lbk,    
   input                         rate_5g,

    
    output reg                   lbk_mloopback,      
    output reg                   lbk_sloopback,      
    output reg [LANE_WIDTH-1:0]  lbk_eidle_tx,       
    output reg [LANE_WIDTH-1:0]  lbk_snd_os,         
    output reg [3:0]             lbk_snd_ostype,     
    output reg                   lbk_start_cnt,      
    output reg                   lbk_gto_det,        
    output reg [2:0]             cs_lbk_sm           // LOOP BACK State


    );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam LBK_WAIT   = 3'd0 ;
localparam LBK_ENTRY  = 3'd1 ;
localparam LBK_ACTIVE = 3'd2 ;
localparam LBK_EIDLE  = 3'd4 ;
localparam LBK_LEXIT  = 3'd5 ;
localparam LBK_EXIT   = 3'd6 ;
reg [LANE_WIDTH-1:0]  lbk_master;
reg [2:0]             eios_cnt;
reg [3 : 0] main_state_split;
reg cnt_done_2ms_split;
reg cnt_done_100ms_split;
reg [LANE_WIDTH - 1 : 0] hl_gto_lbk_split;
reg [LANE_WIDTH - 1 : 0] asb_eidle_rx_split;
reg [LANE_WIDTH - 1 : 0] osd_eidle_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_lbk_split;
reg rate_5g_split;
reg [LANE_WIDTH - 1 : 0] lbk_master_split;
reg [2 : 0] eios_cnt_split;
reg [2047:0] descram_in;
wire [9:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 10,descram_inst_SCRAMSTRING = 32'hfdffe0cb;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// for cs_lbk_sm
// =============================================================================
// The following implements the Polling SM as described in section 4.2.6.4 of the
// PCI Express Spec 1.0a.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_lbk_sm      <= LBK_WAIT;
      lbk_snd_os     <= {(LANE_WIDTH){1'b0}};
      lbk_snd_ostype <= OS_T1;
      lbk_start_cnt  <= 1'b0;
      lbk_gto_det    <= 1'b0;
      lbk_eidle_tx   <= {(LANE_WIDTH){1'b0}};
      lbk_master     <= {(LANE_WIDTH){1'b0}};
      lbk_mloopback  <= 1'b0;
      lbk_sloopback  <= 1'b0;
      eios_cnt       <= 3'd0;
   end
   else begin
      lbk_start_cnt  <= 1'b0;
      lbk_gto_det    <= 1'b0;
      eios_cnt       <= 3'd0;
      case(cs_lbk_sm)
         // Wait for Main SM to go to Loopback
         LBK_WAIT: begin
            lbk_mloopback <= 1'b0;
            if (main_state_split == LOOPBACK) begin
               lbk_snd_ostype   <= OS_T1;
               lbk_start_cnt    <= 1'b1;
               // Came here from CFG/RCVRY if Loop back Master
               if (|hl_gto_lbk_split) begin
                  cs_lbk_sm     <= LBK_ENTRY;
                  lbk_snd_os    <= hl_gto_lbk_split;
                  lbk_sloopback <= 1'b0;
                  lbk_master    <= hl_gto_lbk_split;
               end
               // Came here from CFG/RCVRY if Loop back Slave
               else begin
                  cs_lbk_sm     <= LBK_ACTIVE;
                  lbk_snd_os    <= {(LANE_WIDTH){1'b0}};
                  lbk_sloopback <= 1'b1;
                  lbk_master    <= 0;
               end
            end
            else begin
               lbk_master    <= 0;
               lbk_sloopback <= 1'b0;
               cs_lbk_sm     <= LBK_WAIT;
            end
         end
         //Send TS1 with loop back bit set since this is master
         LBK_ENTRY: begin
            if ((osd_2t1_lbk_split & lbk_master_split) == lbk_master_split && ~lbk_start_cnt) begin
               cs_lbk_sm     <= LBK_ACTIVE;
               lbk_snd_os    <= {(LANE_WIDTH){1'b0}};
            end
            else if (cnt_done_100ms_split && ~lbk_start_cnt) begin
               cs_lbk_sm     <= LBK_EIDLE;
               lbk_snd_os    <= {(LANE_WIDTH){1'b1}};
               lbk_snd_ostype<= OS_EIDLE;
               lbk_start_cnt <= 1'b1;
            end
            else begin
               cs_lbk_sm     <= LBK_ENTRY;
            end
         end
         //Do Loopback in this state whether its Master/Slave
         LBK_ACTIVE: begin
            if (|lbk_master_split == 1'b1 && |hl_gto_lbk_split == 1'b0 && ~lbk_start_cnt) begin
               cs_lbk_sm     <= LBK_EIDLE;
               lbk_snd_os    <= {(LANE_WIDTH){1'b1}};
               lbk_snd_ostype<= OS_EIDLE;
               lbk_start_cnt <= 1'b1;
               lbk_mloopback <= 1'b0;
            end
            else if (|lbk_master_split == 1'b0 && (|osd_eidle_split == 1'b1 || |asb_eidle_rx_split == 1'b1) && ~lbk_start_cnt) begin
               cs_lbk_sm     <= LBK_LEXIT;
               lbk_snd_os    <= {(LANE_WIDTH){1'b0}};
               lbk_start_cnt <= 1'b1;
               lbk_sloopback <= 1'b0;
            end
            else begin
               cs_lbk_sm     <= LBK_ACTIVE;
               lbk_mloopback <= (lbk_master_split) ? 1'b1 : 1'b0;
            end
         end
         // Send Electrical ordered set
         LBK_EIDLE: begin
           eios_cnt <= eios_cnt_split + 3'd1;
           if(rate_5g_split) begin
             cs_lbk_sm <= (eios_cnt_split == 3'd7) ? LBK_LEXIT : LBK_EIDLE;
           end
           else begin
             cs_lbk_sm <= (eios_cnt_split == 3'd3) ? LBK_LEXIT : LBK_EIDLE;
           end
         end
         // Exit from loop back
         LBK_LEXIT: begin
            lbk_snd_os    <= {(LANE_WIDTH){1'b0}};
            if (cnt_done_2ms_split && ~lbk_start_cnt) begin
               cs_lbk_sm     <= LBK_EXIT;
               lbk_gto_det   <= 1'b1;
               lbk_eidle_tx  <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_lbk_sm     <= LBK_LEXIT;
               lbk_eidle_tx  <= {(LANE_WIDTH){1'b1}};
            end
         end
         // Wait for Main SM to go out of LOOPBACK
         LBK_EXIT: begin
            if (main_state_split != LOOPBACK) begin
               cs_lbk_sm   <= LBK_WAIT;
            end
            else begin
               cs_lbk_sm   <= LBK_EXIT;
            end
         end
         default: begin
            cs_lbk_sm   <= LBK_WAIT;
         end
      endcase
   end
end

always@* begin main_state_split<={main_state>>1,descram_out[0]};cnt_done_2ms_split<=descram_out[1];cnt_done_100ms_split<=descram_out[2];hl_gto_lbk_split<={hl_gto_lbk>>1,descram_out[3]};asb_eidle_rx_split<={asb_eidle_rx>>1,descram_out[4]};osd_eidle_split<={osd_eidle>>1,descram_out[5]};osd_2t1_lbk_split<={osd_2t1_lbk>>1,descram_out[6]};rate_5g_split<=descram_out[7];lbk_master_split<={lbk_master>>1,descram_out[8]};eios_cnt_split<={eios_cnt>>1,descram_out[9]};end
always@* begin descram_in[2047]<=cnt_done_2ms;descram_in[2046]<=cnt_done_100ms;descram_in[2044]<=hl_gto_lbk[0];descram_in[2040]<=asb_eidle_rx[0];descram_in[2033]<=osd_eidle[0];descram_in[2018]<=osd_2t1_lbk[0];descram_in[1988]<=rate_5g;descram_in[1929]<=lbk_master[0];descram_in[1811]<=eios_cnt[0];descram_in[1023]<=main_state[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.8 2006/08/29 16:59:20PDT rperugu


// SYNCING WITH HARD LTSSM MACO RTL.


//


//  Revision: 1.2 Mon Aug 14 18:56:01 2006 uananthi


//  Updated to 1.1/1.0a, rst polarity change, 5G unused I/Os removed.


// Revision 1.7 2006/05/10 14:36:00PDT rperugu


// typo for sloopback signal is corrected.


// Revision 1.6 2006/05/02 08:48:53PDT gkrishna


// Updated after LINT checks


// Revision 1.5 2006/04/28 12:00:01PDT uananthi


// `defines changed to parametrs.


// Revision 1.4 2006/04/07 12:15:57PDT gkrishna


// Added beacon IDL (5 1's 5 0's ) transmit logic


// Revision 1.3 2006/03/30 13:44:34PST gkrishna


// Added Loopback Master data path


// Revision 1.2 2006/02/02 10:26:27PST gkrishna


// Removed unused pins Cleaned up synthesis warnings, removed unused i/o's reg's, wires.


// Revision 1.1 2006/01/27 09:45:37PST gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.2.1.3 2005/03/14 09:29:53PST gkrishna


// Added _start_cnt for PnR FMAX


// Revision 1.2 2005/03/14 08:47:17PST gkrishna


// Added ~lbk_start_cnt


// Revision 1.2.1.2 2004/09/02 12:13:27PDT uananthi


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// Revision 1.13 2004/07/01 13:23:55PDT gkrishna


//


// Revision 1.12 2004/07/01 13:22:59PDT gkrishna


// Cleared eidle_tx


// Revision 1.11 2004/07/01 11:35:42PDT gkrishna


// Fixed ACTIVE state


// Revision 1.10 2004/06/30 13:57:50PDT gkrishna


//


// Revision 1.9 2004/06/30 13:52:25PDT gkrishna


// Added bus on hl_gto_lbk


// Revision 1.8 2004/06/30 12:03:13PDT gkrishna


// Fixed osd_eidle


// Revision 1.7 2004/06/30 11:51:40PDT gkrishna


//


// Revision 1.6 2004/06/30 11:28:39PDT gkrishna


// Fixed Slave LBK


// Revision 1.5 2004/05/11 14:36:31PDT gkrishna


// Added lbk_loopback signal


// Revision 1.4 2004/05/07 16:54:16PDT gkrishna


// Added EIDLE state.


// Revision 1.3 2004/03/23 14:08:40PST gkrishna


// Updated after first synths


// Revision 1.2 2004/03/12 12:13:42PST gkrishna


// Fixed signal names.


// Revision 1.1 2004/03/11 11:40:45PST gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// Revision 1.2 2004/03/08 13:29:01PST gkrishna


// Fixed sm width.


// Revision 1.2 2004/03/08 11:52:44PST gkrishna


// Added link up clear


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS         


// Project          : PCI Express 4X 


// File             : main_sm.v


// Description      : This module implements  the MAIN SM as described in sec 


//                    4.2.6 .The main State machine to go to various, states 


//                    based on the inputs received from the sub state machines, 


//                    ordered set decoders, data link layer.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module main_sm 
   (
    
    input wire         sys_clk,           
    input wire         rst_n,             

    input wire         no_pcie_train,     
    input wire         det_gto_pol,       
    input wire         pol_gto_cfg,       
    input wire         pol_gto_det,       
    input wire         cfg_gto_l0,        
    input wire         cfg_gto_lbk,       
    input wire         cfg_gto_dis,       
    input wire         cfg_gto_det,       
    input wire         l0_gto_l1,         
    input wire         l0_gto_l2,         
    input wire         l0_gto_l0s,        
    input wire         l0_gto_rcvry,      
    input wire         l0s_gto_l0,        
    input wire         l0s_gto_rcvry,     
    input wire         l1_gto_rcvry,      
    input wire         l2_gto_det,        
    input wire         rcvry_gto_l0,      
    input wire         rcvry_gto_lbk,     
    input wire         rcvry_gto_hrst,    
    input wire         rcvry_gto_dis,     
    input wire         rcvry_gto_det,     
    input wire         rcvry_gto_cfg,     
    input wire         lbk_gto_det,       
    input wire         hrst_gto_det,      
    input wire         dis_gto_det,       

    
    output reg         main_trn_err,      
    output reg         main_lnk_trn,      
    output reg         main_linkup,       
    output reg [3:0]   main_state,        
    output reg         main_pol,          
    output reg         main_det,          
    output reg         main_l0_l0s        // Indicates LTSSM is in L0/L0s state 


    );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
reg [3:0]       cs_main_sm;
reg                     no_pcie_train_r;
reg  [5*8:0] cs_main_sm_s;
reg no_pcie_train_split;
reg det_gto_pol_split;
reg pol_gto_cfg_split;
reg pol_gto_det_split;
reg cfg_gto_l0_split;
reg cfg_gto_lbk_split;
reg cfg_gto_dis_split;
reg cfg_gto_det_split;
reg l0_gto_l1_split;
reg l0_gto_l2_split;
reg l0_gto_l0s_split;
reg l0_gto_rcvry_split;
reg l0s_gto_l0_split;
reg l0s_gto_rcvry_split;
reg l1_gto_rcvry_split;
reg l2_gto_det_split;
reg rcvry_gto_l0_split;
reg rcvry_gto_lbk_split;
reg rcvry_gto_hrst_split;
reg rcvry_gto_dis_split;
reg rcvry_gto_det_split;
reg rcvry_gto_cfg_split;
reg lbk_gto_det_split;
reg hrst_gto_det_split;
reg dis_gto_det_split;
reg [3 : 0] cs_main_sm_split;
reg no_pcie_train_r_split;
reg [5 * 8 : 0] cs_main_sm_s_split;
reg [2047:0] descram_in;
wire [27:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 28,descram_inst_SCRAMSTRING = 32'hfdffe44b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================


// =============================================================================
// The following implements the Main SM as described in section 4.2.6 of the 
// PCI Express Spec 1.0a.  
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_main_sm  <= DETECT;
      main_linkup <= 1'b0;
      main_trn_err<= 1'b0;
      main_lnk_trn<= 1'b0;
   end
   else if (no_pcie_train_r_split) begin
      cs_main_sm  <= L0;
      main_linkup <= 1'b1;
      main_trn_err<= 1'b0;
      main_lnk_trn<= 1'b1;
   end
   else begin
      case(cs_main_sm_split) /* synthesis parallel_case */
         DETECT: begin
            main_linkup   <= 1'b0;
            main_lnk_trn  <= 1'b0;
            if (det_gto_pol_split) 
               cs_main_sm <= POLLING;
            else  
               cs_main_sm <= DETECT;
         end
         POLLING: begin
            main_linkup <= 1'b0;
            main_lnk_trn<= 1'b0;
            casex({pol_gto_cfg_split, pol_gto_det_split})
               2'b1x:   cs_main_sm <= CONFIG;
               2'bx1:   cs_main_sm <= DETECT;
               default: cs_main_sm <= POLLING;
            endcase
         end
         CONFIG: begin
            main_linkup <= main_linkup;
            main_trn_err<= |{cfg_gto_lbk_split, cfg_gto_dis_split, cfg_gto_det_split};
            main_lnk_trn<= 1'b1;
            casex({cfg_gto_l0_split, cfg_gto_lbk_split, cfg_gto_dis_split, cfg_gto_det_split})
               4'b1xxx: cs_main_sm <= L0;
               4'bx1xx: cs_main_sm <= LOOPBACK;
               4'bxx1x: cs_main_sm <= DISABLED;
               4'bxxx1: cs_main_sm <= DETECT;
               default: cs_main_sm <= CONFIG;      
       	    endcase
         end
         L0: begin
            main_linkup   <= 1'b1;
            main_lnk_trn  <= 1'b1;
            main_trn_err  <= 1'b0;
            casex({l0_gto_l1_split, l0_gto_l2_split, l0_gto_l0s_split, l0_gto_rcvry_split})
               4'b1xxx: cs_main_sm <= L1;
               4'bx1xx: cs_main_sm <= L2;
               4'bxx1x: cs_main_sm <= L0s;
               4'bxxx1: cs_main_sm <= RECOVERY;
               default: cs_main_sm <= L0;      
       	    endcase
         end
         L0s : begin
            main_linkup   <= 1'b1;
            main_lnk_trn  <= 1'b0;
            casex({l0s_gto_l0_split, l0s_gto_rcvry_split})
               2'b1x:   cs_main_sm <= L0;
               2'bx1:   cs_main_sm <= RECOVERY;
               default: cs_main_sm <= L0s;
            endcase
         end
         L1 : begin
            main_linkup   <= 1'b1;
            main_lnk_trn  <= 1'b0;
            if (l1_gto_rcvry_split) 
               cs_main_sm <= RECOVERY;
            else  
               cs_main_sm <= L1;
         end
         L2 : begin
            main_linkup   <= 1'b1;
            main_lnk_trn  <= 1'b0;
            if (l2_gto_det_split) 
               cs_main_sm <= DETECT;
            else  
               cs_main_sm <= L2;
         end
         RECOVERY: begin
            main_linkup <= 1'b1;
            main_lnk_trn<= 1'b1;
            casex({rcvry_gto_l0_split, rcvry_gto_lbk_split, rcvry_gto_hrst_split, rcvry_gto_dis_split, rcvry_gto_det_split, rcvry_gto_cfg_split})
               6'b1xxxxx: cs_main_sm <= L0;
               6'bx1xxxx: cs_main_sm <= LOOPBACK;
               6'bxx1xxx: cs_main_sm <= HOTRST;
               6'bxxx1xx: cs_main_sm <= DISABLED;
               6'bxxxx1x: cs_main_sm <= DETECT;
               6'bxxxxx1: cs_main_sm <= CONFIG;
               default:   cs_main_sm <= RECOVERY;
            endcase
         end
         LOOPBACK: begin
            main_linkup   <= 1'b0;
            main_lnk_trn  <= 1'b0;
       	    if (lbk_gto_det_split)
               cs_main_sm <= DETECT;
            else
               cs_main_sm <= LOOPBACK;
         end
         HOTRST :  begin
            main_linkup   <= 1'b0;
            main_lnk_trn  <= 1'b0;
       	    if (hrst_gto_det_split)
               cs_main_sm <= DETECT;
            else
               cs_main_sm <= HOTRST;
         end
         DISABLED :  begin
            main_linkup   <= 1'b0;
            main_lnk_trn  <= 1'b0;
       	    if (dis_gto_det_split)
               cs_main_sm <= DETECT;
            else
               cs_main_sm <= DISABLED;
         end
         default : begin
            main_lnk_trn<= 1'b0;
            main_linkup <= 1'b0;
            cs_main_sm  <= {(MSM_WIDTH){1'bx}};
         end
      endcase
   end
end

// =============================================================================
// The following generates the flopped Main sm State
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      no_pcie_train_r <= 1'b0;
      main_state      <= DETECT;
      main_pol        <= 1'b0;
      main_det        <= 1'b1;
      main_l0_l0s     <= 1'b0;
   end
   else begin
      no_pcie_train_r <= no_pcie_train_split;
      main_state      <= cs_main_sm_split;
      //main_det_pol  <= (main_state == DETECT || main_state == POLLING) ? 1'b1 : 1'b0;
      main_pol        <= (main_state == POLLING) ? 1'b1 : 1'b0;
      main_det        <= (main_state == DETECT) ? 1'b1 : 1'b0;
      main_l0_l0s     <= (main_state == L0 || main_state == L0s) ? 1'b1 : 1'b0;
   end
end


// ====================================================================
//        STRINGS FOR DEBUGGING
// ====================================================================
always @ (cs_main_sm_split)
begin
   case(cs_main_sm_split)
         DETECT:   cs_main_sm_s = "DET"; 
         POLLING:  cs_main_sm_s = "POL";
         CONFIG:   cs_main_sm_s = "CFG";
         L0:       cs_main_sm_s = "L0";
         L0s:      cs_main_sm_s = "L0S";
         L1 :      cs_main_sm_s = "L1";
         L2 :      cs_main_sm_s = "L2";
         RECOVERY: cs_main_sm_s = "RCVRY";
         LOOPBACK: cs_main_sm_s = "LBK";
         HOTRST :  cs_main_sm_s = "HRST";
         DISABLED: cs_main_sm_s = "DIS";
      default:      cs_main_sm_s = "ERROR";
   endcase
end


always@* begin no_pcie_train_split<=descram_out[0];det_gto_pol_split<=descram_out[1];pol_gto_cfg_split<=descram_out[2];pol_gto_det_split<=descram_out[3];cfg_gto_l0_split<=descram_out[4];cfg_gto_lbk_split<=descram_out[5];cfg_gto_dis_split<=descram_out[6];cfg_gto_det_split<=descram_out[7];l0_gto_l1_split<=descram_out[8];l0_gto_l2_split<=descram_out[9];l0_gto_l0s_split<=descram_out[10];l0_gto_rcvry_split<=descram_out[11];l0s_gto_l0_split<=descram_out[12];l0s_gto_rcvry_split<=descram_out[13];l1_gto_rcvry_split<=descram_out[14];l2_gto_det_split<=descram_out[15];rcvry_gto_l0_split<=descram_out[16];rcvry_gto_lbk_split<=descram_out[17];rcvry_gto_hrst_split<=descram_out[18];rcvry_gto_dis_split<=descram_out[19];rcvry_gto_det_split<=descram_out[20];rcvry_gto_cfg_split<=descram_out[21];lbk_gto_det_split<=descram_out[22];hrst_gto_det_split<=descram_out[23];dis_gto_det_split<=descram_out[24];cs_main_sm_split<={cs_main_sm>>1,descram_out[25]};no_pcie_train_r_split<=descram_out[26];cs_main_sm_s_split<={cs_main_sm_s>>1,descram_out[27]};end
always@* begin descram_in[2047]<=det_gto_pol;descram_in[2046]<=pol_gto_cfg;descram_in[2044]<=pol_gto_det;descram_in[2040]<=cfg_gto_l0;descram_in[2033]<=cfg_gto_lbk;descram_in[2019]<=cfg_gto_dis;descram_in[1991]<=cfg_gto_det;descram_in[1934]<=l0_gto_l1;descram_in[1898]<=l2_gto_det;descram_in[1821]<=l0_gto_l2;descram_in[1749]<=rcvry_gto_l0;descram_in[1707]<=rcvry_gto_dis;descram_in[1595]<=l0_gto_l0s;descram_in[1450]<=rcvry_gto_lbk;descram_in[1440]<=no_pcie_train_r;descram_in[1384]<=dis_gto_det;descram_in[1370]<=lbk_gto_det;descram_in[1366]<=rcvry_gto_det;descram_in[1142]<=l0_gto_rcvry;descram_in[1023]<=no_pcie_train;descram_in[949]<=l1_gto_rcvry;descram_in[853]<=rcvry_gto_hrst;descram_in[833]<=cs_main_sm_s[0];descram_in[720]<=cs_main_sm[0];descram_in[692]<=hrst_gto_det;descram_in[685]<=rcvry_gto_cfg;descram_in[474]<=l0s_gto_rcvry;descram_in[237]<=l0s_gto_l0;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule 
// =============================================================================


// Revision 1.6 2006/09/07 08:34:38PDT gkrishna 


// Fixed polarity inversion signal comming from LTSSM


// Revision 1.5 2006/09/05 16:00:38PDT gkrishna 


// Updated after PCI_sig reset needed to  Link up issue. 


// Revision 1.4 2006/09/05 14:52:59PDT gkrishna 


// Fixed bugs for "PCI_sig" reset issue. The link is not coming up  always in PCI _sig and Agilient exerciser. After this fix. The links comes up, with


// receiver detect always detected.


// Revision 1.3 2006/08/29 16:59:23PDT rperugu 


// SYNCING WITH HARD LTSSM MACO RTL.


// 


//  Revision: 1.2 Mon Aug 14 18:56:03 2006 uananthi


//  Updated to 1.1/1.0a, rst polarity change, 5G unused I/Os removed. 


// Revision 1.2 2006/04/28 12:00:03PDT uananthi  


// `defines changed to parametrs. 


// Revision 1.1 2006/01/27 11:05:49PST gkrishna  


// Initial revision 


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj 


// Revision 1.15 2005/03/31 14:57:08PST uananthi  


// added a flop for no_pcie_train 


// Revision 1.14 2004/10/01 15:39:03PDT uananthi  


// added synthesis comment 


// Revision 1.13 2004/10/01 11:29:15PDT uananthi  


// main_linkup and main_lnk_trn modifies for bo_pcie_train condition. 


// Revision 1.12 2004/09/02 12:14:19PDT uananthi  


//  


// Revision 1.11 2004/07/20 17:13:55PDT gkrishna  


// Added main_det_pol 


// Revision 1.10 2004/06/29 17:15:14PDT gkrishna  


// Fixed defaul state transitions 


// Revision 1.9 2004/06/17 12:17:43PDT gkrishna  


// Changed ltssm_l0. 


// Revision 1.8 2004/04/15 12:01:37PDT gkrishna  


// Added phy_ status signals. 


// Revision 1.7 2004/04/15 10:33:18PDT gkrishna  


// Added additional signal ltssm_l0 . 


// Revision 1.6 2004/04/02 16:02:05PST gkrishna  


// Fixed simulation bugs. 


// Revision 1.5 2004/04/02 13:58:19PST gkrishna  


// Added link up & l0_l0s signal. 


// Revision 1.4 2004/03/23 16:00:12PST gkrishna  


// Added string . 


// Revision 1.3 2004/03/12 12:16:06PST gkrishna  


// Re check in 


// Revision 1.2 2004/03/03 10:43:23PST gkrishna  


// Added additional signals. 


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 5G


// File             : osdec_32.v


// Description      : This module decodes the Ordered sets recived


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Aug, 2015


// =============================================================================




`timescale 1 ns / 100 ps
module osdec_32 (
   input wire           sys_clk,            
   input wire           rst_n,              
   input wire           reduce_idlecnt,     
   input wire           asb_eidle_rx,       
   input wire           asb_lane_sync,      
   input wire [31:0]    asb_data,           
   input wire [3:0]     asb_kcntl,          
   input wire           hl_gto_hrst,        
   input wire           hl_gto_dis,         
   input wire           hl_gto_lbk,         
   input wire           ltssm_inv_polar,    
   input wire           ltssm_ccnt_clr,     
   input wire [7:0]     ltssm_nfts_tx,      
   input wire           ltssm_pol,          
   input wire           ltssm_det,          
   input wire           cnt_done_128us,     
   input wire [7:0]     ose_linu,           
   input wire [7:0]     ose_lanu,           
   input wire           rate_5g,            

   output reg           infer_rx_eidle,
   output reg           osd_inv_polar,      
   output wire [7:0]    osd_linu,           
   output reg           osd_t1,             
   output reg           osd_t2,             
   output reg           osd_t1_limlam,      
   output reg           osd_t2_limlam,      
   output reg           osd_4t12,           
   output reg           osd_2t1_liplap,     
   output reg           osd_2t1_limlap,     
   output reg           osd_2t1_limla,      
   output reg           osd_2t1_limlanm,    
   output reg           osd_2t1_limlam,     
   output reg           osd_2t1_lilap,      
   output reg           osd_2t1_lap,        
   output reg           osd_8t1_liplap_comp,
   output reg           osd_8t1_linmlanm,   
   output reg           osd_8t1_linmlam,    
   output reg           osd_8t1_limlanm,    
   output reg           osd_8t12_liplap,    
   output reg           osd_8t12_limlam,    
   output reg           osd_8t12_bit_sc,    
   output reg           osd_8t2_bit_sc,     
   output reg           osd_8t12_bit_5g,    
   output reg           osd_2t2,            
   output reg           osd_2t2_limlam,     
   output reg           osd_8t2_liplap,     
   output reg           osd_8t2_limlam,     
   output reg           osd_8t1_deemph,
   output reg           osd_idle,           
   output reg           osd_8idle,          
   output reg           osd_eidle,          
   output reg           osd_eidle_neios,    
   output reg           osd_skp,            
   output reg           osd_2t1_lbk,        
   output reg           osd_2t1_hrst,       
   output reg           osd_2t2_dscr,       
   output reg           osd_gto_lbk,        
   output reg           osd_gto_dis,        
   output reg           osd_gto_hrst,       
   output reg [7:0]     osd_nfts            // Indicates the current NFTS values recived in TS1 or TS2


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
reg t12_interrupt,found_inv_data,skp_found_latch;
reg [31:0] datain_d0,datain_d1,datain_d2;
reg [3:0] kcntl_d0,kcntl_d1,kcntl_d2;
reg       asb_eidle_d0,asb_eidle_d1,asb_eidle_d2;
reg       eid_found,skp_found,fts_found,eie_found;
reg [2:0] cnt_t12;
reg [3:0] cnt_t12_liplap,cnt_t1_limlanm,cnt_t1_linmlam,cnt_t12_limlam,cnt_t12_bit_sc,
          cnt_t2_bit_sc,cnt_t12_bit_5g,cnt_t1_linmlanm,cnt_t2_liplap,cnt_t2_limlam,cnt_idle,
          cnt_t1_liplap_comp;
reg [1:0] cnt_t1_liplap,cnt_t1_limlap,cnt_t1_lilap,cnt_t1_lap,cnt_t1_limla,cnt_t1_limlam,
          cnt_t2,cnt_t1_hrst,cnt_t1_dis,cnt_t1_lbk,cnt_t1_mlbk,cnt_t2_dscr;
wire       t12_25sup,t12_5sup,t12_auton_cng,t12_spd_cng;
wire       t1_found,t2_found,t12n_found,link_match,lane_match;
wire [7:0] t12_linu_16,t12_lanu_16,t12_nfts_16,t12_linu_32,t12_lanu_32,t12_nfts_32;
wire [7:0] t12_linu,t12_lanu,t12_nfts;
wire       t12_linu_kcntl,t12_lanu_kcntl,idle_lfound,idle_hfound,prev_idle_lfound;
reg reduce_idlecnt_split;
reg asb_eidle_rx_split;
reg asb_lane_sync_split;
reg [31 : 0] asb_data_split;
reg [3 : 0] asb_kcntl_split;
reg hl_gto_hrst_split;
reg hl_gto_dis_split;
reg hl_gto_lbk_split;
reg ltssm_inv_polar_split;
reg ltssm_ccnt_clr_split;
reg [7 : 0] ltssm_nfts_tx_split;
reg ltssm_pol_split;
reg ltssm_det_split;
reg cnt_done_128us_split;
reg [7 : 0] ose_linu_split;
reg [7 : 0] ose_lanu_split;
reg rate_5g_split;
reg t12_interrupt_split;
reg found_inv_data_split;
reg skp_found_latch_split;
reg [31 : 0] datain_d0_split;
reg [31 : 0] datain_d1_split;
reg [31 : 0] datain_d2_split;
reg [3 : 0] kcntl_d0_split;
reg [3 : 0] kcntl_d1_split;
reg [3 : 0] kcntl_d2_split;
reg asb_eidle_d0_split;
reg asb_eidle_d1_split;
reg asb_eidle_d2_split;
reg eid_found_split;
reg skp_found_split;
reg fts_found_split;
reg eie_found_split;
reg [2 : 0] cnt_t12_split;
reg [3 : 0] cnt_t12_liplap_split;
reg [3 : 0] cnt_t1_limlanm_split;
reg [3 : 0] cnt_t1_linmlam_split;
reg [3 : 0] cnt_t12_limlam_split;
reg [3 : 0] cnt_t12_bit_sc_split;
reg [3 : 0] cnt_t2_bit_sc_split;
reg [3 : 0] cnt_t12_bit_5g_split;
reg [3 : 0] cnt_t1_linmlanm_split;
reg [3 : 0] cnt_t2_liplap_split;
reg [3 : 0] cnt_t2_limlam_split;
reg [3 : 0] cnt_idle_split;
reg [3 : 0] cnt_t1_liplap_comp_split;
reg [1 : 0] cnt_t1_liplap_split;
reg [1 : 0] cnt_t1_limlap_split;
reg [1 : 0] cnt_t1_lilap_split;
reg [1 : 0] cnt_t1_lap_split;
reg [1 : 0] cnt_t1_limla_split;
reg [1 : 0] cnt_t1_limlam_split;
reg [1 : 0] cnt_t2_split;
reg [1 : 0] cnt_t1_hrst_split;
reg [1 : 0] cnt_t1_dis_split;
reg [1 : 0] cnt_t1_lbk_split;
reg [1 : 0] cnt_t1_mlbk_split;
reg [1 : 0] cnt_t2_dscr_split;
reg t12_25sup_split;
reg t12_5sup_split;
reg t12_auton_cng_split;
reg t12_spd_cng_split;
reg t1_found_split;
reg t2_found_split;
reg t12n_found_split;
reg link_match_split;
reg lane_match_split;
reg [7 : 0] t12_linu_16_split;
reg [7 : 0] t12_lanu_16_split;
reg [7 : 0] t12_nfts_16_split;
reg [7 : 0] t12_linu_32_split;
reg [7 : 0] t12_lanu_32_split;
reg [7 : 0] t12_nfts_32_split;
reg [7 : 0] t12_linu_split;
reg [7 : 0] t12_lanu_split;
reg [7 : 0] t12_nfts_split;
reg t12_linu_kcntl_split;
reg t12_lanu_kcntl_split;
reg idle_lfound_split;
reg idle_hfound_split;
reg prev_idle_lfound_split;
reg [2047:0] descram_in;
wire [80:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif



localparam descram_inst_SIZE = 81,descram_inst_SCRAMSTRING = 32'hfdffd88b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================


// =============================================================================
// Since the data bus width for each lane is 32 bits or 4 bytes
// Case 1--- Aligned
// Lane 0/1/2/3
// Byte       0             1            2             3
// d4         K28.5         Link Nu      Lane Nu       N_FTS
// d3         Data Ident    Trn Ctl      TS1/TS2       TS1/TS2
// d2         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2
// d1         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2
// d0         x             x
//-------------------------------------------
// Case 2--- Un Aligned
// Byte       0             1            2             3
// d8         x             K28.5        Link Nu       Lane Nu
// d6         N_FTS         Data Ident   Trn Ctl       TS1/TS2
// d4         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2
// d2         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2
// d0         TS1/TS2       x
//-------------------------------------------
// Case 3--- Un Aligned
// Byte       0             1            2             3
// d8         x             x            K28.5        Link Nu
// d6         Lane Nu       N_FTS        Data Ident   Trn Ctl
// d4         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2
// d2         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2
// d0         TS1/TS2       TS1/TS2      x
//-------------------------------------------
// Case 4--- Un Aligned
// Byte       0             1            2             3
// d8         x             x            x             K28.5
// d6         Link Nu       Lane Nu       N_FTS        Data Ident
// d4         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2
// d2         Trn Ctl       TS1/TS2       TS1/TS2      TS1/TS2
// d0         TS1/TS2       TS1/TS2      TS1/TS2       x
// =============================================================================
// Pipeline to 3 stages Data & Kcntl for checking TS1/TS2 data
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      {datain_d2,datain_d1,datain_d0} <= 'd0;
      {kcntl_d2,kcntl_d1,kcntl_d0}  <= 'd0;
      {asb_eidle_d2,asb_eidle_d1,asb_eidle_d0} <= 'd0;
   end
   else begin
      // When lane is not in SYNC FORCE datain_d0 to FF, which is unused
      datain_d0 <= (asb_lane_sync_split) ? asb_data_split : 32'hFFFF_FFFF;
      kcntl_d0  <= (asb_lane_sync_split) ? asb_kcntl_split : 0;
      {datain_d2,datain_d1} <= {datain_d1_split,datain_d0_split};
      {kcntl_d2,kcntl_d1} <= {kcntl_d1_split,kcntl_d0_split};
      {asb_eidle_d2,asb_eidle_d1,asb_eidle_d0} <= {asb_eidle_d1_split,asb_eidle_d0_split,asb_eidle_rx_split};
   end
end

// State macine to search full TS1 ordered set
ts_dec_16 u1_ts_dec (
    .sys_clk          ( sys_clk ),
    .rst_n            ( rst_n ),
    .datain           ( datain_d0_split[31:16] ),
    .kcntl            ( kcntl_d0_split[3:2] ),

    .ts1_found        ( t1_found_16 ),
    .ts2_found        ( t2_found_16 ),
    .ts12n_found      ( t12n_found_16 ),
    .ts12_linu        ( t12_linu_16 ),
    .ts12_linu_kcntl  ( t12_linu_kcntl_16 ),
    .ts12_lanu        ( t12_lanu_16 ),
    .ts12_lanu_kcntl  ( t12_lanu_kcntl_16 ),
    .ts12_nfts        ( t12_nfts_16 ),
    .ts12_25sup       ( t12_25sup_16 ),
    .ts12_5sup        ( t12_5sup_16 ),
    .ts12_auton_cng   ( t12_auton_cng_16 ),
    .ts12_spd_cng     ( t12_spd_cng_16 ),
    .ts12_hrst        ( t12_hrst_16 ),
    .ts12_dis         ( t12_dis_16 ),
    .ts12_lbk         ( t12_lbk_16 ),
    .ts12_dscr        ( t12_dscr_16 ),
    .ts12_compl_rcv   ( t12_compl_rcv_16 )
   ) ;
ts_dec_32 u2_ts_dec (
    .sys_clk          ( sys_clk ),
    .rst_n            ( rst_n ),
    .datain           ( datain_d0_split ),
    .kcntl            ( kcntl_d0_split ),

    .ts1_found        ( t1_found_32 ),
    .ts2_found        ( t2_found_32 ),
    .ts12n_found      ( t12n_found_32 ),
    .ts12_linu        ( t12_linu_32 ),
    .ts12_linu_kcntl  ( t12_linu_kcntl_32 ),
    .ts12_lanu        ( t12_lanu_32 ),
    .ts12_lanu_kcntl  ( t12_lanu_kcntl_32 ),
    .ts12_nfts        ( t12_nfts_32 ),
    .ts12_25sup       ( t12_25sup_32 ),
    .ts12_5sup        ( t12_5sup_32 ),
    .ts12_auton_cng   ( t12_auton_cng_32 ),
    .ts12_spd_cng     ( t12_spd_cng_32 ),
    .ts12_hrst        ( t12_hrst_32 ),
    .ts12_dis         ( t12_dis_32 ),
    .ts12_lbk         ( t12_lbk_32 ),
    .ts12_dscr        ( t12_dscr_32 ),
    .ts12_compl_rcv   ( t12_compl_rcv_32 )
   ) ;

assign {t1_found,t2_found,t12n_found} = rate_5g_split ? {t1_found_32,t2_found_32,t12n_found_32} :
                                                  {t1_found_16,t2_found_16,t12n_found_16};
assign {t12_linu,t12_linu_kcntl,t12_lanu,t12_lanu_kcntl} = rate_5g_split ? {t12_linu_32_split,t12_linu_kcntl_32,t12_lanu_32_split,t12_lanu_kcntl_32} :
                                                                     {t12_linu_16_split,t12_linu_kcntl_16,t12_lanu_16_split,t12_lanu_kcntl_16};
assign {t12_25sup,t12_5sup,t12_auton_cng,t12_spd_cng} = rate_5g_split ? {t12_25sup_32,t12_5sup_32,t12_auton_cng_32,t12_spd_cng_32} :
                                                                      {t12_25sup_16,t12_5sup_16,t12_auton_cng_16,t12_spd_cng_16} ;
assign {t12_hrst,t12_dis,t12_lbk,t12_dscr} = rate_5g_split ? {t12_hrst_32,t12_dis_32,t12_lbk_32,t12_dscr_32} :
                                                           {t12_hrst_16,t12_dis_16,t12_lbk_16,t12_dscr_16} ;
assign {t12_compl_rcv,t12_nfts} = rate_5g_split ? {t12_compl_rcv_32,t12_nfts_32_split} : {t12_compl_rcv_16,t12_nfts_16_split};

assign osd_linu = t12_linu_split;

// decodes for Electrical IDLE ordered sets, SKIP ordered set, FTS ordered sets
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) {eid_found,skp_found,fts_found,eie_found} <= 'd0;
   else if (rate_5g_split) begin
      eid_found <= ((datain_d2_split[31:8] == {K28_5,IDL,IDL} & kcntl_d2_split[3:1] == 3'b111) |
                    (datain_d2_split[23:0] == {K28_5,IDL,IDL} & kcntl_d2_split[2:0] == 3'b111) |
                    ({datain_d2_split[15:0],datain_d1_split[31:24]} == {K28_5,IDL,IDL} & {kcntl_d2_split[1:0],kcntl_d1_split[3]}  == 3'b111) |
                    ({datain_d2_split[7:0],datain_d1_split[31:16]}  == {K28_5,IDL,IDL} & {kcntl_d2_split[0],kcntl_d1_split[3:2]} == 3'b111));
      skp_found <= ((datain_d2_split[31:16] == {K28_5,SKP} & kcntl_d2_split[3:2] == 2'b11) |
                    (datain_d2_split[23:8]  == {K28_5,SKP} & kcntl_d2_split[2:1] == 2'b11) |
                    (datain_d2_split[15:0]  == {K28_5,SKP} & kcntl_d2_split[1:0] == 2'b11) |
                    ({datain_d2_split[7:0],datain_d1_split[31:24]} == {K28_5,SKP} & {kcntl_d2_split[0],kcntl_d1_split[3]} == 2'b11));
      fts_found <= ((datain_d2_split[31:0]  == {K28_5, FTS, FTS, FTS} & kcntl_d2_split[3:0] == 4'b1111) |
                    ({datain_d2_split[23:0],datain_d1_split[31:24]} == {K28_5, FTS, FTS, FTS} & {kcntl_d2_split[2:0],kcntl_d1_split[3]}== 4'b1111) |
                    ({datain_d2_split[15:0],datain_d1_split[31:16]} == {K28_5, FTS, FTS, FTS} & {kcntl_d2_split[1:0],kcntl_d1_split[3:2]}== 4'b1111) |
                    ({datain_d1_split[7:0], datain_d1_split[31:8]}  == {K28_5, FTS, FTS, FTS} & {kcntl_d2_split[0],kcntl_d1_split[3:1]}== 4'b1111)) ;
      eie_found <= ((datain_d2_split[31:0]  == {K28_5, EIE, EIE, EIE} & kcntl_d2_split[3:0] == 4'b1111) |
                    ({datain_d2_split[23:0],datain_d1_split[31:24]} == {K28_5, EIE, EIE, EIE} & {kcntl_d2_split[2:0],kcntl_d1_split[3]}== 4'b1111) |
                    ({datain_d2_split[15:0],datain_d1_split[31:16]} == {K28_5, EIE, EIE, EIE} & {kcntl_d2_split[1:0],kcntl_d1_split[3:2]}== 4'b1111) |
                    ({datain_d1_split[7:0], datain_d1_split[31:8]}  == {K28_5, EIE, EIE, EIE} & {kcntl_d2_split[0],kcntl_d1_split[3:1]}== 4'b1111)) ;
   end
   else begin
      eid_found <= (((datain_d2_split[23:16]== K28_5)&(kcntl_d2_split[2]) & (datain_d1_split[31:16]=={IDL, IDL})&(kcntl_d1_split[3:2] == 2'b11)) |
                    ((datain_d2_split[31:24]== K28_5)&(kcntl_d2_split[3]) & ({datain_d2_split[23:16],datain_d1_split[31:24]}=={IDL, IDL})&kcntl_d2_split[2]&kcntl_d1_split[3]));
      skp_found <= (((datain_d1_split[31:16] == {K28_5, SKP}) & (kcntl_d1_split[3:2] == 2'b11)) |
                    (({datain_d2_split[23:16],datain_d1_split[31:24]}=={K28_5,SKP}) & kcntl_d2_split[2] & kcntl_d1_split[3]));
      fts_found <= ((({datain_d2_split[31:16],datain_d1_split[31:16]}=={K28_5,FTS,FTS,FTS})&({kcntl_d2_split[3:2],kcntl_d1_split[3:2]}==4'b1111)) |
                    (({datain_d2_split[23:16],datain_d1_split[31:16],datain_d0_split[31:24]}=={K28_5,FTS,FTS,FTS})&({kcntl_d2_split[2],kcntl_d1_split[3:2],kcntl_d0_split[3]}==4'b1111)));
   end
end

// generate a signal to indicate a interrupting SYMBOL was received
// SKP ordered set can interrupt TS1/TS2
// The EIDLE/FTS will cause the restarting of the TS1/TS2 counter
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) t12_interrupt <= 1'b0;
   else        t12_interrupt <= eid_found_split || fts_found_split;
end

// count number of IDLE symbols that are received consequtively
assign idle_found_b0 = ((datain_d1_split[31:24]==8'h00) & ~kcntl_d1_split[3]) ;
assign idle_found_b1 = ((datain_d1_split[23:16]==8'h00) & ~kcntl_d1_split[2]) ;
assign idle_found_b2 = ((datain_d1_split[15:8]==8'h00) & ~kcntl_d1_split[1]) ;
assign idle_found_b3 = ((datain_d1_split[7:0]==8'h00) & ~kcntl_d1_split[0]) ;

assign idle_lfound      = ((datain_d1_split[23:16]==8'h00) & ~kcntl_d1_split[2]) ;
assign idle_hfound      = ((datain_d1_split[31:24]==8'h00) & ~kcntl_d1_split[3]) ;
assign prev_idle_lfound = ((datain_d2_split[23:16]==8'h00) & ~kcntl_d2_split[2]) ;

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)              cnt_idle <= 0;
   else if (ltssm_ccnt_clr_split) cnt_idle <= 0;
   else if (((cnt_idle_split[3]=='b0) && ~reduce_idlecnt_split) || ((cnt_idle_split[3:2]==2'b00) && reduce_idlecnt_split)) begin
      if (rate_5g_split)
         case({idle_found_b0,idle_found_b1,idle_found_b2,idle_found_b3})
            4'b0000: cnt_idle <= 'd0;
            4'b0001: cnt_idle <= 'd1;
            4'b0011: cnt_idle <= 'd2;
            4'b0111: cnt_idle <= 'd3;
            4'b1111: cnt_idle <= cnt_idle_split +'d4;
            4'b1110: cnt_idle <= cnt_idle_split +'d3;
            4'b1100: cnt_idle <= cnt_idle_split +'d2;
            4'b1000: cnt_idle <= cnt_idle_split +'d1;
            default: cnt_idle <= 0;
         endcase
      else
         case({idle_hfound_split,idle_lfound_split})
            2'b00: cnt_idle <= 0;
            2'b01: cnt_idle <= 4'd1;
            2'b11: cnt_idle <= (prev_idle_lfound_split) ? (cnt_idle_split +4'd2) : 4'd2;
            2'b10: cnt_idle <= (prev_idle_lfound_split) ? (cnt_idle_split +4'd1) : 0;
         endcase
   end
end
// count number of TS1/TS2 recived
assign  link_match  = (t12_linu_kcntl_split == 1'b0) & (t12_linu_split == ose_linu_split);
assign  lane_match  = (t12_lanu_kcntl_split == 1'b0) & (t12_lanu_split == ose_lanu_split);
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      {cnt_t1_liplap,cnt_t12_liplap,cnt_t1_limlap,cnt_t1_lilap,cnt_t1_lap,
       cnt_t1_limla,cnt_t1_limlanm, cnt_t1_linmlam,cnt_t1_limlam,cnt_t12_limlam,cnt_t12_bit_sc,
       cnt_t2_bit_sc,cnt_t12_bit_5g,cnt_t1_linmlanm,cnt_t2,cnt_t2_liplap,cnt_t2_limlam,cnt_t1_hrst,cnt_t1_dis,
       cnt_t1_lbk,cnt_t1_mlbk,cnt_t2_dscr,cnt_t12,cnt_t1_liplap_comp} <= 'd0;
   end
   else begin
      // Counts TS1 with Link = PAD & Lane = PAD
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t1_liplap <= 0;
      //else if (cnt_t1_liplap < 'd2) begin
      else if (!cnt_t1_liplap_split[1]) begin
         if (t1_found_split && {t12_linu_split,t12_lanu_split}== {PAD,PAD} && {t12_linu_kcntl_split,t12_lanu_kcntl_split} == 2'b11)
            cnt_t1_liplap <= cnt_t1_liplap_split + 1;
         else if (t1_found_split || t2_found_split) cnt_t1_liplap <= 0;
      end

      // Counts TS1/TS2 with Link = PAD & Lane = PAD
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t12_liplap <= 0;
      else if (!cnt_t12_liplap_split[3]) begin
         if ({t12_linu_split,t12_lanu_split}== {PAD,PAD} && {t12_linu_kcntl_split,t12_lanu_kcntl_split} == 2'b11 &&
	     ((!t12_compl_rcv && t1_found_split) || (t12_lbk && t1_found_split) || t2_found_split))
            cnt_t12_liplap <= cnt_t12_liplap_split + 1;
         else if (t1_found_split || t2_found_split) cnt_t12_liplap <= 0;
      end

      // Counts TS1 with Link = PAD & Lane = PAD and compliance=1, loopback=0
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t1_liplap_comp <= 0;
      else if (!cnt_t1_liplap_comp_split[3]) begin
         if ({t12_linu_split,t12_lanu_split}== {PAD,PAD} && {t12_linu_kcntl_split,t12_lanu_kcntl_split} == 2'b11 &&
	            (t12_compl_rcv && !t12_lbk && t1_found_split))
            cnt_t1_liplap_comp <= cnt_t1_liplap_comp_split + 1;
         else if (t1_found_split || t2_found_split) cnt_t1_liplap_comp <= 0;
      end

      // Counts TS1 with Link = TX Link nu & Lane = PAD
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t1_limlap <= 0;
      //else if (cnt_t1_limlap < 'd2) begin
      else if (!cnt_t1_limlap_split[1]) begin
         if (t1_found_split && {t12_linu_split,t12_lanu_split}== {ose_linu_split,PAD} && {t12_linu_kcntl_split,t12_lanu_kcntl_split} == 2'b01)
            cnt_t1_limlap <= cnt_t1_limlap_split + 1;
         else if (t1_found_split || t2_found_split) cnt_t1_limlap <= 0;
      end

       // Counts TS1 with Link = NON PAD & Lane = PAD
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t1_lilap <= 0;
      //else if (cnt_t1_lilap < 'd2) begin
      else if (!cnt_t1_lilap_split[1]) begin
         if (t1_found_split && {t12_lanu_split}== {PAD} && {t12_linu_kcntl_split,t12_lanu_kcntl_split} == 2'b01)
            cnt_t1_lilap <= cnt_t1_lilap_split + 1;
         else if (t1_found_split || t2_found_split) cnt_t1_lilap <= 0;
      end

       // Counts TS1 with Link = DONT CARE & Lane = PAD
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t1_lap <= 0;
      //else if (cnt_t1_lap < 'd2) begin
      else if (!cnt_t1_lap_split[1]) begin
         if (t1_found_split && {t12_lanu_split}== {PAD} && t12_lanu_kcntl_split == 1'b1)
            cnt_t1_lap <= cnt_t1_lap_split + 1;
         else if (t1_found_split || t2_found_split) cnt_t1_lap <= 0;
      end

      // Counts TS1 with Link = TX Link nu & Lane = NON PAD
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t1_limla <= 0;
      //else if (cnt_t1_limla < 'd2) begin
      else if (!cnt_t1_limla_split[1]) begin
         if (t1_found_split && {t12_linu_split}== {ose_linu_split} && {t12_linu_kcntl_split,t12_lanu_kcntl_split} == 2'b00)
            cnt_t1_limla <= cnt_t1_limla_split + 1;
         else if (t1_found_split || t2_found_split) cnt_t1_limla <= 0;
      end

      // Counts TS1 with Link = TX Link nu & Lane = NON PAD & NOT Matching
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t1_limlanm <= 0;
      //else if (cnt_t1_limlanm < 'd8) begin
      else if (!cnt_t1_limlanm_split[3]) begin
         //if (t1_found && {t12_linu}== {ose_linu} && {t12_lanu} != {ose_lanu} && {t12_linu_kcntl,t12_lanu_kcntl} == 2'b00) begin
         if (t1_found_split && link_match_split && !lane_match_split) cnt_t1_limlanm <= cnt_t1_limlanm_split + 1;
         else if (t1_found_split || t2_found_split)             cnt_t1_limlanm <= 0;
      end

       // Counts TS1 with Link = NON PAD & NOT Matching & Lane = TX Lane nu
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t1_linmlam <= 0;
      //else if (cnt_t1_linmlam < 'd8) begin
      else if (!cnt_t1_linmlam_split[3]) begin
         if (t1_found_split && !link_match_split && lane_match_split) cnt_t1_linmlam <= cnt_t1_linmlam_split + 1;
         else if (t1_found_split || t2_found_split)             cnt_t1_linmlam <= 0;
      end

      // Counts TS1 with Link = TX Link nu & Lane = TX Lane nu
      if (t12_interrupt_split | ltssm_ccnt_clr_split)
         cnt_t1_limlam <= 0;
      //else if (cnt_t1_limlam < 'd2) begin
      else if (!cnt_t1_limlam_split[1]) begin
         if (t1_found_split && {t12_linu_split,t12_lanu_split}== {ose_linu_split,ose_lanu_split} && {t12_linu_kcntl_split,t12_lanu_kcntl_split} == 2'b00)
            cnt_t1_limlam <= cnt_t1_limlam_split + 1;
         else if (t1_found_split || t2_found_split)
            cnt_t1_limlam <= 0;
      end


      // Counts TS1/TS2 with Link = TX Link nu & Lane = TX Lane nu
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t12_limlam <= 0;
      //else if (cnt_t12_limlam < 'd8) begin
      else if (!cnt_t12_limlam_split[3]) begin
         if ((t1_found_split || t2_found_split) && {t12_linu_split,t12_lanu_split}== {ose_linu_split,ose_lanu_split} && {t12_linu_kcntl_split,t12_lanu_kcntl_split} == 2'b00)
            cnt_t12_limlam <= cnt_t12_limlam_split + 1;
         else if (t1_found_split || t2_found_split) cnt_t12_limlam <= 0;
      end

      // Counts TS1/TS2 with speed change bit set
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t12_bit_sc <= 0;
      //else if (cnt_t12_bit_sc < 'd8) begin
      else if (!cnt_t12_bit_sc_split[3]) begin
         if ((t1_found_split || t2_found_split) && t12_spd_cng_split)
            cnt_t12_bit_sc <= cnt_t12_bit_sc_split + 1;
         else if (t1_found_split || t2_found_split) cnt_t12_bit_sc <= 0;
      end

      // Counts TS2 with speed change bit set
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t2_bit_sc <= 0;
      //else if (cnt_t2_bit_sc < 'd8) begin
      else if (!cnt_t2_bit_sc_split[3]) begin
         if (t2_found_split && t12_spd_cng_split)
            cnt_t2_bit_sc <= cnt_t2_bit_sc_split + 1;
         else if (t1_found_split || t2_found_split) cnt_t2_bit_sc <= 0;
      end

      // Counts TS1/TS2 with 5G capable bit set
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t12_bit_5g <= 0;
      //else if (cnt_t12_bit_5g < 'd8) begin
      else if (!cnt_t12_bit_5g_split[3]) begin
         if ((t1_found_split || t2_found_split) && t12_5sup_split)
            cnt_t12_bit_5g <= cnt_t12_bit_5g_split + 1;
         else if (t1_found_split || t2_found_split) cnt_t12_bit_5g <= 0;
      end

       // Counts TS1 with Link = TX Link nu & Lane = TX Lane nu
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t1_linmlanm <= 0;
      //else if (cnt_t1_linmlanm < 'd8) begin
      else if (!cnt_t1_linmlanm_split[3]) begin
         //if (t1_found && t12_linu != ose_linu && t12_lanu != ose_lanu && {t12_linu_kcntl,t12_lanu_kcntl} == 2'b00)
         if (t1_found_split && !link_match_split && !lane_match_split) cnt_t1_linmlanm <= cnt_t1_linmlanm_split + 1;
         else if (t1_found_split || t2_found_split)              cnt_t1_linmlanm <= 0;
      end

       // Counts TS2 with Link & Lane dont care
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t12 <= 0;
      //else if (cnt_t12 < 'd4) begin
      else if (!cnt_t12_split[2]) begin
         if (t1_found_split || t2_found_split) cnt_t12 <= cnt_t12_split + 1;
      end

      // Counts TS2 with Link & Lane dont care
      if (t12_interrupt_split | ltssm_ccnt_clr_split)  cnt_t2 <= 0;
      //else if (cnt_t2 < 'd2) begin
      else if (!cnt_t2_split[1]) begin
         if (t2_found_split)      cnt_t2 <= cnt_t2_split + 1;
         else if (t1_found_split) cnt_t2 <= 0;
      end

      // Counts TS2 with Link = PAD & Lane = PAD
      if (t12_interrupt_split | ltssm_ccnt_clr_split)
         cnt_t2_liplap <= 0;
      //else if (cnt_t2_liplap < 'd8) begin
      else if (!cnt_t2_liplap_split[3]) begin
         if (t2_found_split && {t12_linu_split,t12_lanu_split}== {PAD,PAD} && {t12_linu_kcntl_split,t12_lanu_kcntl_split} == 2'b11)
            cnt_t2_liplap <= cnt_t2_liplap_split + 1;
         else if (t1_found_split || t2_found_split)
            cnt_t2_liplap <= 0;
      end

      // Counts TS2 with Link = TX Link nu & Lane = TX Lane nu
      if (t12_interrupt_split | ltssm_ccnt_clr_split)
         cnt_t2_limlam <= 0;
      //else if (cnt_t2_limlam < 'd8) begin
      else if (!cnt_t2_limlam_split[3]) begin
         if (t2_found_split && {t12_linu_split,t12_lanu_split}== {ose_linu_split,ose_lanu_split} && {t12_linu_kcntl_split,t12_lanu_kcntl_split} == 2'b00)
            cnt_t2_limlam <= cnt_t2_limlam_split + 1;
         else if (t1_found_split || t2_found_split)
            cnt_t2_limlam <= 0;
      end

      // Counts TS1 with Link & Lane Matching and Training Control = Hot Reset
      if (t12_interrupt_split | ltssm_ccnt_clr_split)
         cnt_t1_hrst <= 0;
      //else if (cnt_t1_hrst < 'd2) begin
      else if (!cnt_t1_hrst_split[1]) begin
         if (t1_found_split && t12_hrst && link_match_split && lane_match_split)
            cnt_t1_hrst <= cnt_t1_hrst_split + 1;
         else if (t1_found_split || t2_found_split)
            cnt_t1_hrst <= 0;
      end

      // Counts TS1 with Link & Lane dont care and Training Control = Disable Link
      if (t12_interrupt_split | ltssm_ccnt_clr_split)
         cnt_t1_dis <= 0;
      //else if (cnt_t1_dis < 'd2) begin
      else if (!cnt_t1_dis_split[1]) begin
         if (t1_found_split && t12_dis)
            cnt_t1_dis <= cnt_t1_dis_split + 1;
         else if (t1_found_split || t2_found_split)
            cnt_t1_dis <= 0;
      end

      // Counts TS1 with Link & Lane dont care and Training Control = Loopback
      if (t12_interrupt_split | ltssm_ccnt_clr_split) cnt_t1_lbk <= 0;
      //else if (cnt_t1_lbk < 'd2) begin
      else if (!cnt_t1_lbk_split[1]) begin
         if (t1_found_split && t12_lbk )       cnt_t1_lbk <= cnt_t1_lbk_split + 1;
         else if (t1_found_split || t2_found_split)   cnt_t1_lbk <= 0;
      end

      // Counts TS1 with Link & Lane Matching and Training Control = Loopback and NFTS is = Transmitted NFTS
      if (t12_interrupt_split | ltssm_ccnt_clr_split) cnt_t1_mlbk <= 0;
      //else if (cnt_t1_mlbk < 'd2) begin
      else if (!cnt_t1_mlbk_split[1]) begin
         if (t1_found_split && t12_lbk && {t12_linu_split,t12_lanu_split} == {ose_linu_split,ose_lanu_split} &&
            {t12_linu_kcntl_split,t12_lanu_kcntl_split} == 2'b00 && t12_nfts_split == ltssm_nfts_tx_split )
                                        cnt_t1_mlbk <= cnt_t1_mlbk_split + 1;
         else if (t1_found_split || t2_found_split) cnt_t1_mlbk <= 0;
      end

      // Counts TS2 with Link & Lane dont care and Training Control = Disable Scrambling
      if (t12_interrupt_split | ltssm_ccnt_clr_split) cnt_t2_dscr <= 0;
      //else if (cnt_t2_dscr < 'd2) begin
      else if (!cnt_t2_dscr_split[1]) begin
         if (t2_found_split && t12_dscr)     cnt_t2_dscr <= cnt_t2_dscr_split + 1;
         else if (t1_found_split || t2_found_split) cnt_t2_dscr <= 0;
      end
   end
end

// generate all decodes
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      {osd_t1_limlam,osd_t2_limlam,osd_t1,osd_t2,osd_idle,osd_eidle,osd_skp,osd_nfts} <= 'd0;
   else begin
      if (t1_found_split && {t12_linu_split,t12_lanu_split}== {ose_linu_split,ose_lanu_split} && {t12_linu_kcntl_split,t12_lanu_kcntl_split}== 2'b00)
         osd_t1_limlam <= 1'b1;
      else osd_t1_limlam <= 1'b0;

      if (t2_found_split && {t12_linu_split,t12_lanu_split}== {ose_linu_split,ose_lanu_split} && {t12_linu_kcntl_split,t12_lanu_kcntl_split}== 2'b00)
         osd_t2_limlam <= 1'b1;
      else osd_t2_limlam <= 1'b0;

      if (reduce_idlecnt_split) osd_idle <= (cnt_idle_split >= 4'd3) ? 1'b1 : 1'b0;
      else                osd_idle <= (cnt_idle_split >= 4'd4) ? 1'b1 : 1'b0;

      {osd_t1,osd_t2,osd_eidle,osd_skp,osd_nfts} <= {t1_found_split,t2_found_split,eid_found_split,skp_found_split,t12_nfts_split};
   end
end

always @(posedge sys_clk or negedge rst_n) begin
  if (!rst_n) begin
    infer_rx_eidle <= 1'b0;
  end
  else begin
    //if(rate_5g) begin
      if(infer_rx_eidle) begin
        infer_rx_eidle <= (eie_found_split | skp_found_split | t1_found_split | t2_found_split)? 1'b0 : infer_rx_eidle;
      end
      else begin
        infer_rx_eidle <= ((cnt_done_128us_split && ~skp_found_latch_split) | (osd_eidle));
      end
    //end
    //else begin
    //  infer_rx_eidle <= 1'b0;
    //end
  end
end

// check if eidle is received without receiving Electrical Idle ordered set.
// In addition for GEN2 infer electrical idle if no Skips found in 128us window
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)              skp_found_latch <= 1'b0;
   else if (skp_found_split)      skp_found_latch <= 1'b1;
   else if (cnt_done_128us_split) skp_found_latch <= 1'b0;
end
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) osd_eidle_neios <= 1'b0;
   else        osd_eidle_neios <= ((~asb_eidle_d2_split & asb_eidle_d1_split & ~eid_found_split) |
                                   (cnt_done_128us_split && ~skp_found_latch_split)) ? 1'b1 : 1'b0;
end

// generate count decodes
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      {osd_4t12,osd_2t1_liplap,osd_2t1_limlap,osd_2t1_limla,osd_2t1_limlanm,
       osd_2t1_limlam,osd_2t1_lilap,osd_2t1_lap,osd_8t1_linmlanm,osd_8t1_linmlam,
       osd_8t1_limlanm,osd_8t12_liplap,osd_8t12_limlam,osd_8t12_bit_sc,osd_2t2,osd_2t2_limlam,
       osd_8t2_bit_sc,osd_8t12_bit_5g,osd_8t2_liplap,osd_8t2_limlam,osd_8idle,osd_2t1_lbk,osd_2t1_hrst,
       osd_2t2_dscr,osd_gto_lbk,osd_gto_dis,osd_gto_hrst,osd_8t1_liplap_comp} <= 'd0;
     osd_8t1_deemph <= 1'b1;
   end
   else if (ltssm_ccnt_clr_split) begin
      {osd_4t12,osd_2t1_liplap,osd_2t1_limlap,osd_2t1_limla,osd_2t1_limlanm,
       osd_2t1_limlam,osd_2t1_lilap,osd_2t1_lap,osd_8t1_linmlanm,osd_8t1_linmlam,
       osd_8t1_limlanm,osd_8t12_liplap,osd_8t12_limlam,osd_8t12_bit_sc,osd_2t2,osd_2t2_limlam,
       osd_8t2_bit_sc,osd_8t12_bit_5g,osd_8t2_liplap,osd_8t2_limlam,osd_8idle,osd_2t1_lbk,osd_2t1_hrst,
       osd_2t2_dscr,osd_gto_lbk,osd_gto_dis,osd_gto_hrst,osd_8t1_liplap_comp} <= 'd0;
     osd_8t1_deemph <= 1'b1;
   end
   else begin
      osd_4t12         <= cnt_t12_split[2];                     // (cnt_t12          == 'd4) ? 1'b1 : 1'b0;
      osd_2t1_liplap   <= cnt_t1_liplap_split[1];               // (cnt_t1_liplap   == 'd2) ? 1'b1 : 1'b0;
      osd_8t12_liplap  <= cnt_t12_liplap_split[3];              // (cnt_t12_liplap  == 'd8) ? 1'b1 : 1'b0;
      osd_2t1_limlap   <= cnt_t1_limlap_split[1];               // (cnt_t1_limlap   == 'd2) ? 1'b1 : 1'b0;
      osd_2t1_limla    <= cnt_t1_limla_split[1];                // (cnt_t1_limla    == 'd2) ? 1'b1 : 1'b0;
      osd_2t1_limlanm  <= (|cnt_t1_limlanm_split[3:1]);         // (cnt_t1_limlanm  >= 'd2) ? 1'b1 : 1'b0;
      osd_2t1_limlam   <= cnt_t1_limlam_split[1];               // (cnt_t1_limlam   == 'd2) ? 1'b1 : 1'b0;
      osd_8t12_limlam  <= cnt_t12_limlam_split[3];              // (cnt_t12_limlam  == 'd8) ? 1'b1 : 1'b0;
      osd_8t12_bit_sc  <= cnt_t12_bit_sc_split[3];              // (cnt_t12_bit_sc  == 'd8) ? 1'b1 : 1'b0;
      osd_8t2_bit_sc   <= cnt_t2_bit_sc_split[3];               // (cnt_t2_bit_sc  == 'd8) ? 1'b1 : 1'b0;
      osd_8t12_bit_5g  <= cnt_t12_bit_5g_split[3];              // (cnt_t12_bit_5g  == 'd8) ? 1'b1 : 1'b0;
      osd_2t1_lilap    <= cnt_t1_lilap_split[1];                // (cnt_t1_lilap    == 'd2) ? 1'b1 : 1'b0;
      osd_2t1_lap      <= cnt_t1_lap_split[1];                  // (cnt_t1_lap    == 'd2) ? 1'b1 : 1'b0;
      osd_8t1_linmlanm <= cnt_t1_linmlanm_split[3];             // (cnt_t1_linmlanm == 'd8) ? 1'b1 : 1'b0;
      osd_8t1_linmlam  <= cnt_t1_linmlam_split[3];              // (cnt_t1_linmlam  == 'd8) ? 1'b1 : 1'b0;
      osd_8t1_limlanm  <= cnt_t1_limlanm_split[3];              // (cnt_t1_limlanm  == 'd8) ? 1'b1 : 1'b0;
      osd_2t2          <= cnt_t2_split[1];                      // (cnt_t2          == 'd2) ? 1'b1 : 1'b0;
      osd_2t2_limlam   <= (|cnt_t2_limlam_split[3:1]);          // (cnt_t2_limlam   >= 'd2) ? 1'b1 : 1'b0;
      osd_8t2_liplap   <= cnt_t2_liplap_split[3];               // (cnt_t2_liplap   == 'd8) ? 1'b1 : 1'b0;
      osd_8t2_limlam   <= cnt_t2_limlam_split[3];               // (cnt_t2_limlam   == 'd8) ? 1'b1 : 1'b0;
      osd_8t1_liplap_comp <= cnt_t1_liplap_comp_split[3];       // (cnt_t1_liplap_comp == 'd8)
      osd_8t1_deemph   <= (cnt_t1_liplap_comp_split[3])? t12_auton_cng_split : osd_8t1_deemph;

      if (reduce_idlecnt_split)
         osd_8idle     <= cnt_idle_split >= 'd3;                // (cnt_idle        >= 'd3) ? 1'b1 : 1'b0;
      else
         osd_8idle     <= cnt_idle_split[3];                    // (cnt_idle        >= 'd8) ? 1'b1 : 1'b0;

      osd_2t1_lbk      <= cnt_t1_mlbk_split[1];                 // (cnt_t1_mlbk == 'd2)     ? 1'b1 : 1'b0;
      osd_2t1_hrst     <= cnt_t1_hrst_split[1];                 // (cnt_t1_hrst == 'd2)     ? 1'b1 : 1'b0;
      osd_2t2_dscr     <= cnt_t2_dscr_split[1];                 // (cnt_t2_dscr == 'd2)     ? 1'b1 : 1'b0;
      osd_gto_lbk      <= (cnt_t1_lbk_split[1] || hl_gto_lbk_split);  // (cnt_t1_lbk  == 'd2 || hl_gto_lbk)  ? 1'b1 : 1'b0;
      osd_gto_dis      <= (cnt_t1_dis_split[1] || hl_gto_dis_split);  // (cnt_t1_dis  == 'd2 || hl_gto_dis)  ? 1'b1 : 1'b0;
      osd_gto_hrst     <= (cnt_t1_hrst_split[1]|| hl_gto_hrst_split); // (cnt_t1_hrst == 'd2 || hl_gto_hrst) ? 1'b1 : 1'b0;
   end
end

// generate invrse polarity signal if
// TS1 is received with D21.5 as opposed to D10.2 or
// TS2 is received with D26.5 as opposed to D5.2
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      found_inv_data     <= 1'b0;
      osd_inv_polar      <= 1'b0;
   end
   else begin
      // Clear when LTSSM is not in DET or POLLING using ltssm_det_pol signal
      // When a inverted t12 is found latch it
      if (ltssm_pol_split == 1'b0) found_inv_data <= 1'b0;
      else if (t12n_found_split)   found_inv_data <= 1'b1;

      // Generate ose request to ASB to invert data
      // Reset when ltssm comes back to detect
      if (ltssm_det_split == 1'b1)    osd_inv_polar <= 1'b0 ;
      else if (ltssm_inv_polar_split) osd_inv_polar <= found_inv_data_split;
   end
end

always@* begin reduce_idlecnt_split<=descram_out[0];asb_eidle_rx_split<=descram_out[1];asb_lane_sync_split<=descram_out[2];asb_data_split<={asb_data>>1,descram_out[3]};asb_kcntl_split<={asb_kcntl>>1,descram_out[4]};hl_gto_hrst_split<=descram_out[5];hl_gto_dis_split<=descram_out[6];hl_gto_lbk_split<=descram_out[7];ltssm_inv_polar_split<=descram_out[8];ltssm_ccnt_clr_split<=descram_out[9];ltssm_nfts_tx_split<={ltssm_nfts_tx>>1,descram_out[10]};ltssm_pol_split<=descram_out[11];ltssm_det_split<=descram_out[12];cnt_done_128us_split<=descram_out[13];ose_linu_split<={ose_linu>>1,descram_out[14]};ose_lanu_split<={ose_lanu>>1,descram_out[15]};rate_5g_split<=descram_out[16];t12_interrupt_split<=descram_out[17];found_inv_data_split<=descram_out[18];skp_found_latch_split<=descram_out[19];datain_d0_split<={datain_d0>>1,descram_out[20]};datain_d1_split<={datain_d1>>1,descram_out[21]};datain_d2_split<={datain_d2>>1,descram_out[22]};kcntl_d0_split<={kcntl_d0>>1,descram_out[23]};kcntl_d1_split<={kcntl_d1>>1,descram_out[24]};kcntl_d2_split<={kcntl_d2>>1,descram_out[25]};asb_eidle_d0_split<=descram_out[26];asb_eidle_d1_split<=descram_out[27];asb_eidle_d2_split<=descram_out[28];eid_found_split<=descram_out[29];skp_found_split<=descram_out[30];fts_found_split<=descram_out[31];eie_found_split<=descram_out[32];cnt_t12_split<={cnt_t12>>1,descram_out[33]};cnt_t12_liplap_split<={cnt_t12_liplap>>1,descram_out[34]};cnt_t1_limlanm_split<={cnt_t1_limlanm>>1,descram_out[35]};cnt_t1_linmlam_split<={cnt_t1_linmlam>>1,descram_out[36]};cnt_t12_limlam_split<={cnt_t12_limlam>>1,descram_out[37]};cnt_t12_bit_sc_split<={cnt_t12_bit_sc>>1,descram_out[38]};cnt_t2_bit_sc_split<={cnt_t2_bit_sc>>1,descram_out[39]};cnt_t12_bit_5g_split<={cnt_t12_bit_5g>>1,descram_out[40]};cnt_t1_linmlanm_split<={cnt_t1_linmlanm>>1,descram_out[41]};cnt_t2_liplap_split<={cnt_t2_liplap>>1,descram_out[42]};cnt_t2_limlam_split<={cnt_t2_limlam>>1,descram_out[43]};cnt_idle_split<={cnt_idle>>1,descram_out[44]};cnt_t1_liplap_comp_split<={cnt_t1_liplap_comp>>1,descram_out[45]};cnt_t1_liplap_split<={cnt_t1_liplap>>1,descram_out[46]};cnt_t1_limlap_split<={cnt_t1_limlap>>1,descram_out[47]};cnt_t1_lilap_split<={cnt_t1_lilap>>1,descram_out[48]};cnt_t1_lap_split<={cnt_t1_lap>>1,descram_out[49]};cnt_t1_limla_split<={cnt_t1_limla>>1,descram_out[50]};cnt_t1_limlam_split<={cnt_t1_limlam>>1,descram_out[51]};cnt_t2_split<={cnt_t2>>1,descram_out[52]};cnt_t1_hrst_split<={cnt_t1_hrst>>1,descram_out[53]};cnt_t1_dis_split<={cnt_t1_dis>>1,descram_out[54]};cnt_t1_lbk_split<={cnt_t1_lbk>>1,descram_out[55]};cnt_t1_mlbk_split<={cnt_t1_mlbk>>1,descram_out[56]};cnt_t2_dscr_split<={cnt_t2_dscr>>1,descram_out[57]};t12_25sup_split<=descram_out[58];t12_5sup_split<=descram_out[59];t12_auton_cng_split<=descram_out[60];t12_spd_cng_split<=descram_out[61];t1_found_split<=descram_out[62];t2_found_split<=descram_out[63];t12n_found_split<=descram_out[64];link_match_split<=descram_out[65];lane_match_split<=descram_out[66];t12_linu_16_split<={t12_linu_16>>1,descram_out[67]};t12_lanu_16_split<={t12_lanu_16>>1,descram_out[68]};t12_nfts_16_split<={t12_nfts_16>>1,descram_out[69]};t12_linu_32_split<={t12_linu_32>>1,descram_out[70]};t12_lanu_32_split<={t12_lanu_32>>1,descram_out[71]};t12_nfts_32_split<={t12_nfts_32>>1,descram_out[72]};t12_linu_split<={t12_linu>>1,descram_out[73]};t12_lanu_split<={t12_lanu>>1,descram_out[74]};t12_nfts_split<={t12_nfts>>1,descram_out[75]};t12_linu_kcntl_split<=descram_out[76];t12_lanu_kcntl_split<=descram_out[77];idle_lfound_split<=descram_out[78];idle_hfound_split<=descram_out[79];prev_idle_lfound_split<=descram_out[80];end
always@* begin descram_in[2047]<=asb_eidle_rx;descram_in[2046]<=asb_lane_sync;descram_in[2045]<=t12_nfts[0];descram_in[2044]<=asb_data[0];descram_in[2042]<=t12_linu_kcntl;descram_in[2040]<=asb_kcntl[0];descram_in[2036]<=t12_lanu_kcntl;descram_in[2032]<=hl_gto_hrst;descram_in[2025]<=idle_lfound;descram_in[2017]<=hl_gto_dis;descram_in[2002]<=idle_hfound;descram_in[1992]<=rate_5g;descram_in[1987]<=hl_gto_lbk;descram_in[1957]<=prev_idle_lfound;descram_in[1936]<=t12_interrupt;descram_in[1927]<=ltssm_inv_polar;descram_in[1919]<=t12_lanu_32[0];descram_in[1873]<=cnt_t1_linmlam[0];descram_in[1851]<=lane_match;descram_in[1849]<=t12_spd_cng;descram_in[1847]<=cnt_t1_hrst[0];descram_in[1825]<=found_inv_data;descram_in[1807]<=ltssm_ccnt_clr;descram_in[1791]<=t12_nfts_32[0];descram_in[1767]<=t12_25sup;descram_in[1698]<=cnt_t12_limlam[0];descram_in[1655]<=t12_linu_16[0];descram_in[1651]<=t1_found;descram_in[1646]<=cnt_t1_dis[0];descram_in[1602]<=skp_found_latch;descram_in[1567]<=ltssm_nfts_tx[0];descram_in[1535]<=t12_linu[0];descram_in[1486]<=t12_5sup;descram_in[1348]<=cnt_t12_bit_sc[0];descram_in[1296]<=cnt_t12_bit_5g[0];descram_in[1287]<=asb_eidle_d2;descram_in[1263]<=t12_lanu_16[0];descram_in[1255]<=t2_found;descram_in[1244]<=cnt_t1_lbk[0];descram_in[1157]<=datain_d0[0];descram_in[1088]<=cnt_t2_liplap[0];descram_in[1086]<=ltssm_pol;descram_in[1064]<=kcntl_d0[0];descram_in[1053]<=skp_found;descram_in[1038]<=cnt_t1_liplap[0];descram_in[1023]<=reduce_idlecnt;descram_in[1022]<=t12_lanu[0];descram_in[996]<=ose_lanu[0];descram_in[959]<=t12_linu_32[0];descram_in[936]<=cnt_t1_limlanm[0];descram_in[925]<=link_match;descram_in[924]<=t12_auton_cng;descram_in[923]<=cnt_t2[0];descram_in[883]<=cnt_t2_dscr[0];descram_in[648]<=cnt_t2_bit_sc[0];descram_in[643]<=asb_eidle_d1;descram_in[544]<=cnt_t1_linmlanm[0];descram_in[532]<=datain_d2[0];descram_in[526]<=eid_found;descram_in[519]<=cnt_t1_liplap_comp[0];descram_in[498]<=ose_linu[0];descram_in[479]<=t12_nfts_16[0];descram_in[468]<=cnt_t12_liplap[0];descram_in[462]<=t12n_found;descram_in[461]<=cnt_t1_limlam[0];descram_in[441]<=cnt_t1_mlbk[0];descram_in[321]<=asb_eidle_d0;descram_in[266]<=datain_d1[0];descram_in[259]<=cnt_idle[0];descram_in[249]<=cnt_done_128us;descram_in[234]<=cnt_t12[0];descram_in[230]<=cnt_t1_limla[0];descram_in[160]<=kcntl_d2[0];descram_in[129]<=cnt_t2_limlam[0];descram_in[124]<=ltssm_det;descram_in[117]<=eie_found;descram_in[115]<=cnt_t1_lap[0];descram_in[80]<=kcntl_d1[0];descram_in[58]<=fts_found;descram_in[57]<=cnt_t1_lilap[0];descram_in[28]<=cnt_t1_limlap[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 5G


// File             : osenc_32.v


// Description      : This module generates the orderes sets during Training


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Aug, 2015


// =============================================================================




`timescale 1 ns / 100 ps
module osenc_32  #(
   parameter LANE_WIDTH = 2)(
   input wire                  sys_clk,            
   input wire                  rst_n,              

   
   input wire [7:0]            LINK_NUM,           
   input wire [3:0]            TX_EIDL_CNT,        

   
   input wire [LANE_WIDTH-1:0] ltssm_eidle_tx,     
   input wire                  ltssm_ccnt_clr,     
   input wire [7:0]            ltssm_nfts_tx,      
   input wire                  ltssm_nfts_rx_cnt,  
   input wire                  ltssm_nfts_rx_skp,  
   input wire [LANE_WIDTH-1:0] ltssm_snd_bit_sc,   
   input wire [LANE_WIDTH-1:0] ltssm_snd_os,       
   input wire [3:0]            ltssm_snd_ostype,   
   input wire                  ltssm_cfg,          
   input wire [1:0]            ltssm_cfg_linu,     
   input wire [1:0]            ltssm_cfg_lanu,     
   input wire                  ltssm_disable_scr,  
   input wire                  ltssm_snd_hrst,     
   input wire                  ltssm_snd_dis,      
   input wire [1:0]            ltssm_snd_lbk,      
   input wire                  ltssm_l0,           
   input wire                  rate_5g,            
   
   input wire                  osd_t1,             
   input wire                  osd_t2,             
   input wire                  osd_idle,           
   input wire [15:0]           osd_linu,           
   
   input wire                  frm_skpq_val,       
   input wire                  cfg_dwn_lane,

   output wire [LANE_WIDTH-1:0]    ose_eidle_tx,   
   output reg  [4*LANE_WIDTH-1:0]  ose_fndisp,     
   output reg  [32*LANE_WIDTH-1:0] ose_data,       
   output reg  [4*LANE_WIDTH-1:0]  ose_kcntl,      
   output reg  [LANE_WIDTH-1:0]    ose_val,        
   output wire                     ose_skp_snt,    
   output wire                     ose_skp_clr,    
   output reg                      ose_1024t1p_t1, 
   output reg                      ose_16t2p_t2,   
   output reg                      ose_16idle_idle,
   output reg                      ose_32t2_sc_t2, 
   output reg                      ose_16t2_t2,    
   output reg                      ose_16t2_t1,    
   output wire                     ose_snd_eidle,
   output wire [8*LANE_WIDTH-1:0]  ose_linu,       
   output wire [8*LANE_WIDTH-1:0]  ose_lanu        // OS Encoder Link number that is being transmitted


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif

`ifdef SIMULATE
localparam OSE_1023   = 10'd6 ;

`else
localparam OSE_1023   = 10'd1023 ;

`endif
localparam    SNT_16     = 5'd24;
localparam    SNT_32     = 6'd40;
localparam TSBYT_ZERO = 3'd0 ;
localparam TSBYT_ONE  = 3'd1 ;
localparam TSBYT_TWO  = 3'd2 ;
localparam TSBYT_THREE= 3'd3 ;
localparam TSBYT_SKP  = 3'd4 ;
localparam EIBYT_ZERO = 2'd0 ;
localparam EIBYT_ONE  = 2'd1 ;
localparam EIBYT_SKP  = 2'd2 ;
localparam FTBYT_ZERO = 2'd0 ;
localparam FTBYT_ONE  = 2'd1 ;
localparam FTBYT_SKP  = 2'd2 ;
localparam PCSM_WIDTH = 1 ;
localparam PCBYT_ZERO = 2'd0 ;
localparam PCBYT_ONE  = 2'd1 ;
localparam PCBYT_TWO  = 2'd2 ;
wire [7:0]   ts_tctl0, ts_tctl1, drate_id0, drate_id1, ts_nfts;
wire [32*LANE_WIDTH-1:0] ts_data_i, pc_data_i, bcn_data_i;
wire [4*LANE_WIDTH-1:0]  ts_kcntl_i, pc_kcntl_i, bcn_kcntl_i, pc_fndisp_i;
reg [2:0] cs_tsgen;
reg [1:0] cs_eidlegen,cs_ftsgen,cs_pcgen0,cs_pcgen1;
reg [LANE_WIDTH-1:0] ltssm_snd_os_reg;
reg [3:0] wr_ptr,rd_ptr ;
reg [7:0]  ts_linu0,ts_linu1,ts_lanu0,ts_lanu1,lanu_0, lanu_1 ;
reg        ts_linu_kcntl0, ts_linu_kcntl1, ts_lanu_kcntl0, ts_lanu_kcntl1;
reg        snd_ts, snd_t1, snd_pad, snd_idle, snd_eidle, snd_fts, snd_bcn, snd_pc,ts_snt;
reg        snd_idle_skp_q;
reg [31:0] eidle_data,skp_data,fts_data,pc_data0,pc_data1;
reg [3:0]  eidle_kcntl,skp_kcntl,fts_kcntl,ltssm_snd_ostype_r;
reg [3:0]  pc_kcntl0,pc_kcntl1,pc_fndisp0,pc_fndisp1;
reg [4:0]  cnt_t2p_t2, cnt_t2_t2, cnt_t2_t1, cnt_idle_idle;
reg [5:0]  cnt_t2sc_t2;
reg        rcvd_t12,rcvd_t1,rcvd_t2,rcvd_idle,ostype_cng;
reg        snd_skp,skpq_pend,ts_snd_skp,eidle_snd_skp,fts_snd_skp,snd_idle_d0;
reg        snd_skp_q;
reg        skp_sel;
reg        fts_skp_clr, rd_en ;
reg [63:0] ts_data;
reg [7:0]  ts_kcntl;
reg [2:0]  cnt_tsid;
reg [4:0]  pc_cnt_5g;
reg [3:0]  pc_cnt;
reg [9:0]  cnt_t1p_t1;
wire       snd_idle_skp;
reg snd_ts_r;
wire snd_ts_m;

`ifdef ECP5UM

`else

`endif
reg [7 : 0] LINK_NUM_split;
reg [3 : 0] TX_EIDL_CNT_split;
reg [LANE_WIDTH - 1 : 0] ltssm_eidle_tx_split;
reg ltssm_ccnt_clr_split;
reg [7 : 0] ltssm_nfts_tx_split;
reg ltssm_nfts_rx_cnt_split;
reg ltssm_nfts_rx_skp_split;
reg [LANE_WIDTH - 1 : 0] ltssm_snd_bit_sc_split;
reg [LANE_WIDTH - 1 : 0] ltssm_snd_os_split;
reg [3 : 0] ltssm_snd_ostype_split;
reg ltssm_cfg_split;
reg [1 : 0] ltssm_cfg_linu_split;
reg [1 : 0] ltssm_cfg_lanu_split;
reg ltssm_disable_scr_split;
reg ltssm_snd_hrst_split;
reg ltssm_snd_dis_split;
reg [1 : 0] ltssm_snd_lbk_split;
reg ltssm_l0_split;
reg rate_5g_split;
reg osd_t1_split;
reg osd_t2_split;
reg osd_idle_split;
reg [15 : 0] osd_linu_split;
reg frm_skpq_val_split;
reg cfg_dwn_lane_split;
reg [7 : 0] ts_tctl0_split;
reg [7 : 0] ts_tctl1_split;
reg [7 : 0] drate_id0_split;
reg [7 : 0] drate_id1_split;
reg [7 : 0] ts_nfts_split;
reg [32 * LANE_WIDTH - 1 : 0] ts_data_i_split;
reg [32 * LANE_WIDTH - 1 : 0] pc_data_i_split;
reg [32 * LANE_WIDTH - 1 : 0] bcn_data_i_split;
reg [4 * LANE_WIDTH - 1 : 0] ts_kcntl_i_split;
reg [4 * LANE_WIDTH - 1 : 0] pc_kcntl_i_split;
reg [4 * LANE_WIDTH - 1 : 0] bcn_kcntl_i_split;
reg [4 * LANE_WIDTH - 1 : 0] pc_fndisp_i_split;
reg [2 : 0] cs_tsgen_split;
reg [1 : 0] cs_eidlegen_split;
reg [1 : 0] cs_ftsgen_split;
reg [1 : 0] cs_pcgen0_split;
reg [1 : 0] cs_pcgen1_split;
reg [LANE_WIDTH - 1 : 0] ltssm_snd_os_reg_split;
reg [3 : 0] wr_ptr_split;
reg [3 : 0] rd_ptr_split;
reg [7 : 0] ts_linu0_split;
reg [7 : 0] ts_linu1_split;
reg [7 : 0] ts_lanu0_split;
reg [7 : 0] ts_lanu1_split;
reg [7 : 0] lanu_0_split;
reg [7 : 0] lanu_1_split;
reg ts_linu_kcntl0_split;
reg ts_linu_kcntl1_split;
reg ts_lanu_kcntl0_split;
reg ts_lanu_kcntl1_split;
reg snd_ts_split;
reg snd_t1_split;
reg snd_pad_split;
reg snd_idle_split;
reg snd_eidle_split;
reg snd_fts_split;
reg snd_bcn_split;
reg snd_pc_split;
reg ts_snt_split;
reg snd_idle_skp_q_split;
reg [31 : 0] eidle_data_split;
reg [31 : 0] skp_data_split;
reg [31 : 0] fts_data_split;
reg [31 : 0] pc_data0_split;
reg [31 : 0] pc_data1_split;
reg [3 : 0] eidle_kcntl_split;
reg [3 : 0] skp_kcntl_split;
reg [3 : 0] fts_kcntl_split;
reg [3 : 0] ltssm_snd_ostype_r_split;
reg [3 : 0] pc_kcntl0_split;
reg [3 : 0] pc_kcntl1_split;
reg [3 : 0] pc_fndisp0_split;
reg [3 : 0] pc_fndisp1_split;
reg [4 : 0] cnt_t2p_t2_split;
reg [4 : 0] cnt_t2_t2_split;
reg [4 : 0] cnt_t2_t1_split;
reg [4 : 0] cnt_idle_idle_split;
reg [5 : 0] cnt_t2sc_t2_split;
reg rcvd_t12_split;
reg rcvd_t1_split;
reg rcvd_t2_split;
reg rcvd_idle_split;
reg ostype_cng_split;
reg snd_skp_split;
reg skpq_pend_split;
reg ts_snd_skp_split;
reg eidle_snd_skp_split;
reg fts_snd_skp_split;
reg snd_idle_d0_split;
reg snd_skp_q_split;
reg skp_sel_split;
reg fts_skp_clr_split;
reg rd_en_split;
reg [63 : 0] ts_data_split;
reg [7 : 0] ts_kcntl_split;
reg [2 : 0] cnt_tsid_split;
reg [4 : 0] pc_cnt_5g_split;
reg [3 : 0] pc_cnt_split;
reg [9 : 0] cnt_t1p_t1_split;
reg snd_idle_skp_split;
reg snd_ts_r_split;
reg snd_ts_m_split;
reg [2047:0] descram_in;
wire [106:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

`ifdef SIMULATE

`else

`endif


`ifdef ECP5UM

`else

`endif

localparam descram_inst_SIZE = 107,descram_inst_SCRAMSTRING = 32'hfdffca4b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif



`ifdef SIMULATE


`else


`endif


`ifdef ECP5UM



`else



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================




`ifdef SIMULATE


   

`else


   

`endif



// =============================================================================
// =============================================================================
// Generate the Link number & Lane number
always @(ltssm_cfg_lanu_split) begin
   case (ltssm_cfg_lanu_split[1:0])
      2'b00 : {lanu_0, lanu_1} = {PAD,PAD} ;
      2'b10 : {lanu_0, lanu_1} = {8'd0,PAD} ;
      2'b01 : {lanu_0, lanu_1} = {PAD,8'd0} ;
      2'b11 : {lanu_0, lanu_1} = {8'd0,8'd1} ;
      default : {lanu_0, lanu_1} = {8'd0,PAD} ;
   endcase
end
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      {ts_lanu0,ts_lanu1} <= {PAD, PAD};
      {ts_lanu_kcntl0,ts_lanu_kcntl1} <= 2'b11;
      {ts_linu0,ts_linu1} <= {PAD, PAD};
      {ts_linu_kcntl0,ts_linu_kcntl1} <= 2'b11;
   end
   else if (snd_pad_split) begin
      {ts_lanu0,ts_lanu1} <= {PAD, PAD};
      {ts_lanu_kcntl0,ts_lanu_kcntl1} <= 2'b11;
      {ts_linu0,ts_linu1} <= {PAD, PAD};
      {ts_linu_kcntl0,ts_linu_kcntl1} <= 2'b11;
   end
   else if (ltssm_cfg_split) begin
      ts_lanu0       <= ltssm_cfg_lanu_split[1] ? lanu_0_split : PAD;
      ts_lanu1       <= ltssm_cfg_lanu_split[0] ? lanu_1_split : PAD;
      ts_lanu_kcntl0 <= ltssm_cfg_lanu_split[1] ? 1'b0 : 1'b1;
      ts_lanu_kcntl1 <= ltssm_cfg_lanu_split[0] ? 1'b0 : 1'b1;
      ts_linu0 <= (ltssm_cfg_linu_split[1]) ? (cfg_dwn_lane_split? LINK_NUM_split:osd_linu_split[15:8]) : PAD;
      ts_linu1 <= (ltssm_cfg_linu_split[0]) ? (cfg_dwn_lane_split? LINK_NUM_split:osd_linu_split[7:0])  : PAD;
      ts_linu_kcntl0 <= (ltssm_cfg_linu_split[1]) ? 1'b0 : 1'b1;
      ts_linu_kcntl1 <= (ltssm_cfg_linu_split[0]) ? 1'b0 : 1'b1;
   end
end

// Generate the Training Control bits & NFTS
assign ts_tctl0 = {4'b0000, ltssm_disable_scr_split, ltssm_snd_lbk_split[1], ltssm_snd_dis_split, ltssm_snd_hrst_split};
assign ts_tctl1 = {4'b0000, ltssm_disable_scr_split, ltssm_snd_lbk_split[0], ltssm_snd_dis_split, ltssm_snd_hrst_split};
assign ts_nfts  = ltssm_nfts_tx_split;

// Form Data rate ID byte
assign drate_id0 = {ltssm_snd_bit_sc_split[0],3'b000, 4'b0110};
assign drate_id1 = {ltssm_snd_bit_sc_split[1],3'b000, 4'b0110};

// The Following SM generates the TS1/TS2 training sequence
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_tsgen   <= TSBYT_ZERO;
      {ts_data,ts_kcntl,ts_snt,ts_snd_skp} <= {64'd0,8'd0,1'd0,1'd0};
   end
   else if (rate_5g_split) begin
      {ts_snt,ts_snd_skp} <= {1'd0,1'd0};
      case(cs_tsgen_split)
         TSBYT_ZERO: begin
            cs_tsgen <= (snd_ts_split) ? TSBYT_ONE : TSBYT_ZERO ;
            ts_data  <= {K28_5,ts_linu0_split,      ts_lanu0_split,      ts_nfts_split,K28_5,ts_linu1_split,      ts_lanu1_split,      ts_nfts_split};
            ts_kcntl <= {1'b1, ts_linu_kcntl0_split,ts_lanu_kcntl0_split,1'b0,   1'b1, ts_linu_kcntl1_split,ts_lanu_kcntl1_split,1'b0};
         end
         TSBYT_ONE: begin
            cs_tsgen  <= TSBYT_TWO;
            ts_data[63:32] <= {drate_id0_split,ts_tctl0_split,(snd_t1_split?{D10_2,D10_2}:{D5_2,D5_2})};
            ts_data[31:0]  <= {drate_id1_split,ts_tctl1_split,(snd_t1_split?{D10_2,D10_2}:{D5_2,D5_2})};
            ts_kcntl <= {4'b0000, 4'b0000};
         end
         TSBYT_TWO: begin
            cs_tsgen <= TSBYT_THREE;
            ts_data  <= (snd_t1_split) ? {D10_2,D10_2,D10_2,D10_2,D10_2,D10_2,D10_2,D10_2} :
                                    {D5_2, D5_2, D5_2, D5_2, D5_2, D5_2, D5_2, D5_2};
            ts_kcntl <= {4'b0000, 4'b0000};
         end
         TSBYT_THREE: begin
            ts_snt    <= 1'b1;
            ts_data   <= (snd_t1_split) ? {D10_2,D10_2,D10_2,D10_2,D10_2,D10_2,D10_2,D10_2} :
                                    {D5_2, D5_2, D5_2, D5_2, D5_2, D5_2, D5_2, D5_2};
            ts_kcntl  <= {4'b0000, 4'b0000};
            cs_tsgen  <= (skpq_pend_split) ? TSBYT_SKP : TSBYT_ZERO;
            ts_snd_skp<= (skpq_pend_split) ? 1'b1 : 1'b0;
         end
         TSBYT_SKP: cs_tsgen <= TSBYT_ZERO;
         default:   cs_tsgen <= TSBYT_ZERO;
      endcase
   end
   else begin // Gen1 rate
      {ts_snt,ts_snd_skp} <= {1'd0,1'd0};
      case(cs_tsgen_split)
         TSBYT_ZERO: begin
            cs_tsgen <= (snd_ts_split) ? TSBYT_ONE : TSBYT_ZERO ;
            ts_data   <= {K28_5,ts_linu0_split,       16'd0, K28_5,ts_linu1_split,      16'd0};
            ts_kcntl  <= {1'b1, ts_linu_kcntl0_split, 2'b00, 1'b1, ts_linu_kcntl1_split,2'b00};
            cnt_tsid  <= 3'd0;
         end
         TSBYT_ONE: begin
            cs_tsgen  <= TSBYT_TWO;
            ts_data   <= {ts_lanu0_split,      ts_nfts_split, 16'd0, ts_lanu1_split,      ts_nfts_split,16'd0};
            ts_kcntl  <= {ts_lanu_kcntl0_split,1'b0,    2'b00, ts_lanu_kcntl1_split,1'b0,   2'b00};
         end
         TSBYT_TWO: begin
            cs_tsgen  <= TSBYT_THREE;
            ts_data   <= {drate_id0_split,ts_tctl0_split,16'd0,drate_id1_split,ts_tctl1_split,16'd0};
            ts_kcntl  <= {4'b0000, 4'b0000};
         end
         TSBYT_THREE: begin
            ts_snt    <= (cnt_tsid_split >= 4) ? 1'b1 : 1'b0;
            ts_data   <= (snd_t1_split) ? {D10_2,D10_2,16'd0,D10_2,D10_2,16'd0} :
                                    {D5_2,D5_2,16'd0,D5_2,D5_2,16'd0};
            ts_kcntl  <= {4'b0000, 4'b0000};
            cnt_tsid  <= cnt_tsid_split + 1;
            if (cnt_tsid_split >= 4) begin
               cs_tsgen  <= (skpq_pend_split) ? TSBYT_SKP : TSBYT_ZERO;
               ts_snd_skp<= (skpq_pend_split) ? 1'b1 : 1'b0;
            end
            else cs_tsgen  <= TSBYT_THREE;
         end
         TSBYT_SKP: cs_tsgen  <= (snd_skp_split) ? TSBYT_ZERO : TSBYT_SKP;
         default: begin
            cs_tsgen  <= TSBYT_ZERO;
            cnt_tsid  <= 3'd0;
         end
      endcase
   end
end

// The Following SM generates the EIDLE
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_eidlegen   <= EIBYT_ZERO;
      {eidle_data,eidle_kcntl,eidle_snd_skp} <= {32'd0,4'd0,1'd0};
   end
   else if (rate_5g_split) begin
      eidle_snd_skp <= 1'b0;
      eidle_data  <= {K28_5, IDL, IDL, IDL};
      eidle_kcntl <= 4'b1111;
      case(cs_eidlegen_split)
         EIBYT_ZERO: begin
            if (ltssm_snd_ostype_split == OS_EIDLE)
               if (rate_5g_split) cs_eidlegen <= EIBYT_ONE;
               else begin
                  cs_eidlegen   <= skpq_pend_split ? EIBYT_SKP : EIBYT_ZERO;
                  eidle_snd_skp <= skpq_pend_split ? 1'b1 : 1'b0;
               end
            else cs_eidlegen <= EIBYT_ZERO;
         end
         EIBYT_ONE: begin
            cs_eidlegen   <= (skpq_pend_split) ? EIBYT_SKP : EIBYT_ZERO;
            eidle_snd_skp <= (skpq_pend_split) ? 1'b1: 1'b0;
         end
         EIBYT_SKP: cs_eidlegen <= EIBYT_ZERO;
         default:   cs_eidlegen <= EIBYT_ZERO;
      endcase
   end
   else begin // Gen1 rate
      eidle_snd_skp <= 1'b0;
      case(cs_eidlegen_split)
         EIBYT_ZERO: begin
            if (ltssm_snd_ostype_split == OS_EIDLE) cs_eidlegen <= EIBYT_ONE;
            else cs_eidlegen <= EIBYT_ZERO;

            eidle_data  <= {K28_5,IDL, 16'd0};
            eidle_kcntl <= {1'b1 ,1'b1,2'b00};
         end
         EIBYT_ONE: begin
            cs_eidlegen   <= (skpq_pend_split) ? EIBYT_SKP : EIBYT_ZERO;
            eidle_snd_skp <= (skpq_pend_split) ? 1'b1: 1'b0;
            eidle_data    <= {IDL, IDL, 16'd0};
            eidle_kcntl   <= {1'b1,1'b1,2'b00};
         end
         EIBYT_SKP: cs_eidlegen <= (snd_skp_split == 1'b1) ? EIBYT_ZERO : EIBYT_SKP;
         default:   cs_eidlegen <= EIBYT_ZERO;
      endcase

   end
end

// generates the skip insertion request, which is based on frm_skpq_pend.
assign ose_skp_clr = (snd_fts_split) ? fts_skp_clr_split : snd_skp_split;
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)            skpq_pend <= 1'b0;
   else if (ose_skp_clr)  skpq_pend <= 1'b0;
   else if (frm_skpq_val_split && (|ltssm_snd_os_split == 1'b1) &&
           (ltssm_snd_ostype_split != OS_COMPLI) && (ltssm_l0_split == 1'b0)) skpq_pend <= 1'b1;
end

// generate the SKIP pattern
assign ose_skp_snt = snd_skp_split;
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      {skp_data,skp_kcntl} <= {32'd0,4'd0};
      {snd_skp,snd_idle_d0} <= 2'd0;
      snd_skp_q <= 1'b0;
      skp_sel <= 1'b0;
      snd_idle_skp_q <= 1'b0;
   end
   else begin
      snd_idle_skp_q <= snd_idle_skp_split;
      snd_idle_d0  <= snd_idle_split;

      if(rate_5g_split) begin
        skp_data  <= {K28_5, SKP, SKP, SKP};
        skp_kcntl <= 4'b1111;
      end
      else begin
        skp_data  <= skp_sel_split ? {SKP, SKP, 16'd0} : {K28_5, SKP, 16'd0};
        skp_kcntl <= 4'b1100;
      end
      skp_sel <= (~rate_5g_split & (ts_snd_skp_split |
                              eidle_snd_skp_split |
                              fts_snd_skp_split |
                              snd_idle_skp_split)) ? ~skp_sel_split : 1'b0;

      if ((ts_snd_skp_split) || (eidle_snd_skp_split) || (fts_snd_skp_split) || snd_idle_skp_split)
      //if ((ts_snd_skp) || (eidle_snd_skp) || (fts_snd_skp))
         snd_skp   <= 1'b1;
      else snd_skp <= 1'b0;
      snd_skp_q <= snd_skp_split;
   end
end
//Send SKIP before sending IDLES in config_idle state or Recovery idle state
//So, generate a pulse when ltssm is requesting to sending IDLE
assign snd_idle_skp = skpq_pend_split & snd_idle_split & ~snd_idle_skp_q_split;

// SM generates FTS pattern
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_ftsgen   <= FTBYT_ZERO;
      {fts_data,fts_kcntl,fts_snd_skp,fts_skp_clr} <= 'd0;
   end
   else if (rate_5g_split) begin
      fts_snd_skp <= 1'b0;
      fts_skp_clr <= 1'b0;
      case(cs_ftsgen_split)
         FTBYT_ZERO: begin
           if (snd_fts_split) cs_ftsgen <= FTBYT_ONE;
           else         cs_ftsgen <= FTBYT_ZERO;
           fts_data  <= {K28_5, FTS, FTS, FTS};
           fts_kcntl <= 4'b1111;
           // Send FTS ONLY
           if (ltssm_nfts_rx_cnt_split == 1'b1) begin
              cs_ftsgen   <= FTBYT_ZERO;
              fts_snd_skp <= 1'b0;
           end
           // Send SKP at the end of N_FTS
           else begin
             if (ltssm_snd_ostype_split == OS_NFTS) begin
               cs_ftsgen   <= (ltssm_nfts_rx_skp_split || skpq_pend_split) ? FTBYT_SKP : FTBYT_ZERO ;
               fts_snd_skp <= (ltssm_nfts_rx_skp_split || skpq_pend_split) ? 1'b1 : 1'b0;
             end
             else
               cs_ftsgen <= FTBYT_ZERO;
           end
         end
         FTBYT_SKP: begin
            cs_ftsgen   <= FTBYT_ZERO;
            fts_skp_clr <= 1'b1;
         end
         default:cs_ftsgen <= FTBYT_ZERO;
      endcase
   end
   else begin // Gen1 rate
      fts_snd_skp <= 1'b0;
      fts_skp_clr <= 1'b0;
      case(cs_ftsgen_split)
         FTBYT_ZERO: begin
            if (snd_fts_split) cs_ftsgen <= FTBYT_ONE;
            else         cs_ftsgen <= FTBYT_ZERO;
            fts_data  <= {K28_5,FTS, 16'd0};
            fts_kcntl <= {1'b1, 1'b1,2'b00};
         end
         FTBYT_ONE: begin
            // Send FTS ONLY
            if (ltssm_nfts_rx_cnt_split == 1'b1) begin
               cs_ftsgen   <= FTBYT_ZERO;
               fts_snd_skp <= 1'b0;
            end
            // Send SKP at the end of N_FTS
            else if (ltssm_nfts_rx_skp_split) begin
               cs_ftsgen   <= FTBYT_ONE;
               fts_snd_skp <= 1'b1;
            end
            // Insert SKP after NFTS if pending found
            else begin
               cs_ftsgen   <= (skpq_pend_split) ? FTBYT_SKP : FTBYT_ZERO ;
               fts_snd_skp <= (skpq_pend_split) ? 1'b1 : 1'b0;
            end
            fts_data    <= {FTS, FTS,16'd0};
            fts_kcntl   <= {1'b1,1'b1,2'b00};
         end
         FTBYT_SKP: begin
            cs_ftsgen   <= (snd_skp_split) ? FTBYT_ZERO : FTBYT_SKP;
            fts_skp_clr <= 1'b1;
         end
         default: cs_ftsgen <= FTBYT_ZERO;
      endcase
   end
end

// SM generates the Compliance pattern for GEN1 mode.
// pc_cnt counts Compliance patten i.e K28_5,D21_5,K28_5,D10_2
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      {cs_pcgen0,cs_pcgen1} <= {PCBYT_ZERO,PCBYT_ZERO};
      {pc_data0,pc_data1}   <= 'd0;
      {pc_kcntl0,pc_kcntl1,pc_fndisp0,pc_fndisp1,pc_cnt_5g,pc_cnt} <= 'd0;
   end
   else if (rate_5g_split) begin
      pc_cnt_5g <=  pc_cnt_5g_split + 1;
      if ((pc_cnt_5g_split==0)||(pc_cnt_5g_split==3)) begin
         pc_data0   <= {K28_5,K28_5,K28_5,K28_5};
         pc_kcntl0  <= 4'b1111;
         pc_fndisp0 <= 4'b0000;
      end
      else begin
         pc_data0   <= {K28_5,D21_5,K28_5,D10_2};
         pc_kcntl0  <= 4'b1010;
         pc_fndisp0 <= 4'b1000;
      end
      if ((pc_cnt_5g_split==4)||(pc_cnt_5g_split==7)) begin
         pc_data1   <= {K28_5,K28_5,K28_5,K28_5};
         pc_kcntl1  <= 4'b1111;
         pc_fndisp1 <= 4'b0000;
      end
      else begin
         pc_data1   <= {K28_5,D21_5,K28_5,D10_2};
         pc_kcntl1  <= 4'b1010;
         pc_fndisp1 <= 4'b1000;
      end
   end
   else begin // Gen1 rate
      pc_cnt <=  pc_cnt_split + 1;
      if ((pc_cnt_split==0)||(pc_cnt_split==3)) begin
         pc_data0   <= {K28_5,K28_5,16'd0};
         pc_kcntl0  <= 4'b1100;
         pc_fndisp0 <= 4'b0000;
      end
      else if (pc_cnt_split[0]) begin
         pc_data0   <= {K28_5,D21_5,16'd0};
         pc_kcntl0  <= 4'b1000;
         pc_fndisp0 <= 4'b1000;
      end
      else if (!pc_cnt_split[0]) begin
         pc_data0   <= {K28_5,D10_2,16'd0};
         pc_kcntl0  <= 4'b1000;
         pc_fndisp0 <= 4'b0000;
      end
      if ((pc_cnt_split==4)||(pc_cnt_split==7)) begin
         pc_data1   <= {K28_5,K28_5,16'd0};
         pc_kcntl1  <= 4'b1100;
         pc_fndisp1 <= 4'b0000;
      end
      else if ((pc_cnt_split==5)|| !pc_cnt_split[0]) begin
         pc_data1   <= {K28_5,D21_5,16'd0};
         pc_kcntl1  <= 4'b1000;
         pc_fndisp1 <= 4'b1000;
      end
      else if ((pc_cnt_split==6)|| pc_cnt_split[0]) begin
         pc_data1   <= {K28_5,D10_2,16'd0};
         pc_kcntl1  <= 4'b1000;
         pc_fndisp1 <= 4'b0000;
      end
   end
end
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      ltssm_snd_ostype_r <= 4'd0;
      ostype_cng <=  4'd0;
   end
   else begin
      ltssm_snd_ostype_r <= ltssm_snd_ostype_split;
      ostype_cng <= (ostype_cng_split & ~(cs_tsgen_split == TSBYT_ZERO)) |
                    (ltssm_snd_ostype_split != ltssm_snd_ostype_r_split);
   end
end
//assign ose_snd_eidle = snd_eidle;
assign ose_snd_eidle = (ltssm_snd_ostype_split == OS_EIDLE) & (cs_tsgen_split == TSBYT_ZERO);
// Generate requests
// Changed TS Type (snd_t1) only when CS_TSGEN is in first state TSBYT_ZERO
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      {snd_ts,snd_t1,snd_pad,snd_idle,snd_eidle,snd_fts,snd_bcn,snd_pc} <= 'd0;
   else if (|ltssm_snd_os_split) begin
      {snd_ts,snd_pad,snd_idle,snd_eidle,snd_fts,snd_bcn,snd_pc} <= 'd0;
      case(ltssm_snd_ostype_split)
         OS_T1_LIP_LAP: begin
            snd_ts    <= 1'b1;
            snd_t1    <= (ostype_cng_split && (cs_tsgen_split == TSBYT_ZERO)) ? 1'b1 : snd_t1_split;
            snd_pad   <= 1'b1;
         end
         OS_T2_LIP_LAP: begin
            snd_ts    <= 1'b1;
            snd_t1    <= ((cs_tsgen_split == TSBYT_ZERO)) ? 1'b0 : snd_t1_split;
            snd_pad   <= 1'b1;
         end
         OS_COMPLI: snd_pc    <= 1'b1;
         OS_T1: begin
            snd_ts    <= 1'b1;
            snd_t1    <= (ostype_cng_split && (cs_tsgen_split == TSBYT_ZERO)) ? 1'b1 : snd_t1_split;
         end
         OS_T2: begin
            snd_ts    <= 1'b1;
            snd_t1    <= ((cs_tsgen_split == TSBYT_ZERO)) ? 1'b0 : snd_t1_split;
         end
         OS_IDLE: begin
           snd_idle  <= ((cs_tsgen_split == TSBYT_ZERO)) ? 1'b1 : snd_idle_split;
           snd_ts    <= ((cs_tsgen_split == TSBYT_ZERO)) ? 1'b0 : snd_ts_split;
           snd_t1    <= ((cs_tsgen_split == TSBYT_ZERO)) ? 1'b0 : snd_t1_split;
         end
         OS_EIDLE: begin
           snd_eidle <= ((cs_tsgen_split == TSBYT_ZERO)) ? 1'b1 : snd_eidle_split;
           snd_ts    <= ((cs_tsgen_split == TSBYT_ZERO)) ? 1'b0 : snd_ts_split;
           snd_t1    <= ((cs_tsgen_split == TSBYT_ZERO)) ? 1'b0 : snd_t1_split;
         end
         OS_NFTS:  snd_fts   <= 1'b1;
         OS_BEACON:snd_bcn   <= 1'b1;
         default :{snd_ts,snd_pad,snd_idle,snd_eidle,snd_fts,snd_pc} <= 'd0;
      endcase
   end
   else {snd_ts,snd_t1,snd_pad,snd_idle,snd_eidle,snd_fts,snd_bcn,snd_pc} <= 'd0;
end

// Assign correct data based on LW
generate
if (LANE_WIDTH == 2) begin
   assign ts_data_i   = ts_data_split;
   assign ts_kcntl_i  = ts_kcntl_split;
   assign pc_data_i   = {pc_data0_split,pc_data1_split};
   assign pc_kcntl_i  = {pc_kcntl0_split, pc_kcntl1_split};
   assign pc_fndisp_i = {pc_fndisp0_split, pc_fndisp1_split};
   assign bcn_data_i  = {K28_7,K28_7,K28_7,K28_7};
   assign bcn_kcntl_i = 4'b1111;
   assign ose_linu    = {ts_linu0_split, ts_linu1_split};
   assign ose_lanu    = {ts_lanu0_split, ts_lanu1_split};
end
if (LANE_WIDTH == 1) begin
   assign ts_data_i   = ts_data_split[63:32];
   assign ts_kcntl_i  = ts_kcntl_split[7:4];
   assign pc_data_i   = pc_data0_split;
   assign pc_kcntl_i  = pc_kcntl0_split;
   assign pc_fndisp_i = pc_fndisp0_split;
   assign bcn_data_i  = {K28_7,K28_7};// Used for Beacon has  5 1's 5 0's
   assign bcn_kcntl_i = 2'b11;
   assign ose_linu    = ts_linu0_split;
   assign ose_lanu    = ts_lanu0_split;
end
endgenerate

// Output the requested ordered set
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) ltssm_snd_os_reg <= {LANE_WIDTH{1'b0}};
   else ltssm_snd_os_reg <= ltssm_snd_os_split;
end
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) snd_ts_r <= 1'b0;
   else snd_ts_r <= snd_ts_split;
end
assign snd_ts_m = snd_ts_split & snd_ts_r_split;

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      ose_data  <= {32*LANE_WIDTH{1'b0}};
      ose_kcntl <= {4*LANE_WIDTH{1'b0}};
      ose_fndisp<= {4*LANE_WIDTH{1'b0}};
      ose_val   <= {LANE_WIDTH{1'b0}};
   end
   //else if (snd_skp || snd_idle_skp) begin
   else if (snd_skp_split | (snd_skp_q_split & ~rate_5g_split)) begin
      ose_data   <= {LANE_WIDTH{skp_data_split}};
      ose_kcntl  <= {LANE_WIDTH{skp_kcntl_split}};
      ose_fndisp <= {4*LANE_WIDTH{1'b0}};
      ose_val    <= {LANE_WIDTH{1'b1}};
   end
   else begin
      ose_val    <= ltssm_snd_os_reg_split;
      casex({snd_ts_m_split, snd_eidle_split, snd_fts_split, snd_pc_split, snd_idle_split,snd_bcn_split})
         6'b1xxxxx: begin
            ose_data   <= ts_data_i_split;
            ose_kcntl  <= ts_kcntl_i_split;
            ose_fndisp <= {4*LANE_WIDTH{1'b0}};
         end
         6'bx1xxxx: begin
            ose_data   <= {LANE_WIDTH{eidle_data_split}} ;
            ose_kcntl  <= {LANE_WIDTH{eidle_kcntl_split}} ;
            ose_fndisp <= {4*LANE_WIDTH{1'b0}};
         end
         6'bxx1xxx: begin
            ose_data   <= {LANE_WIDTH{fts_data_split}};
            ose_kcntl  <= {LANE_WIDTH{fts_kcntl_split}};
            ose_fndisp <= {4*LANE_WIDTH{1'b0}};
         end
         6'bxxx1xx: begin
            ose_data   <= pc_data_i_split;
            ose_kcntl  <= pc_kcntl_i_split;
            ose_fndisp <= pc_fndisp_i_split;
         end
         6'bxxxx1x: begin
            ose_data  <= {32*LANE_WIDTH{1'b0}};
            ose_kcntl <= {4*LANE_WIDTH{1'b0}};
            ose_fndisp<= {4*LANE_WIDTH{1'b0}};
         end
         6'bxxxxx1: begin
            ose_data   <= (rate_5g_split) ? {K28_7,K28_7,K28_7,K28_7,K28_7,K28_7,K28_7,K28_7} :
                                      {K28_7,K28_7,16'd0,K28_7,K28_7,16'd0};
            ose_kcntl  <= (rate_5g_split)? {4'b1111,4'b1111}:{4'b1100,4'b1100};
            ose_fndisp<= {4*LANE_WIDTH{1'b0}};
         end
      endcase
   end
end

// count ordered sets sent out
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      {rcvd_t12,rcvd_t1,rcvd_t2,rcvd_idle} <= 'd0;
      {cnt_t2p_t2,cnt_t2_t2,cnt_t2sc_t2,cnt_t2_t1,cnt_idle_idle,cnt_t1p_t1} <= 'd0;
   end
   else begin
      // Start counter after reciving T1/T2/IDLE
      if (ltssm_ccnt_clr_split) {rcvd_t12,rcvd_t1,rcvd_t2,rcvd_idle} <= 4'd0;
      else begin
         rcvd_t12  <= (osd_t1_split|osd_t2_split) ? 1'b1 : rcvd_t12_split;
         rcvd_t1   <= (osd_t1_split)        ? 1'b1 : rcvd_t1_split;
         rcvd_t2   <= (osd_t2_split)        ? 1'b1 : rcvd_t2_split;
         rcvd_idle <= (osd_idle_split)      ? 1'b1 : rcvd_idle_split;
      end

      // Counts TS1 Sent with Link = PAD & Lane = PAD after reciving TS1 on RX
      if (rcvd_t12_split == 1'b0) cnt_t1p_t1 <= 10'd0;
      //else if (snd_ts && snd_t1 && snd_pad && ts_snt && cnt_t1p_t1 < 10'd1023)
      else if (snd_ts_split && snd_t1_split && snd_pad_split && ts_snt_split && cnt_t1p_t1_split < OSE_1023)
         cnt_t1p_t1 <= cnt_t1p_t1_split + 1;
      else cnt_t1p_t1 <= cnt_t1p_t1_split;

      // Counts TS2 Sent with Link = PAD & Lane = PAD after reciving TS2 on RX
      if (rcvd_t2_split == 1'b0) cnt_t2p_t2 <= 5'd0;
      //else if (snd_ts && !snd_t1 && snd_pad && ts_snt && cnt_t2p_t2 < 'd16)
      else if (snd_ts_split && !snd_t1_split && snd_pad_split && ts_snt_split && (cnt_t2p_t2_split < SNT_16))
         cnt_t2p_t2 <= cnt_t2p_t2_split + 1;
      else cnt_t2p_t2 <= cnt_t2p_t2_split;

      // Counts TS2 Sent with sc bit set after reciving TS2 on RX
      if (rcvd_t2_split == 1'b0) cnt_t2sc_t2 <= 6'd0;
      else if (snd_ts_split && ltssm_snd_bit_sc_split && !snd_t1_split && ts_snt_split && (cnt_t2sc_t2_split < SNT_32))
         cnt_t2sc_t2 <= cnt_t2sc_t2_split + 1;
      else cnt_t2sc_t2 <= cnt_t2sc_t2_split;

      // Counts TS2 Sent with Link & Lane dont care after reciving TS2 on RX
      if (rcvd_t2_split == 1'b0) cnt_t2_t2 <= 5'd0;
      //else if (snd_ts && !snd_t1 && ts_snt && cnt_t2_t2 < 'd16)
      else if (snd_ts_split && !ltssm_snd_bit_sc_split && !snd_t1_split && ts_snt_split && (cnt_t2_t2_split < SNT_16))
         cnt_t2_t2 <= cnt_t2_t2_split + 1;
      else cnt_t2_t2 <= cnt_t2_t2_split;

      // Counts TS2 Sent with Link & Lane dont care after reciving TS1 on RX
      if (rcvd_t1_split == 1'b0) cnt_t2_t1 <= 5'd0;
      //else if (snd_ts && !snd_t1 && ts_snt && cnt_t2_t1 < 'd16)
      else if (snd_ts_split && !snd_t1_split && ts_snt_split && (cnt_t2_t1_split < SNT_16))
         cnt_t2_t1 <= cnt_t2_t1_split + 1;
      else cnt_t2_t1 <= cnt_t2_t1_split;

      // Counts Idles Sent receving one IDLE on RX
      if (rcvd_idle_split == 1'b0) cnt_idle_idle <= 5'd0;
      else if (snd_idle_split && (cnt_idle_idle_split < SNT_16))
         cnt_idle_idle <= cnt_idle_idle_split + 2;
      else cnt_idle_idle <= cnt_idle_idle_split;
   end
end

// generate all decodes of counter
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) {ose_1024t1p_t1,ose_32t2_sc_t2,ose_16t2p_t2,ose_16t2_t2,ose_16t2_t1,ose_16idle_idle} <= 'd0;
   else begin
      ose_1024t1p_t1  <= (ltssm_ccnt_clr_split) ? 1'b0 :(cnt_t1p_t1_split    == OSE_1023);
      ose_16t2p_t2    <= (ltssm_ccnt_clr_split) ? 1'b0 :(cnt_t2p_t2_split    == SNT_16/*5'd16*/);
      ose_32t2_sc_t2  <= (ltssm_ccnt_clr_split) ? 1'b0 :(cnt_t2sc_t2_split   == SNT_32/*6'd32*/);
      ose_16t2_t2     <= (ltssm_ccnt_clr_split) ? 1'b0 :(cnt_t2_t2_split     == SNT_16/*5'd16*/);
      ose_16t2_t1     <= (ltssm_ccnt_clr_split) ? 1'b0 :(cnt_t2_t1_split     == SNT_16/*5'd16*/);
      ose_16idle_idle <= (ltssm_ccnt_clr_split) ? 1'b0 :(cnt_idle_idle_split == SNT_16/*5'd16*/);
   end
end
// generate ose_eidle_tx signal
// Delay this signal equal to the delay path in FRM & DGRX (or PCS) blocks
pmi_distributed_dpram #(
   .pmi_addr_depth       ( 16 ),
   .pmi_addr_width       ( 4 ),
   .pmi_data_width       ( LANE_WIDTH ),
   .pmi_regmode          ("noreg" ),
   .pmi_init_file        ("none" ),
   .pmi_init_file_format ("binary" ),
 

`ifdef ECP5UM


   .pmi_family           ("ECP5U"),
 

`else


   .pmi_family           ("ECP3"),
 

`endif


   .module_type          ("pmi_distributed_dpram"))

   u1_pmi_distributed_dpram (
   .WrAddress            ( wr_ptr ),
   .Data                 ( ltssm_eidle_tx ),
   .WrClock              ( sys_clk ),
   .WE                   ( 1'b1 ),
   .WrClockEn            ( 1'b1 ),
   .RdAddress            ( rd_ptr ),
   .RdClock              ( sys_clk ),
   .RdClockEn            ( rd_en ),
   .Reset                ( ~rst_n ),
   .Q                    ( ose_eidle_tx )
   );

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) wr_ptr <= 4'd0 ;
   else        wr_ptr <=  wr_ptr_split + 4'd1;
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)                         rd_en <= 1'b0 ;
   else if (wr_ptr_split == TX_EIDL_CNT_split - 1) rd_en <=  1'b1;
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)     rd_ptr <= 4'd0 ;
   else if (rd_en_split) rd_ptr <= rd_ptr_split + 4'd1 ;
end

always@* begin LINK_NUM_split<={LINK_NUM>>1,descram_out[0]};TX_EIDL_CNT_split<={TX_EIDL_CNT>>1,descram_out[1]};ltssm_eidle_tx_split<={ltssm_eidle_tx>>1,descram_out[2]};ltssm_ccnt_clr_split<=descram_out[3];ltssm_nfts_tx_split<={ltssm_nfts_tx>>1,descram_out[4]};ltssm_nfts_rx_cnt_split<=descram_out[5];ltssm_nfts_rx_skp_split<=descram_out[6];ltssm_snd_bit_sc_split<={ltssm_snd_bit_sc>>1,descram_out[7]};ltssm_snd_os_split<={ltssm_snd_os>>1,descram_out[8]};ltssm_snd_ostype_split<={ltssm_snd_ostype>>1,descram_out[9]};ltssm_cfg_split<=descram_out[10];ltssm_cfg_linu_split<={ltssm_cfg_linu>>1,descram_out[11]};ltssm_cfg_lanu_split<={ltssm_cfg_lanu>>1,descram_out[12]};ltssm_disable_scr_split<=descram_out[13];ltssm_snd_hrst_split<=descram_out[14];ltssm_snd_dis_split<=descram_out[15];ltssm_snd_lbk_split<={ltssm_snd_lbk>>1,descram_out[16]};ltssm_l0_split<=descram_out[17];rate_5g_split<=descram_out[18];osd_t1_split<=descram_out[19];osd_t2_split<=descram_out[20];osd_idle_split<=descram_out[21];osd_linu_split<={osd_linu>>1,descram_out[22]};frm_skpq_val_split<=descram_out[23];cfg_dwn_lane_split<=descram_out[24];ts_tctl0_split<={ts_tctl0>>1,descram_out[25]};ts_tctl1_split<={ts_tctl1>>1,descram_out[26]};drate_id0_split<={drate_id0>>1,descram_out[27]};drate_id1_split<={drate_id1>>1,descram_out[28]};ts_nfts_split<={ts_nfts>>1,descram_out[29]};ts_data_i_split<={ts_data_i>>1,descram_out[30]};pc_data_i_split<={pc_data_i>>1,descram_out[31]};bcn_data_i_split<={bcn_data_i>>1,descram_out[32]};ts_kcntl_i_split<={ts_kcntl_i>>1,descram_out[33]};pc_kcntl_i_split<={pc_kcntl_i>>1,descram_out[34]};bcn_kcntl_i_split<={bcn_kcntl_i>>1,descram_out[35]};pc_fndisp_i_split<={pc_fndisp_i>>1,descram_out[36]};cs_tsgen_split<={cs_tsgen>>1,descram_out[37]};cs_eidlegen_split<={cs_eidlegen>>1,descram_out[38]};cs_ftsgen_split<={cs_ftsgen>>1,descram_out[39]};cs_pcgen0_split<={cs_pcgen0>>1,descram_out[40]};cs_pcgen1_split<={cs_pcgen1>>1,descram_out[41]};ltssm_snd_os_reg_split<={ltssm_snd_os_reg>>1,descram_out[42]};wr_ptr_split<={wr_ptr>>1,descram_out[43]};rd_ptr_split<={rd_ptr>>1,descram_out[44]};ts_linu0_split<={ts_linu0>>1,descram_out[45]};ts_linu1_split<={ts_linu1>>1,descram_out[46]};ts_lanu0_split<={ts_lanu0>>1,descram_out[47]};ts_lanu1_split<={ts_lanu1>>1,descram_out[48]};lanu_0_split<={lanu_0>>1,descram_out[49]};lanu_1_split<={lanu_1>>1,descram_out[50]};ts_linu_kcntl0_split<=descram_out[51];ts_linu_kcntl1_split<=descram_out[52];ts_lanu_kcntl0_split<=descram_out[53];ts_lanu_kcntl1_split<=descram_out[54];snd_ts_split<=descram_out[55];snd_t1_split<=descram_out[56];snd_pad_split<=descram_out[57];snd_idle_split<=descram_out[58];snd_eidle_split<=descram_out[59];snd_fts_split<=descram_out[60];snd_bcn_split<=descram_out[61];snd_pc_split<=descram_out[62];ts_snt_split<=descram_out[63];snd_idle_skp_q_split<=descram_out[64];eidle_data_split<={eidle_data>>1,descram_out[65]};skp_data_split<={skp_data>>1,descram_out[66]};fts_data_split<={fts_data>>1,descram_out[67]};pc_data0_split<={pc_data0>>1,descram_out[68]};pc_data1_split<={pc_data1>>1,descram_out[69]};eidle_kcntl_split<={eidle_kcntl>>1,descram_out[70]};skp_kcntl_split<={skp_kcntl>>1,descram_out[71]};fts_kcntl_split<={fts_kcntl>>1,descram_out[72]};ltssm_snd_ostype_r_split<={ltssm_snd_ostype_r>>1,descram_out[73]};pc_kcntl0_split<={pc_kcntl0>>1,descram_out[74]};pc_kcntl1_split<={pc_kcntl1>>1,descram_out[75]};pc_fndisp0_split<={pc_fndisp0>>1,descram_out[76]};pc_fndisp1_split<={pc_fndisp1>>1,descram_out[77]};cnt_t2p_t2_split<={cnt_t2p_t2>>1,descram_out[78]};cnt_t2_t2_split<={cnt_t2_t2>>1,descram_out[79]};cnt_t2_t1_split<={cnt_t2_t1>>1,descram_out[80]};cnt_idle_idle_split<={cnt_idle_idle>>1,descram_out[81]};cnt_t2sc_t2_split<={cnt_t2sc_t2>>1,descram_out[82]};rcvd_t12_split<=descram_out[83];rcvd_t1_split<=descram_out[84];rcvd_t2_split<=descram_out[85];rcvd_idle_split<=descram_out[86];ostype_cng_split<=descram_out[87];snd_skp_split<=descram_out[88];skpq_pend_split<=descram_out[89];ts_snd_skp_split<=descram_out[90];eidle_snd_skp_split<=descram_out[91];fts_snd_skp_split<=descram_out[92];snd_idle_d0_split<=descram_out[93];snd_skp_q_split<=descram_out[94];skp_sel_split<=descram_out[95];fts_skp_clr_split<=descram_out[96];rd_en_split<=descram_out[97];ts_data_split<={ts_data>>1,descram_out[98]};ts_kcntl_split<={ts_kcntl>>1,descram_out[99]};cnt_tsid_split<={cnt_tsid>>1,descram_out[100]};pc_cnt_5g_split<={pc_cnt_5g>>1,descram_out[101]};pc_cnt_split<={pc_cnt>>1,descram_out[102]};cnt_t1p_t1_split<={cnt_t1p_t1>>1,descram_out[103]};snd_idle_skp_split<=descram_out[104];snd_ts_r_split<=descram_out[105];snd_ts_m_split<=descram_out[106];end
always@* begin descram_in[2047]<=TX_EIDL_CNT[0];descram_in[2046]<=ltssm_eidle_tx[0];descram_in[2044]<=ltssm_ccnt_clr;descram_in[2041]<=snd_ts_r;descram_in[2040]<=ltssm_nfts_tx[0];descram_in[2035]<=snd_ts_m;descram_in[2033]<=ltssm_nfts_rx_cnt;descram_in[2032]<=rcvd_t2;descram_in[2019]<=ltssm_nfts_rx_skp;descram_in[2017]<=rcvd_idle;descram_in[2011]<=ltssm_snd_dis;descram_in[1991]<=ltssm_snd_bit_sc[0];descram_in[1987]<=ostype_cng;descram_in[1974]<=ltssm_snd_lbk[0];descram_in[1935]<=ltssm_snd_os[0];descram_in[1926]<=snd_skp;descram_in[1925]<=ts_linu0[0];descram_in[1919]<=pc_cnt_5g[0];descram_in[1900]<=ltssm_l0;descram_in[1892]<=snd_ts;descram_in[1862]<=ts_kcntl_i[0];descram_in[1847]<=pc_fndisp1[0];descram_in[1823]<=ltssm_snd_ostype[0];descram_in[1805]<=skpq_pend;descram_in[1803]<=ts_linu1[0];descram_in[1791]<=pc_cnt[0];descram_in[1790]<=cnt_t2sc_t2[0];descram_in[1753]<=rate_5g;descram_in[1738]<=osd_idle;descram_in[1737]<=snd_t1;descram_in[1723]<=fts_skp_clr;descram_in[1721]<=fts_kcntl[0];descram_in[1676]<=pc_kcntl_i[0];descram_in[1656]<=cs_pcgen1[0];descram_in[1647]<=cnt_t2p_t2[0];descram_in[1619]<=cfg_dwn_lane;descram_in[1608]<=snd_eidle;descram_in[1598]<=ltssm_cfg;descram_in[1562]<=ts_snd_skp;descram_in[1559]<=ts_lanu0[0];descram_in[1534]<=cnt_t1p_t1[0];descram_in[1532]<=rcvd_t12;descram_in[1503]<=ts_kcntl[0];descram_in[1497]<=ts_lanu_kcntl0;descram_in[1485]<=pc_kcntl1[0];descram_in[1458]<=osd_t1;descram_in[1454]<=eidle_kcntl[0];descram_in[1428]<=osd_linu[0];descram_in[1426]<=snd_pad;descram_in[1399]<=rd_en;descram_in[1395]<=ltssm_snd_ostype_r[0];descram_in[1338]<=drate_id1[0];descram_in[1305]<=bcn_kcntl_i[0];descram_in[1264]<=ltssm_snd_os_reg[0];descram_in[1256]<=ts_data_i[0];descram_in[1247]<=cnt_t2_t2[0];descram_in[1191]<=ts_tctl0[0];descram_in[1169]<=snd_fts;descram_in[1163]<=ts_snt;descram_in[1149]<=ltssm_cfg_linu[0];descram_in[1127]<=cs_tsgen[0];descram_in[1114]<=skp_data[0];descram_in[1077]<=eidle_snd_skp;descram_in[1070]<=ts_lanu1[0];descram_in[1023]<=LINK_NUM[0];descram_in[1020]<=snd_idle_skp;descram_in[1016]<=rcvd_t1;descram_in[1005]<=ltssm_snd_hrst;descram_in[962]<=rd_ptr[0];descram_in[959]<=cnt_tsid[0];descram_in[946]<=ts_lanu_kcntl1;descram_in[931]<=bcn_data_i[0];descram_in[923]<=pc_fndisp0[0];descram_in[895]<=cnt_idle_idle[0];descram_in[869]<=osd_t2;descram_in[861]<=skp_sel;descram_in[860]<=skp_kcntl[0];descram_in[828]<=cs_pcgen0[0];descram_in[809]<=frm_skpq_val;descram_in[804]<=snd_idle;descram_in[751]<=ts_data[0];descram_in[748]<=ts_linu_kcntl1;descram_in[742]<=pc_kcntl0[0];descram_in[727]<=pc_data1[0];descram_in[669]<=drate_id0[0];descram_in[628]<=ts_nfts[0];descram_in[581]<=snd_pc;descram_in[563]<=pc_fndisp_i[0];descram_in[557]<=eidle_data[0];descram_in[502]<=ltssm_disable_scr;descram_in[481]<=wr_ptr[0];descram_in[465]<=pc_data_i[0];descram_in[447]<=cnt_t2_t1[0];descram_in[430]<=snd_skp_q;descram_in[414]<=cs_ftsgen[0];descram_in[374]<=ts_linu_kcntl0;descram_in[363]<=pc_data0[0];descram_in[334]<=ts_tctl1[0];descram_in[290]<=snd_bcn;descram_in[278]<=snd_idle_skp_q;descram_in[251]<=ltssm_cfg_lanu[0];descram_in[215]<=snd_idle_d0;descram_in[207]<=cs_eidlegen[0];descram_in[187]<=lanu_1[0];descram_in[181]<=fts_data[0];descram_in[107]<=fts_snd_skp;descram_in[93]<=lanu_0[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : pol_sm.v


// Description      : This module implements the POLLING Sub state machine as


//                    described in sec  4.2.6.2


//                    Signal Naming convention example


//                    snt_16t2p_t2 = 16 Ts2 with lane & link set to Pad sent


//                    after receiving Ts2


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module pol_sm#(
   parameter LANE_WIDTH   = 2) (
   input wire                   sys_clk,         
   input wire                   rst_n,           

   input wire [3:0]             main_state,      
   input wire                   cnt_done_1p5ms,  
   input wire                   cnt_done_24ms,   
   input wire                   cnt_done_48ms,   
   input wire                   cnt_done_1024t1, 
   input wire [LANE_WIDTH-1:0]  det_lanes,       
   input wire [LANE_WIDTH-1:0]  asb_eidle_rx,    
   input wire [LANE_WIDTH-1:0]  ose_1024t1p_t1,  
   input wire [LANE_WIDTH-1:0]  ose_16t2p_t2,    
   input wire [LANE_WIDTH-1:0]  osd_8t12_liplap, 
   input wire [LANE_WIDTH-1:0]  osd_8t2_liplap,  
   input      [LANE_WIDTH-1:0]  osd_8t1_liplap_comp, 
   input      [LANE_WIDTH-1:0]  osd_8t12_bit_5g, 
   input      [LANE_WIDTH-1:0]  osd_8t1_deemph,
   input      [LANE_WIDTH-1:0]  osd_eidle,
   input                        cs_enter_compliance, 
   input      [3:0]             cs_target_lnk_spd,
   input                        cs_comp_demp,
   input                        ltssm_snd_eidle,

   output reg [LANE_WIDTH-1:0]  pol_eidle_tx,    
   output reg                   pol_inv_polar,   
   output reg                   pol_start_cnt,   
   output reg [LANE_WIDTH-1:0]  pol_snd_os,      
   output reg [3:0]             pol_snd_ostype,  
   output reg                   pol_gto_det,     
   output reg                   pol_gto_cfg,     
   output wire                  pol_compliance,  
   output reg                   pol_compl_rate,
   output reg                   pol_compl_deemph,
   output reg [2:0]             cs_pol_sm        // POLLING SM state


    );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam POL_WAIT       = 3'd0 ;
localparam POL_ACTIVE     = 3'd1 ;
localparam POL_COMPLIANCE = 3'd2 ;
localparam POL_CONFIG     = 3'd3 ;
localparam POL_EXIT       = 3'd4 ;
localparam                    ST_COMPL_IDLE       = 4'd0;
localparam                    ST_COMPL_EIOS       = 4'd1;
localparam                    ST_COMPL_SPEED      = 4'd2;
localparam                    ST_COMPL_MODE1      = 4'd3;
localparam                    ST_COMPL_MODE2      = 4'd4;
localparam                    ST_COMPL_MODE3      = 4'd5;
localparam                    ST_COMPL_DONE_EIOS  = 4'd6;
localparam                    ST_COMPL_DONE_SPEED = 4'd7;
localparam                    ST_COMPL_EXIT_ACT   = 4'd8;
localparam                    ST_COMPL_EXIT_DET   = 4'd9;
wire [LANE_WIDTH-1:0]  snt_1024t1p_t1;
wire [LANE_WIDTH-1:0]  snt_16t2p_t2;
wire [LANE_WIDTH-1:0]  rcvd_8t12_liplap;
wire [LANE_WIDTH-1:0]  rcvd_8t2_liplap;
wire [LANE_WIDTH-1:0]  rcvd_8t1_liplap_comp;
wire [LANE_WIDTH-1:0]  eidle;
wire [LANE_WIDTH-1:0]  rcvd_eidle_os;
reg  [LANE_WIDTH-1:0]   store_all_eexit;
reg  [1:0]              next_pol_speed_deemph;
reg  [LANE_WIDTH-1:0]   snd_compl_os;
reg  [3:0]              snd_compl_ostype;
reg  [3:0]              compl_sm_cs;
reg  [3:0]              goto_compliance;
reg  [3:0]              wait_eios_cntr;
reg                     compl_start_cnt;
integer                 i;
reg  [15*8:0] POL_SM;
reg [3 : 0] main_state_split;
reg cnt_done_1p5ms_split;
reg cnt_done_24ms_split;
reg cnt_done_48ms_split;
reg cnt_done_1024t1_split;
reg [LANE_WIDTH - 1 : 0] det_lanes_split;
reg [LANE_WIDTH - 1 : 0] asb_eidle_rx_split;
reg [LANE_WIDTH - 1 : 0] ose_1024t1p_t1_split;
reg [LANE_WIDTH - 1 : 0] ose_16t2p_t2_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_liplap_split;
reg [LANE_WIDTH - 1 : 0] osd_8t2_liplap_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_liplap_comp_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_bit_5g_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_deemph_split;
reg [LANE_WIDTH - 1 : 0] osd_eidle_split;
reg cs_enter_compliance_split;
reg [3 : 0] cs_target_lnk_spd_split;
reg cs_comp_demp_split;
reg ltssm_snd_eidle_split;
reg [LANE_WIDTH - 1 : 0] snt_1024t1p_t1_split;
reg [LANE_WIDTH - 1 : 0] snt_16t2p_t2_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8t12_liplap_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8t2_liplap_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8t1_liplap_comp_split;
reg [LANE_WIDTH - 1 : 0] eidle_split;
reg [LANE_WIDTH - 1 : 0] rcvd_eidle_os_split;
reg [LANE_WIDTH - 1 : 0] store_all_eexit_split;
reg [1 : 0] next_pol_speed_deemph_split;
reg [LANE_WIDTH - 1 : 0] snd_compl_os_split;
reg [3 : 0] snd_compl_ostype_split;
reg [3 : 0] compl_sm_cs_split;
reg [3 : 0] goto_compliance_split;
reg [3 : 0] wait_eios_cntr_split;
reg compl_start_cnt_split;
reg [15 * 8 : 0] POL_SM_split;
reg [2047:0] descram_in;
wire [34:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 35,descram_inst_SCRAMSTRING = 32'hfdffd28b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// for cs_pol_sm
// [3:2] - type [1] - deemp, [0] - speed
assign pol_compliance = (cs_pol_sm == POL_COMPLIANCE) ? 1'b1 : 1'b0;

// =============================================================================
// The following and's the signal with Lanes that were detected during DETECT
// so that the un detected lanes are masked by making the bits zero
// =============================================================================
// This indicate that 1024 TS1 ordered sets were sent after receiving one TS1
assign snt_1024t1p_t1  = ose_1024t1p_t1_split & det_lanes_split;

// This indicate that 16 TS2 ordered sets were sent after receiving one TS2
assign snt_16t2p_t2    = ose_16t2p_t2_split & det_lanes_split;

// This indicate that 8 TS1 or 8 TS2 ordered sets were received with Lane & Link set to PAD
assign rcvd_8t12_liplap= osd_8t12_liplap_split & det_lanes_split;

// This indicate that 8 TS2 ordered sets were received with Lane & Link set to PAD
assign rcvd_8t2_liplap = osd_8t2_liplap_split  & det_lanes_split;

// This indicate that 8 TS1 ordered sets were received with Lane & Link set to PAD and compliance bit asserted
assign rcvd_8t1_liplap_comp = osd_8t1_liplap_comp_split  & det_lanes_split;

// This indicate that electrical idle
assign eidle           = asb_eidle_rx_split  & det_lanes_split;
assign rcvd_eidle_os   = osd_eidle_split & det_lanes_split;

// =============================================================================
// The following implements the Polling SM as described in section 4.2.6.2 of the
// PCI Express Spec 1.0a.
// Note: Polling Speed State not implemented since we support only one speed
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_pol_sm        <= POL_WAIT;
      pol_start_cnt    <= 1'b0;
      pol_snd_os       <= {(LANE_WIDTH){1'b0}};
      pol_snd_ostype   <= OS_T1_LIP_LAP;
      pol_inv_polar    <= 1'b0;
      pol_gto_det      <= 1'b0;
      pol_gto_cfg      <= 1'b0;
      store_all_eexit  <= {(LANE_WIDTH){1'b0}};
      goto_compliance  <= 'd0;
      next_pol_speed_deemph <= 2'b01;
   end
   else begin
      pol_start_cnt    <= 1'b0;
      pol_gto_det      <= 1'b0;
      pol_gto_cfg      <= 1'b0;
      pol_inv_polar    <= 1'b0;
      case(cs_pol_sm)
         // Wait for Main SM to go to POLLING
         POL_WAIT: begin
            store_all_eexit  <= {(LANE_WIDTH){1'b0}};
            next_pol_speed_deemph <= 2'b01;
            goto_compliance  <= 'd0;
            if (main_state_split == POLLING) begin
              if(cs_enter_compliance_split) begin
                cs_pol_sm       <= POL_COMPLIANCE;
                pol_snd_os      <= (cs_target_lnk_spd_split == 4'd2)? {(LANE_WIDTH){1'b0}} : det_lanes_split;
                pol_snd_ostype  <= OS_COMPLI;
                pol_start_cnt   <= (cs_target_lnk_spd_split == 4'd2);
                goto_compliance[0] <= (cs_target_lnk_spd_split == 4'd2);
                goto_compliance[1] <= (cs_target_lnk_spd_split == 4'd2)? cs_comp_demp_split : 1'b1;
                goto_compliance[3:2] <= 2'b01;
              end
              else begin
                cs_pol_sm        <= POL_ACTIVE;
                pol_start_cnt    <= 1'b1;
                pol_snd_os       <= det_lanes_split;
                pol_snd_ostype   <= OS_T1_LIP_LAP;
              end
            end
            else begin
               cs_pol_sm        <= POL_WAIT;
               pol_snd_os       <= {(LANE_WIDTH){1'b0}};
            end
         end
         // Send & receive TS1 ordered sets
         POL_ACTIVE: begin
            // During active state store if ALL lane exit from eidle
            for (i=0; i<LANE_WIDTH; i=i+1) begin
               if (store_all_eexit_split[i] == 1'b0)
                 store_all_eexit[i] <= (asb_eidle_rx_split[i] == 0) ? 1'b1 : 1'b0;
            end

            if(cs_enter_compliance_split) begin
              cs_pol_sm       <= POL_COMPLIANCE;
              pol_snd_os      <= det_lanes_split;
              pol_snd_ostype  <= (cs_target_lnk_spd_split == 4'd2)? OS_EIDLE : OS_COMPLI;
              pol_start_cnt   <= (cs_target_lnk_spd_split == 4'd2);
              goto_compliance[0] <= (cs_target_lnk_spd_split == 4'd2);
              goto_compliance[1] <= (cs_target_lnk_spd_split == 4'd2)? cs_comp_demp_split : 1'b1;
              goto_compliance[3:2] <= 2'b01;
            end
            else if (rcvd_8t12_liplap_split == det_lanes_split  && cnt_done_1024t1_split && ~pol_start_cnt) begin
               cs_pol_sm       <= POL_CONFIG;
               pol_snd_os      <= det_lanes_split;
               pol_snd_ostype  <= OS_T2_LIP_LAP;
               pol_start_cnt   <= 1'b1;
               pol_inv_polar   <= 1'b1;
            end
            else if (cnt_done_24ms_split && ~pol_start_cnt) begin
               // if all Lanes are in eidle then go to compliance
               //if ((|store_all_eexit == 1'b0)) begin
               if (eidle_split == det_lanes_split) begin
                  cs_pol_sm       <= POL_COMPLIANCE;
                  pol_snd_os      <= det_lanes_split;
                  pol_snd_ostype  <= (next_pol_speed_deemph_split[1])? OS_EIDLE : OS_COMPLI;
                  pol_start_cnt   <= next_pol_speed_deemph_split[1];
                  goto_compliance[0] <= next_pol_speed_deemph_split[1];
                  goto_compliance[1] <= next_pol_speed_deemph_split[0];
                  goto_compliance[3:2] <= 2'b11;
                  case(next_pol_speed_deemph_split)
                    2'b01   : next_pol_speed_deemph <= 2'b11;
                    2'b11   : next_pol_speed_deemph <= 2'b10;
                    default : next_pol_speed_deemph <= 2'b01;
                  endcase
               end
               else if ((|rcvd_8t1_liplap_comp_split)) begin
                  cs_pol_sm       <= POL_COMPLIANCE;
                  pol_snd_os      <= det_lanes_split;
                  pol_snd_ostype  <= (|(osd_8t12_bit_5g_split & det_lanes_split))? OS_EIDLE : OS_COMPLI;
                  pol_start_cnt   <= |(osd_8t12_bit_5g_split & det_lanes_split);
                  goto_compliance[0] <= |(osd_8t12_bit_5g_split & det_lanes_split);
                  goto_compliance[1] <= |(osd_8t1_deemph_split & det_lanes_split);
                  goto_compliance[3:2] <= 2'b10;
               end
               else if (|rcvd_8t12_liplap_split == 1'b1 && |snt_1024t1p_t1_split == 1'b1 && |store_all_eexit_split == 1'b1) begin
                  cs_pol_sm       <= POL_CONFIG;
                  pol_snd_os      <= det_lanes_split;
                  pol_snd_ostype  <= OS_T2_LIP_LAP;
                  pol_start_cnt   <= 1'b1;
                  pol_inv_polar   <= 1'b1;
               end
               else begin
                  cs_pol_sm       <= POL_EXIT;
                  pol_gto_det     <= 1'b1;
               end
            end
            else begin
               cs_pol_sm    <= POL_ACTIVE;
            end
         end
         // Found a passive test load on the detected lanes
         POL_COMPLIANCE: begin
            store_all_eexit   <= {(LANE_WIDTH){1'b0}};
            if (compl_sm_cs_split == ST_COMPL_EXIT_ACT) begin
              cs_pol_sm      <= POL_ACTIVE;
              pol_snd_os     <= det_lanes_split;
              pol_snd_ostype <= OS_T1_LIP_LAP;
              pol_start_cnt  <= 1'b1;
              goto_compliance <= 'd0;
            end
            else if (compl_sm_cs_split == ST_COMPL_EXIT_DET) begin
              cs_pol_sm      <= POL_EXIT;
              pol_gto_det    <= 1'b1;
              pol_snd_os     <= {(LANE_WIDTH){1'b0}};
              goto_compliance <= 'd0;
            end
            else begin
              cs_pol_sm      <= POL_COMPLIANCE;
              if(compl_sm_cs_split != ST_COMPL_IDLE) begin
                pol_snd_os     <= snd_compl_os_split;
                pol_snd_ostype <= snd_compl_ostype_split;
                pol_start_cnt  <= compl_start_cnt_split;
              end
            end
         end
         // Send & receive TS2 ordered sets
         POL_CONFIG: begin
            store_all_eexit   <= {(LANE_WIDTH){1'b0}};
            if (|rcvd_8t2_liplap_split == 1'b1 && |snt_16t2p_t2_split == 1'b1 && ~pol_start_cnt) begin
               cs_pol_sm      <= POL_EXIT;
               pol_gto_cfg    <= 1'b1;
               pol_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else if (cnt_done_48ms_split && ~pol_start_cnt) begin
               cs_pol_sm      <= POL_EXIT;
               pol_gto_det    <= 1'b1;
               pol_snd_os     <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_pol_sm      <= POL_CONFIG;
            end
         end
         POL_EXIT: begin
            if (main_state_split != POLLING) begin
               cs_pol_sm   <= POL_WAIT;
            end
            else begin
               cs_pol_sm   <= POL_EXIT;
            end
         end
         default: begin
            cs_pol_sm   <= POL_WAIT;
         end
      endcase
   end
end

//--------------------------------------------
//-- Compliance Mode --
//--------------------------------------------
always @(posedge sys_clk or negedge rst_n) begin
  if(~rst_n) begin
    compl_sm_cs      <= ST_COMPL_IDLE;
    pol_compl_rate   <= 1'b0;
    pol_compl_deemph <= 1'b1;
    pol_eidle_tx     <= {(LANE_WIDTH){1'b0}};
    wait_eios_cntr   <= 'd0;
    snd_compl_os     <= {(LANE_WIDTH){1'b0}};
    snd_compl_ostype <= OS_COMPLI;
    compl_start_cnt  <= 1'b0;
    /*AUTORESET*/
  end
  else begin
    compl_start_cnt <= 1'b0;
    case(compl_sm_cs_split)
      ST_COMPL_EIOS : begin
        wait_eios_cntr <= wait_eios_cntr_split - {3'd0,|wait_eios_cntr_split};
        if(ltssm_snd_eidle_split) begin
          compl_sm_cs <= ST_COMPL_SPEED;
          snd_compl_os <= {(LANE_WIDTH){1'b0}};
          pol_eidle_tx <= {(LANE_WIDTH){1'b1}};
          compl_start_cnt <= 1'b1;
        end
        else begin
          compl_sm_cs <= ST_COMPL_EIOS;
        end
      end
      ST_COMPL_SPEED : begin
        pol_compl_rate   <= goto_compliance_split[0];
        pol_compl_deemph <= goto_compliance_split[1];
        if(cnt_done_1p5ms_split) begin
          pol_eidle_tx <= {(LANE_WIDTH){1'b0}};
          case(goto_compliance_split[3:2])
            2'b01   : compl_sm_cs <= ST_COMPL_MODE1;
            2'b10   : compl_sm_cs <= ST_COMPL_MODE2;
            default : compl_sm_cs <= ST_COMPL_MODE3;
          endcase
        end
        else begin
          compl_sm_cs <= ST_COMPL_SPEED;
        end
      end
      ST_COMPL_MODE1 : begin
        snd_compl_os <= det_lanes_split;
        snd_compl_ostype <= OS_COMPLI;
        if(!cs_enter_compliance_split || (|rcvd_eidle_os_split)) begin
          if(goto_compliance_split[0]) begin
            snd_compl_os <= det_lanes_split;
            snd_compl_ostype <= OS_EIDLE;
            wait_eios_cntr <= 4'h2;
            compl_sm_cs <= ST_COMPL_DONE_EIOS;
          end
          else begin
            compl_sm_cs <= ST_COMPL_EXIT_ACT;
            snd_compl_os <= det_lanes_split;
            snd_compl_ostype <= OS_T1_LIP_LAP;
          end
        end
        else begin
          compl_sm_cs <= ST_COMPL_MODE1;
        end
      end
      ST_COMPL_MODE2 : begin
        snd_compl_os <= det_lanes_split;
        snd_compl_ostype <= OS_COMPLI;
        if(!cs_enter_compliance_split) begin
          compl_sm_cs <= ST_COMPL_EXIT_DET;
          snd_compl_os <= {(LANE_WIDTH){1'b0}};
        end
        else begin
          compl_sm_cs <= ST_COMPL_MODE2;
        end
      end
      ST_COMPL_MODE3 : begin
        snd_compl_os <= det_lanes_split;
        snd_compl_ostype <= OS_COMPLI;
        if((&asb_eidle_rx_split == 0 && !cs_enter_compliance_split) ||
           |rcvd_eidle_os_split) begin
          if(goto_compliance_split[0]) begin
            snd_compl_os <= det_lanes_split;
            snd_compl_ostype <= OS_EIDLE;
            wait_eios_cntr <= 4'hF;
            compl_sm_cs <= ST_COMPL_DONE_EIOS;
          end
          else begin
            compl_sm_cs <= ST_COMPL_EXIT_ACT;
            snd_compl_os <= det_lanes_split;
            snd_compl_ostype <= OS_T1_LIP_LAP;
          end
        end
        else begin
          compl_sm_cs <= ST_COMPL_MODE3;
        end
      end
      ST_COMPL_DONE_EIOS : begin
        wait_eios_cntr <= wait_eios_cntr_split - {3'd0,|wait_eios_cntr_split};
        if(ltssm_snd_eidle_split) begin
          snd_compl_os <= {(LANE_WIDTH){1'b0}};
          compl_sm_cs <= ST_COMPL_DONE_SPEED;
          pol_eidle_tx <= {(LANE_WIDTH){1'b1}};
          compl_start_cnt <= 1'b1;
        end
        else begin
          compl_sm_cs <= ST_COMPL_DONE_EIOS;
        end
      end
      ST_COMPL_DONE_SPEED : begin
        pol_compl_rate   <= 1'b0;
        pol_compl_deemph <= 1'b1;
        if(cnt_done_1p5ms_split) begin
          pol_eidle_tx <= {(LANE_WIDTH){1'b0}};
          snd_compl_os <= det_lanes_split;
          snd_compl_ostype <= OS_T1_LIP_LAP;
          compl_sm_cs <= ST_COMPL_EXIT_ACT;
        end
        else begin
          compl_sm_cs <= ST_COMPL_DONE_SPEED;
        end
      end
      ST_COMPL_EXIT_ACT : begin
        compl_sm_cs <= ST_COMPL_IDLE;
      end
      ST_COMPL_EXIT_DET : begin
        compl_sm_cs <= ST_COMPL_IDLE;
      end
      default : begin
        wait_eios_cntr <= 'd0;
        pol_eidle_tx <= {(LANE_WIDTH){1'b0}};
        snd_compl_os <= pol_snd_os;
        snd_compl_ostype <= pol_snd_ostype;
        pol_compl_rate   <= 1'b0;
        pol_compl_deemph <= 1'b1;
        if(|goto_compliance_split[3:2]) begin
          if(goto_compliance_split[0]) begin
            compl_sm_cs <= ST_COMPL_EIOS;
            wait_eios_cntr <= 4'd2;
          end
          else begin
            case(goto_compliance_split[3:2])
              2'b01   : compl_sm_cs <= ST_COMPL_MODE1;
              2'b10   : compl_sm_cs <= ST_COMPL_MODE2;
              default : compl_sm_cs <= ST_COMPL_MODE3;
            endcase
          end
        end
        else begin
          compl_sm_cs <= ST_COMPL_IDLE;
        end
      end
    endcase
  end
end //--always @(posedge sys_clk or negedge rst_n)--

// =============================================================================
//        STRINGS FOR DEBUGGING
// ====================================================================
always @ (cs_pol_sm)
begin
   case(cs_pol_sm)
      POL_WAIT       : POL_SM = "POL_WAIT";
      POL_ACTIVE     : POL_SM = "POL_ACTIVE";
      POL_COMPLIANCE : POL_SM = "POL_COMP";
      POL_CONFIG     : POL_SM = "POL_CFG";
      POL_EXIT       : POL_SM = "POL_EXIT";
      default         : POL_SM = "ERROR";
   endcase
end


always@* begin main_state_split<={main_state>>1,descram_out[0]};cnt_done_1p5ms_split<=descram_out[1];cnt_done_24ms_split<=descram_out[2];cnt_done_48ms_split<=descram_out[3];cnt_done_1024t1_split<=descram_out[4];det_lanes_split<={det_lanes>>1,descram_out[5]};asb_eidle_rx_split<={asb_eidle_rx>>1,descram_out[6]};ose_1024t1p_t1_split<={ose_1024t1p_t1>>1,descram_out[7]};ose_16t2p_t2_split<={ose_16t2p_t2>>1,descram_out[8]};osd_8t12_liplap_split<={osd_8t12_liplap>>1,descram_out[9]};osd_8t2_liplap_split<={osd_8t2_liplap>>1,descram_out[10]};osd_8t1_liplap_comp_split<={osd_8t1_liplap_comp>>1,descram_out[11]};osd_8t12_bit_5g_split<={osd_8t12_bit_5g>>1,descram_out[12]};osd_8t1_deemph_split<={osd_8t1_deemph>>1,descram_out[13]};osd_eidle_split<={osd_eidle>>1,descram_out[14]};cs_enter_compliance_split<=descram_out[15];cs_target_lnk_spd_split<={cs_target_lnk_spd>>1,descram_out[16]};cs_comp_demp_split<=descram_out[17];ltssm_snd_eidle_split<=descram_out[18];snt_1024t1p_t1_split<={snt_1024t1p_t1>>1,descram_out[19]};snt_16t2p_t2_split<={snt_16t2p_t2>>1,descram_out[20]};rcvd_8t12_liplap_split<={rcvd_8t12_liplap>>1,descram_out[21]};rcvd_8t2_liplap_split<={rcvd_8t2_liplap>>1,descram_out[22]};rcvd_8t1_liplap_comp_split<={rcvd_8t1_liplap_comp>>1,descram_out[23]};eidle_split<={eidle>>1,descram_out[24]};rcvd_eidle_os_split<={rcvd_eidle_os>>1,descram_out[25]};store_all_eexit_split<={store_all_eexit>>1,descram_out[26]};next_pol_speed_deemph_split<={next_pol_speed_deemph>>1,descram_out[27]};snd_compl_os_split<={snd_compl_os>>1,descram_out[28]};snd_compl_ostype_split<={snd_compl_ostype>>1,descram_out[29]};compl_sm_cs_split<={compl_sm_cs>>1,descram_out[30]};goto_compliance_split<={goto_compliance>>1,descram_out[31]};wait_eios_cntr_split<={wait_eios_cntr>>1,descram_out[32]};compl_start_cnt_split<=descram_out[33];POL_SM_split<={POL_SM>>1,descram_out[34]};end
always@* begin descram_in[2047]<=cnt_done_1p5ms;descram_in[2046]<=cnt_done_24ms;descram_in[2044]<=cnt_done_48ms;descram_in[2040]<=cnt_done_1024t1;descram_in[2032]<=det_lanes[0];descram_in[2017]<=asb_eidle_rx[0];descram_in[1987]<=ose_1024t1p_t1[0];descram_in[1926]<=ose_16t2p_t2[0];descram_in[1818]<=rcvd_8t1_liplap_comp[0];descram_in[1804]<=osd_8t12_liplap[0];descram_in[1707]<=snd_compl_ostype[0];descram_in[1614]<=cs_target_lnk_spd[0];descram_in[1589]<=eidle[0];descram_in[1561]<=osd_8t2_liplap[0];descram_in[1394]<=POL_SM[0];descram_in[1372]<=wait_eios_cntr[0];descram_in[1367]<=compl_sm_cs[0];descram_in[1251]<=snt_16t2p_t2[0];descram_in[1180]<=cs_comp_demp;descram_in[1130]<=rcvd_eidle_os[0];descram_in[1074]<=osd_8t1_liplap_comp[0];descram_in[1023]<=main_state[0];descram_in[909]<=rcvd_8t2_liplap[0];descram_in[853]<=snd_compl_os[0];descram_in[807]<=cs_enter_compliance;descram_in[697]<=compl_start_cnt;descram_in[686]<=goto_compliance[0];descram_in[625]<=snt_1024t1p_t1[0];descram_in[454]<=rcvd_8t12_liplap[0];descram_in[426]<=next_pol_speed_deemph[0];descram_in[403]<=osd_eidle[0];descram_in[312]<=ltssm_snd_eidle;descram_in[213]<=store_all_eexit[0];descram_in[201]<=osd_8t1_deemph[0];descram_in[100]<=osd_8t12_bit_5g[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : rcvry_sm.v


// Title            : LTSSM Recovery Sub State Machine


// Dependencies     : pci_exp_params.v


// Description      : This module implements the RECOVERY Sub state machine as


//                    described in sec  4.2.6.4


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Mar 1, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module rcvry_sm #(
   parameter LANE_WIDTH   = 2) (
   input wire                   sys_clk,          
   input wire                   rst_n,            

   input wire                   ext_sync,         
   input wire                   cnt_done_1ms,     
   input wire                   cnt_done_2ms,     
   input wire                   cnt_done_24ms,    
   input wire                   cnt_done_48ms,    
   input wire                   cnt_done_1024t1,  
   input wire [LANE_WIDTH-1:0]  asb_eidle_rx,     
   input wire [LANE_WIDTH-1:0]  osd_eidle_neios,  
   output reg                   rate_5g_req,          
   input wire                   rate_5g_capable,  
   input wire [3:0]             main_state,       
   input wire [LANE_WIDTH-1:0]  cfg_lanes,        
   input wire [LANE_WIDTH-1:0]  ose_32t2_sc_t2,   
   input wire [LANE_WIDTH-1:0]  ose_16t2_t2,      
   input wire [LANE_WIDTH-1:0]  ose_16t2_t1,      
   input wire [LANE_WIDTH-1:0]  ose_16idle_idle,  
   input wire [LANE_WIDTH-1:0]  osd_2t1_lilap,    
   input wire [LANE_WIDTH-1:0]  osd_2t1_lap,      
   input wire [LANE_WIDTH-1:0]  osd_8t12_limlam,  
   input wire [LANE_WIDTH-1:0]  osd_8t12_bit_sc,  
   input wire [LANE_WIDTH-1:0]  osd_8t2_bit_sc,   
   input wire [LANE_WIDTH-1:0]  osd_8t12_bit_5g,  
   input wire [LANE_WIDTH-1:0]  osd_8t2_limlam,   
   input wire [LANE_WIDTH-1:0]  osd_8idle,        
   input wire [LANE_WIDTH-1:0]  osd_8t1_linmlanm, 
   input wire [LANE_WIDTH-1:0]  osd_8t1_linmlam,  
   input wire [LANE_WIDTH-1:0]  osd_8t1_limlanm,  
   input wire [LANE_WIDTH-1:0]  osd_t1_limlam,    
   input wire [LANE_WIDTH-1:0]  osd_t2_limlam,    
   input wire [LANE_WIDTH-1:0]  osd_gto_dis,      
   input wire [LANE_WIDTH-1:0]  osd_gto_hrst,     
   input wire [LANE_WIDTH-1:0]  osd_gto_lbk,      
   input wire                   hl_gto_cfg,       
   input wire [LANE_WIDTH-1:0]  asb_dskew_rx,     
   input                        rate_phy_sts_pulse,
   input                        dis_chng_spd2p5,
   input                        pol_compliance,  
   input                        pol_compl_rate,
   input                        ltssm_snd_eidle,

   output reg                   rcvry_rcvrcfg,    
   output reg                   rcvry_start_cnt,  
   output reg [LANE_WIDTH-1:0]  rcvry_snd_bit_sc, 
   output reg [LANE_WIDTH-1:0]  rcvry_snd_os,     
   output reg [3:0]             rcvry_snd_ostype, 
   output reg                   rcvry_gto_dis,    
   output reg                   rcvry_gto_hrst,   
   output reg                   rcvry_gto_cfg,    
   output reg                   rcvry_gto_lbk,    
   output reg                   rcvry_gto_l0,     
   output reg                   rcvry_gto_det,    
   output reg                   rcvry_nfts_updt,  
   output reg [LANE_WIDTH-1:0]  rcvry_eidle_tx,   
   output reg [2:0]             cs_rcvry_sm       // RECOVERY SM state


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam RCVRY_WAIT    = 3'd0 ;
localparam RCVRY_RCVRLK  = 3'd1 ;
localparam RCVRY_RCVRCFG = 3'd2 ;
localparam RCVRY_IDLE    = 3'd3 ;
localparam RCVRY_EXIT    = 3'd4 ;
localparam RCVRY_SPD1    = 3'd5 ;
localparam RCVRY_SPD2    = 3'd6 ;
localparam RCVRY_SPD     = 3'd7 ;
wire [LANE_WIDTH-1:0]   snt_32t2_sc_t2;
wire [LANE_WIDTH-1:0]   snt_16t2_t2;
wire [LANE_WIDTH-1:0]   snt_16t2_t1;
wire [LANE_WIDTH-1:0]   snt_16idle_idle;
wire [LANE_WIDTH-1:0]   rcvd_8t12;
wire [LANE_WIDTH-1:0]   rcvd_8t12_bit_sc;
wire [LANE_WIDTH-1:0]   rcvd_8t2_bit_sc;
wire [LANE_WIDTH-1:0]   rcvd_8t12_bit_5g;
wire [LANE_WIDTH-1:0]   rcvd_8t2;
wire [LANE_WIDTH-1:0]   rcvd_t12;
wire [LANE_WIDTH-1:0]   rcvd_8idle;
wire [LANE_WIDTH-1:0]   rcvd_8t1_nm;
wire                    rcvd_gto_dis;
wire                    rcvd_gto_hrst;
wire                    rcvd_gto_cfg;
wire                    rcvd_gto_lbk;
wire [LANE_WIDTH-1:0]   rcvd_asb_dskew_rx;
wire [LANE_WIDTH-1:0]   rcvd_eidle;
reg                     stored_rcvd_t12;
reg directed_speed_change_var,
    changed_speed_recovery_var, spd_neg_done;
reg         goto_detect_ORed;
reg         next_speed;
reg         prev_speed;
reg         revert_to_prev_speed;
reg         save_rcvd_t2;
reg         rcvd_eidle_any;
reg [5:0]   goto_detect;
reg         rate_5g_req_q;
reg         pending_rate_change;
reg [5:0]   rate_2_5g_cnt;
reg         enter_to_rcvry;
reg         enter_to_rcvry_dly;
reg [3:0]   enter_dlycnt;
reg [2:0]   wait_eidle_propagate;
reg         delay_tx_eidle;
reg ext_sync_split;
reg cnt_done_1ms_split;
reg cnt_done_2ms_split;
reg cnt_done_24ms_split;
reg cnt_done_48ms_split;
reg cnt_done_1024t1_split;
reg [LANE_WIDTH - 1 : 0] asb_eidle_rx_split;
reg [LANE_WIDTH - 1 : 0] osd_eidle_neios_split;
reg rate_5g_capable_split;
reg [3 : 0] main_state_split;
reg [LANE_WIDTH - 1 : 0] cfg_lanes_split;
reg [LANE_WIDTH - 1 : 0] ose_32t2_sc_t2_split;
reg [LANE_WIDTH - 1 : 0] ose_16t2_t2_split;
reg [LANE_WIDTH - 1 : 0] ose_16t2_t1_split;
reg [LANE_WIDTH - 1 : 0] ose_16idle_idle_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_lilap_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_lap_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_bit_sc_split;
reg [LANE_WIDTH - 1 : 0] osd_8t2_bit_sc_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_bit_5g_split;
reg [LANE_WIDTH - 1 : 0] osd_8t2_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_8idle_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_linmlanm_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_linmlam_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_limlanm_split;
reg [LANE_WIDTH - 1 : 0] osd_t1_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_t2_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_gto_dis_split;
reg [LANE_WIDTH - 1 : 0] osd_gto_hrst_split;
reg [LANE_WIDTH - 1 : 0] osd_gto_lbk_split;
reg hl_gto_cfg_split;
reg [LANE_WIDTH - 1 : 0] asb_dskew_rx_split;
reg rate_phy_sts_pulse_split;
reg dis_chng_spd2p5_split;
reg pol_compliance_split;
reg pol_compl_rate_split;
reg ltssm_snd_eidle_split;
reg [LANE_WIDTH - 1 : 0] snt_32t2_sc_t2_split;
reg [LANE_WIDTH - 1 : 0] snt_16t2_t2_split;
reg [LANE_WIDTH - 1 : 0] snt_16t2_t1_split;
reg [LANE_WIDTH - 1 : 0] snt_16idle_idle_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8t12_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8t12_bit_sc_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8t2_bit_sc_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8t12_bit_5g_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8t2_split;
reg [LANE_WIDTH - 1 : 0] rcvd_t12_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8idle_split;
reg [LANE_WIDTH - 1 : 0] rcvd_8t1_nm_split;
reg rcvd_gto_dis_split;
reg rcvd_gto_hrst_split;
reg rcvd_gto_cfg_split;
reg rcvd_gto_lbk_split;
reg [LANE_WIDTH - 1 : 0] rcvd_asb_dskew_rx_split;
reg [LANE_WIDTH - 1 : 0] rcvd_eidle_split;
reg stored_rcvd_t12_split;
reg directed_speed_change_var_split;
reg changed_speed_recovery_var_split;
reg spd_neg_done_split;
reg goto_detect_ORed_split;
reg next_speed_split;
reg prev_speed_split;
reg revert_to_prev_speed_split;
reg save_rcvd_t2_split;
reg rcvd_eidle_any_split;
reg [5 : 0] goto_detect_split;
reg rate_5g_req_q_split;
reg pending_rate_change_split;
reg [5 : 0] rate_2_5g_cnt_split;
reg enter_to_rcvry_split;
reg enter_to_rcvry_dly_split;
reg [3 : 0] enter_dlycnt_split;
reg [2 : 0] wait_eidle_propagate_split;
reg delay_tx_eidle_split;
reg [2047:0] descram_in;
wire [74:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 75,descram_inst_SCRAMSTRING = 32'hfdffd84b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// for cs_rcvry_sm
// =============================================================================
// The following and's the signal with Lanes that were detected during DETECT
// so that the un detected lanes are masked by making the bits zero
// =============================================================================
// This indicate that 16 TS2 ordered sets were sent after receiving one TS2
assign snt_16t2_t2     = ose_16t2_t2_split & cfg_lanes_split;

// This indicate that 16 TS2 ordered sets were sent after receiving one TS2
assign snt_32t2_sc_t2     = ose_32t2_sc_t2_split & cfg_lanes_split;

// This indicate that 16 TS2 ordered sets were sent after receiving one TS1
assign snt_16t2_t1     = ose_16t2_t1_split & cfg_lanes_split;

// This indicate that 8 Idle ordered sets were sent after receiving one Idle
assign snt_16idle_idle  = ose_16idle_idle_split & cfg_lanes_split;

// This indicate that 8 TS1 or 8 TS2 ordered sets were received with Lane & Link
// numbers matching to that of being transmitted
assign rcvd_8t12       = osd_8t12_limlam_split & cfg_lanes_split;

// This indicate that 8 TS1 or 8 TS2 ordered sets were received with speed change set
assign rcvd_8t12_bit_sc = osd_8t12_bit_sc_split & cfg_lanes_split;

// This indicate that 8 TS2 ordered sets were received with speed change set
assign rcvd_8t2_bit_sc = osd_8t2_bit_sc_split & cfg_lanes_split;

// This indicate that 8 TS1 or 8 TS2 ordered sets were received with 5G supported bit set
assign rcvd_8t12_bit_5g = osd_8t12_bit_5g_split & cfg_lanes_split;

// This indicate that 8 TS2 ordered sets were received with Lane & Link
// numbers matching to that of being transmitted
assign rcvd_8t2        = osd_8t2_limlam_split & cfg_lanes_split;

// This indicate that 8 TS2 ordered sets were received with Lane & Link
// numbers NOT matching to that of being transmitted
assign rcvd_8t1_nm     = (osd_8t1_linmlanm_split | osd_8t1_linmlam_split | osd_8t1_limlanm_split)  & cfg_lanes_split;

// This indicate that 1 TS1 or 1 TS2 ordered sets were received with Lane & Link
// numbers matching to that of being transmitted
assign rcvd_t12        = (osd_t1_limlam_split | osd_t2_limlam_split) & cfg_lanes_split;

// This indicate that 8 IDLE data is recived
assign rcvd_8idle      = osd_8idle_split & cfg_lanes_split;

// This indicates that one of the port recived go to DISABLE or a higher layer directed
// a jump to disable
assign rcvd_gto_dis    = |(osd_gto_dis_split & cfg_lanes_split);

// This indicates that one of the port recived go to Hot Reset or a higher layer directed
// a jump to Hot Reset
assign rcvd_gto_hrst   = |(osd_gto_hrst_split & cfg_lanes_split);

// This indicates that one of the port recived Lane set to pad  or a higher layer directed
// a jump to Config
//assign rcvd_gto_cfg    = (|(osd_2t1_lilap & cfg_lanes) | hl_gto_cfg);
assign rcvd_gto_cfg    = (|(osd_2t1_lap_split & cfg_lanes_split) | hl_gto_cfg_split);

// This indicates that one of the port recived go to Loopback or a higher layer directed
// a jump to Loopback
assign rcvd_gto_lbk    = |(osd_gto_lbk_split & cfg_lanes_split);

// This indicate that Lane to Lane dksew is complete
assign rcvd_asb_dskew_rx= asb_dskew_rx_split & cfg_lanes_split;

// This indicate EI
assign rcvd_eidle= (asb_eidle_rx_split | osd_eidle_neios_split) & cfg_lanes_split;

// =============================================================================
// The following implements the Polling SM as described in section 4.2.6.4 of the
// PCI Express Spec 1.0a.
// =============================================================================
//--------------------------------------------
//-- Sequential block --
//-- wait for detect sm to assert Tx electrical idle
//--------------------------------------------
always @(posedge sys_clk or negedge rst_n) begin
  if(~rst_n) begin
    rate_2_5g_cnt <= 6'd0;
    rcvd_eidle_any <= 1'b0;
    /*AUTORESET*/
  end
  else begin
    rcvd_eidle_any <= |(rcvd_eidle_split & cfg_lanes_split);
    if((main_state_split == DETECT) || dis_chng_spd2p5_split) begin
      if(~rate_2_5g_cnt_split[5])
        rate_2_5g_cnt <= rate_2_5g_cnt_split + 6'd1;
    end
    else
      rate_2_5g_cnt <= 6'd0;
  end
end //--always @(posedge sys_clk or negedge rst_n)--

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_rcvry_sm      <= RCVRY_WAIT;
      rcvry_start_cnt  <= 1'b0;
      rcvry_snd_os     <= {(LANE_WIDTH){1'b0}};
      rcvry_snd_bit_sc <= {(LANE_WIDTH){1'b0}};
      rcvry_snd_ostype <= OS_IDLE;
      rcvry_gto_dis    <= 1'b0;
      rcvry_gto_hrst   <= 1'b0;
      rcvry_gto_cfg    <= 1'b0;
      rcvry_gto_lbk    <= 1'b0;
      rcvry_gto_l0     <= 1'b0;
      rcvry_gto_det    <= 1'b0;
      rcvry_nfts_updt  <= 1'b0;
      stored_rcvd_t12  <= 1'b0;
      rcvry_rcvrcfg    <= 1'b0;
      rcvry_eidle_tx   <= {(LANE_WIDTH){1'b0}};
      spd_neg_done     <= 1'b0;
      rate_5g_req      <= 1'b0;
      rate_5g_req_q    <= 1'b0;
      directed_speed_change_var <= 1'b0;
      changed_speed_recovery_var <= 1'b0;
      pending_rate_change <= 1'b0;
      goto_detect <= 6'd0;
      goto_detect_ORed <= 1'b0;
      save_rcvd_t2 <= 1'b0;
      prev_speed <= 1'b0;
      next_speed <= 1'b0;
      revert_to_prev_speed <= 1'b0;
      enter_to_rcvry <= 1'b0;
      enter_to_rcvry_dly <= 1'b0;
      enter_dlycnt <= 4'd0;
      wait_eidle_propagate <= 3'd0;
      delay_tx_eidle <= 1'b0;
   end
   else begin
      rcvry_start_cnt  <= 1'b0;
      rcvry_gto_dis    <= 1'b0;
      rcvry_gto_hrst   <= 1'b0;
      rcvry_gto_cfg    <= 1'b0;
      rcvry_gto_lbk    <= 1'b0;
      rcvry_gto_l0     <= 1'b0;
      rcvry_gto_det    <= goto_detect_split[5];//1'b0;
      rcvry_nfts_updt  <= 1'b0;
      rcvry_rcvrcfg    <= 1'b0;
      rcvry_eidle_tx   <= {(LANE_WIDTH){1'b0}};
      rate_5g_req      <= (pol_compliance_split)? pol_compl_rate_split :
                          (rate_2_5g_cnt_split[5])? 1'b0 : rate_5g_req;
      rate_5g_req_q    <= rate_5g_req;
      goto_detect      <= {goto_detect_split[4:0],1'b0};
      goto_detect_ORed <= |goto_detect_split;
      save_rcvd_t2     <= (cs_rcvry_sm == RCVRY_RCVRCFG)? save_rcvd_t2_split : 1'b0;
      enter_to_rcvry   <= (main_state_split == RECOVERY);
      enter_to_rcvry_dly <= 1'b0;
      wait_eidle_propagate <= 3'd0;
      delay_tx_eidle <= 1'b0;
      case(cs_rcvry_sm)
         // Wait for Main SM to go to RECOVERY
         RCVRY_WAIT: begin
            next_speed <= 1'b0;
            if(|enter_dlycnt_split) begin
              enter_dlycnt <= enter_dlycnt_split - 4'd1;
              enter_to_rcvry_dly <= (enter_dlycnt_split == 4'd1);
            end
            else begin
              enter_dlycnt <= (enter_to_rcvry_split)? {4{1'b1}} : 4'd0;
            end

            if ((main_state_split == RECOVERY)) begin
              rcvry_eidle_tx <= ~cfg_lanes_split;
            end

            if ((main_state_split == RECOVERY) && enter_to_rcvry_dly_split) begin
               cs_rcvry_sm      <= RCVRY_RCVRLK;
               rcvry_start_cnt  <= 1'b1;
               rcvry_snd_os     <= cfg_lanes_split;
               rcvry_snd_ostype <= OS_T1;
               changed_speed_recovery_var <= 1'b0;
               enter_dlycnt     <= 4'd0;
            end
            else begin
               cs_rcvry_sm      <= RCVRY_WAIT;
            end
         end
         //
         RCVRY_RCVRLK: begin
            spd_neg_done     <= 1'b0;
            next_speed <= |rcvd_8t12_bit_5g_split | next_speed_split;
            if (rcvd_8t12_bit_sc_split == cfg_lanes_split)  begin
               directed_speed_change_var <= 1'b1;
               rcvry_snd_bit_sc <= {(LANE_WIDTH){1'b1}};
            end
            if (((ext_sync_split == 1'b0 && rcvd_8t12_split == cfg_lanes_split) || (ext_sync_split == 1'b1 && rcvd_8t12_split == cfg_lanes_split && cnt_done_1024t1_split)) && ~rcvry_start_cnt)  begin
               cs_rcvry_sm      <= RCVRY_RCVRCFG;
               rcvry_start_cnt  <= 1'b1;
               rcvry_snd_os     <= cfg_lanes_split;
               rcvry_snd_ostype <= OS_T2;
               rcvry_rcvrcfg    <= 1'b1;
            end
            else if (cnt_done_24ms_split && ~rcvry_start_cnt) begin
               if (|rcvd_8t12_bit_sc_split & (rate_5g_req | rcvd_8t12_bit_5g_split)) begin
                  cs_rcvry_sm      <= RCVRY_RCVRCFG;
                  rcvry_start_cnt  <= 1'b1;
               end
               else if ((rate_5g_req) | changed_speed_recovery_var_split) begin
                  cs_rcvry_sm <= RCVRY_SPD1;
                  rcvry_snd_os     <= cfg_lanes_split;
                  rcvry_snd_ostype <= OS_EIDLE;
                  revert_to_prev_speed <= changed_speed_recovery_var_split;
               end
               else if (((|rcvd_t12_split | stored_rcvd_t12_split) && ~directed_speed_change_var_split) && (~rcvd_8t12_bit_5g_split & ~rate_5g_capable_split))  begin
                  cs_rcvry_sm   <= RCVRY_EXIT;
                  rcvry_snd_os  <= {(LANE_WIDTH){1'b0}};
                  rcvry_gto_cfg <= 1'b1;
               end
               else begin
                  cs_rcvry_sm   <= RCVRY_EXIT;
                  rcvry_snd_os  <= {(LANE_WIDTH){rate_5g_req}};
                  rcvry_snd_ostype <= OS_EIDLE;
                  goto_detect[0] <= 1'b1;
               end
            end
            else begin
               cs_rcvry_sm      <= RCVRY_RCVRLK;
               stored_rcvd_t12  <= (|rcvd_t12_split) ? 1'b1 : stored_rcvd_t12_split;
            end
         end
         //
         RCVRY_RCVRCFG: begin
            rcvry_rcvrcfg    <= 1'b1;
            next_speed <= |rcvd_8t12_bit_5g_split | next_speed_split;
            //if (rate_5g_capable && (|rcvd_8t12_bit_5g) && (rcvd_8t2_bit_sc == cfg_lanes) && (snt_32t2_sc_t2 == cfg_lanes && ~rcvry_start_cnt)) begin
            if ((snt_32t2_sc_t2_split == cfg_lanes_split && ~rcvry_start_cnt)) begin
               cs_rcvry_sm <= RCVRY_SPD1;
               spd_neg_done <= 1'b1;
               //rcvry_start_cnt  <= 1'b1;
               rcvry_snd_os     <= cfg_lanes_split;
               rcvry_snd_ostype <= OS_EIDLE;
            end
            else if (rcvd_8t2_split == cfg_lanes_split && snt_16t2_t2_split == cfg_lanes_split && ~rcvry_start_cnt && rcvd_asb_dskew_rx_split == cfg_lanes_split) begin
               cs_rcvry_sm      <= RCVRY_IDLE;
               rcvry_start_cnt  <= 1'b1;
               rcvry_nfts_updt  <= 1'b1;
               rcvry_snd_os     <= cfg_lanes_split;
               rcvry_snd_ostype <= rcvd_gto_lbk_split ? OS_T2 : OS_IDLE;
               directed_speed_change_var <= 1'b0;
               changed_speed_recovery_var <= 1'b0;
            end
            else if (|rcvd_8t1_nm_split == 1'b1  && |snt_16t2_t1_split == 1'b1 && ~rcvry_start_cnt) begin
               cs_rcvry_sm      <= RCVRY_EXIT;
               rcvry_snd_os     <= {(LANE_WIDTH){1'b0}};
               rcvry_gto_cfg    <= 1'b1;
               rcvry_nfts_updt  <= 1'b1;
               directed_speed_change_var <= 1'b0;
               changed_speed_recovery_var <= 1'b0;
            end
            else if ((rcvd_eidle_any_split && changed_speed_recovery_var_split) |
                     (rcvd_eidle_any_split && rate_5g_req && ~save_rcvd_t2_split)) begin
               cs_rcvry_sm <= RCVRY_SPD1;
               rcvry_snd_os     <= cfg_lanes_split;
               rcvry_snd_ostype <= OS_EIDLE;
               revert_to_prev_speed <= changed_speed_recovery_var_split;
            end
            else if (cnt_done_48ms_split && ~rcvry_start_cnt) begin
               cs_rcvry_sm   <= RCVRY_EXIT;
               rcvry_snd_os  <= {(LANE_WIDTH){1'b1}};
               rcvry_snd_ostype <= OS_EIDLE;
               goto_detect[0] <= 1'b1;
            end
            else begin
               cs_rcvry_sm   <= RCVRY_RCVRCFG;
               save_rcvd_t2 <= |(osd_t2_limlam_split & cfg_lanes_split) | save_rcvd_t2_split;
            end
         end
          //
         RCVRY_IDLE: begin
            casex({rcvd_gto_dis_split, rcvd_gto_hrst_split, rcvd_gto_cfg_split, rcvd_gto_lbk_split})
               4'b1xxx: begin
                  cs_rcvry_sm   <= RCVRY_EXIT;
                  rcvry_snd_os  <= {(LANE_WIDTH){1'b0}};
                  rcvry_gto_dis <= 1'b1;
               end
               4'bx1xx: begin
                  cs_rcvry_sm   <= RCVRY_EXIT;
                  rcvry_snd_os  <= {(LANE_WIDTH){1'b0}};
                  rcvry_gto_hrst <= 1'b1;
               end
               4'bxx1x: begin
                  cs_rcvry_sm   <= RCVRY_EXIT;
                  rcvry_snd_os  <= {(LANE_WIDTH){1'b0}};
                  rcvry_gto_cfg <= 1'b1;
               end
               4'bxxx1: begin
                  cs_rcvry_sm   <= RCVRY_EXIT;
                  rcvry_snd_os  <= cfg_lanes_split;
                  rcvry_gto_lbk <= 1'b1;
               end
               default: begin
                  if (rcvd_8idle_split == cfg_lanes_split && snt_16idle_idle_split == cfg_lanes_split && ~rcvry_start_cnt) begin
                     cs_rcvry_sm   <= RCVRY_EXIT;
                     rcvry_snd_os  <= {(LANE_WIDTH){1'b0}};
                     rcvry_gto_l0  <= 1'b1;
                     prev_speed    <= rate_5g_req;
                  end
                  else if (cnt_done_2ms_split && ~rcvry_start_cnt) begin
                     cs_rcvry_sm   <= RCVRY_EXIT;
                     rcvry_snd_os  <= {(LANE_WIDTH){1'b1}};
                     rcvry_snd_ostype <= OS_EIDLE;
                     goto_detect[0] <= 1'b1;
                  end
                  else begin
                     cs_rcvry_sm   <= RCVRY_IDLE;
                  end
               end
            endcase
         end
         RCVRY_SPD1: begin
            rcvry_start_cnt <= 1'b1;
            if(ltssm_snd_eidle_split) begin
              cs_rcvry_sm   <= RCVRY_SPD2;
              rcvry_snd_os   <= {(LANE_WIDTH){1'b0}};
              delay_tx_eidle <= rate_5g_req;
            end
            else begin
              cs_rcvry_sm   <= RCVRY_SPD1;
            end
         end
         RCVRY_SPD2: begin
            delay_tx_eidle   <= 1'b1;
            rcvry_snd_os     <= {(LANE_WIDTH){1'b0}};
            rcvry_eidle_tx   <= {(LANE_WIDTH){delay_tx_eidle_split}};
            rcvry_snd_bit_sc <= {(LANE_WIDTH){1'b0}};
            wait_eidle_propagate <= wait_eidle_propagate_split + {2'd0,(~&wait_eidle_propagate_split)};
            //if (spd_neg_done && cnt_done_1ms && ~rcvry_start_cnt) begin
            if(&wait_eidle_propagate_split) begin
              if (spd_neg_done_split) begin
                 rate_5g_req <= next_speed_split;
                 cs_rcvry_sm   <= RCVRY_SPD;
                 pending_rate_change <= (rate_5g_req ^ next_speed_split);
                 changed_speed_recovery_var <= 1'b1;
              end
              //else if (~spd_neg_done && cnt_done_1ms && ~rcvry_start_cnt) begin
              else begin
                 rate_5g_req <= revert_to_prev_speed_split? prev_speed_split : 1'b0;
                 cs_rcvry_sm   <= RCVRY_SPD;
                 pending_rate_change <= revert_to_prev_speed_split? (rate_5g_req ^ prev_speed_split) : rate_5g_req;
                 changed_speed_recovery_var <= 1'b0;
              end
            end
            else begin
              cs_rcvry_sm   <= RCVRY_SPD2;
            end
         end
         RCVRY_SPD: begin
            revert_to_prev_speed <= 1'b0;
            next_speed <= 1'b0;
            if(pending_rate_change_split & ~(cnt_done_48ms_split && ~rcvry_start_cnt)) begin
               cs_rcvry_sm   <= RCVRY_SPD;
               rcvry_eidle_tx <= {(LANE_WIDTH){1'b1}};
               rcvry_snd_os     <= {(LANE_WIDTH){1'b0}};
               pending_rate_change <= rate_phy_sts_pulse_split ? 1'b0 : 1'b1;
            end
            else if (rcvd_eidle_any_split == 0) begin
               cs_rcvry_sm      <= RCVRY_RCVRLK;
               rcvry_snd_os     <= cfg_lanes_split;
               rcvry_snd_ostype <= OS_T1;
               directed_speed_change_var <= 1'b0;
               rcvry_start_cnt  <= 1'b1;
            end
            else if (cnt_done_48ms_split && ~rcvry_start_cnt) begin
               cs_rcvry_sm   <= RCVRY_EXIT;
               rcvry_snd_os  <= {(LANE_WIDTH){rate_5g_req}};
               rcvry_snd_ostype <= OS_EIDLE;
               goto_detect[0] <= 1'b1;
            end
         end
         // Wait for Main SM to go out of RECOVERY
         RCVRY_EXIT: begin
            pending_rate_change <= 1'b0;
            stored_rcvd_t12  <= 1'b0;
            rcvry_snd_bit_sc <= {(LANE_WIDTH){1'b0}};
            delay_tx_eidle <= delay_tx_eidle_split;
            if(rate_5g_req & (|rcvry_snd_os) & (rcvry_snd_ostype == OS_EIDLE)) begin
              if(ltssm_snd_eidle_split) begin
                rcvry_snd_os  <= {(LANE_WIDTH){1'b0}};
                delay_tx_eidle <= 1'b1;
              end
              rcvry_eidle_tx <= {(LANE_WIDTH){delay_tx_eidle_split}};
            end
            if (main_state_split != RECOVERY) begin
               cs_rcvry_sm   <= RCVRY_WAIT;
               rcvry_snd_os  <= {(LANE_WIDTH){1'b0}};
            end
            else begin
               cs_rcvry_sm   <= RCVRY_EXIT;
            end
         end
         default: begin
            cs_rcvry_sm   <= RCVRY_WAIT;
         end
      endcase
   end
end

always@* begin ext_sync_split<=descram_out[0];cnt_done_1ms_split<=descram_out[1];cnt_done_2ms_split<=descram_out[2];cnt_done_24ms_split<=descram_out[3];cnt_done_48ms_split<=descram_out[4];cnt_done_1024t1_split<=descram_out[5];asb_eidle_rx_split<={asb_eidle_rx>>1,descram_out[6]};osd_eidle_neios_split<={osd_eidle_neios>>1,descram_out[7]};rate_5g_capable_split<=descram_out[8];main_state_split<={main_state>>1,descram_out[9]};cfg_lanes_split<={cfg_lanes>>1,descram_out[10]};ose_32t2_sc_t2_split<={ose_32t2_sc_t2>>1,descram_out[11]};ose_16t2_t2_split<={ose_16t2_t2>>1,descram_out[12]};ose_16t2_t1_split<={ose_16t2_t1>>1,descram_out[13]};ose_16idle_idle_split<={ose_16idle_idle>>1,descram_out[14]};osd_2t1_lilap_split<={osd_2t1_lilap>>1,descram_out[15]};osd_2t1_lap_split<={osd_2t1_lap>>1,descram_out[16]};osd_8t12_limlam_split<={osd_8t12_limlam>>1,descram_out[17]};osd_8t12_bit_sc_split<={osd_8t12_bit_sc>>1,descram_out[18]};osd_8t2_bit_sc_split<={osd_8t2_bit_sc>>1,descram_out[19]};osd_8t12_bit_5g_split<={osd_8t12_bit_5g>>1,descram_out[20]};osd_8t2_limlam_split<={osd_8t2_limlam>>1,descram_out[21]};osd_8idle_split<={osd_8idle>>1,descram_out[22]};osd_8t1_linmlanm_split<={osd_8t1_linmlanm>>1,descram_out[23]};osd_8t1_linmlam_split<={osd_8t1_linmlam>>1,descram_out[24]};osd_8t1_limlanm_split<={osd_8t1_limlanm>>1,descram_out[25]};osd_t1_limlam_split<={osd_t1_limlam>>1,descram_out[26]};osd_t2_limlam_split<={osd_t2_limlam>>1,descram_out[27]};osd_gto_dis_split<={osd_gto_dis>>1,descram_out[28]};osd_gto_hrst_split<={osd_gto_hrst>>1,descram_out[29]};osd_gto_lbk_split<={osd_gto_lbk>>1,descram_out[30]};hl_gto_cfg_split<=descram_out[31];asb_dskew_rx_split<={asb_dskew_rx>>1,descram_out[32]};rate_phy_sts_pulse_split<=descram_out[33];dis_chng_spd2p5_split<=descram_out[34];pol_compliance_split<=descram_out[35];pol_compl_rate_split<=descram_out[36];ltssm_snd_eidle_split<=descram_out[37];snt_32t2_sc_t2_split<={snt_32t2_sc_t2>>1,descram_out[38]};snt_16t2_t2_split<={snt_16t2_t2>>1,descram_out[39]};snt_16t2_t1_split<={snt_16t2_t1>>1,descram_out[40]};snt_16idle_idle_split<={snt_16idle_idle>>1,descram_out[41]};rcvd_8t12_split<={rcvd_8t12>>1,descram_out[42]};rcvd_8t12_bit_sc_split<={rcvd_8t12_bit_sc>>1,descram_out[43]};rcvd_8t2_bit_sc_split<={rcvd_8t2_bit_sc>>1,descram_out[44]};rcvd_8t12_bit_5g_split<={rcvd_8t12_bit_5g>>1,descram_out[45]};rcvd_8t2_split<={rcvd_8t2>>1,descram_out[46]};rcvd_t12_split<={rcvd_t12>>1,descram_out[47]};rcvd_8idle_split<={rcvd_8idle>>1,descram_out[48]};rcvd_8t1_nm_split<={rcvd_8t1_nm>>1,descram_out[49]};rcvd_gto_dis_split<=descram_out[50];rcvd_gto_hrst_split<=descram_out[51];rcvd_gto_cfg_split<=descram_out[52];rcvd_gto_lbk_split<=descram_out[53];rcvd_asb_dskew_rx_split<={rcvd_asb_dskew_rx>>1,descram_out[54]};rcvd_eidle_split<={rcvd_eidle>>1,descram_out[55]};stored_rcvd_t12_split<=descram_out[56];directed_speed_change_var_split<=descram_out[57];changed_speed_recovery_var_split<=descram_out[58];spd_neg_done_split<=descram_out[59];goto_detect_ORed_split<=descram_out[60];next_speed_split<=descram_out[61];prev_speed_split<=descram_out[62];revert_to_prev_speed_split<=descram_out[63];save_rcvd_t2_split<=descram_out[64];rcvd_eidle_any_split<=descram_out[65];goto_detect_split<={goto_detect>>1,descram_out[66]};rate_5g_req_q_split<=descram_out[67];pending_rate_change_split<=descram_out[68];rate_2_5g_cnt_split<={rate_2_5g_cnt>>1,descram_out[69]};enter_to_rcvry_split<=descram_out[70];enter_to_rcvry_dly_split<=descram_out[71];enter_dlycnt_split<={enter_dlycnt>>1,descram_out[72]};wait_eidle_propagate_split<={wait_eidle_propagate>>1,descram_out[73]};delay_tx_eidle_split<=descram_out[74];end
always@* begin descram_in[2047]<=cnt_done_1ms;descram_in[2046]<=cnt_done_2ms;descram_in[2044]<=cnt_done_24ms;descram_in[2040]<=cnt_done_48ms;descram_in[2033]<=cnt_done_1024t1;descram_in[2019]<=asb_eidle_rx[0];descram_in[1999]<=pol_compliance;descram_in[1991]<=osd_eidle_neios[0];descram_in[1981]<=rcvd_gto_hrst;descram_in[1958]<=stored_rcvd_t12;descram_in[1950]<=pol_compl_rate;descram_in[1947]<=rcvd_8t12[0];descram_in[1934]<=rate_5g_capable;descram_in[1914]<=rcvd_gto_cfg;descram_in[1892]<=osd_8t12_bit_5g[0];descram_in[1868]<=directed_speed_change_var;descram_in[1852]<=ltssm_snd_eidle;descram_in[1851]<=osd_2t1_lilap[0];descram_in[1847]<=rcvd_8t12_bit_sc[0];descram_in[1820]<=main_state[0];descram_in[1783]<=rcvd_8idle[0];descram_in[1780]<=rcvd_gto_lbk;descram_in[1737]<=osd_8t2_limlam[0];descram_in[1689]<=changed_speed_recovery_var;descram_in[1657]<=snt_32t2_sc_t2[0];descram_in[1654]<=osd_2t1_lap[0];descram_in[1647]<=rcvd_8t2_bit_sc[0];descram_in[1610]<=osd_8t1_linmlam[0];descram_in[1608]<=save_rcvd_t2;descram_in[1593]<=cfg_lanes[0];descram_in[1523]<=rate_phy_sts_pulse;descram_in[1519]<=rcvd_8t1_nm[0];descram_in[1513]<=rcvd_asb_dskew_rx[0];descram_in[1426]<=osd_8idle[0];descram_in[1404]<=hl_gto_cfg;descram_in[1330]<=spd_neg_done;descram_in[1267]<=snt_16t2_t2[0];descram_in[1260]<=osd_8t12_limlam[0];descram_in[1246]<=rcvd_8t12_bit_5g[0];descram_in[1225]<=next_speed;descram_in[1199]<=osd_gto_dis[0];descram_in[1173]<=osd_8t1_limlanm[0];descram_in[1169]<=rcvd_eidle_any;descram_in[1163]<=pending_rate_change;descram_in[1139]<=ose_32t2_sc_t2[0];descram_in[1113]<=enter_to_rcvry_dly;descram_in[1023]<=ext_sync;descram_in[999]<=dis_chng_spd2p5;descram_in[990]<=rcvd_gto_dis;descram_in[979]<=rcvd_eidle[0];descram_in[973]<=snt_16idle_idle[0];descram_in[946]<=osd_8t2_bit_sc[0];descram_in[925]<=ose_16idle_idle[0];descram_in[891]<=rcvd_t12[0];descram_in[805]<=osd_8t1_linmlanm[0];descram_in[804]<=revert_to_prev_speed;descram_in[761]<=asb_dskew_rx[0];descram_in[718]<=delay_tx_eidle;descram_in[702]<=osd_gto_lbk[0];descram_in[612]<=goto_detect_ORed;descram_in[599]<=osd_t2_limlam[0];descram_in[581]<=rate_5g_req_q;descram_in[556]<=enter_to_rcvry;descram_in[486]<=snt_16t2_t1[0];descram_in[473]<=osd_8t12_bit_sc[0];descram_in[462]<=ose_16t2_t1[0];descram_in[445]<=rcvd_8t2[0];descram_in[402]<=prev_speed;descram_in[359]<=wait_eidle_propagate[0];descram_in[351]<=osd_gto_hrst[0];descram_in[299]<=osd_t1_limlam[0];descram_in[290]<=goto_detect[0];descram_in[278]<=rate_2_5g_cnt[0];descram_in[231]<=ose_16t2_t2[0];descram_in[179]<=enter_dlycnt[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule

// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS         


// Project          : PCI Express 4X 


// File             : ts_dec.v


// Description      : This module decodes TS1/TS2  Ordered sets recived 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Aug 8, 2004


// =============================================================================



`timescale 1 ns / 100 ps
module ts_dec_16 (
   input wire         sys_clk,      
   input wire         rst_n,        
   input wire [15:0]  datain,      
   input wire [1:0]   kcntl,    

   output reg         ts1_found,      
   output reg         ts2_found,    
   output reg         ts12n_found,    
   output reg [7:0]   ts12_linu,    
   output reg         ts12_linu_kcntl,    
   output reg [7:0]   ts12_lanu,    
   output reg         ts12_lanu_kcntl,    
   output reg [7:0]   ts12_nfts,    
   output reg         ts12_25sup,    
   output reg         ts12_5sup,    
   output reg         ts12_auton_cng,    
   output reg         ts12_spd_cng,    
   output reg         ts12_hrst,    
   output reg         ts12_dis,    
   output reg         ts12_lbk,    
   output reg         ts12_dscr,    
   output reg         ts12_compl_rcv    
   ) ;
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam T_COMMA = 4'd0 ;
localparam T_LANU  = 4'd1 ;
localparam T_LINU  = 4'd2 ;
localparam T_NFTS  = 4'd3 ;
localparam T_DRATE = 4'd4 ;
localparam T_TRNC  = 4'd5 ;
localparam TS_S0   = 4'd6 ;
localparam TS_S1   = 4'd7 ;
localparam TS_S2   = 4'd8 ;
localparam TS_S3   = 4'd9 ;
localparam TS_S4   = 4'd10 ;
localparam TS_S5   = 4'd11 ;
reg ts1_detect,ts2_detect,ts12n_detect,linu_kcntl,lanu_kcntl,nal_flag ;
reg [3:0] cs_ts ;
reg [7:0] linu,lanu,drate,nfts,tctl;
wire  dcom_ldec,dcom_hdec,dts1_ldec,dts1_hdec,dts1_dec,dts2_ldec,dts2_hdec,dts2_dec;
wire  dts1n_ldec,dts1n_hdec,dts1n_dec,dts2n_ldec,dts2n_hdec,dts2n_dec;
wire  dts_ldec,dts_hdec,dts_dec;
reg [15 : 0] datain_split;
reg [1 : 0] kcntl_split;
reg ts1_detect_split;
reg ts2_detect_split;
reg ts12n_detect_split;
reg linu_kcntl_split;
reg lanu_kcntl_split;
reg nal_flag_split;
reg [3 : 0] cs_ts_split;
reg [7 : 0] linu_split;
reg [7 : 0] lanu_split;
reg [7 : 0] drate_split;
reg [7 : 0] nfts_split;
reg [7 : 0] tctl_split;
reg dcom_ldec_split;
reg dcom_hdec_split;
reg dts1_ldec_split;
reg dts1_hdec_split;
reg dts1_dec_split;
reg dts2_ldec_split;
reg dts2_hdec_split;
reg dts2_dec_split;
reg dts1n_ldec_split;
reg dts1n_hdec_split;
reg dts1n_dec_split;
reg dts2n_ldec_split;
reg dts2n_hdec_split;
reg dts2n_dec_split;
reg dts_ldec_split;
reg dts_hdec_split;
reg dts_dec_split;
reg [2047:0] descram_in;
wire [30:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 31,descram_inst_SCRAMSTRING = 32'hfdffea0b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// Local Defines
// This module decodes TS1/TS2 ordered sets Aligned & Unaligned and extracts 
// link number, lane number, nfts and training control bytes of TS1/TS2
//COM
assign dcom_ldec = (kcntl_split[0] & (datain_split[7:0]  ==K28_5)) ;
assign dcom_hdec = (kcntl_split[1] & (datain_split[15:8] ==K28_5)) ;
// TS1 ID
assign dts1_ldec = (~kcntl_split[0] & (datain_split[7:0]  == D10_2)) ;
assign dts1_hdec = (~kcntl_split[1] & (datain_split[15:8] == D10_2)) ;
assign dts1_dec  = dts1_ldec_split & dts1_hdec_split ;
// TS2 ID
assign dts2_ldec = (~kcntl_split[0] & (datain_split[7:0]  == D5_2)) ;
assign dts2_hdec = (~kcntl_split[1] & (datain_split[15:8] == D5_2)) ;
assign dts2_dec  = dts2_ldec_split & dts2_hdec_split ;
// TS1n ID
assign dts1n_ldec = (~kcntl_split[0] & (datain_split[7:0]  == D21_5)) ;
assign dts1n_hdec = (~kcntl_split[1] & (datain_split[15:8] == D21_5)) ;
assign dts1n_dec  = dts1n_ldec_split & dts1n_hdec_split ;
// TS2n ID
assign dts2n_ldec = (~kcntl_split[0] & (datain_split[7:0]  == D26_5)) ;
assign dts2n_hdec = (~kcntl_split[1] & (datain_split[15:8] == D26_5)) ;
assign dts2n_dec  = dts2n_ldec_split & dts2n_hdec_split ;
// TS
assign dts_ldec  = dts1_ldec_split | dts1n_ldec_split  | dts2_ldec_split | dts2n_ldec_split ;
assign dts_hdec  = dts1_hdec_split | dts1n_hdec_split  | dts2_hdec_split | dts2n_hdec_split ;
assign dts_dec   = dts1_dec_split  | dts1n_dec_split   | dts2_dec_split  | dts2n_dec_split ;

// State macine to search full TS1 identifier string
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) cs_ts    <= T_COMMA;
   else begin
      case(cs_ts_split) /* synthesis parallel_case */
         T_COMMA:                                 // Wait for Comma 
            if (dcom_hdec_split) cs_ts <= T_LANU;       // COMMA-alligned & Link number/skip 
            else if (dcom_ldec_split) cs_ts <= T_LINU;  // COMMA-nonalligned 
            else cs_ts <= T_COMMA;
         T_LANU:                                  // Lane number and nfts 
            if (!kcntl_split[0]) cs_ts <= T_DRATE;
            else if (dcom_hdec_split) cs_ts <= T_LANU;   // COMMA-alligned & Link number/skip  
            else if (dcom_ldec_split) cs_ts <= T_LINU;   // COMMA-nonalligned 
            else cs_ts <= T_COMMA;
         T_LINU:                                   // Link number and Lane number 
            if (dcom_hdec_split) cs_ts <= T_LANU;        // COMMA-alligned & Link number/skip  
            else if (dcom_ldec_split) cs_ts <= T_LINU;   // COMMA-nonalligned 
            else cs_ts <= T_NFTS;
         T_NFTS:                                   // nfts and data rate cntl 
            if (!kcntl_split[1])  cs_ts <= T_TRNC;
            else if (dcom_hdec_split) cs_ts <= T_LANU;   // COMMA-alligned & Link number/skip 
            else if (dcom_ldec_split) cs_ts <= T_LINU;   // COMMA-nonalligned 
            else  cs_ts <= T_COMMA;
         T_DRATE:                                  // data rate control and training control 
            if (dcom_hdec_split) cs_ts <= T_LANU;        // COMMA-alligned & Link number/skip 
            else if (dcom_ldec_split) cs_ts <= T_LINU;   // COMMA-nonalligned 
            else if (kcntl_split == 2'b00 && !nal_flag_split) cs_ts <= TS_S0;   
	    else if (kcntl_split == 2'b00 && nal_flag_split) cs_ts <= T_TRNC;  
            else  cs_ts <= T_COMMA;
         T_TRNC:                                   // training control and first TS id 
            if (dcom_hdec_split) cs_ts <= T_LANU;        // COMMA-alligned & Link number/skip 
            else if (dcom_ldec_split) cs_ts <= T_LINU;   // COMMA-nonalligned 
	    else cs_ts <= TS_S0;
         TS_S0:  
            if (dts_dec_split && !nal_flag_split) cs_ts <= TS_S1;
            else if (dts_ldec_split && nal_flag_split) cs_ts <= TS_S1;
            else cs_ts <= T_COMMA;
         TS_S1: 
            if (dts_dec_split) cs_ts <= TS_S2;
            else cs_ts <= T_COMMA;
         TS_S2: 
            if (dts_dec_split) cs_ts <= TS_S3;
            else cs_ts <= T_COMMA;
         TS_S3: 
            if (dts_dec_split)  cs_ts <= TS_S4;
            else cs_ts <= T_COMMA;
         TS_S4: 
            if (dcom_ldec_split) cs_ts <= T_LINU;        // COMMA-nonalligned 
            else cs_ts <= T_COMMA;
         default: cs_ts    <= T_COMMA;
      endcase
   end
end
// Check in T_COMMA state
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) nal_flag  <= 1'b0; 
   else begin
      if (dcom_ldec_split)     nal_flag  <= 1'b1;
      else if(dcom_hdec_split) nal_flag  <= 1'b0;
   end
end
// TS1 detect
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) ts1_detect  <= 1'b0; 
   else if ((cs_ts_split == TS_S4) && (dts1_dec_split || dts1n_dec_split)) ts1_detect <= 1'b1; 
   else if ((cs_ts_split == TS_S4) && (dts1_hdec_split || dts1n_hdec_split) && nal_flag_split) ts1_detect <= 1'b1; 
   else ts1_detect  <= 1'b0; 
end

// TS2 detect
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) ts2_detect  <= 1'b0; 
   else if ((cs_ts_split == TS_S4) && (dts2_dec_split||dts2n_dec_split)) ts2_detect  <= 1'b1; 
   else if ((cs_ts_split == TS_S4) && (dts2_hdec_split||dts2n_hdec_split) && nal_flag_split) ts2_detect <= 1'b1; 
   else ts2_detect  <= 1'b0; 
end
// inverted TS1/2 detect
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) ts12n_detect  <= 1'b0; 
   else if ((cs_ts_split == TS_S4) && (dts1n_dec_split||dts2n_dec_split)) ts12n_detect  <= 1'b1; 
   else if ((cs_ts_split == TS_S4) && (dts1n_hdec_split||dts2n_hdec_split) && nal_flag_split) ts12n_detect <= 1'b1; 
   else ts12n_detect  <= 1'b0; 
end
//
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) {ts1_found, ts2_found,ts12n_found} <= 3'd0;
   else {ts1_found, ts2_found,ts12n_found} <= {ts1_detect_split,ts2_detect_split,ts12n_detect_split};
end
// Extract Link number byte
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) {linu,linu_kcntl} <= 'd0;
   else if (dcom_hdec_split) {linu,linu_kcntl} <= {datain_split[7:0],kcntl_split[0]}; 
   else if (nal_flag_split && (cs_ts_split == T_LINU)) {linu,linu_kcntl} <= {datain_split[15:8],kcntl_split[1]};
end
// Extract Lane number byte
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) {lanu,lanu_kcntl} <= 'd0;
   else if (nal_flag_split && (cs_ts_split == T_LINU)) {lanu,lanu_kcntl} <= {datain_split[7:0],kcntl_split[0]}; 
   else if (!nal_flag_split && (cs_ts_split == T_LANU)) {lanu,lanu_kcntl} <= {datain_split[15:8],kcntl_split[1]};
end
// Extract N_FTS byte
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) nfts <= 8'h00; 
   else if (!nal_flag_split && (cs_ts_split == T_LANU)) nfts <= datain_split[7:0]; 
   else if (nal_flag_split && (cs_ts_split == T_NFTS)) nfts <= datain_split[15:8]; 
end
// Extract Data Rate byte
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) drate <= 8'h00; 
   else if (nal_flag_split && (cs_ts_split == T_NFTS)) drate <= datain_split[7:0]; 
   else if (!nal_flag_split && (cs_ts_split == T_DRATE)) drate <= datain_split[15:8]; 
end
// Extract Training Control byte
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) tctl <= 8'h00; 
   else if (!nal_flag_split && (cs_ts_split == T_DRATE)) tctl <= datain_split[7:0]; 
   else if (nal_flag_split && (cs_ts_split == T_TRNC)) tctl <= datain_split[15:8]; 
end
// If TS1/TS2 os decoded, give out latched Link/Lane/N_FTS/Trn Ctl
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) 
      {ts12_linu,ts12_linu_kcntl,ts12_lanu,ts12_lanu_kcntl,ts12_nfts,ts12_25sup,ts12_5sup,
       ts12_auton_cng,ts12_spd_cng,ts12_hrst,ts12_dis,ts12_lbk,ts12_dscr,ts12_compl_rcv} <= 'd0;    
   else if (ts1_detect_split || ts2_detect_split || ts12n_found)  begin 
      {ts12_linu,ts12_linu_kcntl} <= {linu_split,linu_kcntl_split};
      {ts12_lanu,ts12_lanu_kcntl} <= {lanu_split,lanu_kcntl_split};
      {ts12_spd_cng,ts12_auton_cng,ts12_5sup,ts12_25sup} <= {drate_split[7:6],drate_split[2:1]};
      {ts12_compl_rcv,ts12_dscr,ts12_lbk,ts12_dis,ts12_hrst} <= tctl_split[4:0];
      ts12_nfts <= nfts_split;
   end
end

always@* begin datain_split<={datain>>1,descram_out[0]};kcntl_split<={kcntl>>1,descram_out[1]};ts1_detect_split<=descram_out[2];ts2_detect_split<=descram_out[3];ts12n_detect_split<=descram_out[4];linu_kcntl_split<=descram_out[5];lanu_kcntl_split<=descram_out[6];nal_flag_split<=descram_out[7];cs_ts_split<={cs_ts>>1,descram_out[8]};linu_split<={linu>>1,descram_out[9]};lanu_split<={lanu>>1,descram_out[10]};drate_split<={drate>>1,descram_out[11]};nfts_split<={nfts>>1,descram_out[12]};tctl_split<={tctl>>1,descram_out[13]};dcom_ldec_split<=descram_out[14];dcom_hdec_split<=descram_out[15];dts1_ldec_split<=descram_out[16];dts1_hdec_split<=descram_out[17];dts1_dec_split<=descram_out[18];dts2_ldec_split<=descram_out[19];dts2_hdec_split<=descram_out[20];dts2_dec_split<=descram_out[21];dts1n_ldec_split<=descram_out[22];dts1n_hdec_split<=descram_out[23];dts1n_dec_split<=descram_out[24];dts2n_ldec_split<=descram_out[25];dts2n_hdec_split<=descram_out[26];dts2n_dec_split<=descram_out[27];dts_ldec_split<=descram_out[28];dts_hdec_split<=descram_out[29];dts_dec_split<=descram_out[30];end
always@* begin descram_in[2047]<=kcntl[0];descram_in[2046]<=ts1_detect;descram_in[2044]<=ts2_detect;descram_in[2040]<=ts12n_detect;descram_in[2032]<=linu_kcntl;descram_in[2016]<=lanu_kcntl;descram_in[1984]<=nal_flag;descram_in[1980]<=dts_dec;descram_in[1950]<=dts1n_dec;descram_in[1921]<=cs_ts[0];descram_in[1853]<=dts2n_ldec;descram_in[1795]<=linu[0];descram_in[1659]<=dts2n_hdec;descram_in[1630]<=dts1_dec;descram_in[1542]<=lanu[0];descram_in[1511]<=dts1n_ldec;descram_in[1271]<=dts2n_dec;descram_in[1212]<=dts2_ldec;descram_in[1036]<=drate[0];descram_in[1023]<=datain[0];descram_in[990]<=dts_hdec;descram_in[975]<=dts1n_hdec;descram_in[815]<=dts1_hdec;descram_in[755]<=dts2_dec;descram_in[495]<=dts_ldec;descram_in[407]<=dts1_ldec;descram_in[377]<=dts2_hdec;descram_in[203]<=dcom_hdec;descram_in[101]<=dcom_ldec;descram_in[50]<=tctl[0];descram_in[25]<=nfts[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS         


// Project          : PCI Express 5G 


// File             : ts_dec_32.v


// Description      : This module decodes TS1/TS2  Ordered sets recived 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Aug 2015


// =============================================================================



`timescale 1 ns / 100 ps
module ts_dec_32 (
   input wire           sys_clk,      
   input wire           rst_n,        
   input wire [31:0]    datain,      
   input wire [3:0]     kcntl,    

   output reg         ts1_found,      
   output reg         ts2_found,    
   output reg         ts12n_found,    
   output reg [7:0]   ts12_linu,    
   output reg         ts12_linu_kcntl,    
   output reg [7:0]   ts12_lanu,    
   output reg         ts12_lanu_kcntl,    
   output reg [7:0]   ts12_nfts,    
   output reg         ts12_25sup,    
   output reg         ts12_5sup,    
   output reg         ts12_auton_cng,    
   output reg         ts12_spd_cng,    
   output reg         ts12_hrst,    
   output reg         ts12_dis,    
   output reg         ts12_lbk,    
   output reg         ts12_dscr,    
   output reg         ts12_compl_rcv    
   ) ;
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam COMMA  = 4'd0 ;
localparam B1_432 = 4'd1 ;
localparam B2_432 = 4'd2 ;
localparam TS_3B  = 4'd3 ;
localparam TS_4B  = 4'd4 ;
localparam TS_1B  = 4'd5 ;
reg ts1_detect, ts2_detect, ts12n_detect, linu_kcntl, lanu_kcntl;
reg ts_st0, ts_st1, ts_st2, ts_st3;
reg [3:0] cs_ts ;
reg [7:0] linu,lanu,drate,nfts,tctl;
wire npadk_dec_b0, npadk_dec_b1, npadk_dec_b2, npadk_dec_b3;
wire dcom_dec_b0, dcom_dec_b1, dcom_dec_b2, dcom_dec_b3;
wire dts1_dec_1b, dts1_dec_3b, dts1_dec_4b;
wire dts2_dec_1b, dts2_dec_3b, dts2_dec_4b;
wire dts1n_dec_1b, dts1n_dec_3b, dts1n_dec_4b;
wire dts2n_dec_1b, dts2n_dec_3b, dts2n_dec_4b;
wire dts12_dec_1b, dts12_dec_3b,  dts12_dec_4b;
wire dts12n_dec_1b, dts12n_dec_3b,  dts12n_dec_4b;
wire dts_dec_1b, dts_dec_3b,  dts_dec_4b;
reg [31 : 0] datain_split;
reg [3 : 0] kcntl_split;
reg ts1_detect_split;
reg ts2_detect_split;
reg ts12n_detect_split;
reg linu_kcntl_split;
reg lanu_kcntl_split;
reg ts_st0_split;
reg ts_st1_split;
reg ts_st2_split;
reg ts_st3_split;
reg [3 : 0] cs_ts_split;
reg [7 : 0] linu_split;
reg [7 : 0] lanu_split;
reg [7 : 0] drate_split;
reg [7 : 0] nfts_split;
reg [7 : 0] tctl_split;
reg npadk_dec_b0_split;
reg npadk_dec_b1_split;
reg npadk_dec_b2_split;
reg npadk_dec_b3_split;
reg dcom_dec_b0_split;
reg dcom_dec_b1_split;
reg dcom_dec_b2_split;
reg dcom_dec_b3_split;
reg dts1_dec_1b_split;
reg dts1_dec_3b_split;
reg dts1_dec_4b_split;
reg dts2_dec_1b_split;
reg dts2_dec_3b_split;
reg dts2_dec_4b_split;
reg dts1n_dec_1b_split;
reg dts1n_dec_3b_split;
reg dts1n_dec_4b_split;
reg dts2n_dec_1b_split;
reg dts2n_dec_3b_split;
reg dts2n_dec_4b_split;
reg dts12_dec_1b_split;
reg dts12_dec_3b_split;
reg dts12_dec_4b_split;
reg dts12n_dec_1b_split;
reg dts12n_dec_3b_split;
reg dts12n_dec_4b_split;
reg dts_dec_1b_split;
reg dts_dec_3b_split;
reg dts_dec_4b_split;
reg [2047:0] descram_in;
wire [45:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 46,descram_inst_SCRAMSTRING = 32'hfdffd42b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif

// =============================================================================
// Since the data bus width for each lane is 32 bits or 4 bytes
// Case 1--- Aligned
// Lane 0/1/2/3
// Byte       0             1            2             3
// d4         K28.5         Link Nu      Lane Nu       N_FTS  
// d3         Data Ident    Trn Ctl      TS1/TS2       TS1/TS2
// d2         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2  
// d1         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2  
// d0         x             x  
//-------------------------------------------
// Case 2--- Un Aligned
// Byte       0             1            2             3
// d8         x             K28.5        Link Nu       Lane Nu 
// d6         N_FTS         Data Ident   Trn Ctl       TS1/TS2   
// d4         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2  
// d2         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2  
// d0         TS1/TS2       x 
//-------------------------------------------
// Case 3--- Un Aligned
// Byte       0             1            2             3
// d8         x             x            K28.5        Link Nu        
// d6         Lane Nu       N_FTS        Data Ident   Trn Ctl          
// d4         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2  
// d2         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2  
// d0         TS1/TS2       TS1/TS2      x   
//-------------------------------------------
// Case 4--- Un Aligned
// Byte       0             1            2             3
// d8         x             x            x             K28.5               
// d6         Link Nu       Lane Nu       N_FTS        Data Ident            
// d4         TS1/TS2       TS1/TS2      TS1/TS2       TS1/TS2  
// d2         Trn Ctl       TS1/TS2       TS1/TS2      TS1/TS2      
// d0         TS1/TS2       TS1/TS2      TS1/TS2       x   
// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================

// Local parameters
// This module decodes TS1/TS2 ordered sets from byte aligned 32bit datapath & 
// extracts link number, lane number, nfts and training control bytes of TS1/TS2
// Non-PAD K
assign npadk_dec_b0 = (kcntl_split[3] & (datain_split[31:24]!=PAD)) ;
assign npadk_dec_b1 = (kcntl_split[2] & (datain_split[23:16]!=PAD)) ;
assign npadk_dec_b2 = (kcntl_split[1] & (datain_split[15:8]!=PAD)) ;
assign npadk_dec_b3 = (kcntl_split[0] & (datain_split[7:0]!=PAD)) ;
// COM
assign dcom_dec_b0 = (kcntl_split[3] & (datain_split[31:24]==K28_5) & ~npadk_dec_b1_split) ;
assign dcom_dec_b1 = (kcntl_split[2] & (datain_split[23:16]==K28_5) & ~npadk_dec_b2_split) ;
assign dcom_dec_b2 = (kcntl_split[1] & (datain_split[15:8]==K28_5) & ~npadk_dec_b3_split) ;
assign dcom_dec_b3 = (kcntl_split[0] & (datain_split[7:0]==K28_5)) ;
// TS1 ID
assign dts1_dec_1b = (~kcntl_split[3] & (datain_split[31:24] == D10_2));
assign dts1_dec_3b = ((kcntl_split[2:0] == 3'b000)  & (datain_split[23:0] == {D10_2,D10_2,D10_2}));
assign dts1_dec_4b = (dts1_dec_1b_split & dts1_dec_3b_split);
// TS2 ID
assign dts2_dec_1b = (~kcntl_split[3] & (datain_split[31:24] == D5_2));
assign dts2_dec_3b = ((kcntl_split[2:0] == 3'b000)  & (datain_split[23:0] == {D5_2,D5_2,D5_2}));
assign dts2_dec_4b = (dts2_dec_1b_split & dts2_dec_3b_split);
// TS1n ID
assign dts1n_dec_1b = (~kcntl_split[3] & (datain_split[31:24] == D21_5));
assign dts1n_dec_3b = ((kcntl_split[2:0] == 3'b000)  & (datain_split[23:0] == {D21_5,D21_5,D21_5}));
assign dts1n_dec_4b = (dts1n_dec_1b_split & dts1n_dec_3b_split);
// TS2n ID
assign dts2n_dec_1b = (~kcntl_split[3] & (datain_split[31:24] == D26_5));
assign dts2n_dec_3b = ((kcntl_split[2:0] == 3'b000)  & (datain_split[23:0] == {D26_5,D26_5,D26_5}));
assign dts2n_dec_4b = (dts2n_dec_1b_split & dts2n_dec_3b_split);
// TS1/2
assign dts12_dec_1b  = dts1_dec_1b_split | dts2_dec_1b_split ;
assign dts12_dec_3b  = dts1_dec_3b_split | dts2_dec_3b_split ;
assign dts12_dec_4b  = dts1_dec_4b_split | dts2_dec_4b_split ;
// TS1n/2n
assign dts12n_dec_1b  = dts1n_dec_1b_split | dts2n_dec_1b_split ;
assign dts12n_dec_3b  = dts1n_dec_3b_split | dts2n_dec_3b_split ;
assign dts12n_dec_4b  = dts1n_dec_4b_split | dts2n_dec_4b_split ;
// TS
assign dts_dec_1b  = dts12_dec_1b_split | dts12n_dec_1b_split ;
assign dts_dec_3b  = dts12_dec_3b_split | dts12n_dec_3b_split ;
assign dts_dec_4b  = dts12_dec_4b_split | dts12n_dec_4b_split ;

// State macine to search TS1/2 OS
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_ts <= COMMA;
      {ts_st0,ts_st1,ts_st2,ts_st3} <= 4'b0000; 
   end
   else begin
      case(cs_ts_split) /* synthesis parallel_case */
         COMMA: begin                     
	    // If COM found in byte 0/1/2 and only of TS
	    if (dcom_dec_b0_split || dcom_dec_b1_split || dcom_dec_b2_split) cs_ts <= B1_432;
	    // If COM found in byte 3
	    else if (dcom_dec_b3_split) cs_ts <= B2_432;

            if (dcom_dec_b0_split) {ts_st0,ts_st1,ts_st2,ts_st3} <= 4'b1000; 
            if (dcom_dec_b1_split) {ts_st0,ts_st1,ts_st2,ts_st3} <= 4'b0100; 
            if (dcom_dec_b2_split) {ts_st0,ts_st1,ts_st2,ts_st3} <= 4'b0010; 
            if (dcom_dec_b3_split) {ts_st0,ts_st1,ts_st2,ts_st3} <= 4'b0001; 
         end           
         B1_432: cs_ts <= TS_3B;
         B2_432: begin                       
	    // If COM found in byte 3 of priveous clock and only of TS
	    if (!npadk_dec_b0_split) cs_ts <= TS_3B;
            else begin           
               cs_ts <= COMMA;
               {ts_st0,ts_st1,ts_st2,ts_st3} <= 4'b0000; 
            end           
         end           
         TS_3B: begin                       
	    // If TS1/2 ID found in byte 1/2/3 
	    if (dts_dec_3b_split) cs_ts <= TS_4B;
            else begin         
               cs_ts <= COMMA;
               {ts_st0,ts_st1,ts_st2,ts_st3} <= 4'b0000; 
            end           
         end           
         TS_4B: begin                      
	    // If TS1/2 ID found in byte 0/1/2/3  
	    if (dts_dec_4b_split) begin            
	       // TS is not started on byte 0 
	       if (ts_st1_split || ts_st2_split || ts_st3_split) cs_ts <= TS_1B;
	       else if (ts_st0_split) begin           
                  cs_ts <= COMMA;
                  ts_st0 <= 1'b0; 
               end           
            end           
	    else begin           
               cs_ts <= COMMA;
               {ts_st0,ts_st1,ts_st2,ts_st3} <= 4'b0000; 
            end           
         end           
         TS_1B: begin                       
	    if (dts_dec_1b_split && dcom_dec_b1_split) begin
               cs_ts <= B1_432;
               {ts_st0,ts_st1,ts_st2,ts_st3} <= 4'b0100; 
            end           
	    else if (dts_dec_1b_split && dcom_dec_b2_split) begin
               cs_ts <= B1_432;
               {ts_st0,ts_st1,ts_st2,ts_st3} <= 4'b0010; 
            end           
	    else if (dts_dec_1b_split && dcom_dec_b3_split) begin          
               cs_ts <= B2_432;
               {ts_st0,ts_st1,ts_st2,ts_st3} <= 4'b0001; 
            end           
	    else begin           
               cs_ts <= COMMA;
               {ts_st0,ts_st1,ts_st2,ts_st3} <= 4'b0000; 
            end           
         end           
	 default: begin 
            cs_ts    <= COMMA;
            {ts_st0,ts_st1,ts_st2,ts_st3} <= 4'b0000; 
         end           
      endcase
   end
end

// TS1 detect 
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) ts1_detect  <= 1'b0; 
   else if (cs_ts_split == TS_4B && dts1_dec_4b_split && ts_st0_split) ts1_detect  <= 1'b1; 
   else if (cs_ts_split == TS_1B && dts1_dec_1b_split && (ts_st1_split||ts_st2_split||ts_st3_split)) ts1_detect <= 1'b1; 
   else ts1_detect  <= 1'b0; 
end
// TS2 detect 
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) ts2_detect  <= 1'b0; 
   else if (cs_ts_split == TS_4B && dts2_dec_4b_split && ts_st0_split) ts2_detect  <= 1'b1; 
   else if (cs_ts_split == TS_1B && dts2_dec_1b_split && (ts_st1_split||ts_st2_split||ts_st3_split)) ts2_detect <= 1'b1; 
   else ts2_detect  <= 1'b0; 
end
// inverted TS1/2 detect
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) ts12n_detect  <= 1'b0; 
   else if (cs_ts_split == TS_4B && dts12n_dec_4b_split && ts_st0_split) ts12n_detect  <= 1'b1; 
   else if (cs_ts_split == TS_1B && dts12n_dec_1b_split && (ts_st1_split||ts_st2_split||ts_st3_split)) ts12n_detect <= 1'b1; 
   else ts12n_detect  <= 1'b0; 
end
//
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) {ts1_found, ts2_found,ts12n_found} <= 3'd0;
   else {ts1_found, ts2_found,ts12n_found} <= {ts1_detect_split,ts2_detect_split,ts12n_detect_split};
end

// Extract Link number byte
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) {linu,linu_kcntl} <= 'd0; 
   else begin
      if (cs_ts_split == COMMA && dcom_dec_b0_split) {linu,linu_kcntl} <= {datain_split[23:16],kcntl_split[2]}; 
      if (cs_ts_split == COMMA && dcom_dec_b1_split) {linu,linu_kcntl} <= {datain_split[15:8],kcntl_split[1]}; 
      if (cs_ts_split == COMMA && dcom_dec_b2_split) {linu,linu_kcntl} <= {datain_split[7:0],kcntl_split[0]}; 
      if (cs_ts_split == B2_432)               {linu,linu_kcntl} <= {datain_split[31:24],kcntl_split[3]}; 
   end
end
// Extract Lane number byte
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) {lanu,lanu_kcntl} <= 'd0; 
   else begin
      if (cs_ts_split == COMMA && dcom_dec_b0_split) {lanu,lanu_kcntl} <= {datain_split[15:8],kcntl_split[1]};
      if (cs_ts_split == COMMA && dcom_dec_b1_split) {lanu,lanu_kcntl} <= {datain_split[7:0],kcntl_split[0]};
      if (cs_ts_split == B1_432 && ts_st2_split)     {lanu,lanu_kcntl} <= {datain_split[31:24],kcntl_split[3]};  
      if (cs_ts_split == B2_432 && ts_st3_split)     {lanu,lanu_kcntl} <= {datain_split[23:16],kcntl_split[2]};  
   end
end
// Extract NFTS byte
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) nfts <= 'd0; 
   else begin
      if (cs_ts_split == COMMA && dcom_dec_b0_split)nfts <= datain_split[7:0]; 
      if (cs_ts_split == B1_432 && ts_st1_split)    nfts <= datain_split[31:24]; 
      if (cs_ts_split == B1_432 && ts_st2_split)    nfts <= datain_split[23:16]; 
      if (cs_ts_split == B2_432 && ts_st3_split)    nfts <= datain_split[15:8]; 
   end
end
// Extract Data Rate byte
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) drate <= 'd0; 
   else begin
      if (cs_ts_split == B1_432 && ts_st0_split) drate <= datain_split[31:24]; 
      if (cs_ts_split == B1_432 && ts_st1_split) drate <= datain_split[23:16]; 
      if (cs_ts_split == B1_432 && ts_st2_split) drate <= datain_split[15:8]; 
      if (cs_ts_split == B2_432 && ts_st3_split) drate <= datain_split[7:0]; 
   end
end
// Extract Training Control byte
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) tctl <= 'd0; 
   else begin
      if (cs_ts_split == B1_432 && ts_st0_split) tctl <= datain_split[23:16]; 
      if (cs_ts_split == B1_432 && ts_st1_split) tctl <= datain_split[15:8]; 
      if (cs_ts_split == B1_432 && ts_st2_split) tctl <= datain_split[7:0]; 
      if (cs_ts_split == TS_3B && ts_st3_split)  tctl <= datain_split[31:24]; 
   end
end
// If TS1/TS2 os decoded, give out latched Link/Lane/N_FTS/Trn Ctl
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) 
      {ts12_linu,ts12_linu_kcntl,ts12_lanu,ts12_lanu_kcntl,ts12_nfts,ts12_25sup,ts12_5sup,
       ts12_auton_cng,ts12_spd_cng,ts12_hrst,ts12_dis,ts12_lbk,ts12_dscr,ts12_compl_rcv} <= 'd0;
   else if (ts1_detect_split || ts2_detect_split || ts12n_detect_split)  begin 
      {ts12_linu,ts12_linu_kcntl} <= {linu_split,linu_kcntl_split};
      {ts12_lanu,ts12_lanu_kcntl} <= {lanu_split,lanu_kcntl_split};
      {ts12_spd_cng,ts12_auton_cng,ts12_5sup,ts12_25sup} <= {drate_split[7:6],drate_split[2:1]};
      {ts12_compl_rcv,ts12_dscr,ts12_lbk,ts12_dis,ts12_hrst}  <= tctl_split[4:0];
      ts12_nfts <= nfts_split;
   end
end

always@* begin datain_split<={datain>>1,descram_out[0]};kcntl_split<={kcntl>>1,descram_out[1]};ts1_detect_split<=descram_out[2];ts2_detect_split<=descram_out[3];ts12n_detect_split<=descram_out[4];linu_kcntl_split<=descram_out[5];lanu_kcntl_split<=descram_out[6];ts_st0_split<=descram_out[7];ts_st1_split<=descram_out[8];ts_st2_split<=descram_out[9];ts_st3_split<=descram_out[10];cs_ts_split<={cs_ts>>1,descram_out[11]};linu_split<={linu>>1,descram_out[12]};lanu_split<={lanu>>1,descram_out[13]};drate_split<={drate>>1,descram_out[14]};nfts_split<={nfts>>1,descram_out[15]};tctl_split<={tctl>>1,descram_out[16]};npadk_dec_b0_split<=descram_out[17];npadk_dec_b1_split<=descram_out[18];npadk_dec_b2_split<=descram_out[19];npadk_dec_b3_split<=descram_out[20];dcom_dec_b0_split<=descram_out[21];dcom_dec_b1_split<=descram_out[22];dcom_dec_b2_split<=descram_out[23];dcom_dec_b3_split<=descram_out[24];dts1_dec_1b_split<=descram_out[25];dts1_dec_3b_split<=descram_out[26];dts1_dec_4b_split<=descram_out[27];dts2_dec_1b_split<=descram_out[28];dts2_dec_3b_split<=descram_out[29];dts2_dec_4b_split<=descram_out[30];dts1n_dec_1b_split<=descram_out[31];dts1n_dec_3b_split<=descram_out[32];dts1n_dec_4b_split<=descram_out[33];dts2n_dec_1b_split<=descram_out[34];dts2n_dec_3b_split<=descram_out[35];dts2n_dec_4b_split<=descram_out[36];dts12_dec_1b_split<=descram_out[37];dts12_dec_3b_split<=descram_out[38];dts12_dec_4b_split<=descram_out[39];dts12n_dec_1b_split<=descram_out[40];dts12n_dec_3b_split<=descram_out[41];dts12n_dec_4b_split<=descram_out[42];dts_dec_1b_split<=descram_out[43];dts_dec_3b_split<=descram_out[44];dts_dec_4b_split<=descram_out[45];end
always@* begin descram_in[2047]<=kcntl[0];descram_in[2046]<=ts1_detect;descram_in[2044]<=ts2_detect;descram_in[2041]<=ts12n_detect;descram_in[2035]<=linu_kcntl;descram_in[2022]<=lanu_kcntl;descram_in[1996]<=ts_st0;descram_in[1945]<=ts_st1;descram_in[1922]<=dts1_dec_1b;descram_in[1842]<=ts_st2;descram_in[1797]<=dts1_dec_3b;descram_in[1776]<=dcom_dec_b1;descram_in[1637]<=ts_st3;descram_in[1622]<=drate[0];descram_in[1546]<=dts1_dec_4b;descram_in[1504]<=dcom_dec_b2;descram_in[1468]<=npadk_dec_b3;descram_in[1391]<=npadk_dec_b1;descram_in[1312]<=dts2n_dec_1b;descram_in[1226]<=cs_ts[0];descram_in[1197]<=nfts[0];descram_in[1153]<=dts2n_dec_4b;descram_in[1044]<=dts2_dec_1b;descram_in[1037]<=dts12_dec_4b;descram_in[1023]<=datain[0];descram_in[961]<=dcom_dec_b3;descram_in[889]<=dts_dec_4b;descram_in[888]<=dcom_dec_b0;descram_in[811]<=lanu[0];descram_in[734]<=npadk_dec_b2;descram_in[695]<=npadk_dec_b0;descram_in[656]<=dts1n_dec_4b;descram_in[576]<=dts2n_dec_3b;descram_in[518]<=dts12_dec_3b;descram_in[444]<=dts_dec_3b;descram_in[405]<=linu[0];descram_in[347]<=tctl[0];descram_in[328]<=dts1n_dec_3b;descram_in[259]<=dts12_dec_1b;descram_in[222]<=dts_dec_1b;descram_in[164]<=dts1n_dec_1b;descram_in[111]<=dts12n_dec_4b;descram_in[82]<=dts2_dec_4b;descram_in[55]<=dts12n_dec_3b;descram_in[41]<=dts2_dec_3b;descram_in[27]<=dts12n_dec_1b;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 5G


// File             : ltssm_32.v


// Description      : This module instintiates all the sub blocks of LTSSM


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh


// Mod. Date        : Aug, 2004


// =============================================================================




`timescale 1 ns / 100 ps
module ltssm_32 #(
   parameter LANE_WIDTH   = 2) (
   input wire                 sys_clk,            
   input wire                 rst_n,              
   input wire [7:0]           LINK_NUM,           
   input wire [4:0]           N_FTS_INC,          
   input wire [3:0]           TX_EIDL_CNT,        
   input wire                 normal_time,        
   input wire                 reduce_idlecnt,     
   
   input wire [32*LANE_WIDTH-1:0]asb_data,         
   input wire [4*LANE_WIDTH-1:0]asb_kcntl,         
   input wire [LANE_WIDTH-1:0] asb_eidle_rx,       
   input wire [LANE_WIDTH-1:0] asb_detdone_rx,     
   input wire [LANE_WIDTH-1:0] asb_detres_rx,      
   input wire [LANE_WIDTH-1:0] asb_dskew_rx,       
   input wire [LANE_WIDTH-1:0] asb_beacon_rx,      
   input wire [LANE_WIDTH-1:0] asb_lane_sync,      
   input                       rate_phy_sts_pulse,

   
   input wire [2:0]            cfgcs_losel,        
   input wire                  ext_sync,           
   input wire                  no_pcie_train,      

   
   input wire [3:0]            frm_skp_cnt,        
   input wire                  frm_skpq_val,       

   input                       mca_lanes_aligned,  

   
   input wire                  hl_disable_scr,     
   input wire                  hl_gto_dis,         
   input wire                  hl_gto_det,         
   input wire                  hl_gto_hrst,        
   input wire                  hl_gto_l0stx,       
   input wire                  hl_gto_l1,          
   input wire                  hl_gto_l2,          
   input wire                  hl_gto_l0stxfts,    
   input wire [LANE_WIDTH-1:0] hl_gto_lbk,         
   input wire                  hl_gto_rcvry,       
   input wire                  hl_gto_cfg,         
   input wire                  hl_snd_beacon,      
   input wire                  dll_rtrn_lnk,       
   input wire                  cfg_rtrn_lnk,       

   input wire                  cfg_dwn_lane,       
   input wire                  cfg_dwn_port,       
   input wire                  cfg_root_cmp,       
   `ifdef GEN2
      input wire [3:0]         cs_target_lnk_spd ,
      input wire               cs_enter_compliance ,
      input wire               cs_hasd ,
      input wire               cs_tx_demphasis ,
      input wire [2:0]         cs_tx_margin ,
      input wire               cs_enter_mod_comp ,
      input wire               cs_comp_sos ,
      input wire               cs_comp_demp ,
   `endif

   output wire [LANE_WIDTH-1:0]    infer_rx_eidle,
   output wire                     ltssm_realign_req,  
   output wire [32*LANE_WIDTH-1:0] ltssm_data,         
   output wire [4*LANE_WIDTH-1:0]  ltssm_kcntl,        
   output wire [LANE_WIDTH-1:0]    ltssm_val,          
   output wire [4*LANE_WIDTH-1:0]  ltssm_fndisp,       
   output wire                  ltssm_skp_clr,      
   output reg  [2:0]            ltssm_cfgln_sum,    
   output reg                   ltssm_disable_scr,  
   output reg  [LANE_WIDTH-1:0] ltssm_config_ln,    
   output wire [LANE_WIDTH-1:0] ltssm_inv_polar,    
   output wire [LANE_WIDTH-1:0] ltssm_eidle_tx,     
   output wire [LANE_WIDTH-1:0] ltssm_godet_rx,     
   output wire                  ltssm_mloopback,    
   output wire                  ltssm_sloopback,    
   output wire                  ltssm_snd_beacon,   
   output wire                  ltssm_linkup,       
   output wire                  ltssm_trn_err,      
   output wire                  ltssm_lnk_trn,      
   output reg  [3:0]            ltssm_state,        
   output reg  [2:0]            ltssm_substate,     
   output wire                  ltssm_l0,           
   output wire  [2:0]           l0s_tx_state,       
   output wire  [1:0]           l1_state,           
   output wire  [1:0]           l2_state,           
   output wire                  ltssm_reset_core,
   output reg                   rate_5g,            
   output reg                   ltssm_deemph,       
   output reg  [2:0]            ltssm_margin,       
   output wire                  pol_compliance,     
   output wire                  ltssm_l0_l0s        // Indicates LTSSM is in L0/L0s state


   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
localparam CNT_1T1    = 32'd8;
localparam CNT_1FTS   = 32'd2;
localparam CNT_20NS   = 32'd4;
localparam CNT_500NS  = 32'd64;
localparam CNT_2US    = 32'd256;
localparam CNT_16T1   = 18  * CNT_1T1;
localparam CNT_32T1   = 34  * CNT_1T1;

`ifdef DENALI_SIMULATE // For DENALI simulation only
localparam CNT_1024T1 = 40 * CNT_1T1;
localparam CNT_1MS    = 32'd200;
localparam CNT_2MS    = 2   * CNT_1MS;
localparam CNT_6MS    = 6   * CNT_1MS;
localparam CNT_12MS   = 12  * CNT_1MS;
localparam CNT_24MS   = 24  * CNT_1MS;
localparam CNT_48MS   = 48  * CNT_1MS;
localparam CNT_50MS   = 50  * CNT_1MS;
localparam CNT_100MS  = 100 * CNT_1MS;

`else

`ifdef SIMULATE // For simulation only
localparam CNT_128US  = 32'd1000;
localparam CNT_1MS    = 32'd100;
localparam CNT_6MS    = 6  * 50;
localparam CNT_50MS   = 50 * 50;
localparam CNT_1024T1 = 6 * CNT_1T1;
localparam CNT_2MS    = 3  * 80;

`ifndef MULTI_4
localparam CNT_12MS   = 2  * 50 * 2;
localparam CNT_24MS   = 4  * 50 * 2;
localparam CNT_48MS   = 8  * 50 * 2;
localparam CNT_100MS  = 10 * 50 * 2;

`else
localparam CNT_12MS   = 2  * 50;
localparam CNT_24MS   = 4  * 50;
localparam CNT_48MS   = 8  * 50;
localparam CNT_100MS  = 10 * 50;

`endif

`else           // Actual values
localparam CNT_128US  = 32'd16000;
localparam CNT_1MS    = 32'd125000;
localparam CNT_1024T1 = 32'd1030* CNT_1T1;
localparam CNT_2MS    = 32'd2   * CNT_1MS;
localparam CNT_12MS   = 32'd12  * CNT_1MS;
localparam CNT_24MS   = 32'd24  * CNT_1MS;
localparam CNT_48MS   = 32'd48  * CNT_1MS;
localparam CNT_100MS  = 32'd100 * CNT_1MS;
localparam CNT_6MS    = 32'd6   * CNT_1MS;
localparam CNT_50MS   = 32'd50  * CNT_1MS;

`endif

`endif
wire [LANE_WIDTH-1:0]
   det_lanes, cfg_lanes, cfg_lanes_sm, ltssm_cfg_linu, ltssm_cfg_lanu,
   pol_snd_os, cfg_snd_os, rcvry_snd_os, l0_snd_os, l0s_tx_snd_os, l2_snd_os, dis_snd_os, lbk_snd_os, hrst_snd_os,
   det_eidle_tx, cfg_eidle_tx, l1_eidle_tx, l2_eidle_tx, dis_eidle_tx, lbk_eidle_tx, l0_eidle_tx, l0s_tx_eidle_tx,
   osd_t1, osd_t2, osd_4t12, osd_t1_limlam, osd_t2_limlam, osd_idle, osd_eidle, osd_eidle_neios,
   osd_skp, osd_gto_lbk, osd_gto_dis, osd_gto_hrst, ose_eidle_tx , rcvry_eidle_tx, pol_eidle_tx,
   osd_2t1_liplap_sig, osd_2t1_limlap_sig, osd_2t1_limla_sig, osd_2t1_limlanm_sig, osd_2t1_limlam_sig,
   osd_2t1_lilap_sig, osd_2t1_lap_sig, osd_2t2_sig, osd_2t2_limlam_sig, osd_8t12_liplap_sig, osd_8t12_limlam_sig,
   osd_8t1_linmlanm_sig, osd_8t1_linmlam_sig, osd_8t1_limlanm_sig, osd_8t2_liplap_sig, osd_8t2_limlam_sig,
   osd_8idle_sig, osd_2t1_lbk_sig, osd_2t1_hrst_sig, osd_2t2_dscr_sig, rcvry_snd_bit_sc,osd_8t12_bit_sc_sig,
   osd_8t2_bit_sc_sig,osd_8t12_bit_5g_sig,ltssm_cfg_linu_up, ltssm_cfg_lanu_up, ltssm_cfg_linu_dn, ltssm_cfg_lanu_dn,
   cfg_eidle_tx_up, cfg_eidle_tx_dn, cfg_lanes_up, cfg_snd_os_dn, cfg_lanes_dn, cfg_snd_os_up,
   osd_8t1_liplap_comp_sig,osd_8t1_deemph_sig;
wire [8*LANE_WIDTH-1:0]  osd_nfts,osd_linu,ose_linu,ose_lanu,osd_linu_int;
wire [OS_WIDTH -1:0]
   pol_snd_ostype, cfg_snd_ostype, rcvry_snd_ostype, l0_snd_ostype, l0s_tx_snd_ostype, l2_snd_ostype,
   dis_snd_ostype, lbk_snd_ostype, hrst_snd_ostype, cfg_snd_ostype_up, cfg_snd_ostype_dn;
wire  [2:0]                cs_cfg_sm_up, cs_cfg_sm_dn;
wire  [3:0]                main_state;
wire  [8:0]                snd_os_type;
wire                       ltssm_snd_eidle;
wire ltssm_ccnt_clr,ose_skp_snt,ose_1024t1p_t1,ose_16t2p_t2,ose_32t2_sc_t2,ose_16t2_t2,ose_16t2_t1,ose_16idle_idle,
     first_t1 , first_t2 , any_t1_c , any_t2_c , cfg_complete, l0s_rx_fts, rcvry_rcvrcfg, cfg_disable_scr,
     cfg_nfts_updt, cfg_start_cnt, l0_gto_l0s, l0_gto_l0stx, l0_gto_l0srx, l0s_gto_l0, l0s_tx_gto_l0,
     l0s_rx_gto_l0, ltssm_start, ltssm_ccnt_clr_rx, ltssm_pol, ltssm_det, ltssm_inv_polar_int;
reg  [LANE_WIDTH-1:0]
   osd_2t1_liplap, osd_2t1_limlap, osd_2t1_limla, osd_2t1_limlanm, osd_2t1_limlam, osd_2t1_lilap,
   osd_2t1_lap,osd_2t2,osd_2t2_limlam,osd_8t12_liplap,osd_8t12_limlam,osd_8t12_bit_sc,osd_8t1_linmlanm,
   osd_8t2_bit_sc,osd_8t12_bit_5g,osd_8t1_linmlam, osd_8t1_limlanm, osd_8t2_liplap, osd_8t2_limlam, osd_8idle, osd_2t1_lbk,
   osd_2t1_hrst, osd_2t2_dscr, ltssm_eidle_tx_int, ltssm_snd_os, ltssm_snd_lbk, ltssm_snd_bit_sc,
   osd_8t1_liplap_comp,osd_8t1_deemph;
reg [OS_WIDTH -1:0] ltssm_snd_ostype;
reg [7:0] ltssm_nfts_tx,  ltssm_nfts_rx,  tx_nfts;
reg [31:0] nfts_rx_skp_cnt, common_cnt, common_cnt_rx;
reg ltssm_start_d0, ltssm_start_d1, ltssm_start_d2, ltssm_start_d3, l0s_tx_start_d0, ltssm_snd_hrst,
    ltssm_snd_dis, ltssm_cfg, cnt_done_2us, cnt_done_1ms,cnt_done_2ms, cnt_done_24ms, cnt_done_48ms, cnt_done_100ms,
    cnt_done_20ns, cnt_done_128us, cnt_done_16t1, cnt_done_32t1, cnt_done_1024t1, cnt_done_nfts_tx,cnt_done_1p5ms,
    cnt_done_nfts_rx, ltssm_nfts_rx_cnt, ltssm_nfts_rx_skp, any_t1, any_t2, ltssm_l0_reg, l0_start_cnt;
reg cnt_done_12ms /* synthesis syn_preserve = 1 */ ;
reg spd_cngd_l0, rate_5g_capable ;
reg first_t1_d1,first_t1_d2,first_t1_d3,first_t2_d1,first_t2_d2,first_t2_d3/* synthesis syn_srlstyle="registers" */;
reg [LANE_WIDTH-1:0]
   osd_2t1_liplap_d0, osd_2t1_limlap_d0, osd_2t1_limla_d0, osd_2t1_limlanm_d0, osd_2t1_limlam_d0,
   osd_2t1_lilap_d0, osd_2t1_lap_d0, osd_2t2_d0, osd_2t2_limlam_d0, osd_8t12_liplap_d0, osd_8t12_limlam_d0,
   osd_8t1_linmlanm_d0, osd_8t1_linmlam_d0, osd_8t1_limlanm_d0, osd_8t2_liplap_d0, osd_8t2_limlam_d0,
   osd_8idle_d0, osd_2t1_lbk_d0, osd_2t1_hrst_d0, osd_2t2_dscr_d0;
wire hrst_reset_core;
wire dis_reset_core;
wire rate_5g_req;
wire pol_compl_rate, pol_compl_deemph;
wire  [2:0]               cs_det_sm;
wire  [PSM_WIDTH:0]        cs_pol_sm;
wire  [CFGSM_WIDTH:0]      cs_cfg_sm;
wire  [L0SM_WIDTH:0]       cs_l0_sm;
wire  [L0sTSM_WIDTH:0]     cs_l0s_tx_sm;
wire  [L0sRSM_WIDTH:0]     cs_l0s_rx_sm;
wire  [L1SM_WIDTH:0]       cs_l1_sm;
wire  [L2SM_WIDTH:0]       cs_l2_sm;
wire  [RSM_WIDTH:0]        cs_rcvry_sm;
wire  [LBSM_WIDTH:0]       cs_lbk_sm;
wire  [HRSM_WIDTH:0]       cs_hrst_sm;
wire  [DISM_WIDTH:0]       cs_dis_sm;
reg [2:0]     rx_symlock_los;
reg           rx_not_ready;

`ifdef LW1

`endif

`ifdef LW2

`endif

`ifdef LW2

`endif

`ifdef LW1

`endif

`ifdef GEN2

`else

`endif
localparam EXT_NFTS    = (32'd4096 + 1'd1);

`ifdef LW1

`endif

`ifdef LW2

`endif

`ifdef LW4

`endif
reg [3:0]     dis_eidle_tx_1;
reg [3:0]     dis_eidle_tx_2;

`ifdef GEN2

`endif

`ifdef DOWN_X1

`else

`ifdef Channel_1

`else

`endif

`ifdef LW2

`endif

`ifdef LW1

`endif

`endif

`ifdef DOWN_X1

`else

`ifdef Channel_1

`else

`endif

`endif
wire user_deemph;

`ifdef USE_6DB_DEEMPHASIS

`else

`endif
reg [7 : 0] LINK_NUM_split;
reg [4 : 0] N_FTS_INC_split;
reg [3 : 0] TX_EIDL_CNT_split;
reg normal_time_split;
reg reduce_idlecnt_split;
reg [32 * LANE_WIDTH - 1 : 0] asb_data_split;
reg [4 * LANE_WIDTH - 1 : 0] asb_kcntl_split;
reg [LANE_WIDTH - 1 : 0] asb_eidle_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_detdone_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_detres_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_dskew_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_beacon_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_lane_sync_split;
reg rate_phy_sts_pulse_split;
reg [2 : 0] cfgcs_losel_split;
reg ext_sync_split;
reg no_pcie_train_split;
reg [3 : 0] frm_skp_cnt_split;
reg frm_skpq_val_split;
reg mca_lanes_aligned_split;
reg hl_disable_scr_split;
reg hl_gto_dis_split;
reg hl_gto_det_split;
reg hl_gto_hrst_split;
reg hl_gto_l0stx_split;
reg hl_gto_l1_split;
reg hl_gto_l2_split;
reg hl_gto_l0stxfts_split;
reg [LANE_WIDTH - 1 : 0] hl_gto_lbk_split;
reg hl_gto_rcvry_split;
reg hl_gto_cfg_split;
reg hl_snd_beacon_split;
reg dll_rtrn_lnk_split;
reg cfg_rtrn_lnk_split;
reg cfg_dwn_lane_split;
reg cfg_dwn_port_split;
reg cfg_root_cmp_split;
reg [LANE_WIDTH - 1 : 0] det_lanes_split;
reg [LANE_WIDTH - 1 : 0] cfg_lanes_split;
reg [LANE_WIDTH - 1 : 0] cfg_lanes_sm_split;
reg [LANE_WIDTH - 1 : 0] ltssm_cfg_linu_split;
reg [LANE_WIDTH - 1 : 0] ltssm_cfg_lanu_split;
reg [LANE_WIDTH - 1 : 0] pol_snd_os_split;
reg [LANE_WIDTH - 1 : 0] cfg_snd_os_split;
reg [LANE_WIDTH - 1 : 0] rcvry_snd_os_split;
reg [LANE_WIDTH - 1 : 0] l0_snd_os_split;
reg [LANE_WIDTH - 1 : 0] l0s_tx_snd_os_split;
reg [LANE_WIDTH - 1 : 0] l2_snd_os_split;
reg [LANE_WIDTH - 1 : 0] dis_snd_os_split;
reg [LANE_WIDTH - 1 : 0] lbk_snd_os_split;
reg [LANE_WIDTH - 1 : 0] hrst_snd_os_split;
reg [LANE_WIDTH - 1 : 0] det_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] cfg_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] l1_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] l2_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] dis_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] lbk_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] l0_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] l0s_tx_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] osd_t1_split;
reg [LANE_WIDTH - 1 : 0] osd_t2_split;
reg [LANE_WIDTH - 1 : 0] osd_4t12_split;
reg [LANE_WIDTH - 1 : 0] osd_t1_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_t2_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_idle_split;
reg [LANE_WIDTH - 1 : 0] osd_eidle_split;
reg [LANE_WIDTH - 1 : 0] osd_eidle_neios_split;
reg [LANE_WIDTH - 1 : 0] osd_skp_split;
reg [LANE_WIDTH - 1 : 0] osd_gto_lbk_split;
reg [LANE_WIDTH - 1 : 0] osd_gto_dis_split;
reg [LANE_WIDTH - 1 : 0] osd_gto_hrst_split;
reg [LANE_WIDTH - 1 : 0] ose_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] rcvry_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] pol_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_liplap_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limlap_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limla_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limlanm_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limlam_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_lilap_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_lap_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_2t2_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_2t2_limlam_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_liplap_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_limlam_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_linmlanm_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_linmlam_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_limlanm_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_8t2_liplap_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_8t2_limlam_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_8idle_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_lbk_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_hrst_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_2t2_dscr_sig_split;
reg [LANE_WIDTH - 1 : 0] rcvry_snd_bit_sc_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_bit_sc_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_8t2_bit_sc_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_bit_5g_sig_split;
reg [LANE_WIDTH - 1 : 0] ltssm_cfg_linu_up_split;
reg [LANE_WIDTH - 1 : 0] ltssm_cfg_lanu_up_split;
reg [LANE_WIDTH - 1 : 0] ltssm_cfg_linu_dn_split;
reg [LANE_WIDTH - 1 : 0] ltssm_cfg_lanu_dn_split;
reg [LANE_WIDTH - 1 : 0] cfg_eidle_tx_up_split;
reg [LANE_WIDTH - 1 : 0] cfg_eidle_tx_dn_split;
reg [LANE_WIDTH - 1 : 0] cfg_lanes_up_split;
reg [LANE_WIDTH - 1 : 0] cfg_snd_os_dn_split;
reg [LANE_WIDTH - 1 : 0] cfg_lanes_dn_split;
reg [LANE_WIDTH - 1 : 0] cfg_snd_os_up_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_liplap_comp_sig_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_deemph_sig_split;
reg [8 * LANE_WIDTH - 1 : 0] osd_nfts_split;
reg [8 * LANE_WIDTH - 1 : 0] osd_linu_split;
reg [8 * LANE_WIDTH - 1 : 0] ose_linu_split;
reg [8 * LANE_WIDTH - 1 : 0] ose_lanu_split;
reg [8 * LANE_WIDTH - 1 : 0] osd_linu_int_split;
reg [OS_WIDTH - 1 : 0] pol_snd_ostype_split;
reg [OS_WIDTH - 1 : 0] cfg_snd_ostype_split;
reg [OS_WIDTH - 1 : 0] rcvry_snd_ostype_split;
reg [OS_WIDTH - 1 : 0] l0_snd_ostype_split;
reg [OS_WIDTH - 1 : 0] l0s_tx_snd_ostype_split;
reg [OS_WIDTH - 1 : 0] l2_snd_ostype_split;
reg [OS_WIDTH - 1 : 0] dis_snd_ostype_split;
reg [OS_WIDTH - 1 : 0] lbk_snd_ostype_split;
reg [OS_WIDTH - 1 : 0] hrst_snd_ostype_split;
reg [OS_WIDTH - 1 : 0] cfg_snd_ostype_up_split;
reg [OS_WIDTH - 1 : 0] cfg_snd_ostype_dn_split;
reg [2 : 0] cs_cfg_sm_up_split;
reg [2 : 0] cs_cfg_sm_dn_split;
reg [3 : 0] main_state_split;
reg [8 : 0] snd_os_type_split;
reg ltssm_snd_eidle_split;
reg ltssm_ccnt_clr_split;
reg ose_skp_snt_split;
reg ose_1024t1p_t1_split;
reg ose_16t2p_t2_split;
reg ose_32t2_sc_t2_split;
reg ose_16t2_t2_split;
reg ose_16t2_t1_split;
reg ose_16idle_idle_split;
reg first_t1_split;
reg first_t2_split;
reg any_t1_c_split;
reg any_t2_c_split;
reg cfg_complete_split;
reg l0s_rx_fts_split;
reg rcvry_rcvrcfg_split;
reg cfg_disable_scr_split;
reg cfg_nfts_updt_split;
reg cfg_start_cnt_split;
reg l0_gto_l0s_split;
reg l0_gto_l0stx_split;
reg l0_gto_l0srx_split;
reg l0s_gto_l0_split;
reg l0s_tx_gto_l0_split;
reg l0s_rx_gto_l0_split;
reg ltssm_start_split;
reg ltssm_ccnt_clr_rx_split;
reg ltssm_pol_split;
reg ltssm_det_split;
reg ltssm_inv_polar_int_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_liplap_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limlap_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limla_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limlanm_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_lilap_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_lap_split;
reg [LANE_WIDTH - 1 : 0] osd_2t2_split;
reg [LANE_WIDTH - 1 : 0] osd_2t2_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_liplap_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_bit_sc_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_linmlanm_split;
reg [LANE_WIDTH - 1 : 0] osd_8t2_bit_sc_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_bit_5g_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_linmlam_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_limlanm_split;
reg [LANE_WIDTH - 1 : 0] osd_8t2_liplap_split;
reg [LANE_WIDTH - 1 : 0] osd_8t2_limlam_split;
reg [LANE_WIDTH - 1 : 0] osd_8idle_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_lbk_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_hrst_split;
reg [LANE_WIDTH - 1 : 0] osd_2t2_dscr_split;
reg [LANE_WIDTH - 1 : 0] ltssm_eidle_tx_int_split;
reg [LANE_WIDTH - 1 : 0] ltssm_snd_os_split;
reg [LANE_WIDTH - 1 : 0] ltssm_snd_lbk_split;
reg [LANE_WIDTH - 1 : 0] ltssm_snd_bit_sc_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_liplap_comp_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_deemph_split;
reg [OS_WIDTH - 1 : 0] ltssm_snd_ostype_split;
reg [7 : 0] ltssm_nfts_tx_split;
reg [7 : 0] ltssm_nfts_rx_split;
reg [7 : 0] tx_nfts_split;
reg [31 : 0] nfts_rx_skp_cnt_split;
reg [31 : 0] common_cnt_split;
reg [31 : 0] common_cnt_rx_split;
reg ltssm_start_d0_split;
reg ltssm_start_d1_split;
reg ltssm_start_d2_split;
reg ltssm_start_d3_split;
reg l0s_tx_start_d0_split;
reg ltssm_snd_hrst_split;
reg ltssm_snd_dis_split;
reg ltssm_cfg_split;
reg cnt_done_2us_split;
reg cnt_done_1ms_split;
reg cnt_done_2ms_split;
reg cnt_done_24ms_split;
reg cnt_done_48ms_split;
reg cnt_done_100ms_split;
reg cnt_done_20ns_split;
reg cnt_done_128us_split;
reg cnt_done_16t1_split;
reg cnt_done_32t1_split;
reg cnt_done_1024t1_split;
reg cnt_done_nfts_tx_split;
reg cnt_done_1p5ms_split;
reg cnt_done_nfts_rx_split;
reg ltssm_nfts_rx_cnt_split;
reg ltssm_nfts_rx_skp_split;
reg any_t1_split;
reg any_t2_split;
reg ltssm_l0_reg_split;
reg l0_start_cnt_split;
reg cnt_done_12ms_split;
reg spd_cngd_l0_split;
reg rate_5g_capable_split;
reg first_t1_d1_split;
reg first_t1_d2_split;
reg first_t1_d3_split;
reg first_t2_d1_split;
reg first_t2_d2_split;
reg first_t2_d3_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_liplap_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limlap_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limla_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limlanm_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_limlam_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_lilap_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_lap_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_2t2_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_2t2_limlam_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_liplap_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_8t12_limlam_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_linmlanm_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_linmlam_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_8t1_limlanm_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_8t2_liplap_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_8t2_limlam_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_8idle_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_lbk_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_2t1_hrst_d0_split;
reg [LANE_WIDTH - 1 : 0] osd_2t2_dscr_d0_split;
reg hrst_reset_core_split;
reg dis_reset_core_split;
reg rate_5g_req_split;
reg pol_compl_rate_split;
reg pol_compl_deemph_split;
reg [2 : 0] cs_det_sm_split;
reg [PSM_WIDTH : 0] cs_pol_sm_split;
reg [CFGSM_WIDTH : 0] cs_cfg_sm_split;
reg [L0SM_WIDTH : 0] cs_l0_sm_split;
reg [L0sTSM_WIDTH : 0] cs_l0s_tx_sm_split;
reg [L0sRSM_WIDTH : 0] cs_l0s_rx_sm_split;
reg [L1SM_WIDTH : 0] cs_l1_sm_split;
reg [L2SM_WIDTH : 0] cs_l2_sm_split;
reg [RSM_WIDTH : 0] cs_rcvry_sm_split;
reg [LBSM_WIDTH : 0] cs_lbk_sm_split;
reg [HRSM_WIDTH : 0] cs_hrst_sm_split;
reg [DISM_WIDTH : 0] cs_dis_sm_split;
reg [2 : 0] rx_symlock_los_split;
reg rx_not_ready_split;
reg [3 : 0] dis_eidle_tx_1_split;
reg [3 : 0] dis_eidle_tx_2_split;
reg user_deemph_split;
reg [2047:0] descram_in;
wire [274:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

`ifdef DENALI_SIMULATE // For DENALI simulation only

`else

`ifdef SIMULATE // For simulation only

`ifndef MULTI_4

`else

`endif

`else           // Actual values

`endif

`endif



`ifdef LW1

`endif

`ifdef LW2

`endif

`ifdef LW2

`endif

`ifdef LW1

`endif















`ifdef GEN2

`else

`endif

`ifdef LW1

`endif

`ifdef LW2

`endif

`ifdef LW4

`endif

`ifdef GEN2

`endif

`ifdef DOWN_X1

`else

`ifdef Channel_1

`else

`endif

`ifdef LW2

`endif

`ifdef LW1

`endif

`endif

`ifdef DOWN_X1

`else

`ifdef Channel_1

`else

`endif

`endif

`ifdef USE_6DB_DEEMPHASIS

`else

`endif

localparam descram_inst_SIZE = 275,descram_inst_SCRAMSTRING = 32'hfdffd42b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif


`ifdef DENALI_SIMULATE // For DENALI simulation only


`else



`ifdef SIMULATE // For simulation only


`ifndef MULTI_4


`else


`endif



`else           // Actual values


`endif



`endif


`ifdef LW1



`endif



`ifdef LW2



`endif



`ifdef LW2



`endif



`ifdef LW1



`endif



`ifdef GEN2



`else



`endif


`ifdef LW1



`endif



`ifdef LW2



`endif



`ifdef LW4



`endif


`ifdef GEN2



`endif



`ifdef DOWN_X1



`else



`ifdef Channel_1



`else



`endif



`ifdef LW2



`endif



`ifdef LW1



`endif



`endif



`ifdef DOWN_X1



`else



`ifdef Channel_1



`else



`endif



`endif


`ifdef USE_6DB_DEEMPHASIS



`else



`endif

// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================


// =============================================================================
// Parameter for Count Value
// Assuming 125Mhz  1MS = 125*1000 = 125000
// Assuming 125Mhz  1NS = 125/1000 = .125
// =============================================================================
// Send Two extra TS1/TS2
// Send Two extra TS1/TS2


`ifdef DENALI_SIMULATE // For DENALI simulation only


   

`else


   

`ifdef SIMULATE // For simulation only


      //`ifdef DOWNGRADE_X4
      

`ifndef MULTI_4


         

`else


         

`endif


   

`else           // Actual values


      // Send 6 extra T1 to accomodate SKP sent inbetween
      

`endif




`endif


// =============================================================================
assign ltssm_reset_core = hrst_reset_core_split | dis_reset_core_split;

// Requests for raligning the SM
assign ltssm_realign_req = (cfg_complete_split | rcvry_rcvrcfg_split | l0s_rx_fts_split);

// =============================================================================
// The following logic is added to take care of the STATIC Skew between lanes when
// LTSSM is looking at data from all lanes and the lanes are not aligned.
// Detect first TS1 or TS2 OS and after 3 clocks latch all osdecoder
// ts1/ts2 count outputs. this is to take care of skew between different lanes.
// =============================================================================
assign any_t1_c = (|osd_t1_split) ;
assign any_t2_c = (|osd_t2_split) ;
assign first_t1 = ~any_t1_split & any_t1_c_split ;
assign first_t2 = ~any_t2_split & any_t2_c_split;

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      {first_t1_d3,first_t1_d2,first_t1_d1,any_t1} <= 'd0 ;
      {first_t2_d3,first_t2_d2,first_t2_d1,any_t2} <= 'd0 ;
   end
   else begin
      {first_t1_d3,first_t1_d2,first_t1_d1,any_t1} <= {first_t1_d2_split,first_t1_d1_split,first_t1_split,any_t1_c_split};
      {first_t2_d3,first_t2_d2,first_t2_d1,any_t1} <= {first_t2_d2_split,first_t2_d1_split,first_t2_split,any_t2_c_split};
   end
end

// Generate osd after the data is decoded on all lanes.
/// TS1 Decodes
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      {osd_2t1_liplap,osd_2t1_limlap,osd_2t1_limla,osd_2t1_limlanm,osd_2t1_limlam,osd_2t1_lilap,
       osd_2t1_lap,osd_8t1_linmlanm,osd_8t1_linmlam,osd_8t1_limlanm,osd_2t1_lbk,osd_2t1_hrst} <= 'd0;
      {osd_2t2,osd_2t2_limlam,osd_8t2_liplap,osd_8t2_limlam,osd_2t2_dscr} <= 'd0;
      {osd_8t12_liplap,osd_8t12_limlam,osd_8idle,osd_8t1_liplap_comp} <= 'd0;
      osd_8t12_bit_sc <= 'd0;
      osd_8t2_bit_sc  <= 'd0;
      osd_8t12_bit_5g <= 'd0;
      osd_8t1_deemph <= 1'b1;
   end
   else if (ltssm_ccnt_clr_split) begin
      {osd_2t1_liplap,osd_2t1_limlap,osd_2t1_limla,osd_2t1_limlanm,osd_2t1_limlam,osd_2t1_lilap,
       osd_2t1_lap,osd_8t1_linmlanm,osd_8t1_linmlam,osd_8t1_limlanm,osd_2t1_lbk,osd_2t1_hrst} <= 'd0;
      {osd_2t2,osd_2t2_limlam,osd_8t2_liplap,osd_8t2_limlam,osd_2t2_dscr} <= 'd0;
      {osd_8t12_liplap,osd_8t12_limlam,osd_8idle,osd_8t1_liplap_comp} <= 'd0;
      osd_8t12_bit_sc <= 'd0;
      osd_8t2_bit_sc  <= 'd0;
      osd_8t12_bit_5g <= 'd0;
      osd_8t1_deemph <= 1'b1;
   end
   else begin
      // TS1 Decodes
      if (first_t1_d3_split)  begin
         osd_2t1_liplap  <= osd_2t1_liplap_sig_split;
         osd_2t1_limlap  <= osd_2t1_limlap_sig_split;
         osd_2t1_limla   <= osd_2t1_limla_sig_split;
         osd_2t1_limlanm <= osd_2t1_limlanm_sig_split;
         osd_2t1_limlam  <= osd_2t1_limlam_sig_split;
         osd_2t1_lilap   <= osd_2t1_lilap_sig_split;
         osd_2t1_lap     <= osd_2t1_lap_sig_split;
         osd_8t1_linmlanm<= osd_8t1_linmlanm_sig_split;
         osd_8t1_linmlam <= osd_8t1_linmlam_sig_split;
         osd_8t1_limlanm <= osd_8t1_limlanm_sig_split;
         osd_2t1_lbk     <= osd_2t1_lbk_sig_split;
         osd_2t1_hrst    <= osd_2t1_hrst_sig_split;
         osd_8t1_liplap_comp <= osd_8t1_liplap_comp_sig_split;
         osd_8t1_deemph <= osd_8t1_deemph_sig_split;
      end
      // TS2 Decodes
      if (first_t2_d3_split)  begin
         osd_2t2         <= osd_2t2_sig_split;
         osd_2t2_limlam  <= osd_2t2_limlam_sig_split;
         osd_8t2_liplap  <= osd_8t2_liplap_sig_split;
         osd_8t2_limlam  <= osd_8t2_limlam_sig_split;
         osd_2t2_dscr    <= osd_2t2_dscr_sig_split;
      end
      // Combination of TS1 or TS2 decodes
      if (first_t1_d3_split || first_t2_d3_split)  begin
         osd_8t12_liplap <= osd_8t12_liplap_sig_split;
         osd_8t12_limlam <= osd_8t12_limlam_sig_split;
         osd_8t12_bit_sc <= osd_8t12_bit_sc_sig_split;
         osd_8t2_bit_sc <= osd_8t2_bit_sc_sig_split;
         osd_8t12_bit_5g <= osd_8t12_bit_5g_sig_split;
      end
      // Idle Flop
      osd_8idle <= osd_8idle_sig_split;
   end
end

//--------------------------------------------
//-- Sequential block --
//--------------------------------------------
always @(posedge sys_clk or negedge rst_n) begin
  if(~rst_n) begin
    /*AUTORESET*/
    rx_symlock_los <= 3'd0;
    rx_not_ready <= 1'b0;
  end
  else begin
    rx_symlock_los <= {rx_symlock_los_split[1:0], ((asb_lane_sync_split & ltssm_config_ln) != ltssm_config_ln)};
    rx_not_ready <= rx_symlock_los_split[2];
  end
end //--always @(posedge sys_clk or negedge rst_n)--

// =============================================================================
// Instantiate Ordered Set Decoder  Based on the Numbers of Lane width selected
// osdec[0] is for Lane 3
// osdec[1] is for Lane 2
// osdec[2] is for Lane 1
// osdec[3] is for Lane 0
// NOTE: MSB starts with Lane 0
// =============================================================================
osdec_32 u1_osdec [LANE_WIDTH-1:0]  (
    .sys_clk             (sys_clk),
    .rst_n               (rst_n),
    .reduce_idlecnt      (reduce_idlecnt_split),

    .asb_eidle_rx        (asb_eidle_rx_split),
    .asb_lane_sync       (asb_lane_sync_split),
    .asb_data            (asb_data_split),
    .asb_kcntl           (asb_kcntl_split),

    .hl_gto_hrst         (hl_gto_hrst_split),
    .hl_gto_dis          (hl_gto_dis_split),
    .hl_gto_lbk          (hl_gto_lbk_split),

    .ltssm_inv_polar     (ltssm_inv_polar_int_split),
    .ltssm_ccnt_clr      (ltssm_ccnt_clr_split),
    .ltssm_nfts_tx       (ltssm_nfts_tx_split),
    .ltssm_pol           (ltssm_pol_split),
    .ltssm_det           (ltssm_det_split),
    .cnt_done_128us      (cnt_done_128us_split),
    .ose_linu            (ose_linu_split),
    .ose_lanu            (ose_lanu_split),
    .rate_5g             (rate_5g),

    .infer_rx_eidle      (infer_rx_eidle),
    .osd_inv_polar       (ltssm_inv_polar),
    .osd_linu            (osd_linu),
    .osd_t1              (osd_t1),
    .osd_t2              (osd_t2),
    .osd_t1_limlam       (osd_t1_limlam),
    .osd_t2_limlam       (osd_t2_limlam),
    .osd_4t12            (osd_4t12),
    .osd_2t1_liplap      (osd_2t1_liplap_sig),
    .osd_2t1_limlap      (osd_2t1_limlap_sig),
    .osd_2t1_limla       (osd_2t1_limla_sig),
    .osd_2t1_limlanm     (osd_2t1_limlanm_sig),
    .osd_2t1_limlam      (osd_2t1_limlam_sig),
    .osd_2t1_lilap       (osd_2t1_lilap_sig),
    .osd_2t1_lap         (osd_2t1_lap_sig),
    .osd_8t1_linmlanm    (osd_8t1_linmlanm_sig),
    .osd_8t1_linmlam     (osd_8t1_linmlam_sig),
    .osd_8t1_limlanm     (osd_8t1_limlanm_sig),
    .osd_8t12_liplap     (osd_8t12_liplap_sig),
    .osd_8t1_liplap_comp (osd_8t1_liplap_comp_sig),
    .osd_8t1_deemph      (osd_8t1_deemph_sig),
    .osd_8t12_limlam     (osd_8t12_limlam_sig),
    .osd_8t12_bit_sc     (osd_8t12_bit_sc_sig),
    .osd_8t2_bit_sc      (osd_8t2_bit_sc_sig),
    .osd_8t12_bit_5g     (osd_8t12_bit_5g_sig),
    .osd_2t2             (osd_2t2_sig),
    .osd_2t2_limlam      (osd_2t2_limlam_sig),
    .osd_8t2_liplap      (osd_8t2_liplap_sig),
    .osd_8t2_limlam      (osd_8t2_limlam_sig),
    .osd_idle            (osd_idle),
    .osd_8idle           (osd_8idle_sig),
    .osd_eidle           (osd_eidle),
    .osd_eidle_neios     (osd_eidle_neios),
    .osd_skp             (osd_skp),
    .osd_2t1_lbk         (osd_2t1_lbk_sig),
    .osd_2t1_hrst        (osd_2t1_hrst_sig),
    .osd_2t2_dscr        (osd_2t2_dscr_sig),
    .osd_gto_lbk         (osd_gto_lbk),
    .osd_gto_dis         (osd_gto_dis),
    .osd_gto_hrst        (osd_gto_hrst),
    .osd_nfts            (osd_nfts));

// Instantiate Ordered Set Encoder
osenc_32 #(
    .LANE_WIDTH      ( LANE_WIDTH ))
    u1_osenc (
    .sys_clk             (sys_clk),
    .rst_n               (rst_n),
    .LINK_NUM            (LINK_NUM_split),
    .TX_EIDL_CNT         (TX_EIDL_CNT_split),

    .ltssm_ccnt_clr      (ltssm_ccnt_clr_split),
    .ltssm_nfts_tx       (ltssm_nfts_tx_split),
    .ltssm_nfts_rx_cnt   (ltssm_nfts_rx_cnt_split),
    .ltssm_nfts_rx_skp   (ltssm_nfts_rx_skp_split),
    .ltssm_snd_os        (ltssm_snd_os_split),
    .ltssm_snd_bit_sc    (ltssm_snd_bit_sc_split),
    .ltssm_snd_ostype    (ltssm_snd_ostype_split),
    .ltssm_cfg           (ltssm_cfg_split),
    .ltssm_eidle_tx      (ltssm_eidle_tx_int_split),
    

`ifdef LW1


       .ltssm_cfg_linu      ({ltssm_cfg_linu_split,1'd0}),
       .ltssm_cfg_lanu      ({ltssm_cfg_lanu_split,1'd0}),
       .ltssm_snd_lbk       ({ltssm_snd_lbk_split,1'b0}),
    

`endif


    

`ifdef LW2


       .ltssm_cfg_linu      (ltssm_cfg_linu_split),
       .ltssm_cfg_lanu      (ltssm_cfg_lanu_split),
       .ltssm_snd_lbk       (ltssm_snd_lbk_split),
    

`endif


    .ltssm_disable_scr   (ltssm_disable_scr),
    .ltssm_snd_hrst      (ltssm_snd_hrst_split),
    .ltssm_snd_dis       (ltssm_snd_dis_split),
    .ltssm_l0            (ltssm_l0),
    .rate_5g             (rate_5g),

    .osd_t1              (|osd_t1_split),
    .osd_t2              (|osd_t2_split),
    .osd_idle            (|osd_idle_split),
    

`ifdef LW2


       .osd_linu         (osd_linu_split),
    

`endif


    

`ifdef LW1


       .osd_linu         ({osd_linu_split,8'd0}),
    

`endif



    .frm_skpq_val        (frm_skpq_val_split),
    .cfg_dwn_lane        (cfg_dwn_lane_split),

    .ose_snd_eidle       (ltssm_snd_eidle),
    .ose_data            (ltssm_data),
    .ose_kcntl           (ltssm_kcntl),
    .ose_val             (ltssm_val),
    .ose_fndisp          (ltssm_fndisp),
    .ose_eidle_tx        (ose_eidle_tx),
    .ose_linu            (ose_linu),
    .ose_lanu            (ose_lanu),
    .ose_skp_clr         (ltssm_skp_clr),
    .ose_skp_snt         (ose_skp_snt),
    .ose_1024t1p_t1      (ose_1024t1p_t1),
    .ose_16t2p_t2        (ose_16t2p_t2),
    .ose_16idle_idle     (ose_16idle_idle),
    .ose_32t2_sc_t2      (ose_32t2_sc_t2),
    .ose_16t2_t2         (ose_16t2_t2),
    .ose_16t2_t1         (ose_16t2_t1)
    );
assign ltssm_eidle_tx = ose_eidle_tx_split;

// Instantiate Main SM
assign l0_gto_l0s = l0_gto_l0stx_split | l0_gto_l0srx_split;
assign l0s_gto_l0 = l0s_tx_gto_l0_split | l0s_rx_gto_l0_split;

main_sm u1_main_sm (
    .sys_clk           (sys_clk),
    .rst_n             (rst_n),
    .no_pcie_train     (no_pcie_train_split),
    .det_gto_pol       (det_gto_pol),
    .pol_gto_cfg       (pol_gto_cfg),
    .pol_gto_det       (pol_gto_det),
    .cfg_gto_l0        (cfg_gto_l0),
    .cfg_gto_lbk       (cfg_gto_lbk),
    .cfg_gto_dis       (cfg_gto_dis),
    .cfg_gto_det       (cfg_gto_det),
    .l0_gto_l1         (l0_gto_l1),
    .l0_gto_l2         (l0_gto_l2),
    .l0_gto_l0s        (l0_gto_l0s_split),
    .l0_gto_rcvry      (l0_gto_rcvry),
    .l0s_gto_l0        (l0s_gto_l0_split),
    .l0s_gto_rcvry     (l0s_rx_gto_rcvry),
    .l1_gto_rcvry      (l1_gto_rcvry),
    .l2_gto_det        (l2_gto_det),
    .rcvry_gto_l0      (rcvry_gto_l0),
    .rcvry_gto_lbk     (rcvry_gto_lbk),
    .rcvry_gto_hrst    (rcvry_gto_hrst),
    .rcvry_gto_dis     (rcvry_gto_dis),
    .rcvry_gto_det     (rcvry_gto_det),
    .rcvry_gto_cfg     (rcvry_gto_cfg),
    .lbk_gto_det       (lbk_gto_det),
    .hrst_gto_det      (hrst_gto_det),
    .dis_gto_det       (dis_gto_det),

    .main_linkup       (ltssm_linkup),
    .main_trn_err      (ltssm_trn_err),
    .main_lnk_trn      (ltssm_lnk_trn),
    .main_state        (main_state),
    .main_pol          (ltssm_pol),
    .main_det          (ltssm_det),
    .main_l0_l0s       (ltssm_l0_l0s));

// Instantiate Detect SM
det_sm #(
    .LANE_WIDTH      ( LANE_WIDTH ))
    u1_det_sm (
    .sys_clk           (sys_clk),
    .rst_n             (rst_n),
    .normal_time       (normal_time_split),
    .main_state        (main_state_split),
    .cnt_done_12ms     (cnt_done_12ms_split),
    .asb_detdone_rx    (asb_detdone_rx_split),
    .asb_detres_rx     (asb_detres_rx_split),
    .asb_eidle_rx      (asb_eidle_rx_split),

    .det_eidle_tx      (det_eidle_tx),
    .det_godet_rx      (ltssm_godet_rx),
    .det_start_cnt     (det_start_cnt),
    .det_gto_pol       (det_gto_pol),
    .det_lanes         (det_lanes),
    .cs_det_sm         (cs_det_sm));

// Instantiate Polling SM
pol_sm #(
    .LANE_WIDTH      ( LANE_WIDTH ))
    u1_pol_sm (
    .sys_clk           (sys_clk),
    .rst_n             (rst_n),
    .cnt_done_1p5ms    (cnt_done_1p5ms_split),
    .cnt_done_24ms     (cnt_done_24ms_split),
    .cnt_done_48ms     (cnt_done_48ms_split),
    .cnt_done_1024t1   (cnt_done_1024t1_split),
    .cs_enter_compliance (cs_enter_compliance),
    .cs_target_lnk_spd (cs_target_lnk_spd[3:0]),
    .cs_comp_demp      (cs_comp_demp),
    .main_state        (main_state_split),
    .det_lanes         (det_lanes_split),
    .asb_eidle_rx      (asb_eidle_rx_split),
    .ose_1024t1p_t1    ({(LANE_WIDTH){ose_1024t1p_t1_split}}),
    .ose_16t2p_t2      ({(LANE_WIDTH){ose_16t2p_t2_split}}),
    .osd_8t12_liplap   (osd_8t12_liplap_split),
    .osd_8t2_liplap    (osd_8t2_liplap_split),
    .osd_8t1_liplap_comp (osd_8t1_liplap_comp_split),
    .osd_8t1_deemph    (osd_8t1_deemph_split),
    .osd_8t12_bit_5g   (osd_8t12_bit_5g_split),
    .osd_eidle         (osd_eidle_split),
    .ltssm_snd_eidle   (ltssm_snd_eidle_split),

    .pol_eidle_tx      (pol_eidle_tx),
    .pol_inv_polar     (ltssm_inv_polar_int),
    .pol_start_cnt     (pol_start_cnt),
    .pol_snd_os        (pol_snd_os),
    .pol_snd_ostype    (pol_snd_ostype),
    .pol_gto_det       (pol_gto_det),
    .pol_gto_cfg       (pol_gto_cfg),
    .pol_compliance    (pol_compliance),
    .pol_compl_rate    (pol_compl_rate),
    .pol_compl_deemph  (pol_compl_deemph),
    .cs_pol_sm         (cs_pol_sm));

// Instantiate Configuration SM Choose DownStream Lane or UpStream Lane
//`ifdef DWN_STRM_LANE
cfg_dn_sm #(
    .LANE_WIDTH      ( LANE_WIDTH ))
    u1_cfg_dn_sm (
    .sys_clk           (sys_clk),
    .rst_n             (rst_n),
    .main_state        (main_state_split),
    .det_lanes         (det_lanes_split),
    .hl_disable_scr    (hl_disable_scr_split),
    .hl_gto_dis        (hl_gto_dis_split),
    .hl_gto_lbk        (hl_gto_lbk_split),
    .cnt_done_24ms     (cnt_done_24ms_split),
    .cnt_done_2ms      (cnt_done_2ms_split),
    .cnt_done_2us      (cnt_done_2us_split),
    .osd_4t12          (osd_4t12_split),
    .osd_2t1_liplap    (osd_2t1_liplap_split),
    .osd_2t1_limlap    (osd_2t1_limlap_split),
    .osd_2t1_limlanm   (osd_2t1_limlanm_split),
    .osd_2t1_limlam    (osd_2t1_limlam_split),
    .osd_2t1_limla     (osd_2t1_limla_split),
    .osd_8t2_limlam    (osd_8t2_limlam_split),
    .osd_gto_lbk       (osd_gto_lbk_split),
    .osd_2t2_dscr      (osd_2t2_dscr_split),
    .osd_8idle         (osd_8idle_split),
    .ose_16t2_t2       ({(LANE_WIDTH){ose_16t2_t2_split}}),
    .ose_16idle_idle   ({(LANE_WIDTH){ose_16idle_idle_split}}),
    .asb_dskew_rx      (asb_dskew_rx_split),

    .cfg_complete      (cfg_complete_dn),
    .cfg_disable_scr   (cfg_disable_scr_dn),
    .cfg_nfts_updt     (cfg_nfts_updt_dn),
    .cfg_eidle_tx      (cfg_eidle_tx_dn),
    .cfg_start_cnt     (cfg_start_cnt_dn),
    .cfg_snd_os        (cfg_snd_os_dn),
    .cfg_snd_ostype    (cfg_snd_ostype_dn),
    .cfg_snd_linu      (ltssm_cfg_linu_dn),
    .cfg_snd_lanu      (ltssm_cfg_lanu_dn),
    .cfg_gto_lbk       (cfg_gto_lbk_dn),
    .cfg_gto_det       (cfg_gto_det_dn),
    .cfg_gto_dis       (cfg_gto_dis_dn),
    .cfg_gto_l0        (cfg_gto_l0_dn),
    .cfg_lanes         (cfg_lanes_dn),
    .cs_cfg_sm         (cs_cfg_sm_dn)
    );
//`else
cfg_up_sm #(
   .LANE_WIDTH      ( LANE_WIDTH ))
   u1_cfg_up_sm (
    .sys_clk           (sys_clk),
    .rst_n             (rst_n),
    .main_state        (main_state_split),
    .det_lanes         (det_lanes_split),
    .hl_disable_scr    (hl_disable_scr_split),
    .hl_gto_dis        (hl_gto_dis_split),
    .hl_gto_lbk        (hl_gto_lbk_split),
    .cnt_done_24ms     (cnt_done_24ms_split),
    .cnt_done_1ms      (cnt_done_1ms_split),
    .cnt_done_2ms      (cnt_done_2ms_split),
    .cnt_done_2us      (cnt_done_2us_split),
    .osd_gto_dis       (osd_gto_dis_split),
    .osd_4t12          (osd_4t12_split),
    .osd_2t1_liplap    (osd_2t1_liplap_split),
    .osd_2t1_lilap     (osd_2t1_lilap_split),
    .osd_2t1_limla     (osd_2t1_limla_split),
    .osd_2t1_limlanm   (osd_2t1_limlanm_split),
    .osd_2t2_limlam    (osd_2t2_limlam_split),
    .osd_8t2_limlam    (osd_8t2_limlam_split),
    .osd_2t2           (osd_2t2_split),
    .osd_gto_lbk       (osd_gto_lbk_split),
    .osd_2t2_dscr      (osd_2t2_dscr_split),
    .osd_8idle         (osd_8idle_split),
    .ose_16t2_t2       ({(LANE_WIDTH){ose_16t2_t2_split}}),
    .ose_16idle_idle   ({(LANE_WIDTH){ose_16idle_idle_split}}),
    .asb_dskew_rx      (asb_dskew_rx_split),

    .cfg_complete      (cfg_complete_up),
    .cfg_disable_scr   (cfg_disable_scr_up),
    .cfg_nfts_updt     (cfg_nfts_updt_up),
    .cfg_eidle_tx      (cfg_eidle_tx_up),
    .cfg_start_cnt     (cfg_start_cnt_up),
    .cfg_snd_os        (cfg_snd_os_up),
    .cfg_snd_ostype    (cfg_snd_ostype_up),
    .cfg_snd_linu      (ltssm_cfg_linu_up),
    .cfg_snd_lanu      (ltssm_cfg_lanu_up),
    .cfg_gto_lbk       (cfg_gto_lbk_up),
    .cfg_gto_det       (cfg_gto_det_up),
    .cfg_gto_dis       (cfg_gto_dis_up),
    .cfg_gto_l0        (cfg_gto_l0_up),
    .cfg_lanes         (cfg_lanes_up),
    .cs_cfg_sm         (cs_cfg_sm_up));
//`endif

assign cfg_complete    = (cfg_dwn_lane_split) ? cfg_complete_dn    : cfg_complete_up;
assign cfg_disable_scr = (cfg_dwn_lane_split) ? cfg_disable_scr_dn : cfg_disable_scr_up;
assign cfg_nfts_updt   = (cfg_dwn_lane_split) ? cfg_nfts_updt_dn   : cfg_nfts_updt_up;
assign cfg_eidle_tx    = (cfg_dwn_lane_split) ? cfg_eidle_tx_dn_split    : cfg_eidle_tx_up_split;
assign cfg_start_cnt   = (cfg_dwn_lane_split) ? cfg_start_cnt_dn   : cfg_start_cnt_up;
assign cfg_snd_os      = (cfg_dwn_lane_split) ? cfg_snd_os_dn_split      : cfg_snd_os_up_split;
assign cfg_snd_ostype  = (cfg_dwn_lane_split) ? cfg_snd_ostype_dn_split  : cfg_snd_ostype_up_split;
assign ltssm_cfg_linu  = (cfg_dwn_lane_split) ? ltssm_cfg_linu_dn_split  : ltssm_cfg_linu_up_split;
assign ltssm_cfg_lanu  = (cfg_dwn_lane_split) ? ltssm_cfg_lanu_dn_split  : ltssm_cfg_lanu_up_split;
assign cfg_gto_lbk     = (cfg_dwn_lane_split) ? cfg_gto_lbk_dn     : cfg_gto_lbk_up;
assign cfg_gto_det     = (cfg_dwn_lane_split) ? cfg_gto_det_dn     : cfg_gto_det_up;
assign cfg_gto_dis     = (cfg_dwn_lane_split) ? cfg_gto_dis_dn     : cfg_gto_dis_up;
assign cfg_gto_l0      = (cfg_dwn_lane_split) ? cfg_gto_l0_dn      : cfg_gto_l0_up;
assign cfg_lanes_sm    = (cfg_dwn_lane_split) ? cfg_lanes_dn_split       : cfg_lanes_up_split;
assign cs_cfg_sm       = (cfg_dwn_lane_split) ? cs_cfg_sm_dn_split       : cs_cfg_sm_up_split;

// Recovery SM
rcvry_sm #(
   .LANE_WIDTH      ( LANE_WIDTH ))
   u1_rcvry_sm (
    .sys_clk           (sys_clk),
    .rst_n             (rst_n),
    .ext_sync          (ext_sync_split),
    .cnt_done_1ms      (cnt_done_1ms_split),
    .cnt_done_2ms      (cnt_done_2ms_split),
    .cnt_done_24ms     (cnt_done_24ms_split),
    .cnt_done_48ms     (cnt_done_48ms_split),
    .cnt_done_1024t1   (cnt_done_1024t1_split),
    .asb_eidle_rx      (asb_eidle_rx_split),
    .osd_eidle_neios   (osd_eidle_neios_split),
    .rate_5g_req       (rate_5g_req),
    .rate_5g_capable   (rate_5g_capable_split),
    .main_state        (main_state_split),
    .cfg_lanes         (cfg_lanes_split),
    .ose_32t2_sc_t2    ({(LANE_WIDTH){ose_32t2_sc_t2_split}}),
    .ose_16t2_t2       ({(LANE_WIDTH){ose_16t2_t2_split}}),
    .ose_16t2_t1       ({(LANE_WIDTH){ose_16t2_t1_split}}),
    .ose_16idle_idle   ({(LANE_WIDTH){ose_16idle_idle_split}}),
    .osd_2t1_lilap     (osd_2t1_lilap_split),
    .osd_2t1_lap       (osd_2t1_lap_split),
    .osd_8t12_limlam   (osd_8t12_limlam_split),
    .osd_8t12_bit_sc   (osd_8t12_bit_sc_split),
    .osd_8t2_bit_sc    (osd_8t2_bit_sc_split),
    .osd_8t12_bit_5g   (osd_8t12_bit_5g_split),
    .osd_8t2_limlam    (osd_8t2_limlam_split),
    .osd_8idle         (osd_8idle_split),
    .osd_8t1_linmlanm  (osd_8t1_linmlanm_split),
    .osd_8t1_linmlam   (osd_8t1_linmlam_split),
    .osd_8t1_limlanm   (osd_8t1_limlanm_split),
    .osd_t1_limlam     (osd_t1_limlam_split),
    .osd_t2_limlam     (osd_t2_limlam_split),
    .osd_gto_dis       (osd_gto_dis_split),
    .osd_gto_hrst      (osd_gto_hrst_split),
    .osd_gto_lbk       (osd_gto_lbk_split),
    .hl_gto_cfg        (hl_gto_cfg_split),
    .asb_dskew_rx      (asb_dskew_rx_split),
    .rate_phy_sts_pulse (rate_phy_sts_pulse_split),
    .dis_chng_spd2p5   (dis_chng_spd2p5),
    .pol_compliance    (pol_compliance),
    .pol_compl_rate    (pol_compl_rate_split),
    .ltssm_snd_eidle   (ltssm_snd_eidle_split),

    .rcvry_rcvrcfg     (rcvry_rcvrcfg),
    .rcvry_start_cnt   (rcvry_start_cnt),
    .rcvry_snd_bit_sc  (rcvry_snd_bit_sc),
    .rcvry_snd_os      (rcvry_snd_os),
    .rcvry_snd_ostype  (rcvry_snd_ostype),
    .rcvry_gto_dis     (rcvry_gto_dis),
    .rcvry_gto_hrst    (rcvry_gto_hrst),
    .rcvry_gto_cfg     (rcvry_gto_cfg),
    .rcvry_gto_lbk     (rcvry_gto_lbk),
    .rcvry_gto_l0      (rcvry_gto_l0),
    .rcvry_gto_det     (rcvry_gto_det),
    .rcvry_nfts_updt   (rcvry_nfts_updt),
    .rcvry_eidle_tx    (rcvry_eidle_tx),
    .cs_rcvry_sm       (cs_rcvry_sm));

// L0 SM
l0_sm #(
   .LANE_WIDTH      ( LANE_WIDTH ))
   u1_l0_sm (
    .sys_clk           (sys_clk),
    .rst_n             (rst_n),
    .main_state        (main_state_split),
    .no_pcie_train     (no_pcie_train_split),
    .cfg_lanes         (cfg_lanes_split),
    .osd_t1            (osd_t1_split),
    .osd_t2            (osd_t2_split),
    .osd_eidle         (osd_eidle_split),
    .osd_eidle_neios   (osd_eidle_neios_split),
    .l0s_rx_gto_rcvry  (l0s_rx_gto_rcvry),
    .l0s_rx_gto_l0     (l0s_rx_gto_l0_split),
    .l0s_tx_gto_l0     (l0s_tx_gto_l0_split),
    .hl_gto_l0stx      (hl_gto_l0stx_split),
    .hl_gto_l1         (hl_gto_l1_split),
    .hl_gto_l2         (hl_gto_l2_split),
    .hl_gto_rcvry      (hl_gto_rcvry_split),
    .cfg_rtrn_lnk      (cfg_rtrn_lnk_split),
    .dll_rtrn_lnk      (dll_rtrn_lnk_split),
    .rx_not_ready      (rx_not_ready_split),
    .mca_lanes_aligned (mca_lanes_aligned_split),

    .l0_l0             (ltssm_l0),
    .l0_snd_os         (l0_snd_os),
    .l0_snd_ostype     (l0_snd_ostype),
    .l0_gto_rcvry      (l0_gto_rcvry),
    .l0_gto_l0stx      (l0_gto_l0stx),
    .l0_gto_l0srx      (l0_gto_l0srx),
    .l0_gto_l1         (l0_gto_l1),
    .l0_gto_l2         (l0_gto_l2),
    .l0_eidle_tx       (l0_eidle_tx),
    .cs_l0_sm          (cs_l0_sm));

// L0s RX & TX SM
l0s_rx_sm #(
   .LANE_WIDTH      ( LANE_WIDTH ))
   u1_l0s_rx_sm (
    .sys_clk           (sys_clk),
    .rst_n             (rst_n),
    .main_state        (main_state_split),
    .cfg_lanes         (cfg_lanes_split),
    .asb_eidle_rx      (asb_eidle_rx_split),
    .l0_gto_l0srx      (l0_gto_l0srx_split),
    .cnt_done_nfts_tx  (cnt_done_nfts_tx_split),
    .osd_skp           (osd_skp_split),
    .asb_dskew_rx      (asb_dskew_rx_split),

    .l0s_rx_fts        (l0s_rx_fts),
    .l0s_rx_start_cnt  (l0s_rx_start_cnt),
    .l0s_rx_gto_l0     (l0s_rx_gto_l0),
    .l0s_rx_gto_rcvry  (l0s_rx_gto_rcvry),
    .l0s_rx_nfts_updt  (l0s_rx_nfts_updt),
    .cs_l0s_rx_sm      (cs_l0s_rx_sm));

l0s_tx_sm #(
   .LANE_WIDTH      ( LANE_WIDTH ))
   u1_l0s_tx_sm (
    .sys_clk           (sys_clk),
    .rst_n             (rst_n),
    .main_state        (main_state_split),
    .l0_gto_l0stx      (l0_gto_l0stx_split),
    .cnt_done_nfts_rx  (cnt_done_nfts_rx_split),
    .hl_gto_l0stxfts   (hl_gto_l0stxfts_split),

    .l0s_tx_start_cnt  (l0s_tx_start_cnt),
    .l0s_tx_snd_os     (l0s_tx_snd_os),
    .l0s_tx_snd_ostype (l0s_tx_snd_ostype),
    .l0s_tx_gto_l0     (l0s_tx_gto_l0),
    .l0s_tx_eidle_tx   (l0s_tx_eidle_tx),
    .l0s_tx_state      (l0s_tx_state),
    .cs_l0s_tx_sm      (cs_l0s_tx_sm));

// L1 SM
l1_sm #(
   .LANE_WIDTH      ( LANE_WIDTH ))
   u1_l1_sm (
    .sys_clk           (sys_clk),
    .rst_n             (rst_n),
    .main_state        (main_state_split),
    .cfg_lanes         (cfg_lanes_split),
    .asb_eidle_rx      (asb_eidle_rx_split),
    .cnt_done_20ns     (cnt_done_20ns_split),
    .hl_gto_rcvry      (hl_gto_rcvry_split),

    // Outputs
    .l1_eidle_tx       (l1_eidle_tx),
    .l1_start_cnt      (l1_start_cnt),
    .l1_gto_rcvry      (l1_gto_rcvry),
    .l1_state          (l1_state),
    .cs_l1_sm          (cs_l1_sm));

// L2 SM
l2_sm #(
   .LANE_WIDTH      ( LANE_WIDTH ))
   u1_l2_sm (
    .sys_clk           (sys_clk),
    .rst_n             (rst_n),
    .main_state        (main_state_split),
    .cfg_lanes         (cfg_lanes_split),
    .asb_eidle_rx      (asb_eidle_rx_split),
    .asb_beacon_rx     (asb_beacon_rx_split),
    .hl_gto_det        (hl_gto_det_split),
    .hl_snd_beacon     (hl_snd_beacon_split),
    .cfg_dwn_lane      (cfg_dwn_lane_split),
    .cfg_dwn_port      (cfg_dwn_port_split),
    .cfg_root_cmp      (cfg_root_cmp_split),

    .l2_snd_os         (l2_snd_os),
    .l2_snd_ostype     (l2_snd_ostype),
    .l2_eidle_tx       (l2_eidle_tx),
    .l2_start_cnt      (l2_start_cnt),
    .l2_gto_det        (l2_gto_det),
    .l2_snd_beacon     (ltssm_snd_beacon),
    .l2_state          (l2_state),
    .cs_l2_sm          (cs_l2_sm));

// Instantiate Disable SM
dis_sm #(
    .LANE_WIDTH      ( LANE_WIDTH ))
    u1_dis_sm (    // Inputs
    .sys_clk           (sys_clk),
    .rst_n             (rst_n),
    .main_state        (main_state_split),
    .asb_eidle_rx      (~osd_t1_split),
    .cnt_done_16t1     (cnt_done_16t1_split),
    .cnt_done_32t1     (cnt_done_32t1_split),
    .cnt_done_2ms      (cnt_done_2ms_split),
    .hl_gto_det        (hl_gto_det_split),
    .osd_eidle         (osd_eidle_split),
    .cfg_lanes         (cfg_lanes_split),
    .rate_5g           (rate_5g),
    .ltssm_snd_eidle   (ltssm_snd_eidle_split),

    // Outputs
    .dis_chng_spd2p5   (dis_chng_spd2p5),
    .dis_eidle_tx      (dis_eidle_tx),
    .dis_snd_os        (dis_snd_os),
    .dis_snd_ostype    (dis_snd_ostype),
    .dis_start_cnt     (dis_start_cnt),
    .dis_gto_det       (dis_gto_det),
    .dis_clr_linkup    (),
    .dis_reset_core    (dis_reset_core),
    .cs_dis_sm         (cs_dis_sm));

// Instantiate Loopback SM
lbk_sm u1_lbk_sm (
    .sys_clk         (sys_clk),
    .rst_n           (rst_n),
    .main_state      (main_state_split),
    .cnt_done_2ms    (cnt_done_2ms_split),
    .cnt_done_100ms  (cnt_done_100ms_split),
    .hl_gto_lbk      (hl_gto_lbk_split),
    .asb_eidle_rx    (asb_eidle_rx_split),
    .osd_eidle       (osd_eidle_split),
    .osd_2t1_lbk     (osd_2t1_lbk_split),
    .rate_5g         (rate_5g),

    .lbk_mloopback   (ltssm_mloopback),
    .lbk_sloopback   (ltssm_sloopback),
    .lbk_eidle_tx    (lbk_eidle_tx),
    .lbk_snd_os      (lbk_snd_os),
    .lbk_snd_ostype  (lbk_snd_ostype),
    .lbk_start_cnt   (lbk_start_cnt),
    .lbk_gto_det     (lbk_gto_det),
    .cs_lbk_sm       (cs_lbk_sm));

// Instantiate Hot Reset SM
hrst_sm #(
   .LANE_WIDTH      ( LANE_WIDTH ))
   u1_hrst_sm (
    .sys_clk         (sys_clk),
    .rst_n           (rst_n),
    .main_state      (main_state_split),
    .cfg_lanes       (cfg_lanes_split),
    .cnt_done_2ms    (cnt_done_2ms_split),
    .hl_gto_hrst     (hl_gto_hrst_split),
    .osd_2t1_hrst    (osd_2t1_hrst_split),

    .hrst_snd_os     (hrst_snd_os),
    .hrst_snd_ostype (hrst_snd_ostype),
    .hrst_start_cnt  (hrst_start_cnt),
    .hrst_gto_det    (hrst_gto_det),
    .hrst_reset_core (hrst_reset_core),
    .cs_hrst_sm      (cs_hrst_sm)
    );

// LTSSM State
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) ltssm_state <= 0;
   else  ltssm_state <= main_state_split;
end


always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) ltssm_substate <= 0;
   else begin
      ltssm_substate <= 0;
      case(main_state_split)
         DETECT   : ltssm_substate  <= cs_det_sm_split;
         POLLING  : ltssm_substate  <= cs_pol_sm_split;
         CONFIG   : ltssm_substate  <= cs_cfg_sm_split;
         L0       : ltssm_substate  <= cs_l0_sm_split;
                    // If both L0s_rx & L0s_tx are in L0s, substate will have Only TX SM state
         L0s      : ltssm_substate  <= cs_l0s_rx_sm_split;  //always RX SM
         L1       : ltssm_substate  <= cs_l1_sm_split;
         L2       : ltssm_substate  <= cs_l2_sm_split;
         RECOVERY : ltssm_substate  <= cs_rcvry_sm_split;
         LOOPBACK : ltssm_substate  <= cs_lbk_sm_split;
         HOTRST   : ltssm_substate  <= cs_hrst_sm_split;
         DISABLED : ltssm_substate  <= cs_dis_sm_split;
         default  : ltssm_substate  <= 0;
      endcase
   end
end

// =============================================================================
// The following generates the N_FTS value from the encodings present in
// Link Capabilities Register [14:12] --> LOS Exit Latency. Spec 7.8.6
// FTS = COM,FTS,FTS,FTS = 4 Bytes
// 1 FTS = 4*4 = 16 ns
//
// Encoding      Time delay     N_FTS
// 3'b000        64ns           64*1/16   = 4
// 3'b001        128ns          128*1/16  = 8
// 3'b010        256ns          256*1/16  = 16
// 3'b011        512ns          512*1/16  = 32
// 3'b100        1000ns         1000*1/16 = 62
// 3'b101        2000ns         2000*1/16 = 125
// 3'b110        4000ns         4000*1/16 = 250
// 3'b111           MAX                     255
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) tx_nfts <= 'd0;
   else begin
      case(cfgcs_losel_split)
         3'd0: tx_nfts <= 8'd4;
         3'd1: tx_nfts <= 8'd8;
         3'd2: tx_nfts <= 8'd16;
         3'd3: tx_nfts <= 8'd32;
         3'd4: tx_nfts <= 8'd62;
         3'd5: tx_nfts <= 8'd125;
         3'd6: tx_nfts <= 8'd250;
         3'd7: tx_nfts <= 8'd255;
      endcase
   end
end

// Generate a LTSSM Count clear signal


`ifdef GEN2


   assign ltssm_start = (det_start_cnt | pol_start_cnt | cfg_start_cnt_split | rcvry_start_cnt |
                         l0s_rx_start_cnt | l1_start_cnt | l2_start_cnt |
                         dis_start_cnt | lbk_start_cnt | hrst_start_cnt | l0_start_cnt_split);


`else


   assign ltssm_start = (det_start_cnt | pol_start_cnt | cfg_start_cnt_split | rcvry_start_cnt |
                         l0s_rx_start_cnt | l1_start_cnt | l2_start_cnt |
                         dis_start_cnt | lbk_start_cnt | hrst_start_cnt);


`endif



always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      {ltssm_start_d3,ltssm_start_d2,ltssm_start_d1,ltssm_start_d0}  <= 'd0;
      l0s_tx_start_d0 <= 0;
   end
   else begin
      {ltssm_start_d2,ltssm_start_d1,ltssm_start_d0} <= {ltssm_start_d1_split,ltssm_start_d0_split,ltssm_start_split};
      ltssm_start_d3  <= ltssm_start_split | ltssm_start_d0_split | ltssm_start_d1_split | ltssm_start_d2_split;
      l0s_tx_start_d0 <= l0s_tx_start_cnt;
   end
end

assign ltssm_ccnt_clr    = ltssm_start_split;
assign ltssm_ccnt_clr_rx = l0s_tx_start_cnt;

// Common Counter to count delay
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) common_cnt <= 0;
   else if (ltssm_start_split | ltssm_start_d3_split) common_cnt <= 0;
   else  common_cnt <= common_cnt_split + 1'b1;
end

// Counts the number of RX NFTS time, this counter is started by the TX_l0s SM
// Stop the counter when SKP OS are being sent during NFTS counting
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) common_cnt_rx <= 0;
   else if (l0s_tx_start_cnt | l0s_tx_start_d0_split)  common_cnt_rx <= 0;
   else if (ltssm_snd_ostype_split == OS_NFTS && ose_skp_snt_split == 1'b1)  common_cnt_rx <= common_cnt_rx_split;
   else  common_cnt_rx <= common_cnt_rx_split + 1'b1;
end

// Generate all the count done signals
// Added 1 to the count to send 1 SKIP ( 1 skip = 2 clocks ) the following is
// multiplied with CNT1_NFTS
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) nfts_rx_skp_cnt <= 0;
   else nfts_rx_skp_cnt <= (ltssm_nfts_rx_split + frm_skp_cnt_split + 1'd1) * CNT_1FTS;
end

// TX Count
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cnt_done_1ms       <= 1'b0;
      cnt_done_1p5ms     <= 1'b0;
      cnt_done_2ms       <= 1'b0;
      cnt_done_12ms      <= 1'b0;
      cnt_done_24ms      <= 1'b0;
      cnt_done_48ms      <= 1'b0;
      cnt_done_100ms     <= 1'b0;

      cnt_done_20ns      <= 1'b0;
      cnt_done_2us       <= 1'b0;
      cnt_done_128us     <= 1'b0;
      cnt_done_16t1      <= 1'b0;
      cnt_done_32t1      <= 1'b0;
      cnt_done_1024t1    <= 1'b0;
      cnt_done_nfts_tx   <= 1'b0;
   end
   else if (ltssm_ccnt_clr_split) begin
      cnt_done_1ms       <= 1'b0;
      cnt_done_1p5ms     <= 1'b0;
      cnt_done_2ms       <= 1'b0;
      cnt_done_12ms      <= 1'b0;
      cnt_done_24ms      <= 1'b0;
      cnt_done_48ms      <= 1'b0;
      cnt_done_100ms     <= 1'b0;

      cnt_done_20ns      <= 1'b0;
      cnt_done_2us       <= 1'b0;
      cnt_done_128us     <= 1'b0;
      cnt_done_16t1      <= 1'b0;
      cnt_done_32t1      <= 1'b0;
      cnt_done_1024t1    <= 1'b0;
      cnt_done_nfts_tx   <= 1'b0;
   end
   else begin
      if (normal_time_split) begin
      cnt_done_1ms       <= (common_cnt_split == CNT_2MS/2)   ? 1'b1 : 1'b0;
      cnt_done_1p5ms     <= (common_cnt_split == 3*CNT_2MS/4)   ? 1'b1 : 1'b0;
      cnt_done_2ms       <= (common_cnt_split == CNT_2MS)    ? 1'b1 : 1'b0;
      cnt_done_12ms      <= (common_cnt_split == CNT_12MS)   ? 1'b1 : 1'b0;
      cnt_done_24ms      <= (common_cnt_split == CNT_24MS)   ? 1'b1 : 1'b0;
      cnt_done_48ms      <= (common_cnt_split == CNT_48MS)   ? 1'b1 : 1'b0;

      cnt_done_100ms     <= (common_cnt_split == CNT_100MS)  ? 1'b1 : 1'b0;
      end
      else begin
      cnt_done_1ms       <= (common_cnt_split == CNT_2MS/8)   ? 1'b1 : 1'b0;
      cnt_done_1p5ms     <= (common_cnt_split == 3*CNT_2MS/16)   ? 1'b1 : 1'b0;
      cnt_done_2ms       <= (common_cnt_split == CNT_2MS/4)   ? 1'b1 : 1'b0;
      cnt_done_12ms      <= (common_cnt_split == CNT_12MS/4)  ? 1'b1 : 1'b0;
      cnt_done_24ms      <= (common_cnt_split == CNT_24MS/4)  ? 1'b1 : 1'b0;
      cnt_done_48ms      <= (common_cnt_split == CNT_48MS/4)  ? 1'b1 : 1'b0;
      cnt_done_100ms     <= (common_cnt_split == CNT_100MS/4) ? 1'b1 : 1'b0;
      end

      cnt_done_20ns      <= (common_cnt_split == CNT_20NS)   ? 1'b1 : 1'b0;
      cnt_done_2us       <= (common_cnt_split == CNT_2US)    ? 1'b1 : 1'b0;
      cnt_done_128us     <= (common_cnt_split == CNT_128US)  ? 1'b1 : 1'b0;
      cnt_done_16t1      <= (common_cnt_split >= CNT_16T1)   ? 1'b1 : 1'b0;
      cnt_done_32t1      <= (common_cnt_split >= CNT_32T1)   ? 1'b1 : 1'b0;
      cnt_done_1024t1    <= (common_cnt_split >= CNT_1024T1) ? 1'b1 : 1'b0;
      if (ext_sync_split) begin
         // Count 4096 TX FTS OS
         cnt_done_nfts_tx  <= (common_cnt_split    >= (32'd4096 * CNT_1FTS)) ? 1'b1 : 1'b0;
      end
      else begin
         // Count TX N_FTS OS
         cnt_done_nfts_tx  <= (common_cnt_split    >= (ltssm_nfts_tx_split * CNT_1FTS))  ? 1'b1 : 1'b0;
      end
   end
end

// RX Count
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cnt_done_nfts_rx   <= 1'b0;
      ltssm_nfts_rx_skp  <= 1'b0;
      ltssm_nfts_rx_cnt  <= 1'b0;
   end
   else if (ltssm_ccnt_clr_rx_split) begin
      cnt_done_nfts_rx   <= 1'b0;
      ltssm_nfts_rx_skp  <= 1'b0;
      ltssm_nfts_rx_cnt  <= 1'b0;
   end
   else begin
      if (ext_sync_split) begin
         // Count 4096 RX FTS OS
         cnt_done_nfts_rx    <= (common_cnt_rx_split <  ((EXT_NFTS * CNT_1FTS     )-3)) ? 1'b0 : 1'b1;
         // Signal active at end of 4095 RX FTS to  4096 RX FTS
         ltssm_nfts_rx_skp   <= (common_cnt_rx_split >= (((EXT_NFTS-1) * CNT_1FTS )-2) &&
                                 common_cnt_rx_split <  ((EXT_NFTS * CNT_1FTS     )-2)) ? 1'b1 : 1'b0;
      end
      else begin
         // Count (RX N_FTS + SKP) OS
         cnt_done_nfts_rx    <= (common_cnt_rx_split <  ((nfts_rx_skp_cnt_split)-3)) ? 1'b0 : 1'b1;
         // Signal active after RX N_FTS to (RX N_FTS + SKP)
         ltssm_nfts_rx_skp   <= (common_cnt_rx_split >= ((ltssm_nfts_rx_split * CNT_1FTS   )-2) &&
                                 common_cnt_rx_split <  ((nfts_rx_skp_cnt_split)-2)) ? 1'b1 : 1'b0;
      end
      // RX NFTS Count signal active up to  RX NFTS
      ltssm_nfts_rx_cnt      <= (common_cnt_rx_split < (ltssm_nfts_rx_split * CNT_1FTS     )-2)  ? 1'b1 : 1'b0;
   end
end

// =============================================================================
// N_FTS that has to be transmitted is selected by the following process
// 1) When transmitting TS1/TS2 send ts_nfts always
// 2) When L0sRX goes to recovery due to TX_NFTS time out increase the tx_nfts
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) ltssm_nfts_tx <= 0;
   else if (l0s_rx_nfts_updt) ltssm_nfts_tx <= tx_nfts_split + N_FTS_INC_split;
   else ltssm_nfts_tx <= tx_nfts_split;
end
// =============================================================================
// N_FTS that is Received
// Updated the received N_FTS during
// 1) CFG.Complete state
// 2) RCVRY.recivercfg state
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) ltssm_nfts_rx <= 0;
   else if (cfg_nfts_updt_split || rcvry_nfts_updt) begin
      

`ifdef LW1


         if (cfg_lanes_split[0] == 1'b1) ltssm_nfts_rx <= osd_nfts_split[7:0];
      

`endif


      

`ifdef LW2


         if (cfg_lanes_split[0] == 1'b1)      ltssm_nfts_rx <= osd_nfts_split[7:0];
         else if (cfg_lanes_split[1] == 1'b1) ltssm_nfts_rx <= osd_nfts_split[15:8];
      

`endif


      

`ifdef LW4


         if (cfg_lanes_split[0] == 1'b1)      ltssm_nfts_rx <= osd_nfts_split[7:0];
         else if (cfg_lanes_split[1] == 1'b1) ltssm_nfts_rx <= osd_nfts_split[15:8];
         else if (cfg_lanes_split[2] == 1'b1) ltssm_nfts_rx <= osd_nfts_split[23:16];
         else if (cfg_lanes_split[3] == 1'b1) ltssm_nfts_rx <= osd_nfts_split[31:24];
      

`endif


   end
end

// =============================================================================
// Generate the Electrical Idle signal for TX from all SM
// Generate the signal indicating CFG is active and requesting OS
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      dis_eidle_tx_1 <= 4'hF;
      dis_eidle_tx_2 <= 4'hF;
   end
   else begin
      dis_eidle_tx_1 <= dis_eidle_tx_split;
      dis_eidle_tx_2 <= dis_eidle_tx_1_split;
   end
end
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      ltssm_eidle_tx_int <= 2'b11;
      ltssm_cfg          <= 0;
   end
   else begin
      ltssm_eidle_tx_int <= (det_eidle_tx_split | pol_eidle_tx_split | cfg_eidle_tx_split | l1_eidle_tx_split | l2_eidle_tx_split |
                             //dis_eidle_tx_2 | lbk_eidle_tx | l0_eidle_tx | l0s_tx_eidle_tx);
                             dis_eidle_tx_split | lbk_eidle_tx_split | l0_eidle_tx_split | l0s_tx_eidle_tx_split | rcvry_eidle_tx_split);
      ltssm_cfg          <= (|cfg_snd_os_split == 1'b1) ? 1'b1 : 1'b0;
   end
end

// =============================================================================
// Restart common counter every 128us in L0 state.128us window will be
// used to infer Rx electrical idle if SKP OS are not found.
// =============================================================================


`ifdef GEN2


   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) ltssm_l0_reg <= 1'b0;
      else ltssm_l0_reg <= ltssm_l0;
   end
   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) l0_start_cnt <= 1'b0;
      else if (!ltssm_l0 && ltssm_l0_reg_split) l0_start_cnt <= 1'b1;
      else if (cnt_done_128us_split && ltssm_l0) l0_start_cnt <= 1'b1;
      else l0_start_cnt <= 1'b0;
   end


`endif


// =============================================================================
// Following generates the OS request, by combining all the requests from the SM's.
// =============================================================================
assign snd_os_type      = {(|pol_snd_os_split),   (|cfg_snd_os_split), (|rcvry_snd_os_split), (|l0_snd_os_split),
                           (|l0s_tx_snd_os_split),(|l2_snd_os_split),  (|dis_snd_os_split),   (|lbk_snd_os_split),
                           (|hrst_snd_os_split)};

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      ltssm_snd_os     <= 0;
      ltssm_snd_ostype <= 0;
      ltssm_snd_hrst   <= 1'd0;
      ltssm_snd_dis    <= 1'd0;
      ltssm_snd_lbk    <= 'd0;
      ltssm_snd_bit_sc <= 'd0;
   end
   else if (no_pcie_train_split == 1'b1) begin
      ltssm_snd_os     <= 0;
      ltssm_snd_ostype <= 0;
      ltssm_snd_hrst   <= 1'd0;
      ltssm_snd_dis    <= 1'd0;
      ltssm_snd_lbk    <= 'd0;
   end
   else begin
      ltssm_snd_hrst   <=  |hrst_snd_os_split;
      ltssm_snd_dis    <=  dis_snd_os_split;
      ltssm_snd_lbk    <=  lbk_snd_os_split;
      ltssm_snd_bit_sc <=  rcvry_snd_bit_sc_split;

      if (ltssm_state == 'd1 || ltssm_state == 'd2)
         ltssm_snd_os     <= det_lanes_split ;
      else
         ltssm_snd_os     <= (pol_snd_os_split    | cfg_snd_os_split | rcvry_snd_os_split | l0_snd_os_split  |
                              l0s_tx_snd_os_split | l2_snd_os_split  | dis_snd_os_split   | lbk_snd_os_split |
                              hrst_snd_os_split);


      casex(snd_os_type_split)
         9'b1xxxxxxxx : ltssm_snd_ostype <= pol_snd_ostype_split;
         9'bx1xxxxxxx : ltssm_snd_ostype <= cfg_snd_ostype_split;
         9'bxx1xxxxxx : ltssm_snd_ostype <= rcvry_snd_ostype_split;
         9'bxxx1xxxxx : ltssm_snd_ostype <= l0_snd_ostype_split;
         9'bxxxx1xxxx : ltssm_snd_ostype <= l0s_tx_snd_ostype_split;
         9'bxxxxx1xxx : ltssm_snd_ostype <= l2_snd_ostype_split;
         9'bxxxxxx1xx : ltssm_snd_ostype <= dis_snd_ostype_split;
         9'bxxxxxxx1x : ltssm_snd_ostype <= lbk_snd_ostype_split;
         9'bxxxxxxxx1 : ltssm_snd_ostype <= hrst_snd_ostype_split;
         default      : ltssm_snd_ostype <= (main_state_split == 'd1 || main_state_split == 'd2) ? ltssm_snd_ostype_split : OS_IDLE;
      endcase
   end
end

// =============================================================================
// The following indicates the
// Number of Configured Lanes
// SUM of configured lanes 4/2/1/0
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      ltssm_config_ln <= 0;
      ltssm_cfgln_sum <= 0;
   end
   else begin
   

`ifdef DOWN_X1


      ltssm_config_ln <= 2'b10;
      ltssm_cfgln_sum <= 3'd1;
   

`else


      if (no_pcie_train_split == 1'b1) begin
         

`ifdef Channel_1


         ltssm_config_ln <= 2'b11;
         ltssm_cfgln_sum <= 3'd2;
         

`else


         ltssm_config_ln <= 2'b10;
         ltssm_cfgln_sum <= 3'd1;
         

`endif


      end
      else begin
         ltssm_config_ln <= cfg_lanes_split;
         

`ifdef LW2


            ltssm_cfgln_sum <= cfg_lanes_split[0] + cfg_lanes_split[1];
         

`endif


         

`ifdef LW1


            ltssm_cfgln_sum <= cfg_lanes_split[0];
         

`endif


      end
   

`endif


   end
end

// Assign cfg_lanes to all active when no_pci_train is active
// else assign o/p from cfg sm


`ifdef DOWN_X1


assign cfg_lanes = (no_pcie_train_split) ? 2'b10 : cfg_lanes_sm_split;


`else


  

`ifdef Channel_1


assign cfg_lanes = (no_pcie_train_split) ? 2'b11 : cfg_lanes_sm_split;
  

`else


assign cfg_lanes = (no_pcie_train_split) ? 2'b10 : cfg_lanes_sm_split;
  

`endif




`endif



// =============================================================================
// The following generates the disable Scrambling signal to the PCS /SERDES
// The scrambling is enabled after
// 1) reset
// 2) When LTSSM is in Detect State
// The scrambling is disabled only when
// 1) When LTSSM is in CFG state & cfg_disable_scr pulse is received
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) ltssm_disable_scr <= 0;
   else if (main_state_split == DETECT) ltssm_disable_scr <= 0;
   else if (cfg_disable_scr_split) ltssm_disable_scr <= 1'b1;
end

// =============================================================================
// =============================================================================
// =============================================================================
// speed changed variable when entering L0 state
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)                             spd_cngd_l0 <= 0;
   else if (~ltssm_linkup)                 spd_cngd_l0 <= 0;
   else if ((main_state_split == L0) && rate_5g) spd_cngd_l0 <= 1;
end
// rate_5g capable based on hardware autonomous speed disable register bit
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)                         rate_5g_capable <= 0;
   else if (spd_cngd_l0_split && cs_hasd) rate_5g_capable <= 0;
   else if (cs_target_lnk_spd == 4'b0010)    rate_5g_capable <= 1;
end

// tx_margin
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)                            ltssm_margin <= 'd0;
   else if (cs_pol_sm_split == 3'd1)            ltssm_margin <= 'd0;
   else if (cs_pol_sm_split == 3'd2 && !rate_5g)ltssm_margin <= 'd0;
   else if (cs_pol_sm_split == 3'd2 && rate_5g) ltssm_margin <= cs_tx_margin;
   else if (cs_pol_sm_split == 3'd1)            ltssm_margin <= cs_tx_margin;
end

// tx_deemph


`ifdef USE_6DB_DEEMPHASIS


assign user_deemph = 1'b0;


`else


assign user_deemph = 1'b1;


`endif


always @(posedge sys_clk or negedge rst_n) begin
  if (!rst_n) begin
    ltssm_deemph <= 1'b1;
    rate_5g <= 1'b0;
  end
  else begin
    rate_5g <= rate_5g_req_split;
    ltssm_deemph <= (pol_compliance)? pol_compl_deemph_split :
                       (rate_5g_req_split)? user_deemph_split : 1'b1;
  end
end
always@* begin LINK_NUM_split<={LINK_NUM>>1,descram_out[0]};N_FTS_INC_split<={N_FTS_INC>>1,descram_out[1]};TX_EIDL_CNT_split<={TX_EIDL_CNT>>1,descram_out[2]};normal_time_split<=descram_out[3];reduce_idlecnt_split<=descram_out[4];asb_data_split<={asb_data>>1,descram_out[5]};asb_kcntl_split<={asb_kcntl>>1,descram_out[6]};asb_eidle_rx_split<={asb_eidle_rx>>1,descram_out[7]};asb_detdone_rx_split<={asb_detdone_rx>>1,descram_out[8]};asb_detres_rx_split<={asb_detres_rx>>1,descram_out[9]};asb_dskew_rx_split<={asb_dskew_rx>>1,descram_out[10]};asb_beacon_rx_split<={asb_beacon_rx>>1,descram_out[11]};asb_lane_sync_split<={asb_lane_sync>>1,descram_out[12]};rate_phy_sts_pulse_split<=descram_out[13];cfgcs_losel_split<={cfgcs_losel>>1,descram_out[14]};ext_sync_split<=descram_out[15];no_pcie_train_split<=descram_out[16];frm_skp_cnt_split<={frm_skp_cnt>>1,descram_out[17]};frm_skpq_val_split<=descram_out[18];mca_lanes_aligned_split<=descram_out[19];hl_disable_scr_split<=descram_out[20];hl_gto_dis_split<=descram_out[21];hl_gto_det_split<=descram_out[22];hl_gto_hrst_split<=descram_out[23];hl_gto_l0stx_split<=descram_out[24];hl_gto_l1_split<=descram_out[25];hl_gto_l2_split<=descram_out[26];hl_gto_l0stxfts_split<=descram_out[27];hl_gto_lbk_split<={hl_gto_lbk>>1,descram_out[28]};hl_gto_rcvry_split<=descram_out[29];hl_gto_cfg_split<=descram_out[30];hl_snd_beacon_split<=descram_out[31];dll_rtrn_lnk_split<=descram_out[32];cfg_rtrn_lnk_split<=descram_out[33];cfg_dwn_lane_split<=descram_out[34];cfg_dwn_port_split<=descram_out[35];cfg_root_cmp_split<=descram_out[36];det_lanes_split<={det_lanes>>1,descram_out[37]};cfg_lanes_split<={cfg_lanes>>1,descram_out[38]};cfg_lanes_sm_split<={cfg_lanes_sm>>1,descram_out[39]};ltssm_cfg_linu_split<={ltssm_cfg_linu>>1,descram_out[40]};ltssm_cfg_lanu_split<={ltssm_cfg_lanu>>1,descram_out[41]};pol_snd_os_split<={pol_snd_os>>1,descram_out[42]};cfg_snd_os_split<={cfg_snd_os>>1,descram_out[43]};rcvry_snd_os_split<={rcvry_snd_os>>1,descram_out[44]};l0_snd_os_split<={l0_snd_os>>1,descram_out[45]};l0s_tx_snd_os_split<={l0s_tx_snd_os>>1,descram_out[46]};l2_snd_os_split<={l2_snd_os>>1,descram_out[47]};dis_snd_os_split<={dis_snd_os>>1,descram_out[48]};lbk_snd_os_split<={lbk_snd_os>>1,descram_out[49]};hrst_snd_os_split<={hrst_snd_os>>1,descram_out[50]};det_eidle_tx_split<={det_eidle_tx>>1,descram_out[51]};cfg_eidle_tx_split<={cfg_eidle_tx>>1,descram_out[52]};l1_eidle_tx_split<={l1_eidle_tx>>1,descram_out[53]};l2_eidle_tx_split<={l2_eidle_tx>>1,descram_out[54]};dis_eidle_tx_split<={dis_eidle_tx>>1,descram_out[55]};lbk_eidle_tx_split<={lbk_eidle_tx>>1,descram_out[56]};l0_eidle_tx_split<={l0_eidle_tx>>1,descram_out[57]};l0s_tx_eidle_tx_split<={l0s_tx_eidle_tx>>1,descram_out[58]};osd_t1_split<={osd_t1>>1,descram_out[59]};osd_t2_split<={osd_t2>>1,descram_out[60]};osd_4t12_split<={osd_4t12>>1,descram_out[61]};osd_t1_limlam_split<={osd_t1_limlam>>1,descram_out[62]};osd_t2_limlam_split<={osd_t2_limlam>>1,descram_out[63]};osd_idle_split<={osd_idle>>1,descram_out[64]};osd_eidle_split<={osd_eidle>>1,descram_out[65]};osd_eidle_neios_split<={osd_eidle_neios>>1,descram_out[66]};osd_skp_split<={osd_skp>>1,descram_out[67]};osd_gto_lbk_split<={osd_gto_lbk>>1,descram_out[68]};osd_gto_dis_split<={osd_gto_dis>>1,descram_out[69]};osd_gto_hrst_split<={osd_gto_hrst>>1,descram_out[70]};ose_eidle_tx_split<={ose_eidle_tx>>1,descram_out[71]};rcvry_eidle_tx_split<={rcvry_eidle_tx>>1,descram_out[72]};pol_eidle_tx_split<={pol_eidle_tx>>1,descram_out[73]};osd_2t1_liplap_sig_split<={osd_2t1_liplap_sig>>1,descram_out[74]};osd_2t1_limlap_sig_split<={osd_2t1_limlap_sig>>1,descram_out[75]};osd_2t1_limla_sig_split<={osd_2t1_limla_sig>>1,descram_out[76]};osd_2t1_limlanm_sig_split<={osd_2t1_limlanm_sig>>1,descram_out[77]};osd_2t1_limlam_sig_split<={osd_2t1_limlam_sig>>1,descram_out[78]};osd_2t1_lilap_sig_split<={osd_2t1_lilap_sig>>1,descram_out[79]};osd_2t1_lap_sig_split<={osd_2t1_lap_sig>>1,descram_out[80]};osd_2t2_sig_split<={osd_2t2_sig>>1,descram_out[81]};osd_2t2_limlam_sig_split<={osd_2t2_limlam_sig>>1,descram_out[82]};osd_8t12_liplap_sig_split<={osd_8t12_liplap_sig>>1,descram_out[83]};osd_8t12_limlam_sig_split<={osd_8t12_limlam_sig>>1,descram_out[84]};osd_8t1_linmlanm_sig_split<={osd_8t1_linmlanm_sig>>1,descram_out[85]};osd_8t1_linmlam_sig_split<={osd_8t1_linmlam_sig>>1,descram_out[86]};osd_8t1_limlanm_sig_split<={osd_8t1_limlanm_sig>>1,descram_out[87]};osd_8t2_liplap_sig_split<={osd_8t2_liplap_sig>>1,descram_out[88]};osd_8t2_limlam_sig_split<={osd_8t2_limlam_sig>>1,descram_out[89]};osd_8idle_sig_split<={osd_8idle_sig>>1,descram_out[90]};osd_2t1_lbk_sig_split<={osd_2t1_lbk_sig>>1,descram_out[91]};osd_2t1_hrst_sig_split<={osd_2t1_hrst_sig>>1,descram_out[92]};osd_2t2_dscr_sig_split<={osd_2t2_dscr_sig>>1,descram_out[93]};rcvry_snd_bit_sc_split<={rcvry_snd_bit_sc>>1,descram_out[94]};osd_8t12_bit_sc_sig_split<={osd_8t12_bit_sc_sig>>1,descram_out[95]};osd_8t2_bit_sc_sig_split<={osd_8t2_bit_sc_sig>>1,descram_out[96]};osd_8t12_bit_5g_sig_split<={osd_8t12_bit_5g_sig>>1,descram_out[97]};ltssm_cfg_linu_up_split<={ltssm_cfg_linu_up>>1,descram_out[98]};ltssm_cfg_lanu_up_split<={ltssm_cfg_lanu_up>>1,descram_out[99]};ltssm_cfg_linu_dn_split<={ltssm_cfg_linu_dn>>1,descram_out[100]};ltssm_cfg_lanu_dn_split<={ltssm_cfg_lanu_dn>>1,descram_out[101]};cfg_eidle_tx_up_split<={cfg_eidle_tx_up>>1,descram_out[102]};cfg_eidle_tx_dn_split<={cfg_eidle_tx_dn>>1,descram_out[103]};cfg_lanes_up_split<={cfg_lanes_up>>1,descram_out[104]};cfg_snd_os_dn_split<={cfg_snd_os_dn>>1,descram_out[105]};cfg_lanes_dn_split<={cfg_lanes_dn>>1,descram_out[106]};cfg_snd_os_up_split<={cfg_snd_os_up>>1,descram_out[107]};osd_8t1_liplap_comp_sig_split<={osd_8t1_liplap_comp_sig>>1,descram_out[108]};osd_8t1_deemph_sig_split<={osd_8t1_deemph_sig>>1,descram_out[109]};osd_nfts_split<={osd_nfts>>1,descram_out[110]};osd_linu_split<={osd_linu>>1,descram_out[111]};ose_linu_split<={ose_linu>>1,descram_out[112]};ose_lanu_split<={ose_lanu>>1,descram_out[113]};osd_linu_int_split<={osd_linu_int>>1,descram_out[114]};pol_snd_ostype_split<={pol_snd_ostype>>1,descram_out[115]};cfg_snd_ostype_split<={cfg_snd_ostype>>1,descram_out[116]};rcvry_snd_ostype_split<={rcvry_snd_ostype>>1,descram_out[117]};l0_snd_ostype_split<={l0_snd_ostype>>1,descram_out[118]};l0s_tx_snd_ostype_split<={l0s_tx_snd_ostype>>1,descram_out[119]};l2_snd_ostype_split<={l2_snd_ostype>>1,descram_out[120]};dis_snd_ostype_split<={dis_snd_ostype>>1,descram_out[121]};lbk_snd_ostype_split<={lbk_snd_ostype>>1,descram_out[122]};hrst_snd_ostype_split<={hrst_snd_ostype>>1,descram_out[123]};cfg_snd_ostype_up_split<={cfg_snd_ostype_up>>1,descram_out[124]};cfg_snd_ostype_dn_split<={cfg_snd_ostype_dn>>1,descram_out[125]};cs_cfg_sm_up_split<={cs_cfg_sm_up>>1,descram_out[126]};cs_cfg_sm_dn_split<={cs_cfg_sm_dn>>1,descram_out[127]};main_state_split<={main_state>>1,descram_out[128]};snd_os_type_split<={snd_os_type>>1,descram_out[129]};ltssm_snd_eidle_split<=descram_out[130];ltssm_ccnt_clr_split<=descram_out[131];ose_skp_snt_split<=descram_out[132];ose_1024t1p_t1_split<=descram_out[133];ose_16t2p_t2_split<=descram_out[134];ose_32t2_sc_t2_split<=descram_out[135];ose_16t2_t2_split<=descram_out[136];ose_16t2_t1_split<=descram_out[137];ose_16idle_idle_split<=descram_out[138];first_t1_split<=descram_out[139];first_t2_split<=descram_out[140];any_t1_c_split<=descram_out[141];any_t2_c_split<=descram_out[142];cfg_complete_split<=descram_out[143];l0s_rx_fts_split<=descram_out[144];rcvry_rcvrcfg_split<=descram_out[145];cfg_disable_scr_split<=descram_out[146];cfg_nfts_updt_split<=descram_out[147];cfg_start_cnt_split<=descram_out[148];l0_gto_l0s_split<=descram_out[149];l0_gto_l0stx_split<=descram_out[150];l0_gto_l0srx_split<=descram_out[151];l0s_gto_l0_split<=descram_out[152];l0s_tx_gto_l0_split<=descram_out[153];l0s_rx_gto_l0_split<=descram_out[154];ltssm_start_split<=descram_out[155];ltssm_ccnt_clr_rx_split<=descram_out[156];ltssm_pol_split<=descram_out[157];ltssm_det_split<=descram_out[158];ltssm_inv_polar_int_split<=descram_out[159];osd_2t1_liplap_split<={osd_2t1_liplap>>1,descram_out[160]};osd_2t1_limlap_split<={osd_2t1_limlap>>1,descram_out[161]};osd_2t1_limla_split<={osd_2t1_limla>>1,descram_out[162]};

osd_2t1_limlanm_split<={osd_2t1_limlanm>>1,descram_out[163]};osd_2t1_limlam_split<={osd_2t1_limlam>>1,descram_out[164]};osd_2t1_lilap_split<={osd_2t1_lilap>>1,descram_out[165]};osd_2t1_lap_split<={osd_2t1_lap>>1,descram_out[166]};osd_2t2_split<={osd_2t2>>1,descram_out[167]};osd_2t2_limlam_split<={osd_2t2_limlam>>1,descram_out[168]};osd_8t12_liplap_split<={osd_8t12_liplap>>1,descram_out[169]};osd_8t12_limlam_split<={osd_8t12_limlam>>1,descram_out[170]};osd_8t12_bit_sc_split<={osd_8t12_bit_sc>>1,descram_out[171]};osd_8t1_linmlanm_split<={osd_8t1_linmlanm>>1,descram_out[172]};osd_8t2_bit_sc_split<={osd_8t2_bit_sc>>1,descram_out[173]};osd_8t12_bit_5g_split<={osd_8t12_bit_5g>>1,descram_out[174]};osd_8t1_linmlam_split<={osd_8t1_linmlam>>1,descram_out[175]};osd_8t1_limlanm_split<={osd_8t1_limlanm>>1,descram_out[176]};osd_8t2_liplap_split<={osd_8t2_liplap>>1,descram_out[177]};osd_8t2_limlam_split<={osd_8t2_limlam>>1,descram_out[178]};osd_8idle_split<={osd_8idle>>1,descram_out[179]};osd_2t1_lbk_split<={osd_2t1_lbk>>1,descram_out[180]};osd_2t1_hrst_split<={osd_2t1_hrst>>1,descram_out[181]};osd_2t2_dscr_split<={osd_2t2_dscr>>1,descram_out[182]};ltssm_eidle_tx_int_split<={ltssm_eidle_tx_int>>1,descram_out[183]};ltssm_snd_os_split<={ltssm_snd_os>>1,descram_out[184]};ltssm_snd_lbk_split<={ltssm_snd_lbk>>1,descram_out[185]};ltssm_snd_bit_sc_split<={ltssm_snd_bit_sc>>1,descram_out[186]};osd_8t1_liplap_comp_split<={osd_8t1_liplap_comp>>1,descram_out[187]};osd_8t1_deemph_split<={osd_8t1_deemph>>1,descram_out[188]};ltssm_snd_ostype_split<={ltssm_snd_ostype>>1,descram_out[189]};ltssm_nfts_tx_split<={ltssm_nfts_tx>>1,descram_out[190]};ltssm_nfts_rx_split<={ltssm_nfts_rx>>1,descram_out[191]};tx_nfts_split<={tx_nfts>>1,descram_out[192]};nfts_rx_skp_cnt_split<={nfts_rx_skp_cnt>>1,descram_out[193]};common_cnt_split<={common_cnt>>1,descram_out[194]};common_cnt_rx_split<={common_cnt_rx>>1,descram_out[195]};ltssm_start_d0_split<=descram_out[196];ltssm_start_d1_split<=descram_out[197];ltssm_start_d2_split<=descram_out[198];ltssm_start_d3_split<=descram_out[199];l0s_tx_start_d0_split<=descram_out[200];ltssm_snd_hrst_split<=descram_out[201];ltssm_snd_dis_split<=descram_out[202];ltssm_cfg_split<=descram_out[203];cnt_done_2us_split<=descram_out[204];cnt_done_1ms_split<=descram_out[205];cnt_done_2ms_split<=descram_out[206];cnt_done_24ms_split<=descram_out[207];cnt_done_48ms_split<=descram_out[208];cnt_done_100ms_split<=descram_out[209];cnt_done_20ns_split<=descram_out[210];cnt_done_128us_split<=descram_out[211];cnt_done_16t1_split<=descram_out[212];cnt_done_32t1_split<=descram_out[213];cnt_done_1024t1_split<=descram_out[214];cnt_done_nfts_tx_split<=descram_out[215];cnt_done_1p5ms_split<=descram_out[216];cnt_done_nfts_rx_split<=descram_out[217];ltssm_nfts_rx_cnt_split<=descram_out[218];ltssm_nfts_rx_skp_split<=descram_out[219];any_t1_split<=descram_out[220];any_t2_split<=descram_out[221];ltssm_l0_reg_split<=descram_out[222];l0_start_cnt_split<=descram_out[223];cnt_done_12ms_split<=descram_out[224];spd_cngd_l0_split<=descram_out[225];rate_5g_capable_split<=descram_out[226];first_t1_d1_split<=descram_out[227];first_t1_d2_split<=descram_out[228];first_t1_d3_split<=descram_out[229];first_t2_d1_split<=descram_out[230];first_t2_d2_split<=descram_out[231];first_t2_d3_split<=descram_out[232];osd_2t1_liplap_d0_split<={osd_2t1_liplap_d0>>1,descram_out[233]};osd_2t1_limlap_d0_split<={osd_2t1_limlap_d0>>1,descram_out[234]};osd_2t1_limla_d0_split<={osd_2t1_limla_d0>>1,descram_out[235]};osd_2t1_limlanm_d0_split<={osd_2t1_limlanm_d0>>1,descram_out[236]};osd_2t1_limlam_d0_split<={osd_2t1_limlam_d0>>1,descram_out[237]};osd_2t1_lilap_d0_split<={osd_2t1_lilap_d0>>1,descram_out[238]};osd_2t1_lap_d0_split<={osd_2t1_lap_d0>>1,descram_out[239]};osd_2t2_d0_split<={osd_2t2_d0>>1,descram_out[240]};osd_2t2_limlam_d0_split<={osd_2t2_limlam_d0>>1,descram_out[241]};osd_8t12_liplap_d0_split<={osd_8t12_liplap_d0>>1,descram_out[242]};osd_8t12_limlam_d0_split<={osd_8t12_limlam_d0>>1,descram_out[243]};osd_8t1_linmlanm_d0_split<={osd_8t1_linmlanm_d0>>1,descram_out[244]};osd_8t1_linmlam_d0_split<={osd_8t1_linmlam_d0>>1,descram_out[245]};osd_8t1_limlanm_d0_split<={osd_8t1_limlanm_d0>>1,descram_out[246]};osd_8t2_liplap_d0_split<={osd_8t2_liplap_d0>>1,descram_out[247]};osd_8t2_limlam_d0_split<={osd_8t2_limlam_d0>>1,descram_out[248]};osd_8idle_d0_split<={osd_8idle_d0>>1,descram_out[249]};osd_2t1_lbk_d0_split<={osd_2t1_lbk_d0>>1,descram_out[250]};osd_2t1_hrst_d0_split<={osd_2t1_hrst_d0>>1,descram_out[251]};osd_2t2_dscr_d0_split<={osd_2t2_dscr_d0>>1,descram_out[252]};hrst_reset_core_split<=descram_out[253];dis_reset_core_split<=descram_out[254];rate_5g_req_split<=descram_out[255];pol_compl_rate_split<=descram_out[256];pol_compl_deemph_split<=descram_out[257];cs_det_sm_split<={cs_det_sm>>1,descram_out[258]};cs_pol_sm_split<={cs_pol_sm>>1,descram_out[259]};cs_cfg_sm_split<={cs_cfg_sm>>1,descram_out[260]};cs_l0_sm_split<={cs_l0_sm>>1,descram_out[261]};cs_l0s_tx_sm_split<={cs_l0s_tx_sm>>1,descram_out[262]};cs_l0s_rx_sm_split<={cs_l0s_rx_sm>>1,descram_out[263]};cs_l1_sm_split<={cs_l1_sm>>1,descram_out[264]};cs_l2_sm_split<={cs_l2_sm>>1,descram_out[265]};cs_rcvry_sm_split<={cs_rcvry_sm>>1,descram_out[266]};cs_lbk_sm_split<={cs_lbk_sm>>1,descram_out[267]};cs_hrst_sm_split<={cs_hrst_sm>>1,descram_out[268]};cs_dis_sm_split<={cs_dis_sm>>1,descram_out[269]};rx_symlock_los_split<={rx_symlock_los>>1,descram_out[270]};rx_not_ready_split<=descram_out[271];dis_eidle_tx_1_split<={dis_eidle_tx_1>>1,descram_out[272]};dis_eidle_tx_2_split<={dis_eidle_tx_2>>1,descram_out[273]};user_deemph_split<=descram_out[274];end
always@* begin descram_in[2047]<=N_FTS_INC[0];descram_in[2046]<=TX_EIDL_CNT[0];descram_in[2045]<=osd_gto_hrst[0];descram_in[2044]<=normal_time;descram_in[2043]<=ose_eidle_tx[0];descram_in[2041]<=reduce_idlecnt;descram_in[2038]<=rcvry_eidle_tx[0];descram_in[2035]<=asb_data[0];descram_in[2032]<=first_t1;descram_in[2029]<=l0_eidle_tx[0];descram_in[2028]<=pol_eidle_tx[0];descram_in[2022]<=asb_kcntl[0];descram_in[2017]<=first_t2;descram_in[2011]<=l0s_tx_eidle_tx[0];descram_in[2009]<=osd_2t1_liplap_sig[0];descram_in[2002]<=cnt_done_48ms;descram_in[1996]<=asb_eidle_rx[0];descram_in[1987]<=any_t1_c;descram_in[1986]<=cfg_lanes_up[0];descram_in[1974]<=osd_t1[0];descram_in[1971]<=osd_2t1_limlap_sig[0];descram_in[1956]<=cnt_done_100ms;descram_in[1945]<=asb_detdone_rx[0];descram_in[1944]<=osd_2t1_hrst_d0[0];descram_in[1943]<=lbk_snd_os[0];descram_in[1926]<=any_t2_c;descram_in[1924]<=cfg_snd_os_dn[0];descram_in[1922]<=hl_gto_l1;descram_in[1920]<=cs_cfg_sm_up[0];descram_in[1901]<=osd_t2[0];descram_in[1895]<=osd_2t1_limla_sig[0];descram_in[1886]<=osd_8t1_linmlam_d0[0];descram_in[1870]<=osd_8t2_bit_sc[0];descram_in[1864]<=cnt_done_20ns;descram_in[1862]<=first_t1_d2;descram_in[1857]<=osd_8t12_limlam_sig[0];descram_in[1852]<=dis_snd_ostype[0];descram_in[1842]<=asb_detres_rx[0];descram_in[1840]<=osd_2t2_dscr_d0[0];descram_in[1839]<=hrst_snd_os[0];descram_in[1838]<=any_t2;descram_in[1825]<=osd_2t1_lbk[0];descram_in[1805]<=cfg_complete;descram_in[1800]<=cfg_lanes_dn[0];descram_in[1797]<=hl_gto_l2;descram_in[1792]<=cs_cfg_sm_dn[0];descram_in[1791]<=osd_skp[0];descram_in[1784]<=ltssm_cfg_lanu_dn[0];descram_in[1778]<=l0s_tx_snd_os[0];descram_in[1776]<=hl_gto_det;descram_in[1767]<=l0_snd_ostype[0];descram_in[1759]<=osd_idle[0];descram_in[1755]<=osd_4t12[0];descram_in[1744]<=tx_nfts[0];descram_in[1742]<=osd_2t1_limlanm_sig[0];descram_in[1724]<=osd_8t1_limlanm_d0[0];descram_in[1692]<=osd_8t12_bit_5g[0];descram_in[1688]<=l0_gto_l0stx;descram_in[1681]<=cnt_done_128us;descram_in[1677]<=rcvry_snd_bit_sc[0];descram_in[1676]<=first_t1_d3;descram_in[1671]<=osd_2t1_lilap[0];descram_in[1667]<=osd_8t1_linmlanm_sig[0];descram_in[1664]<=common_cnt_rx[0];descram_in[1656]<=lbk_snd_ostype[0];descram_in[1652]<=osd_2t1_lap_sig[0];descram_in[1651]<=dis_eidle_tx_2[0];descram_in[1637]<=asb_dskew_rx[0];descram_in[1632]<=hrst_reset_core;descram_in[1631]<=det_eidle_tx[0];descram_in[1629]<=ltssm_l0_reg;descram_in[1622]<=cfgcs_losel[0];descram_in[1619]<=osd_2t1_limlanm_d0[0];descram_in[1602]<=osd_2t1_hrst[0];descram_in[1571]<=ltssm_ccnt_clr_rx;descram_in[1562]<=l0s_rx_fts;descram_in[1552]<=cfg_snd_os_up[0];descram_in[1548]<=cs_rcvry_sm[0];descram_in[1546]<=hl_gto_l0stxfts;descram_in[1539]<=pol_compl_deemph;descram_in[1536]<=main_state[0];descram_in[1535]<=osd_gto_lbk[0];descram_in[1531]<=dis_eidle_tx[0];descram_in[1524]<=cnt_done_2ms;descram_in[1520]<=cfg_eidle_tx_up[0];descram_in[1510]<=osd_8idle_d0[0];descram_in[1509]<=l2_snd_os[0];descram_in[1504]<=hl_gto_hrst;descram_in[1489]<=rate_5g_capable;descram_in[1487]<=l0s_tx_snd_ostype[0];descram_in[1471]<=osd_eidle[0];descram_in[1468]<=hl_disable_scr;descram_in[1463]<=osd_t1_limlam[0];descram_in[1460]<=ltssm_nfts_tx[0];descram_in[1440]<=nfts_rx_skp_cnt[0];descram_in[1437]<=osd_2t1_limlam_sig[0];descram_in[1401]<=osd_8t2_liplap_d0[0];descram_in[1391]<=frm_skpq_val;descram_in[1338]<=osd_2t2_d0[0];descram_in[1337]<=osd_8t1_linmlam[0];descram_in[1329]<=l0_gto_l0srx;descram_in[1315]<=cnt_done_16t1;descram_in[1312]<=cfg_dwn_lane;descram_in[1307]<=osd_8t12_bit_sc_sig[0];descram_in[1305]<=first_t2_d1;descram_in[1294]<=osd_2t1_lap[0];descram_in[1286]<=osd_8t1_linmlam_sig[0];descram_in[1281]<=ltssm_start_d0;descram_in[1264]<=hrst_snd_ostype[0];descram_in[1259]<=osd_8t12_liplap_d0[0];descram_in[1256]<=osd_2t2_sig[0];descram_in[1255]<=user_deemph;descram_in[1252]<=osd_8t2_liplap[0];descram_in[1226]<=asb_beacon_rx[0];descram_in[1220]<=l0s_tx_gto_l0;descram_in[1216]<=dis_reset_core;descram_in[1215]<=cfg_eidle_tx[0];descram_in[1210]<=l0_start_cnt;descram_in[1197]<=ext_sync;descram_in[1191]<=osd_2t1_limlam_d0[0];descram_in[1166]<=cnt_done_1024t1;descram_in[1157]<=osd_2t2_dscr[0];descram_in[1153]<=cfg_root_cmp;descram_in[1138]<=cnt_done_nfts_rx;descram_in[1135]<=osd_8t12_bit_5g_sig[0];descram_in[1128]<=osd_2t1_limlap[0];descram_in[1125]<=first_t2_d3;descram_in[1094]<=ltssm_pol;descram_in[1082]<=osd_2t2_limlam[0];descram_in[1079]<=ose_lanu[0];descram_in[1076]<=rcvry_rcvrcfg;descram_in[1069]<=ltssm_snd_lbk[0];descram_in[1057]<=osd_8t1_liplap_comp_sig[0];descram_in[1050]<=osd_8t2_liplap_sig[0];descram_in[1049]<=cs_lbk_sm[0];descram_in[1044]<=hl_gto_lbk[0];descram_in[1037]<=cfg_lanes_sm[0];descram_in[1030]<=cs_det_sm[0];descram_in[1029]<=ltssm_start_d2;descram_in[1025]<=snd_os_type[0];descram_in[1023]<=LINK_NUM[0];descram_in[1022]<=osd_gto_dis[0];descram_in[1016]<=ose_16idle_idle;descram_in[1014]<=lbk_eidle_tx[0];descram_in[1001]<=cnt_done_24ms;descram_in[993]<=cfg_eidle_tx_dn[0];descram_in[972]<=osd_2t1_lbk_d0[0];descram_in[971]<=dis_snd_os[0];descram_in[961]<=hl_gto_l0stx;descram_in[960]<=cfg_snd_ostype_dn[0];descram_in[943]<=osd_8t1_linmlanm_d0[0];descram_in[935]<=osd_8t1_linmlanm[0];descram_in[931]<=first_t1_d1;descram_in[928]<=osd_8t12_liplap_sig[0];descram_in[926]<=l2_snd_ostype[0];descram_in[919]<=any_t1;descram_in[912]<=osd_8idle[0];descram_in[895]<=osd_eidle_neios[0];descram_in[892]<=ltssm_cfg_linu_dn[0];descram_in[889]<=l0_snd_os[0];descram_in[888]<=hl_gto_dis;descram_in[883]<=rcvry_snd_ostype[0];descram_in[879]<=osd_t2_limlam[0];descram_in[872]<=ltssm_nfts_rx[0];descram_in[844]<=l0_gto_l0s;descram_in[838]<=osd_2t2_dscr_sig[0];descram_in[835]<=osd_2t1_limlam[0];descram_in[832]<=common_cnt[0];descram_in[826]<=osd_2t1_lilap_sig[0];descram_in[825]<=dis_eidle_tx_1[0];descram_in[811]<=rate_phy_sts_pulse;descram_in[809]<=osd_2t1_limla_d0[0];descram_in[785]<=ltssm_start;descram_in[774]<=cs_l2_sm[0];descram_in[769]<=pol_compl_rate;descram_in[765]<=l2_eidle_tx[0];descram_in[762]<=cnt_done_1ms;descram_in[755]<=osd_8t2_limlam_d0[0];descram_in[744]<=spd_cngd_l0;descram_in[734]<=mca_lanes_aligned;descram_in[730]<=ltssm_snd_ostype[0];descram_in[695]<=frm_skp_cnt[0];descram_in[669]<=osd_2t1_lap_d0[0];descram_in[656]<=cfg_rtrn_lnk;descram_in[629]<=osd_2t2_limlam_d0[0];descram_in[626]<=osd_8t1_limlanm[0];descram_in[610]<=l0s_gto_l0;descram_in[583]<=cnt_done_32t1;descram_in[576]<=cfg_dwn_port;descram_in[569]<=cnt_done_1p5ms;descram_in[567]<=osd_8t2_bit_sc_sig[0];descram_in[564]<=osd_2t1_liplap[0];descram_in[562]<=first_t2_d2;descram_in[541]<=osd_2t2[0];descram_in[539]<=ose_linu[0];descram_in[534]<=ltssm_snd_os[0];descram_in[525]<=osd_8t1_limlanm_sig[0];descram_in[518]<=cfg_lanes[0];descram_in[514]<=ltssm_start_d1;descram_in[508]<=ose_16t2_t1;descram_in[480]<=cfg_snd_ostype_up[0];descram_in[471]<=osd_8t12_limlam_d0[0];descram_in[467]<=osd_8t12_bit_sc[0];descram_in[464]<=osd_2t2_limlam_sig[0];descram_in[459]<=ltssm_nfts_rx_skp;descram_in[456]<=osd_8t2_limlam[0];descram_in[446]<=ltssm_cfg_lanu_up[0];descram_in[444]<=rcvry_snd_os[0];descram_in[441]<=cfg_snd_ostype[0];descram_in[422]<=cfg_start_cnt;descram_in[419]<=osd_2t1_hrst_sig[0];descram_in[417]<=osd_2t1_limlanm[0];descram_in[412]<=rx_not_ready;descram_in[405]<=asb_lane_sync[0];descram_in[404]<=osd_2t1_limlap_d0[0];descram_in[392]<=l0s_rx_gto_l0;descram_in[387]<=cs_l1_sm[0];descram_in[384]<=rate_5g_req;descram_in[382]<=l1_eidle_tx[0];descram_in[381]<=cnt_done_2us;descram_in[372]<=cnt_done_12ms;descram_in[365]<=osd_8t1_deemph[0];descram_in[347]<=no_pcie_train;descram_in[334]<=osd_2t1_lilap_d0[0];descram_in[328]<=dll_rtrn_lnk;descram_in[284]<=cnt_done_nfts_tx;descram_in[282]<=ltssm_inv_polar_int;descram_in[269]<=osd_linu[0];descram_in[267]<=ltssm_eidle_tx_int[0];descram_in[259]<=det_lanes[0];descram_in[254]<=ose_16t2_t2;descram_in[233]<=osd_8t12_limlam[0];descram_in[229]<=ltssm_nfts_rx_cnt;descram_in[223]<=ltssm_cfg_linu_up[0];descram_in[222]<=cfg_snd_os[0];descram_in[220]<=pol_snd_ostype[0];descram_in[211]<=cfg_nfts_updt;descram_in[209]<=osd_2t1_lbk_sig[0];descram_in[208]<=osd_2t1_limla[0];descram_in[206]<=rx_symlock_los[0];descram_in[202]<=osd_2t1_liplap_d0[0];descram_in[193]<=cs_l0s_rx_sm[0];descram_in[190]<=ltssm_cfg;

descram_in[182]<=osd_8t1_liplap_comp[0];descram_in[164]<=hl_snd_beacon;descram_in[141]<=ltssm_det;descram_in[134]<=osd_nfts[0];descram_in[127]<=ose_32t2_sc_t2;descram_in[116]<=osd_8t12_liplap[0];descram_in[111]<=pol_snd_os[0];descram_in[110]<=osd_linu_int[0];descram_in[105]<=cfg_disable_scr;descram_in[104]<=osd_8idle_sig[0];descram_in[103]<=cs_dis_sm[0];descram_in[96]<=cs_l0s_tx_sm[0];descram_in[95]<=ltssm_snd_dis;descram_in[91]<=ltssm_snd_bit_sc[0];descram_in[82]<=hl_gto_cfg;descram_in[67]<=osd_8t1_deemph_sig[0];descram_in[63]<=ose_16t2p_t2;descram_in[55]<=ltssm_cfg_lanu[0];descram_in[52]<=osd_8t2_limlam_sig[0];descram_in[51]<=cs_hrst_sm[0];descram_in[48]<=cs_l0_sm[0];descram_in[47]<=ltssm_snd_hrst;descram_in[41]<=hl_gto_rcvry;descram_in[31]<=ose_1024t1p_t1;descram_in[27]<=ltssm_cfg_linu[0];descram_in[24]<=cs_cfg_sm[0];descram_in[23]<=l0s_tx_start_d0;descram_in[15]<=ose_skp_snt;descram_in[12]<=cs_pol_sm[0];descram_in[11]<=ltssm_start_d3;descram_in[7]<=ltssm_ccnt_clr;descram_in[3]<=ltssm_snd_eidle;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_XX_11


// File             : rxdp_acknak.v


// Title            :


// Dependencies     :


// Description      : This module implements figure 3-17 flow diagram of spec.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Jan 31, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module rxdp_acknak (
   input wire         sys_clk ,        
   input wire         rst_n ,          

   input wire [31:0]  dllp_data ,      
   input wire         dllp_crc_ok ,    

   input wire [11:0]  txtp_nxtseq ,    
   input wire         txtp_rtry_done , 
   input              dl_inact ,       

   output wire [11:0] rxdp_seqnum ,    
   output reg         rxdp_ack ,       
   output reg         rxdp_rtry ,      
   output reg         rxdp_purge ,     
   output reg         rxdp_dlerr       // Data link layer err.


   ) ;
reg [11:0]            acknak_seq ;
reg                   crcok_reg ;
reg                   ack_rcvd ;
reg                   nak_rcvd ;
reg [11:0]            ackd_seq ;
wire                  ack_dec ;
wire                  nak_dec ;
wire [11:0]           cmp_acknak_seq ;
wire [11:0]           cmp_ackd_seq ;
wire                  calc1 ;
wire                  calc2 ;
wire                  calc3 ;
wire                  rtry_enb ;
parameter ACKD_SEQ    = 12'hFFF ;
reg [31 : 0] dllp_data_split;
reg dllp_crc_ok_split;
reg [11 : 0] txtp_nxtseq_split;
reg txtp_rtry_done_split;
reg dl_inact_split;
reg crcok_reg_split;
reg ack_rcvd_split;
reg nak_rcvd_split;
reg [11 : 0] ackd_seq_split;
reg ack_dec_split;
reg nak_dec_split;
reg [11 : 0] cmp_acknak_seq_split;
reg [11 : 0] cmp_ackd_seq_split;
reg calc1_split;
reg calc2_split;
reg calc3_split;
reg rtry_enb_split;
reg [2047:0] descram_in;
wire [16:0] descram_out;

localparam descram_inst_SIZE = 17,descram_inst_SCRAMSTRING = 32'hfdffd84b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

// =============================================================================

// =============================================================================
// The logic here implemts the criteria given in figure 3-17 of the spec. about
// processing of the ACK and NAk DLLPs based on the received sequence numbers.
// =============================================================================

// Decode for ACK DLLP
assign ack_dec = (dllp_data_split[31:24] == 8'h00)  ;

// Decode for NAK DLLP
assign nak_dec = (dllp_data_split[31:24] == 8'h10) ;

// Register Ack_nak_seq number if it is ACK or NAK DLLP.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin
       acknak_seq  <= 12'h000 ;
       crcok_reg   <= 1'b0 ;
   end
   else if (ack_dec_split || nak_dec_split) begin
       acknak_seq  <= dllp_data_split[11:0] ;
       crcok_reg   <= dllp_crc_ok_split ;
   end
   else  begin
       acknak_seq  <= acknak_seq ;
       crcok_reg   <= 1'b0 ;
   end
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin
      ack_rcvd   <= 1'b0 ;
      nak_rcvd   <= 1'b0 ;
   end
   else  begin
      ack_rcvd   <= ack_dec_split ;
      nak_rcvd   <= nak_dec_split ;
   end
end

// 1's complement of acknak_seq number.
assign cmp_acknak_seq = ~acknak_seq ;

// Compute the equation "(txtp_nxtseq) - acknak_seq)mod 4096 <= 2048".
// This is same as "(txtp_nxtseq) + 2's complemet acknak_seq ) <= 2048".
// This is same as "(txtp_nxtseq + 1's complemet acknak_seq ) <= 2048".
assign calc1 = ((txtp_nxtseq_split + cmp_acknak_seq_split) <= 12'd2048) ;

// 2's complement of ackd_seq number.
assign cmp_ackd_seq = ((~ackd_seq_split) + 12'h001) ;

// Compute the equation "(acknak_seq - ackd_seq)mod 4096 < 2048".
// This is same as "(acknak_seq + 2's complement ackd_seq) < 2048".
assign calc2 = ((acknak_seq + cmp_ackd_seq_split) < 12'd2048) ;

// Compute the equation "(acknak_seq = ackd_seq)".
assign calc3 = (acknak_seq == ackd_seq_split) ;


// Generate Data Link layer protocol error
// (refer to figure 3-17 of the spec.)
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      rxdp_dlerr <= 1'b0 ;
   else if (crcok_reg_split && (!calc1_split || (calc1_split && !calc2_split)))
      rxdp_dlerr <= 1'b1 ;
   else
      rxdp_dlerr <= 1'b0 ;
end

// Generate retry buffer purge signal for transmit TLP block.
// (refer to figure 3-17 of the spec.)
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin
      rxdp_purge <= 1'b0 ;
      ackd_seq   <= ACKD_SEQ ;
   end
   else if (dl_inact_split) begin
      rxdp_purge <= 1'b0 ;
      ackd_seq   <= ACKD_SEQ ;
   end
   else if (crcok_reg_split && calc1_split && calc2_split & !calc3_split) begin
      //if (ack_rcvd || (nak_rcvd && rtry_enb)) begin
      if (ack_rcvd_split || nak_rcvd_split) begin
         rxdp_purge <= 1'b1 ;
         ackd_seq   <= acknak_seq ;
      end
      else begin
         rxdp_purge <= 1'b0 ;
         ackd_seq   <= ackd_seq_split ;
      end
   end
   else begin
      rxdp_purge <= 1'b0 ;
      ackd_seq   <= ackd_seq_split ;
   end
end


assign rxdp_seqnum = ackd_seq_split ;

// Enble retry/purge generation only if received ACL/NAK
// is for the packet in buffer.
assign rtry_enb =  ~(txtp_nxtseq_split == (acknak_seq + 1));

// Generate retry signal for transmit TLP block.
// (refer to figure 3-17 of the spec.)
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      rxdp_rtry <= 1'b0 ;
   else if (crcok_reg_split && calc1_split && calc2_split && nak_rcvd_split && rtry_enb_split)
      rxdp_rtry <= 1'b1 ;
   else if (txtp_rtry_done_split)
      rxdp_rtry <= 1'b0 ;
   else
      rxdp_rtry <= rxdp_rtry ;
end

// Generate rxdp_ack signal for transmit TLP block.
// whenever right ack has been received.
// (refer to figure 3-17 of the spec.)
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      rxdp_ack <= 1'b0 ;
   else if (crcok_reg_split && calc1_split && calc2_split && ack_rcvd_split)
      rxdp_ack <= 1'b1 ;
   else
      rxdp_ack <= 1'b0 ;
end

always@* begin dllp_data_split<={dllp_data>>1,descram_out[0]};dllp_crc_ok_split<=descram_out[1];txtp_nxtseq_split<={txtp_nxtseq>>1,descram_out[2]};txtp_rtry_done_split<=descram_out[3];dl_inact_split<=descram_out[4];crcok_reg_split<=descram_out[5];ack_rcvd_split<=descram_out[6];nak_rcvd_split<=descram_out[7];ackd_seq_split<={ackd_seq>>1,descram_out[8]};ack_dec_split<=descram_out[9];nak_dec_split<=descram_out[10];cmp_acknak_seq_split<={cmp_acknak_seq>>1,descram_out[11]};cmp_ackd_seq_split<={cmp_ackd_seq>>1,descram_out[12]};calc1_split<=descram_out[13];calc2_split<=descram_out[14];calc3_split<=descram_out[15];rtry_enb_split<=descram_out[16];end
always@* begin descram_in[2047]<=dllp_crc_ok;descram_in[2046]<=txtp_nxtseq[0];descram_in[2044]<=txtp_rtry_done;descram_in[2040]<=dl_inact;descram_in[2033]<=crcok_reg;descram_in[2019]<=ack_rcvd;descram_in[1991]<=nak_rcvd;descram_in[1934]<=ackd_seq[0];descram_in[1851]<=calc3;descram_in[1820]<=ack_dec;descram_in[1654]<=rtry_enb;descram_in[1593]<=nak_dec;descram_in[1139]<=cmp_acknak_seq[0];descram_in[1023]<=dllp_data[0];descram_in[925]<=calc2;descram_in[462]<=calc1;descram_in[231]<=cmp_ackd_seq[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.4 2007/02/02 17:19:50PST uananthi


//


// Revision 1.3 2007/02/02 15:45:57PST uananthi


// updated for coverage report


// Revision 1.2 2006/05/23 16:59:09PDT uananthi


// first cut for X4 ECP2M


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X1_11


// File             : rxdp_cfilt.v


// Title            :


// Dependencies     :


// Description      : This module 16 bit CRC verification of received DLLPs.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Jan 31, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module rxdp_cfilt (
   input wire         sys_clk ,        
   input wire         rst_n ,          

   `ifdef X1
      input wire [15:0]  dfrm_dllp_data , 
      input wire         dfrm_dllp_st ,   
      output wire        dllp_crc_ok ,    
      output wire        dllp_crc_err ,   
   `endif
   `ifdef X4
      input wire [47:0]  dfrm_dllp_data , 
      input wire         dfrm_dval ,      
      output reg         dllp_crc_ok ,    
      output reg         dllp_crc_err ,   
   `endif

   input              dl_inact ,       

   output reg [31:0]  dllp_data        // DLLP data.


   ) ;
reg [15:0]       crc_in ;
reg [15:0]       C ;
reg [31:0]       D ;
reg [31:0]       A ;
wire [15:0]      act_crc ;
wire [15:0]      crc_result ;
wire             crc_ok ;
wire [31:0]      dllp_data_int ;

`ifdef X1
wire             dllp_clk1 ;
reg              dllp_clk2 ;
reg              dllp_clk3 ;
reg              dllp_clk4 ;
reg [15:0]       dfrm_dllp_dreg ;
reg [15:0]       act_crc_reg ;

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif
reg dl_inact_split;
reg [15 : 0] C_split;
reg [31 : 0] D_split;
reg [31 : 0] A_split;
reg [15 : 0] act_crc_split;
reg [15 : 0] crc_result_split;
reg crc_ok_split;
reg [31 : 0] dllp_data_int_split;
reg [2047:0] descram_in;
wire [7:0] descram_out;

`ifdef X1

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

localparam descram_inst_SIZE = 8,descram_inst_SCRAMSTRING = 32'hfdfff02b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X1


`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif

// =============================================================================



`ifdef X1


   

`endif



// =============================================================================
// Get 32 bits of DLLP data on which CRC has to be calculated


`ifdef X1


   assign dllp_clk1 = dfrm_dllp_st ;
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) begin
         dllp_clk2 <= 1'b0 ;
         dllp_clk3 <= 1'b0 ;
         dllp_clk4 <= 1'b0 ;

         dfrm_dllp_dreg <= 1'd0 ;
      end
      else begin
         dllp_clk2 <=  dllp_clk1 ;
         dllp_clk3 <=  dllp_clk2 ;
         dllp_clk4 <=  dllp_clk3 ;

         if (dllp_clk1)
            dfrm_dllp_dreg <= dfrm_dllp_data ;
         else
            dfrm_dllp_dreg <= dfrm_dllp_dreg ;
      end
   end
   assign dllp_data_int = {dfrm_dllp_dreg, dfrm_dllp_data} ;


`endif




`ifdef X4


   assign dllp_data_int = dfrm_dllp_data[47:16] ;


`endif



// Cobinatorial XOR tree for CRC computation.
always @* begin
   A = dllp_data_int_split ;
   D = {A_split[24],A_split[25],A_split[26],A_split[27],A_split[28],A_split[29],A_split[30],A_split[31],
        A_split[16],A_split[17],A_split[18],A_split[19],A_split[20],A_split[21],A_split[22],A_split[23],
        A_split[8],A_split[9],A_split[10],A_split[11],A_split[12],A_split[13],A_split[14],A_split[15],
        A_split[0],A_split[1],A_split[2],A_split[3],A_split[4],A_split[5],A_split[6],A_split[7] };
   C = 16'h32B9;

   crc_in[0] = D_split[31] ^ D_split[29] ^ D_split[28] ^ D_split[26] ^ D_split[23] ^ D_split[21] ^ D_split[20] ^
               D_split[15] ^ D_split[13] ^ D_split[12] ^ D_split[8] ^ D_split[4] ^ D_split[0] ^ C_split[0] ;
   crc_in[1] = D_split[31] ^ D_split[30] ^ D_split[28] ^ D_split[27] ^ D_split[26] ^ D_split[24] ^ D_split[23] ^
               D_split[22] ^ D_split[20] ^ D_split[16] ^ D_split[15] ^ D_split[14] ^ D_split[12] ^ D_split[9] ^
               D_split[8] ^ D_split[5] ^ D_split[4] ^ D_split[1] ^ D_split[0] ^ C_split[1] ;
   crc_in[2] = D_split[31] ^ D_split[29] ^ D_split[28] ^ D_split[27] ^ D_split[25] ^ D_split[24] ^ D_split[23] ^
               D_split[21] ^ D_split[17] ^ D_split[16] ^ D_split[15] ^ D_split[13] ^ D_split[10] ^ D_split[9] ^
               D_split[6] ^ D_split[5] ^ D_split[2] ^ D_split[1] ^ C_split[2] ;
   crc_in[3] = D_split[31] ^ D_split[30] ^ D_split[25] ^ D_split[24] ^ D_split[23] ^ D_split[22] ^ D_split[21] ^
               D_split[20] ^ D_split[18] ^ D_split[17] ^ D_split[16] ^ D_split[15] ^ D_split[14] ^ D_split[13] ^
               D_split[12] ^ D_split[11] ^ D_split[10] ^ D_split[8] ^ D_split[7] ^ D_split[6] ^ D_split[4] ^
               D_split[3] ^ D_split[2] ^ D_split[0] ^ C_split[3] ;
   crc_in[4] = D_split[31] ^ D_split[26] ^ D_split[25] ^ D_split[24] ^ D_split[23] ^ D_split[22] ^ D_split[21] ^
               D_split[19] ^ D_split[18] ^ D_split[17] ^ D_split[16] ^ D_split[15] ^ D_split[14] ^ D_split[13] ^
               D_split[12] ^ D_split[11] ^ D_split[9] ^ D_split[8] ^ D_split[7] ^ D_split[5] ^ D_split[4] ^
               D_split[3] ^ D_split[1] ^ C_split[4] ;
   crc_in[5] = D_split[27] ^ D_split[26] ^ D_split[25] ^ D_split[24] ^ D_split[23] ^ D_split[22] ^ D_split[20] ^
               D_split[19] ^ D_split[18] ^ D_split[17] ^ D_split[16] ^ D_split[15] ^ D_split[14] ^ D_split[13] ^
               D_split[12] ^ D_split[10] ^ D_split[9] ^ D_split[8] ^ D_split[6] ^ D_split[5] ^ D_split[4] ^
               D_split[2] ^  C_split[5] ;
   crc_in[6] = D_split[28] ^ D_split[27] ^ D_split[26] ^ D_split[25] ^ D_split[24] ^ D_split[23] ^ D_split[21] ^
               D_split[20] ^ D_split[19] ^ D_split[18] ^ D_split[17] ^ D_split[16] ^ D_split[15] ^ D_split[14] ^
               D_split[13] ^ D_split[11] ^ D_split[10] ^ D_split[9] ^ D_split[7] ^ D_split[6] ^ D_split[5] ^
               D_split[3] ^ C_split[6] ;
   crc_in[7] = D_split[29] ^ D_split[28] ^ D_split[27] ^ D_split[26] ^ D_split[25] ^ D_split[24] ^ D_split[22] ^
               D_split[21] ^ D_split[20] ^ D_split[19] ^ D_split[18] ^ D_split[17] ^ D_split[16] ^ D_split[15] ^
               D_split[14] ^ D_split[12] ^ D_split[11] ^ D_split[10] ^ D_split[8] ^ D_split[7] ^ D_split[6] ^
               D_split[4] ^ C_split[7] ;
   crc_in[8] = D_split[30] ^ D_split[29] ^ D_split[28] ^ D_split[27] ^ D_split[26] ^ D_split[25] ^ D_split[23] ^
               D_split[22] ^ D_split[21] ^ D_split[20] ^ D_split[19] ^ D_split[18] ^ D_split[17] ^ D_split[16] ^
               D_split[15] ^ D_split[13] ^ D_split[12] ^ D_split[11] ^ D_split[9] ^ D_split[8] ^ D_split[7] ^
               D_split[5] ^ C_split[8] ;
   crc_in[9] = D_split[31] ^ D_split[30] ^ D_split[29] ^ D_split[28] ^ D_split[27] ^ D_split[26] ^ D_split[24] ^
               D_split[23] ^ D_split[22] ^ D_split[21] ^ D_split[20] ^ D_split[19] ^ D_split[18] ^ D_split[17] ^
               D_split[16] ^ D_split[14] ^ D_split[13] ^ D_split[12] ^ D_split[10] ^ D_split[9] ^ D_split[8] ^
               D_split[6] ^ C_split[9] ;
   crc_in[10] = D_split[31] ^ D_split[30] ^ D_split[29] ^ D_split[28] ^ D_split[27] ^ D_split[25] ^ D_split[24] ^
                D_split[23] ^ D_split[22] ^ D_split[21] ^ D_split[20] ^ D_split[19] ^ D_split[18] ^ D_split[17] ^
                D_split[15] ^ D_split[14] ^ D_split[13] ^ D_split[11] ^ D_split[10] ^ D_split[9] ^ D_split[7] ^ C_split[10] ;
   crc_in[11] = D_split[31] ^ D_split[30] ^ D_split[29] ^ D_split[28] ^ D_split[26] ^ D_split[25] ^ D_split[24] ^
                D_split[23] ^ D_split[22] ^ D_split[21] ^ D_split[20] ^ D_split[19] ^ D_split[18] ^ D_split[16] ^
                D_split[15] ^ D_split[14] ^ D_split[12] ^ D_split[11] ^ D_split[10] ^ D_split[8] ^ C_split[11] ;
   crc_in[12] = D_split[30] ^ D_split[28] ^ D_split[27] ^ D_split[25] ^ D_split[24] ^ D_split[22] ^ D_split[19] ^
                D_split[17] ^ D_split[16] ^ D_split[11] ^ D_split[9] ^ D_split[8] ^ D_split[4] ^ D_split[0] ^ C_split[12] ;
   crc_in[13] = D_split[31] ^ D_split[29] ^ D_split[28] ^ D_split[26] ^ D_split[25] ^ D_split[23] ^ D_split[20] ^
                D_split[18] ^ D_split[17] ^ D_split[12] ^ D_split[10] ^ D_split[9] ^ D_split[5] ^ D_split[1] ^ C_split[13];
   crc_in[14] = D_split[30] ^ D_split[29] ^ D_split[27] ^ D_split[26] ^ D_split[24] ^ D_split[21] ^ D_split[19] ^
                D_split[18] ^ D_split[13] ^ D_split[11] ^ D_split[10] ^ D_split[6] ^ D_split[2] ^ C_split[14] ;
   crc_in[15] = D_split[31] ^ D_split[30] ^ D_split[28] ^ D_split[27] ^ D_split[25] ^ D_split[22] ^ D_split[20] ^
                D_split[19] ^ D_split[14] ^ D_split[12] ^ D_split[11] ^ D_split[7] ^ D_split[3] ^ C_split[15] ;

end

// Complement the computed CRC.
assign act_crc = {~crc_in[8],  ~crc_in[9],  ~crc_in[10], ~crc_in[11],
                  ~crc_in[12], ~crc_in[13], ~crc_in[14], ~crc_in[15],
                  ~crc_in[0],  ~crc_in[1],  ~crc_in[2],  ~crc_in[3],
                  ~crc_in[4],  ~crc_in[5],  ~crc_in[6],  ~crc_in[7]} ;



`ifdef X1


   // Register actual CRC to have it ready in 3rd clock for comparision
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n)
         act_crc_reg <= 16'h0000 ;
      else
         act_crc_reg <= act_crc_split ;
   end
   // XOR the computed CRC with extracted CRC
   assign crc_result = (act_crc_reg ^ dfrm_dllp_data[15:0]) ;


`endif




`ifdef X4


   // XOR the computed CRC with extracted CRC
   assign crc_result = (act_crc_split ^ dfrm_dllp_data[15:0]) ;


`endif




// Generate crc_ok signal by checking CRC result
assign crc_ok =  (crc_result_split == 16'h0000) ;

// Give out registered outputs.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      dllp_data <= 32'h0000_0000 ;
   

`ifdef X1


      else if (dllp_clk2)
         dllp_data <= dllp_data_int_split ;
   

`endif


   

`ifdef X4


      else
         dllp_data <= dllp_data_int_split ;
   

`endif


end



`ifdef X1


   assign dllp_crc_ok  = (!dl_inact_split & dllp_clk3 & crc_ok_split) ;
   assign dllp_crc_err = (!dl_inact_split & dllp_clk3 & ~crc_ok_split) ;


`endif




`ifdef X4


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n)
         dllp_crc_ok  <= 1'b0 ;
      else if (!dl_inact_split && dfrm_dval && crc_ok_split)
         dllp_crc_ok  <= 1'b1 ;
      else
         dllp_crc_ok  <= 1'b0 ;
   end

   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n)
         dllp_crc_err <= 1'b0 ;
      else if (!dl_inact_split && dfrm_dval && !crc_ok_split)
         dllp_crc_err <= 1'b1 ;
      else
         dllp_crc_err <= 1'b0 ;
   end


`endif



always@* begin dl_inact_split<=descram_out[0];C_split<={C>>1,descram_out[1]};D_split<={D>>1,descram_out[2]};A_split<={A>>1,descram_out[3]};act_crc_split<={act_crc>>1,descram_out[4]};crc_result_split<={crc_result>>1,descram_out[5]};crc_ok_split<=descram_out[6];dllp_data_int_split<={dllp_data_int>>1,descram_out[7]};end
always@* begin descram_in[2047]<=C[0];descram_in[2046]<=D[0];descram_in[2044]<=A[0];descram_in[2041]<=act_crc[0];descram_in[2035]<=crc_result[0];descram_in[2022]<=crc_ok;descram_in[1996]<=dllp_data_int[0];descram_in[1023]<=dl_inact;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.4 2007/08/03 14:59:16PDT rperugu


//


// Revision 1.3 2006/06/16 12:12:24PDT rperugu


// dfrm_perr is removed.


// Revision 1.2 2006/05/23 16:59:09PDT uananthi


// first cut for X4 ECP2M


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_XX_11


// File             : rxdp_ddec.v


// Title            :


// Dependencies     :


// Description      : This module decodes different DLLPs .


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Mar 01, 2004


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module rxdp_ddec (
   input wire         sys_clk ,        
   input wire         rst_n ,          

   input wire [31:0]  dllp_data ,      
   input wire         dllp_crc_ok ,    

   output reg [22:0]  rxdp_fcdata ,    
   output reg [1:0]   rxdp_fcd_type ,  
   output reg         rxdp_ifc1_val ,  
   output reg         rxdp_ifc2_val ,  
   output reg         rxdp_ufc_val ,   
   output reg [23:0]  rxdp_vsd_data ,  
   output reg         rxdp_vsd_val,    
   output reg [2:0]   rxdp_pmd_type ,  
   output reg         rxdp_pm_val      // PM bits are valid.


   ) ;
reg                    pm_dec ;
reg                    initfc1_dec ;
reg                    initfc2_dec ;
reg                    updfc_dec ;
reg                    vsd_dec ;
reg [31 : 0] dllp_data_split;
reg dllp_crc_ok_split;
reg initfc1_dec_split;
reg initfc2_dec_split;
reg updfc_dec_split;
reg vsd_dec_split;
reg [2047:0] descram_in;
wire [5:0] descram_out;

localparam descram_inst_SIZE = 6,descram_inst_SCRAMSTRING = 32'hfdfff02b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

// =============================================================================
// =============================================================================
// This module decodes different DLLPs and generates different
// components of DLLP data.
// =============================================================================

// Decode DLLP types
always @* begin
   if (dllp_crc_ok_split) begin
      casex (dllp_data_split[31:24])
         // Power Management DLLPs
         8'b0010_0000 ,
         8'b0010_0001 ,
         8'b0010_0011 ,
         8'b0010_0100 : begin
            pm_dec       = 1'b1 ;
            initfc1_dec  = 1'b0 ;
            initfc2_dec  = 1'b0 ;
            updfc_dec    = 1'b0 ;
            vsd_dec      = 1'b0 ;
         end
         // Vendor Specific DLLPs
         8'b0011_0000 : begin
            pm_dec       = 1'b0 ;
            initfc1_dec  = 1'b0 ;
            initfc2_dec  = 1'b0 ;
            updfc_dec    = 1'b0 ;
            vsd_dec      = 1'b1 ;
         end
         // InitFC1 DLLPs
         8'b0100_0xxx ,
         8'b0101_0xxx ,
         8'b0110_0xxx : begin
            pm_dec       = 1'b0 ;
            initfc1_dec  = 1'b1 ;
            initfc2_dec  = 1'b0 ;
            updfc_dec    = 1'b0 ;
            vsd_dec      = 1'b0 ;
         end
         // InitFC2 DLLPs
         8'b1100_0xxx ,
         8'b1101_0xxx ,
         8'b1110_0xxx : begin
            pm_dec       = 1'b0 ;
            initfc1_dec  = 1'b0 ;
            initfc2_dec  = 1'b1 ;
            updfc_dec    = 1'b0 ;
            vsd_dec      = 1'b0 ;
         end
         // UpdateFC DLLPs
         8'b1000_0xxx ,
         8'b1001_0xxx ,
         8'b1010_0xxx : begin
            pm_dec       = 1'b0 ;
            initfc1_dec  = 1'b0 ;
            initfc2_dec  = 1'b0 ;
            updfc_dec    = 1'b1 ;
            vsd_dec      = 1'b0 ;
         end
         default      : begin
            pm_dec       = 1'b0 ;
            initfc1_dec  = 1'b0 ;
            initfc2_dec  = 1'b0 ;
            updfc_dec    = 1'b0 ;
            vsd_dec      = 1'b0 ;
         end
     endcase
   end
   else begin
      pm_dec       = 1'b0 ;
      initfc1_dec  = 1'b0 ;
      initfc2_dec  = 1'b0 ;
      updfc_dec    = 1'b0 ;
      vsd_dec      = 1'b0 ;
   end
end


// Generate Headder FC and Data FC values extracted from DLLPs
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      rxdp_fcdata <= 23'h0_0000 ;
   else
      rxdp_fcdata <=  {dllp_data_split[26:24], dllp_data_split[21:14], dllp_data_split[11:0]} ;
end

// Generate FC DLLP type bits for FCI
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      rxdp_fcd_type <= 2'b00 ;
   else
      rxdp_fcd_type <=  dllp_data_split[29:28] ;
end

// Generate PM DLLP type
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      rxdp_pmd_type <= 3'b000 ;
   else
      rxdp_pmd_type <= dllp_data_split[26:24] ;
end

// Generate Vendor specific DLLP data
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      rxdp_vsd_data <= 23'b000 ;
   else
      rxdp_vsd_data <= dllp_data_split[23:0] ;
end


// Generate initfc1 valid signal indicating
// rxfc_data, rx_initfc values belongs to initfc1
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      rxdp_ifc1_val  <= 1'b0 ;
   else if (initfc1_dec_split)
      rxdp_ifc1_val  <= 1'b1 ;
   else
      rxdp_ifc1_val  <= 1'b0 ;
end

// Generate initfc2 valid signal indicating
// rxfc_data, rx_initfc values belongs to initfc2
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      rxdp_ifc2_val  <= 1'b0 ;
   else if (initfc2_dec_split)
      rxdp_ifc2_val  <= 1'b1 ;
   else
      rxdp_ifc2_val  <= 1'b0 ;
end

// Generate updatfc valid signal indicating
// rxfc_data, rx_initfc values belongs to updatafc
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      rxdp_ufc_val  <= 1'b0 ;
   else if (updfc_dec_split)
      rxdp_ufc_val  <= 1'b1 ;
   else
      rxdp_ufc_val  <= 1'b0 ;
end

// Generate power management DLLP valid signal
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      rxdp_pm_val  <= 1'b0 ;
   else if (pm_dec)
      rxdp_pm_val  <= 1'b1 ;
   else
      rxdp_pm_val  <= 1'b0 ;
end

// Generate vendor specific DLLP valid signal
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      rxdp_vsd_val  <= 1'b0 ;
   else if (vsd_dec_split)
      rxdp_vsd_val  <= 1'b1 ;
   else
      rxdp_vsd_val  <= 1'b0 ;
end

always@* begin dllp_data_split<={dllp_data>>1,descram_out[0]};dllp_crc_ok_split<=descram_out[1];initfc1_dec_split<=descram_out[2];initfc2_dec_split<=descram_out[3];updfc_dec_split<=descram_out[4];vsd_dec_split<=descram_out[5];end
always@* begin descram_in[2047]<=dllp_crc_ok;descram_in[2046]<=initfc1_dec;descram_in[2044]<=initfc2_dec;descram_in[2041]<=updfc_dec;descram_in[2035]<=vsd_dec;descram_in[1023]<=dllp_data[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.2 2006/05/23 16:59:10PDT uananthi


// first cut for X4 ECP2M



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_XX_11


// File             : rxdp.v


// Title            :


// Dependencies     : rxdp_cfilt.v


//                    rxdp_ddec.v


//                    rxdp_acknak.v


// Description      : Top level module for rxdp block .


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Jan 31, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module rxdp (
   input wire         sys_clk ,        
   input wire         rst_n ,          

   `ifdef X1
      input wire [15:0]  dfrm_dllp_data , 
      input wire         dfrm_dllp_st ,   
   `endif
   `ifdef X4
      input wire [47:0]  dfrm_dllp_data , 
      input wire         dfrm_dval ,      
   `endif

   input wire [11:0]  txtp_nxtseq ,    
   input wire         txtp_rtry_done , 
   input              dl_inact ,       

   output wire [22:0] rxdp_fcdata ,    
   output wire [1:0]  rxdp_fcd_type ,  
   output wire        rxdp_ifc1_val ,  
   output wire        rxdp_ifc2_val ,  
   output wire        rxdp_ufc_val ,   
   output wire [23:0] rxdp_vsd_data ,  
   output wire [2:0]  rxdp_pmd_type ,  
   output wire [1:0]  rxdp_dllp_val ,  
                                       

   output wire [11:0] rxdp_seqnum ,    
   output wire        rxdp_ack ,       
   output wire        rxdp_rtry ,      
   output wire        rxdp_purge ,     

   output wire        rxdp_bad_dllp ,  
   output wire        rxdp_dlerr       // Data link layer err.


   ) ;
wire [31:0] dllp_data ;

`ifdef X1

`endif

`ifdef X4

`endif
reg rst_n_split;
reg [11 : 0] txtp_nxtseq_split;
reg txtp_rtry_done_split;
reg dl_inact_split;
reg [2047:0] descram_in;
wire [3:0] descram_out;


`ifdef X1

`endif

`ifdef X4

`endif



localparam descram_inst_SIZE = 4,descram_inst_SCRAMSTRING = 32'hfdffd48b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X1



`endif



`ifdef X4



`endif

// =============================================================================
rxdp_cfilt u1_rxdp_cfilt (
// Clock and Reset
   .sys_clk        ( sys_clk ) ,
   .rst_n          ( rst_n_split ) ,

   // Inputs
   

`ifdef X1


      .dfrm_dllp_data ( dfrm_dllp_data ) ,
      .dfrm_dllp_st   ( dfrm_dllp_st ) ,
   

`endif


   

`ifdef X4


      .dfrm_dllp_data ( dfrm_dllp_data ) ,
      .dfrm_dval      ( dfrm_dval ) ,
   

`endif



   .dl_inact       ( dl_inact_split ) ,

   // Outputs
   .dllp_data      ( dllp_data ) ,
   .dllp_crc_ok    ( dllp_crc_ok ) ,
   .dllp_crc_err   ( rxdp_bad_dllp )
  ) ;

rxdp_acknak u1_rxdp_acknak (
   // Clock and Reset
   .sys_clk        ( sys_clk ) ,
   .rst_n          ( rst_n_split ) ,

   // Inputs
   .dllp_data      ( dllp_data ) ,
   .dllp_crc_ok    ( dllp_crc_ok ) ,
   .txtp_nxtseq    ( txtp_nxtseq_split ) ,
   .txtp_rtry_done ( txtp_rtry_done_split ) ,

   .dl_inact       ( dl_inact_split ) ,

   // Outputs
   .rxdp_seqnum    ( rxdp_seqnum ) ,
   .rxdp_ack       ( rxdp_ack ) ,
   .rxdp_rtry      ( rxdp_rtry ) ,
   .rxdp_purge     ( rxdp_purge ) ,
   .rxdp_dlerr     ( rxdp_dlerr )
  ) ;

rxdp_ddec u1_rxdp_ddec (
   // Clock and Reset
   .sys_clk        ( sys_clk ) ,
   .rst_n          ( rst_n_split ) ,

   // Inputs
   .dllp_data      ( dllp_data ) ,
   .dllp_crc_ok    ( dllp_crc_ok ) ,

   // Outputs
   .rxdp_fcdata    ( rxdp_fcdata ) ,
   .rxdp_fcd_type  ( rxdp_fcd_type ) ,
   .rxdp_ifc1_val  ( rxdp_ifc1_val ) ,
   .rxdp_ifc2_val  ( rxdp_ifc2_val ) ,
   .rxdp_ufc_val   ( rxdp_ufc_val ) ,
   .rxdp_vsd_data  ( rxdp_vsd_data ) ,
   .rxdp_pmd_type  ( rxdp_pmd_type ) ,
   .rxdp_vsd_val   ( rxdp_dllp_val[1] ) ,
   .rxdp_pm_val    ( rxdp_dllp_val[0] )
  ) ;

always@* begin rst_n_split<=descram_out[0];txtp_nxtseq_split<={txtp_nxtseq>>1,descram_out[1]};txtp_rtry_done_split<=descram_out[2];dl_inact_split<=descram_out[3];end
always@* begin descram_in[2047]<=txtp_nxtseq[0];descram_in[2046]<=txtp_rtry_done;descram_in[2044]<=dl_inact;descram_in[1023]<=rst_n;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.3 2006/06/16 12:12:17PDT rperugu


// dfrm_perr is removed.


// Revision 1.2 2006/05/23 16:59:05PDT uananthi


// first cut for X4 ECP2M



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X4_11


// File             : rxtp_crc.v


// Title            :


// Dependencies     :


// Description      : This module generates CRC-32 for 64 bit data stream


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Jan 24, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module rxtp_crc #(
   parameter D_WIDTH  = 64 )
   (
   input              sys_clk ,    
   input              rst_n ,      

   input [D_WIDTH-1:0]  data_in ,  
   input                start ,    
   `ifdef X4
      input              valid ,   
      output wire [31:0] crc_out48,
   `endif
   output wire [31:0] crc_out16    // calculated CRC.


   ) ;
reg  [31:0]            crc_reg16 ;
reg  [31:0]            new_crc16 ;
reg  [15:0]            A16 ;
reg  [31:0]            C16 ;
reg  [15:0]            D16 ;
wire [7:0]             act_crc16_b3 ;
wire [7:0]             act_crc16_b2 ;
wire [7:0]             act_crc16_b1 ;
wire [7:0]             act_crc16_b0 ;

`ifdef X4
reg  [31:0]         crc_reg64 ;
reg  [31:0]         crc_reg48 ;
reg  [31:0]         new_crc64 ;
reg  [31:0]         new_crc48 ;
reg  [63:0]         A64 ;
reg  [31:0]         C64 ;
reg  [63:0]         D64 ;
reg  [47:0]         A48 ;
reg  [31:0]         C48 ;
reg  [47:0]         D48 ;
wire [7:0]          act_crc48_b3 ;
wire [7:0]          act_crc48_b2 ;
wire [7:0]          act_crc48_b1 ;
wire [7:0]          act_crc48_b0 ;

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif
reg [D_WIDTH - 1 : 0] data_in_split;
reg start_split;
reg [31 : 0] new_crc16_split;
reg [15 : 0] A16_split;
reg [31 : 0] C16_split;
reg [15 : 0] D16_split;
reg [7 : 0] act_crc16_b3_split;
reg [7 : 0] act_crc16_b2_split;
reg [7 : 0] act_crc16_b1_split;
reg [7 : 0] act_crc16_b0_split;
reg [2047:0] descram_in;
wire [9:0] descram_out;

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif

localparam descram_inst_SIZE = 10,descram_inst_SCRAMSTRING = 32'hfdffca4b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X4


`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X4



`endif


`ifdef X4


   

`endif



// =============================================================================
// Register computed CRC into CRC registers whenever CRC has to
// be computed on 16 bits data for X1 and 16/32/64 bits data for X4.
// =============================================================================
always @( posedge sys_clk, negedge rst_n ) begin
   if (!rst_n) begin
      crc_reg16 <= 32'hFFFF_FFFF ;
      

`ifdef X4


         crc_reg48 <= 32'hFFFF_FFFF ;
         crc_reg64 <= 32'hFFFF_FFFF ;
      

`endif


   end
   else begin
      

`ifdef X1


         if(start_split)
            crc_reg16 <= 32'hFFFF_FFFF ;
         else
            crc_reg16 <= new_crc16_split ;
      

`endif


      

`ifdef X4


         crc_reg16 <= new_crc16_split ;

         crc_reg48 <= new_crc48 ;
         if(start_split)
            crc_reg64 <= 32'hFFFF_FFFF ;
         else if(valid) //Storing is required for downgrade mode
            crc_reg64 <= new_crc64 ;

      

`endif


   end
end



`ifdef X4


   // =============================================================================
   // crc for 64 bit
   // =============================================================================
   always @* begin
   A64 = data_in_split;
   D64 = {
          A64[56], A64[57], A64[58], A64[59], A64[60], A64[61], A64[62], A64[63],
          A64[48], A64[49], A64[50], A64[51], A64[52], A64[53], A64[54], A64[55],
          A64[40], A64[41], A64[42], A64[43], A64[44], A64[45], A64[46], A64[47],
          A64[32], A64[33], A64[34], A64[35], A64[36], A64[37], A64[38], A64[39],
          A64[24], A64[25], A64[26], A64[27], A64[28], A64[29], A64[30], A64[31],
          A64[16], A64[17], A64[18], A64[19], A64[20], A64[21], A64[22], A64[23],
          A64[8], A64[9], A64[10], A64[11], A64[12], A64[13], A64[14], A64[15],
          A64[0], A64[1], A64[2], A64[3], A64[4], A64[5], A64[6], A64[7]
         } ;
   C64 = crc_reg64;

   new_crc64[0] = D64[63] ^ D64[61] ^ D64[60] ^ D64[58] ^ D64[55] ^ D64[54] ^ D64[53] ^
                  D64[50] ^ D64[48] ^ D64[47] ^ D64[45] ^ D64[44] ^ D64[37] ^ D64[34] ^
                  D64[32] ^ D64[31] ^ D64[30] ^ D64[29] ^ D64[28] ^ D64[26] ^ D64[25] ^
                  D64[24] ^ D64[16] ^ D64[12] ^ D64[10] ^ D64[9] ^ D64[6] ^ D64[0] ^
                  C64[0] ^ C64[2] ^ C64[5] ^ C64[12] ^ C64[13] ^ C64[15] ^ C64[16] ^
                  C64[18] ^ C64[21] ^ C64[22] ^ C64[23] ^ C64[26] ^ C64[28] ^ C64[29] ^
                  C64[31];
   new_crc64[1] = D64[63] ^ D64[62] ^ D64[60] ^ D64[59] ^ D64[58] ^ D64[56] ^ D64[53] ^
                  D64[51] ^ D64[50] ^ D64[49] ^ D64[47] ^ D64[46] ^ D64[44] ^ D64[38] ^
                  D64[37] ^ D64[35] ^ D64[34] ^ D64[33] ^ D64[28] ^ D64[27] ^ D64[24] ^
                  D64[17] ^ D64[16] ^ D64[13] ^ D64[12] ^ D64[11] ^ D64[9] ^ D64[7] ^
                  D64[6] ^ D64[1] ^ D64[0] ^ C64[1] ^ C64[2] ^ C64[3] ^ C64[5] ^ C64[6] ^
                  C64[12] ^ C64[14] ^ C64[15] ^ C64[17] ^ C64[18] ^ C64[19] ^ C64[21] ^
                  C64[24] ^ C64[26] ^ C64[27] ^ C64[28] ^ C64[30] ^ C64[31];
   new_crc64[2] = D64[59] ^ D64[58] ^ D64[57] ^ D64[55] ^ D64[53] ^ D64[52] ^ D64[51] ^
                  D64[44] ^ D64[39] ^ D64[38] ^ D64[37] ^ D64[36] ^ D64[35] ^ D64[32] ^
                  D64[31] ^ D64[30] ^ D64[26] ^ D64[24] ^ D64[18] ^ D64[17] ^ D64[16] ^
                  D64[14] ^ D64[13] ^ D64[9] ^ D64[8] ^ D64[7] ^ D64[6] ^ D64[2] ^
                  D64[1] ^ D64[0] ^ C64[0] ^ C64[3] ^ C64[4] ^ C64[5] ^ C64[6] ^ C64[7] ^
                  C64[12] ^ C64[19] ^ C64[20] ^ C64[21] ^ C64[23] ^ C64[25] ^ C64[26] ^
                  C64[27];
   new_crc64[3] = D64[60] ^ D64[59] ^ D64[58] ^ D64[56] ^ D64[54] ^ D64[53] ^ D64[52] ^
                  D64[45] ^ D64[40] ^ D64[39] ^ D64[38] ^ D64[37] ^ D64[36] ^ D64[33] ^
                  D64[32] ^ D64[31] ^ D64[27] ^ D64[25] ^ D64[19] ^ D64[18] ^ D64[17] ^
                  D64[15] ^ D64[14] ^ D64[10] ^ D64[9] ^ D64[8] ^ D64[7] ^ D64[3] ^
                  D64[2] ^ D64[1] ^ C64[0] ^ C64[1] ^ C64[4] ^ C64[5] ^ C64[6] ^ C64[7] ^
                  C64[8] ^ C64[13] ^ C64[20] ^ C64[21] ^ C64[22] ^ C64[24] ^ C64[26] ^
                  C64[27] ^ C64[28];
   new_crc64[4] = D64[63] ^ D64[59] ^ D64[58] ^ D64[57] ^ D64[50] ^ D64[48] ^ D64[47] ^
                  D64[46] ^ D64[45] ^ D64[44] ^ D64[41] ^ D64[40] ^ D64[39] ^ D64[38] ^
                  D64[33] ^ D64[31] ^ D64[30] ^ D64[29] ^ D64[25] ^ D64[24] ^ D64[20] ^
                  D64[19] ^ D64[18] ^ D64[15] ^ D64[12] ^ D64[11] ^ D64[8] ^ D64[6] ^
                  D64[4] ^ D64[3] ^ D64[2] ^ D64[0] ^ C64[1] ^ C64[6] ^ C64[7] ^ C64[8] ^
                  C64[9] ^ C64[12] ^ C64[13] ^ C64[14] ^ C64[15] ^ C64[16] ^ C64[18] ^
                  C64[25] ^ C64[26] ^ C64[27] ^ C64[31];
   new_crc64[5] = D64[63] ^ D64[61] ^ D64[59] ^ D64[55] ^ D64[54] ^ D64[53] ^ D64[51] ^
                  D64[50] ^ D64[49] ^ D64[46] ^ D64[44] ^ D64[42] ^ D64[41] ^ D64[40] ^
                  D64[39] ^ D64[37] ^ D64[29] ^ D64[28] ^ D64[24] ^ D64[21] ^ D64[20] ^
                  D64[19] ^ D64[13] ^ D64[10] ^ D64[7] ^ D64[6] ^ D64[5] ^ D64[4] ^
                  D64[3] ^ D64[1] ^ D64[0] ^ C64[5] ^ C64[7] ^ C64[8] ^ C64[9] ^ C64[10] ^
                  C64[12] ^ C64[14] ^ C64[17] ^ C64[18] ^ C64[19] ^ C64[21] ^ C64[22] ^
                  C64[23] ^ C64[27] ^ C64[29] ^ C64[31];
   new_crc64[6] = D64[62] ^ D64[60] ^ D64[56] ^ D64[55] ^ D64[54] ^ D64[52] ^ D64[51] ^
                  D64[50] ^ D64[47] ^ D64[45] ^ D64[43] ^ D64[42] ^ D64[41] ^ D64[40] ^
                  D64[38] ^ D64[30] ^ D64[29] ^ D64[25] ^ D64[22] ^ D64[21] ^ D64[20] ^
                  D64[14] ^ D64[11] ^ D64[8] ^ D64[7] ^ D64[6] ^ D64[5] ^ D64[4] ^
                  D64[2] ^ D64[1] ^ C64[6] ^ C64[8] ^ C64[9] ^ C64[10] ^ C64[11] ^
                  C64[13] ^ C64[15] ^ C64[18] ^ C64[19] ^ C64[20] ^ C64[22] ^ C64[23] ^
                  C64[24] ^ C64[28] ^ C64[30];
   new_crc64[7] = D64[60] ^ D64[58] ^ D64[57] ^ D64[56] ^ D64[54] ^ D64[52] ^ D64[51] ^
                  D64[50] ^ D64[47] ^ D64[46] ^ D64[45] ^ D64[43] ^ D64[42] ^ D64[41] ^
                  D64[39] ^ D64[37] ^ D64[34] ^ D64[32] ^ D64[29] ^ D64[28] ^ D64[25] ^
                  D64[24] ^ D64[23] ^ D64[22] ^ D64[21] ^ D64[16] ^ D64[15] ^ D64[10] ^
                  D64[8] ^ D64[7] ^ D64[5] ^ D64[3] ^ D64[2] ^ D64[0] ^ C64[0] ^ C64[2] ^
                  C64[5] ^ C64[7] ^ C64[9] ^ C64[10] ^ C64[11] ^ C64[13] ^ C64[14] ^
                  C64[15] ^ C64[18] ^ C64[19] ^ C64[20] ^ C64[22] ^ C64[24] ^ C64[25] ^
                  C64[26] ^ C64[28];
   new_crc64[8] = D64[63] ^ D64[60] ^ D64[59] ^ D64[57] ^ D64[54] ^ D64[52] ^ D64[51] ^
                  D64[50] ^ D64[46] ^ D64[45] ^ D64[43] ^ D64[42] ^ D64[40] ^ D64[38] ^
                  D64[37] ^ D64[35] ^ D64[34] ^ D64[33] ^ D64[32] ^ D64[31] ^ D64[28] ^
                  D64[23] ^ D64[22] ^ D64[17] ^ D64[12] ^ D64[11] ^ D64[10] ^ D64[8] ^
                  D64[4] ^ D64[3] ^ D64[1] ^ D64[0] ^ C64[0] ^ C64[1] ^ C64[2] ^ C64[3] ^
                  C64[5] ^ C64[6] ^ C64[8] ^ C64[10] ^ C64[11] ^ C64[13] ^ C64[14] ^
                  C64[18] ^ C64[19] ^ C64[20] ^ C64[22] ^ C64[25] ^ C64[27] ^ C64[28] ^
                  C64[31];
   new_crc64[9] = D64[61] ^ D64[60] ^ D64[58] ^ D64[55] ^ D64[53] ^ D64[52] ^ D64[51] ^
                  D64[47] ^ D64[46] ^ D64[44] ^ D64[43] ^ D64[41] ^ D64[39] ^ D64[38] ^
                  D64[36] ^ D64[35] ^ D64[34] ^ D64[33] ^ D64[32] ^ D64[29] ^ D64[24] ^
                  D64[23] ^ D64[18] ^ D64[13] ^ D64[12] ^ D64[11] ^ D64[9] ^ D64[5] ^
                  D64[4] ^ D64[2] ^ D64[1] ^ C64[0] ^ C64[1] ^ C64[2] ^ C64[3] ^ C64[4] ^
                  C64[6] ^ C64[7] ^ C64[9] ^ C64[11] ^ C64[12] ^ C64[14] ^ C64[15] ^
                  C64[19] ^ C64[20] ^ C64[21] ^ C64[23] ^ C64[26] ^ C64[28] ^ C64[29];
   new_crc64[10] = D64[63] ^ D64[62] ^ D64[60] ^ D64[59] ^ D64[58] ^ D64[56] ^ D64[55] ^
                   D64[52] ^ D64[50] ^ D64[42] ^ D64[40] ^ D64[39] ^ D64[36] ^ D64[35] ^
                   D64[33] ^ D64[32] ^ D64[31] ^ D64[29] ^ D64[28] ^ D64[26] ^ D64[19] ^
                   D64[16] ^ D64[14] ^ D64[13] ^ D64[9] ^ D64[5] ^ D64[3] ^ D64[2] ^
                   D64[0] ^ C64[0] ^ C64[1] ^ C64[3] ^ C64[4] ^ C64[7] ^ C64[8] ^ C64[10] ^
                   C64[18] ^ C64[20] ^ C64[23] ^ C64[24] ^ C64[26] ^ C64[27] ^ C64[28] ^
                   C64[30] ^ C64[31];
   new_crc64[11] = D64[59] ^ D64[58] ^ D64[57] ^ D64[56] ^ D64[55] ^ D64[54] ^ D64[51] ^
                   D64[50] ^ D64[48] ^ D64[47] ^ D64[45] ^ D64[44] ^ D64[43] ^ D64[41] ^
                   D64[40] ^ D64[36] ^ D64[33] ^ D64[31] ^ D64[28] ^ D64[27] ^ D64[26] ^
                   D64[25] ^ D64[24] ^ D64[20] ^ D64[17] ^ D64[16] ^ D64[15] ^ D64[14] ^
                   D64[12] ^ D64[9] ^ D64[4] ^ D64[3] ^ D64[1] ^ D64[0] ^ C64[1] ^ C64[4] ^
                   C64[8] ^ C64[9] ^ C64[11] ^ C64[12] ^ C64[13] ^ C64[15] ^ C64[16] ^
                   C64[18] ^ C64[19] ^ C64[22] ^ C64[23] ^ C64[24] ^ C64[25] ^ C64[26] ^
                   C64[27];
   new_crc64[12] = D64[63] ^ D64[61] ^ D64[59] ^ D64[57] ^ D64[56] ^ D64[54] ^ D64[53] ^
                   D64[52] ^ D64[51] ^ D64[50] ^ D64[49] ^ D64[47] ^ D64[46] ^ D64[42] ^
                   D64[41] ^ D64[31] ^ D64[30] ^ D64[27] ^ D64[24] ^ D64[21] ^ D64[18] ^
                   D64[17] ^ D64[15] ^ D64[13] ^ D64[12] ^ D64[9] ^ D64[6] ^ D64[5] ^
                   D64[4] ^ D64[2] ^ D64[1] ^ D64[0] ^ C64[9] ^ C64[10] ^ C64[14] ^
                   C64[15] ^ C64[17] ^ C64[18] ^ C64[19] ^ C64[20] ^ C64[21] ^ C64[22] ^
                   C64[24] ^ C64[25] ^ C64[27] ^ C64[29] ^ C64[31];
   new_crc64[13] = D64[62] ^ D64[60] ^ D64[58] ^ D64[57] ^ D64[55] ^ D64[54] ^ D64[53] ^
                   D64[52] ^ D64[51] ^ D64[50] ^ D64[48] ^ D64[47] ^ D64[43] ^ D64[42] ^
                   D64[32] ^ D64[31] ^ D64[28] ^ D64[25] ^ D64[22] ^ D64[19] ^ D64[18] ^
                   D64[16] ^ D64[14] ^ D64[13] ^ D64[10] ^ D64[7] ^ D64[6] ^ D64[5] ^
                   D64[3] ^ D64[2] ^ D64[1] ^ C64[0] ^ C64[10] ^ C64[11] ^ C64[15] ^
                   C64[16] ^ C64[18] ^ C64[19] ^ C64[20] ^ C64[21] ^ C64[22] ^ C64[23] ^
                   C64[25] ^ C64[26] ^ C64[28] ^ C64[30];
   new_crc64[14] = D64[63] ^ D64[61] ^ D64[59] ^ D64[58] ^ D64[56] ^ D64[55] ^ D64[54] ^
                   D64[53] ^ D64[52] ^ D64[51] ^ D64[49] ^ D64[48] ^ D64[44] ^ D64[43] ^
                   D64[33] ^ D64[32] ^ D64[29] ^ D64[26] ^ D64[23] ^ D64[20] ^ D64[19] ^
                   D64[17] ^ D64[15] ^ D64[14] ^ D64[11] ^ D64[8] ^ D64[7] ^ D64[6] ^
                   D64[4] ^ D64[3] ^ D64[2] ^ C64[0] ^ C64[1] ^ C64[11] ^ C64[12] ^
                   C64[16] ^ C64[17] ^ C64[19] ^ C64[20] ^ C64[21] ^ C64[22] ^ C64[23] ^
                   C64[24] ^ C64[26] ^ C64[27] ^ C64[29] ^ C64[31];
   new_crc64[15] = D64[62] ^ D64[60] ^ D64[59] ^ D64[57] ^ D64[56] ^ D64[55] ^ D64[54] ^
                   D64[53] ^ D64[52] ^ D64[50] ^ D64[49] ^ D64[45] ^ D64[44] ^ D64[34] ^
                   D64[33] ^ D64[30] ^ D64[27] ^ D64[24] ^ D64[21] ^ D64[20] ^ D64[18] ^
                   D64[16] ^ D64[15] ^ D64[12] ^ D64[9] ^ D64[8] ^ D64[7] ^ D64[5] ^
                   D64[4] ^ D64[3] ^ C64[1] ^ C64[2] ^ C64[12] ^ C64[13] ^ C64[17] ^
                   C64[18] ^ C64[20] ^ C64[21] ^ C64[22] ^ C64[23] ^ C64[24] ^ C64[25] ^
                   C64[27] ^ C64[28] ^ C64[30];
   new_crc64[16] = D64[57] ^ D64[56] ^ D64[51] ^ D64[48] ^ D64[47] ^ D64[46] ^ D64[44] ^
                   D64[37] ^ D64[35] ^ D64[32] ^ D64[30] ^ D64[29] ^ D64[26] ^ D64[24] ^
                   D64[22] ^ D64[21] ^ D64[19] ^ D64[17] ^ D64[13] ^ D64[12] ^ D64[8] ^
                   D64[5] ^ D64[4] ^ D64[0] ^ C64[0] ^ C64[3] ^ C64[5] ^ C64[12] ^ C64[14] ^
                   C64[15] ^ C64[16] ^ C64[19] ^ C64[24] ^ C64[25];
   new_crc64[17] = D64[58] ^ D64[57] ^ D64[52] ^ D64[49] ^ D64[48] ^ D64[47] ^ D64[45] ^
                   D64[38] ^ D64[36] ^ D64[33] ^ D64[31] ^ D64[30] ^ D64[27] ^ D64[25] ^
                   D64[23] ^ D64[22] ^ D64[20] ^ D64[18] ^ D64[14] ^ D64[13] ^ D64[9] ^
                   D64[6] ^ D64[5] ^ D64[1] ^ C64[1] ^ C64[4] ^ C64[6] ^ C64[13] ^ C64[15] ^
                   C64[16] ^ C64[17] ^ C64[20] ^ C64[25] ^ C64[26];
   new_crc64[18] = D64[59] ^ D64[58] ^ D64[53] ^ D64[50] ^ D64[49] ^ D64[48] ^ D64[46] ^
                   D64[39] ^ D64[37] ^ D64[34] ^ D64[32] ^ D64[31] ^ D64[28] ^ D64[26] ^
                   D64[24] ^ D64[23] ^ D64[21] ^ D64[19] ^ D64[15] ^ D64[14] ^ D64[10] ^
                   D64[7] ^ D64[6] ^ D64[2] ^ C64[0] ^ C64[2] ^ C64[5] ^ C64[7] ^ C64[14] ^
                   C64[16] ^ C64[17] ^ C64[18] ^ C64[21] ^ C64[26] ^ C64[27];
   new_crc64[19] = D64[60] ^ D64[59] ^ D64[54] ^ D64[51] ^ D64[50] ^ D64[49] ^ D64[47] ^
                   D64[40] ^ D64[38] ^ D64[35] ^ D64[33] ^ D64[32] ^ D64[29] ^ D64[27] ^
                   D64[25] ^ D64[24] ^ D64[22] ^ D64[20] ^ D64[16] ^ D64[15] ^ D64[11] ^
                   D64[8] ^ D64[7] ^ D64[3] ^ C64[0] ^ C64[1] ^ C64[3] ^ C64[6] ^ C64[8] ^
                   C64[15] ^ C64[17] ^ C64[18] ^ C64[19] ^ C64[22] ^ C64[27] ^ C64[28];
   new_crc64[20] = D64[61] ^ D64[60] ^ D64[55] ^ D64[52] ^ D64[51] ^ D64[50] ^ D64[48] ^
                   D64[41] ^ D64[39] ^ D64[36] ^ D64[34] ^ D64[33] ^ D64[30] ^ D64[28] ^
                   D64[26] ^ D64[25] ^ D64[23] ^ D64[21] ^ D64[17] ^ D64[16] ^ D64[12] ^
                   D64[9] ^ D64[8] ^ D64[4] ^ C64[1] ^ C64[2] ^ C64[4] ^ C64[7] ^ C64[9] ^
                   C64[16] ^ C64[18] ^ C64[19] ^ C64[20] ^ C64[23] ^ C64[28] ^ C64[29];
   new_crc64[21] = D64[62] ^ D64[61] ^ D64[56] ^ D64[53] ^ D64[52] ^ D64[51] ^ D64[49] ^
                   D64[42] ^ D64[40] ^ D64[37] ^ D64[35] ^ D64[34] ^ D64[31] ^ D64[29] ^
                   D64[27] ^ D64[26] ^ D64[24] ^ D64[22] ^ D64[18] ^ D64[17] ^ D64[13] ^
                   D64[10] ^ D64[9] ^ D64[5] ^ C64[2] ^ C64[3] ^ C64[5] ^ C64[8] ^ C64[10] ^
                   C64[17] ^ C64[19] ^ C64[20] ^ C64[21] ^ C64[24] ^ C64[29] ^ C64[30];
   new_crc64[22] = D64[62] ^ D64[61] ^ D64[60] ^ D64[58] ^ D64[57] ^ D64[55] ^ D64[52] ^
                   D64[48] ^ D64[47] ^ D64[45] ^ D64[44] ^ D64[43] ^ D64[41] ^ D64[38] ^
                   D64[37] ^ D64[36] ^ D64[35] ^ D64[34] ^ D64[31] ^ D64[29] ^ D64[27] ^
                   D64[26] ^ D64[24] ^ D64[23] ^ D64[19] ^ D64[18] ^ D64[16] ^ D64[14] ^
                   D64[12] ^ D64[11] ^ D64[9] ^ D64[0] ^ C64[2] ^ C64[3] ^ C64[4] ^
                   C64[5] ^ C64[6] ^ C64[9] ^ C64[11] ^ C64[12] ^ C64[13] ^ C64[15] ^
                   C64[16] ^ C64[20] ^ C64[23] ^ C64[25] ^ C64[26] ^ C64[28] ^ C64[29] ^
                   C64[30];
   new_crc64[23] = D64[62] ^ D64[60] ^ D64[59] ^ D64[56] ^ D64[55] ^ D64[54] ^ D64[50] ^
                   D64[49] ^ D64[47] ^ D64[46] ^ D64[42] ^ D64[39] ^ D64[38] ^ D64[36] ^
                   D64[35] ^ D64[34] ^ D64[31] ^ D64[29] ^ D64[27] ^ D64[26] ^ D64[20] ^
                   D64[19] ^ D64[17] ^ D64[16] ^ D64[15] ^ D64[13] ^ D64[9] ^ D64[6] ^
                   D64[1] ^ D64[0] ^ C64[2] ^ C64[3] ^ C64[4] ^ C64[6] ^ C64[7] ^ C64[10] ^
                   C64[14] ^ C64[15] ^ C64[17] ^ C64[18] ^ C64[22] ^ C64[23] ^ C64[24] ^
                   C64[27] ^ C64[28] ^ C64[30];
   new_crc64[24] = D64[63] ^ D64[61] ^ D64[60] ^ D64[57] ^ D64[56] ^ D64[55] ^ D64[51] ^
                   D64[50] ^ D64[48] ^ D64[47] ^ D64[43] ^ D64[40] ^ D64[39] ^ D64[37] ^
                   D64[36] ^ D64[35] ^ D64[32] ^ D64[30] ^ D64[28] ^ D64[27] ^ D64[21] ^
                   D64[20] ^ D64[18] ^ D64[17] ^ D64[16] ^ D64[14] ^ D64[10] ^ D64[7] ^
                   D64[2] ^ D64[1] ^ C64[0] ^ C64[3] ^ C64[4] ^ C64[5] ^ C64[7] ^ C64[8] ^
                   C64[11] ^ C64[15] ^ C64[16] ^ C64[18] ^ C64[19] ^ C64[23] ^ C64[24] ^
                   C64[25] ^ C64[28] ^ C64[29] ^ C64[31];
   new_crc64[25] = D64[62] ^ D64[61] ^ D64[58] ^ D64[57] ^ D64[56] ^ D64[52] ^ D64[51] ^
                   D64[49] ^ D64[48] ^ D64[44] ^ D64[41] ^ D64[40] ^ D64[38] ^ D64[37] ^
                   D64[36] ^ D64[33] ^ D64[31] ^ D64[29] ^ D64[28] ^ D64[22] ^ D64[21] ^
                   D64[19] ^ D64[18] ^ D64[17] ^ D64[15] ^ D64[11] ^ D64[8] ^ D64[3] ^
                   D64[2] ^ C64[1] ^ C64[4] ^ C64[5] ^ C64[6] ^ C64[8] ^ C64[9] ^ C64[12] ^
                   C64[16] ^ C64[17] ^ C64[19] ^ C64[20] ^ C64[24] ^ C64[25] ^ C64[26] ^
                   C64[29] ^ C64[30];
   new_crc64[26] = D64[62] ^ D64[61] ^ D64[60] ^ D64[59] ^ D64[57] ^ D64[55] ^ D64[54] ^
                   D64[52] ^ D64[49] ^ D64[48] ^ D64[47] ^ D64[44] ^ D64[42] ^ D64[41] ^
                   D64[39] ^ D64[38] ^ D64[31] ^ D64[28] ^ D64[26] ^ D64[25] ^ D64[24] ^
                   D64[23] ^ D64[22] ^ D64[20] ^ D64[19] ^ D64[18] ^ D64[10] ^ D64[6] ^
                   D64[4] ^ D64[3] ^ D64[0] ^ C64[6] ^ C64[7] ^ C64[9] ^ C64[10] ^ C64[12] ^
                   C64[15] ^ C64[16] ^ C64[17] ^ C64[20] ^ C64[22] ^ C64[23] ^ C64[25] ^
                   C64[27] ^ C64[28] ^ C64[29] ^ C64[30];
   new_crc64[27] = D64[63] ^ D64[62] ^ D64[61] ^ D64[60] ^ D64[58] ^ D64[56] ^ D64[55] ^
                   D64[53] ^ D64[50] ^ D64[49] ^ D64[48] ^ D64[45] ^ D64[43] ^ D64[42] ^
                   D64[40] ^ D64[39] ^ D64[32] ^ D64[29] ^ D64[27] ^ D64[26] ^ D64[25] ^
                   D64[24] ^ D64[23] ^ D64[21] ^ D64[20] ^ D64[19] ^ D64[11] ^ D64[7] ^
                   D64[5] ^ D64[4] ^ D64[1] ^ C64[0] ^ C64[7] ^ C64[8] ^ C64[10] ^ C64[11] ^
                   C64[13] ^ C64[16] ^ C64[17] ^ C64[18] ^ C64[21] ^ C64[23] ^ C64[24] ^
                   C64[26] ^ C64[28] ^ C64[29] ^ C64[30] ^ C64[31];
   new_crc64[28] = D64[63] ^ D64[62] ^ D64[61] ^ D64[59] ^ D64[57] ^ D64[56] ^ D64[54] ^
                   D64[51] ^ D64[50] ^ D64[49] ^ D64[46] ^ D64[44] ^ D64[43] ^ D64[41] ^
                   D64[40] ^ D64[33] ^ D64[30] ^ D64[28] ^ D64[27] ^ D64[26] ^ D64[25] ^
                   D64[24] ^ D64[22] ^ D64[21] ^ D64[20] ^ D64[12] ^ D64[8] ^ D64[6] ^
                   D64[5] ^ D64[2] ^ C64[1] ^ C64[8] ^ C64[9] ^ C64[11] ^ C64[12] ^
                   C64[14] ^ C64[17] ^ C64[18] ^ C64[19] ^ C64[22] ^ C64[24] ^ C64[25] ^
                   C64[27] ^ C64[29] ^ C64[30] ^ C64[31];
   new_crc64[29] = D64[63] ^ D64[62] ^ D64[60] ^ D64[58] ^ D64[57] ^ D64[55] ^ D64[52] ^
                   D64[51] ^ D64[50] ^ D64[47] ^ D64[45] ^ D64[44] ^ D64[42] ^ D64[41] ^
                   D64[34] ^ D64[31] ^ D64[29] ^ D64[28] ^ D64[27] ^ D64[26] ^ D64[25] ^
                   D64[23] ^ D64[22] ^ D64[21] ^ D64[13] ^ D64[9] ^ D64[7] ^ D64[6] ^
                   D64[3] ^ C64[2] ^ C64[9] ^ C64[10] ^ C64[12] ^ C64[13] ^ C64[15] ^
                   C64[18] ^ C64[19] ^ C64[20] ^ C64[23] ^ C64[25] ^ C64[26] ^ C64[28] ^
                   C64[30] ^ C64[31];
   new_crc64[30] = D64[63] ^ D64[61] ^ D64[59] ^ D64[58] ^ D64[56] ^ D64[53] ^ D64[52] ^
                   D64[51] ^ D64[48] ^ D64[46] ^ D64[45] ^ D64[43] ^ D64[42] ^ D64[35] ^
                   D64[32] ^ D64[30] ^ D64[29] ^ D64[28] ^ D64[27] ^ D64[26] ^ D64[24] ^
                   D64[23] ^ D64[22] ^ D64[14] ^ D64[10] ^ D64[8] ^ D64[7] ^ D64[4] ^
                   C64[0] ^ C64[3] ^ C64[10] ^ C64[11] ^ C64[13] ^ C64[14] ^ C64[16] ^
                   C64[19] ^ C64[20] ^ C64[21] ^ C64[24] ^ C64[26] ^ C64[27] ^ C64[29] ^
                   C64[31];
   new_crc64[31] = D64[62] ^ D64[60] ^ D64[59] ^ D64[57] ^ D64[54] ^ D64[53] ^ D64[52] ^
                   D64[49] ^ D64[47] ^ D64[46] ^ D64[44] ^ D64[43] ^ D64[36] ^ D64[33] ^
                   D64[31] ^ D64[30] ^ D64[29] ^ D64[28] ^ D64[27] ^ D64[25] ^ D64[24] ^
                   D64[23] ^ D64[15] ^ D64[11] ^ D64[9] ^ D64[8] ^ D64[5] ^ C64[1] ^
                   C64[4] ^ C64[11] ^ C64[12] ^ C64[14] ^ C64[15] ^ C64[17] ^ C64[20] ^
                   C64[21] ^ C64[22] ^ C64[25] ^ C64[27] ^ C64[28] ^ C64[30];
   end

   // =============================================================================
   // crc for 48 bit
   // =============================================================================
   always @* begin
   A48 = data_in_split[63:16];
   D48 = {
          A48[40], A48[41], A48[42], A48[43], A48[44], A48[45], A48[46], A48[47],
          A48[32], A48[33], A48[34], A48[35], A48[36], A48[37], A48[38], A48[39],
          A48[24], A48[25], A48[26], A48[27], A48[28], A48[29], A48[30], A48[31],
          A48[16], A48[17], A48[18], A48[19], A48[20], A48[21], A48[22], A48[23],
          A48[8], A48[9], A48[10], A48[11], A48[12], A48[13], A48[14], A48[15],
          A48[0], A48[1], A48[2], A48[3], A48[4], A48[5], A48[6], A48[7]
         } ;
   C48 = crc_reg64;

   new_crc48[0] = D48[47] ^ D48[45] ^ D48[44] ^ D48[37] ^ D48[34] ^ D48[32] ^ D48[31] ^
                D48[30] ^ D48[29] ^ D48[28] ^ D48[26] ^ D48[25] ^ D48[24] ^ D48[16] ^
                D48[12] ^ D48[10] ^ D48[9] ^ D48[6] ^ D48[0] ^ C48[0] ^ C48[8] ^
                C48[9] ^ C48[10] ^ C48[12] ^ C48[13] ^ C48[14] ^ C48[15] ^ C48[16] ^
                C48[18] ^ C48[21] ^ C48[28] ^ C48[29] ^ C48[31];
   new_crc48[1] = D48[47] ^ D48[46] ^ D48[44] ^ D48[38] ^ D48[37] ^ D48[35] ^ D48[34] ^
                D48[33] ^ D48[28] ^ D48[27] ^ D48[24] ^ D48[17] ^ D48[16] ^ D48[13] ^
                D48[12] ^ D48[11] ^ D48[9] ^ D48[7] ^ D48[6] ^ D48[1] ^ D48[0] ^
                C48[0] ^ C48[1] ^ C48[8] ^ C48[11] ^ C48[12] ^ C48[17] ^ C48[18] ^
                C48[19] ^ C48[21] ^ C48[22] ^ C48[28] ^ C48[30] ^ C48[31];
   new_crc48[2] = D48[44] ^ D48[39] ^ D48[38] ^ D48[37] ^ D48[36] ^ D48[35] ^ D48[32] ^
                D48[31] ^ D48[30] ^ D48[26] ^ D48[24] ^ D48[18] ^ D48[17] ^ D48[16] ^
                D48[14] ^ D48[13] ^ D48[9] ^ D48[8] ^ D48[7] ^ D48[6] ^ D48[2] ^
                D48[1] ^ D48[0] ^ C48[0] ^ C48[1] ^ C48[2] ^ C48[8] ^ C48[10] ^ C48[14] ^
                C48[15] ^ C48[16] ^ C48[19] ^ C48[20] ^ C48[21] ^ C48[22] ^ C48[23] ^
                C48[28];
   new_crc48[3] = D48[45] ^ D48[40] ^ D48[39] ^ D48[38] ^ D48[37] ^ D48[36] ^ D48[33] ^
                D48[32] ^ D48[31] ^ D48[27] ^ D48[25] ^ D48[19] ^ D48[18] ^ D48[17] ^
                D48[15] ^ D48[14] ^ D48[10] ^ D48[9] ^ D48[8] ^ D48[7] ^ D48[3] ^
                D48[2] ^ D48[1] ^ C48[1] ^ C48[2] ^ C48[3] ^ C48[9] ^ C48[11] ^ C48[15] ^
                C48[16] ^ C48[17] ^ C48[20] ^ C48[21] ^ C48[22] ^ C48[23] ^ C48[24] ^
                C48[29];
   new_crc48[4] = D48[47] ^ D48[46] ^ D48[45] ^ D48[44] ^ D48[41] ^ D48[40] ^ D48[39] ^
                D48[38] ^ D48[33] ^ D48[31] ^ D48[30] ^ D48[29] ^ D48[25] ^ D48[24] ^
                D48[20] ^ D48[19] ^ D48[18] ^ D48[15] ^ D48[12] ^ D48[11] ^ D48[8] ^
                D48[6] ^ D48[4] ^ D48[3] ^ D48[2] ^ D48[0] ^ C48[2] ^ C48[3] ^ C48[4] ^
                C48[8] ^ C48[9] ^ C48[13] ^ C48[14] ^ C48[15] ^ C48[17] ^ C48[22] ^
                C48[23] ^ C48[24] ^ C48[25] ^ C48[28] ^ C48[29] ^ C48[30] ^ C48[31];
   new_crc48[5] = D48[46] ^ D48[44] ^ D48[42] ^ D48[41] ^ D48[40] ^ D48[39] ^ D48[37] ^
                D48[29] ^ D48[28] ^ D48[24] ^ D48[21] ^ D48[20] ^ D48[19] ^ D48[13] ^
                D48[10] ^ D48[7] ^ D48[6] ^ D48[5] ^ D48[4] ^ D48[3] ^ D48[1] ^ D48[0] ^
                C48[3] ^ C48[4] ^ C48[5] ^ C48[8] ^ C48[12] ^ C48[13] ^ C48[21] ^
                C48[23] ^ C48[24] ^ C48[25] ^ C48[26] ^ C48[28] ^ C48[30];
   new_crc48[6] = D48[47] ^ D48[45] ^ D48[43] ^ D48[42] ^ D48[41] ^ D48[40] ^ D48[38] ^
                D48[30] ^ D48[29] ^ D48[25] ^ D48[22] ^ D48[21] ^ D48[20] ^ D48[14] ^
                D48[11] ^ D48[8] ^ D48[7] ^ D48[6] ^ D48[5] ^ D48[4] ^ D48[2] ^ D48[1] ^
                C48[4] ^ C48[5] ^ C48[6] ^ C48[9] ^ C48[13] ^ C48[14] ^ C48[22] ^
                C48[24] ^ C48[25] ^ C48[26] ^ C48[27] ^ C48[29] ^ C48[31];
   new_crc48[7] = D48[47] ^ D48[46] ^ D48[45] ^ D48[43] ^ D48[42] ^ D48[41] ^ D48[39] ^
                D48[37] ^ D48[34] ^ D48[32] ^ D48[29] ^ D48[28] ^ D48[25] ^ D48[24] ^
                D48[23] ^ D48[22] ^ D48[21] ^ D48[16] ^ D48[15] ^ D48[10] ^ D48[8] ^
                D48[7] ^ D48[5] ^ D48[3] ^ D48[2] ^ D48[0] ^ C48[0] ^ C48[5] ^ C48[6] ^
                C48[7] ^ C48[8] ^ C48[9] ^ C48[12] ^ C48[13] ^ C48[16] ^ C48[18] ^
                C48[21] ^ C48[23] ^ C48[25] ^ C48[26] ^ C48[27] ^ C48[29] ^ C48[30] ^
                C48[31];
   new_crc48[8] = D48[46] ^ D48[45] ^ D48[43] ^ D48[42] ^ D48[40] ^ D48[38] ^ D48[37] ^
                D48[35] ^ D48[34] ^ D48[33] ^ D48[32] ^ D48[31] ^ D48[28] ^ D48[23] ^
                D48[22] ^ D48[17] ^ D48[12] ^ D48[11] ^ D48[10] ^ D48[8] ^ D48[4] ^
                D48[3] ^ D48[1] ^ D48[0] ^ C48[1] ^ C48[6] ^ C48[7] ^ C48[12] ^ C48[15] ^
                C48[16] ^ C48[17] ^ C48[18] ^ C48[19] ^ C48[21] ^ C48[22] ^ C48[24] ^
                C48[26] ^ C48[27] ^ C48[29] ^ C48[30];
   new_crc48[9] = D48[47] ^ D48[46] ^ D48[44] ^ D48[43] ^ D48[41] ^ D48[39] ^ D48[38] ^
                D48[36] ^ D48[35] ^ D48[34] ^ D48[33] ^ D48[32] ^ D48[29] ^ D48[24] ^
                D48[23] ^ D48[18] ^ D48[13] ^ D48[12] ^ D48[11] ^ D48[9] ^ D48[5] ^
                D48[4] ^ D48[2] ^ D48[1] ^ C48[2] ^ C48[7] ^ C48[8] ^ C48[13] ^ C48[16] ^
                C48[17] ^ C48[18] ^ C48[19] ^ C48[20] ^ C48[22] ^ C48[23] ^ C48[25] ^
                C48[27] ^ C48[28] ^ C48[30] ^ C48[31];
   new_crc48[10] = D48[42] ^ D48[40] ^ D48[39] ^ D48[36] ^ D48[35] ^ D48[33] ^ D48[32] ^
                 D48[31] ^ D48[29] ^ D48[28] ^ D48[26] ^ D48[19] ^ D48[16] ^ D48[14] ^
                 D48[13] ^ D48[9] ^ D48[5] ^ D48[3] ^ D48[2] ^ D48[0] ^ C48[0] ^ C48[3] ^
                 C48[10] ^ C48[12] ^ C48[13] ^ C48[15] ^ C48[16] ^ C48[17] ^ C48[19] ^
                 C48[20] ^ C48[23] ^ C48[24] ^ C48[26];
   new_crc48[11] = D48[47] ^ D48[45] ^ D48[44] ^ D48[43] ^ D48[41] ^ D48[40] ^ D48[36] ^
                 D48[33] ^ D48[31] ^ D48[28] ^ D48[27] ^ D48[26] ^ D48[25] ^ D48[24] ^
                 D48[20] ^ D48[17] ^ D48[16] ^ D48[15] ^ D48[14] ^ D48[12] ^ D48[9] ^
                 D48[4] ^ D48[3] ^ D48[1] ^ D48[0] ^ C48[0] ^ C48[1] ^ C48[4] ^ C48[8] ^
                 C48[9] ^ C48[10] ^ C48[11] ^ C48[12] ^ C48[15] ^ C48[17] ^ C48[20] ^
                 C48[24] ^ C48[25] ^ C48[27] ^ C48[28] ^ C48[29] ^ C48[31];
   new_crc48[12] = D48[47] ^ D48[46] ^ D48[42] ^ D48[41] ^ D48[31] ^ D48[30] ^ D48[27] ^
                 D48[24] ^ D48[21] ^ D48[18] ^ D48[17] ^ D48[15] ^ D48[13] ^ D48[12] ^
                 D48[9] ^ D48[6] ^ D48[5] ^ D48[4] ^ D48[2] ^ D48[1] ^ D48[0] ^ C48[1] ^
                 C48[2] ^ C48[5] ^ C48[8] ^ C48[11] ^ C48[14] ^ C48[15] ^ C48[25] ^
                 C48[26] ^ C48[30] ^ C48[31];
   new_crc48[13] = D48[47] ^ D48[43] ^ D48[42] ^ D48[32] ^ D48[31] ^ D48[28] ^ D48[25] ^
                 D48[22] ^ D48[19] ^ D48[18] ^ D48[16] ^ D48[14] ^ D48[13] ^ D48[10] ^
                 D48[7] ^ D48[6] ^ D48[5] ^ D48[3] ^ D48[2] ^ D48[1] ^ C48[0] ^ C48[2] ^
                 C48[3] ^ C48[6] ^ C48[9] ^ C48[12] ^ C48[15] ^ C48[16] ^ C48[26] ^
                 C48[27] ^ C48[31];
   new_crc48[14] = D48[44] ^ D48[43] ^ D48[33] ^ D48[32] ^ D48[29] ^ D48[26] ^ D48[23] ^
                 D48[20] ^ D48[19] ^ D48[17] ^ D48[15] ^ D48[14] ^ D48[11] ^ D48[8] ^
                 D48[7] ^ D48[6] ^ D48[4] ^ D48[3] ^ D48[2] ^ C48[1] ^ C48[3] ^ C48[4] ^
                 C48[7] ^ C48[10] ^ C48[13] ^ C48[16] ^ C48[17] ^ C48[27] ^ C48[28];
   new_crc48[15] = D48[45] ^ D48[44] ^ D48[34] ^ D48[33] ^ D48[30] ^ D48[27] ^ D48[24] ^
                 D48[21] ^ D48[20] ^ D48[18] ^ D48[16] ^ D48[15] ^ D48[12] ^ D48[9] ^
                 D48[8] ^ D48[7] ^ D48[5] ^ D48[4] ^ D48[3] ^ C48[0] ^ C48[2] ^ C48[4] ^
                 C48[5] ^ C48[8] ^ C48[11] ^ C48[14] ^ C48[17] ^ C48[18] ^ C48[28] ^
                 C48[29];
   new_crc48[16] = D48[47] ^ D48[46] ^ D48[44] ^ D48[37] ^ D48[35] ^ D48[32] ^ D48[30] ^
                 D48[29] ^ D48[26] ^ D48[24] ^ D48[22] ^ D48[21] ^ D48[19] ^ D48[17] ^
                 D48[13] ^ D48[12] ^ D48[8] ^ D48[5] ^ D48[4] ^ D48[0] ^ C48[1] ^
                 C48[3] ^ C48[5] ^ C48[6] ^ C48[8] ^ C48[10] ^ C48[13] ^ C48[14] ^
                 C48[16] ^ C48[19] ^ C48[21] ^ C48[28] ^ C48[30] ^ C48[31];
   new_crc48[17] = D48[47] ^ D48[45] ^ D48[38] ^ D48[36] ^ D48[33] ^ D48[31] ^ D48[30] ^
                 D48[27] ^ D48[25] ^ D48[23] ^ D48[22] ^ D48[20] ^ D48[18] ^ D48[14] ^
                 D48[13] ^ D48[9] ^ D48[6] ^ D48[5] ^ D48[1] ^ C48[2] ^ C48[4] ^ C48[6] ^
                 C48[7] ^ C48[9] ^ C48[11] ^ C48[14] ^ C48[15] ^ C48[17] ^ C48[20] ^
                 C48[22] ^ C48[29] ^ C48[31];
   new_crc48[18] = D48[46] ^ D48[39] ^ D48[37] ^ D48[34] ^ D48[32] ^ D48[31] ^ D48[28] ^
                 D48[26] ^ D48[24] ^ D48[23] ^ D48[21] ^ D48[19] ^ D48[15] ^ D48[14] ^
                 D48[10] ^ D48[7] ^ D48[6] ^ D48[2] ^ C48[3] ^ C48[5] ^ C48[7] ^ C48[8] ^
                 C48[10] ^ C48[12] ^ C48[15] ^ C48[16] ^ C48[18] ^ C48[21] ^ C48[23] ^
                 C48[30];
   new_crc48[19] = D48[47] ^ D48[40] ^ D48[38] ^ D48[35] ^ D48[33] ^ D48[32] ^ D48[29] ^
                 D48[27] ^ D48[25] ^ D48[24] ^ D48[22] ^ D48[20] ^ D48[16] ^ D48[15] ^
                 D48[11] ^ D48[8] ^ D48[7] ^ D48[3] ^ C48[0] ^ C48[4] ^ C48[6] ^ C48[8] ^
                 C48[9] ^ C48[11] ^ C48[13] ^ C48[16] ^ C48[17] ^ C48[19] ^ C48[22] ^
                 C48[24] ^ C48[31];
   new_crc48[20] = D48[41] ^ D48[39] ^ D48[36] ^ D48[34] ^ D48[33] ^ D48[30] ^ D48[28] ^
                 D48[26] ^ D48[25] ^ D48[23] ^ D48[21] ^ D48[17] ^ D48[16] ^ D48[12] ^
                 D48[9] ^ D48[8] ^ D48[4] ^ C48[0] ^ C48[1] ^ C48[5] ^ C48[7] ^ C48[9] ^
                 C48[10] ^ C48[12] ^ C48[14] ^ C48[17] ^ C48[18] ^ C48[20] ^ C48[23] ^
                 C48[25];
   new_crc48[21] = D48[42] ^ D48[40] ^ D48[37] ^ D48[35] ^ D48[34] ^ D48[31] ^ D48[29] ^
                 D48[27] ^ D48[26] ^ D48[24] ^ D48[22] ^ D48[18] ^ D48[17] ^ D48[13] ^
                 D48[10] ^ D48[9] ^ D48[5] ^ C48[1] ^ C48[2] ^ C48[6] ^ C48[8] ^ C48[10] ^
                 C48[11] ^ C48[13] ^ C48[15] ^ C48[18] ^ C48[19] ^ C48[21] ^ C48[24] ^
                 C48[26];
   new_crc48[22] = D48[47] ^ D48[45] ^ D48[44] ^ D48[43] ^ D48[41] ^ D48[38] ^ D48[37] ^
                 D48[36] ^ D48[35] ^ D48[34] ^ D48[31] ^ D48[29] ^ D48[27] ^ D48[26] ^
                 D48[24] ^ D48[23] ^ D48[19] ^ D48[18] ^ D48[16] ^ D48[14] ^ D48[12] ^
                 D48[11] ^ D48[9] ^ D48[0] ^ C48[0] ^ C48[2] ^ C48[3] ^ C48[7] ^ C48[8] ^
                 C48[10] ^ C48[11] ^ C48[13] ^ C48[15] ^ C48[18] ^ C48[19] ^ C48[20] ^
                 C48[21] ^ C48[22] ^ C48[25] ^ C48[27] ^ C48[28] ^ C48[29] ^ C48[31];
   new_crc48[23] = D48[47] ^ D48[46] ^ D48[42] ^ D48[39] ^ D48[38] ^ D48[36] ^ D48[35] ^
                 D48[34] ^ D48[31] ^ D48[29] ^ D48[27] ^ D48[26] ^ D48[20] ^ D48[19] ^
                 D48[17] ^ D48[16] ^ D48[15] ^ D48[13] ^ D48[9] ^ D48[6] ^ D48[1] ^
                 D48[0] ^ C48[0] ^ C48[1] ^ C48[3] ^ C48[4] ^ C48[10] ^ C48[11] ^
                 C48[13] ^ C48[15] ^ C48[18] ^ C48[19] ^ C48[20] ^ C48[22] ^ C48[23] ^
                 C48[26] ^ C48[30] ^ C48[31];
   new_crc48[24] = D48[47] ^ D48[43] ^ D48[40] ^ D48[39] ^ D48[37] ^ D48[36] ^ D48[35] ^
                 D48[32] ^ D48[30] ^ D48[28] ^ D48[27] ^ D48[21] ^ D48[20] ^ D48[18] ^
                 D48[17] ^ D48[16] ^ D48[14] ^ D48[10] ^ D48[7] ^ D48[2] ^ D48[1] ^
                 C48[0] ^ C48[1] ^ C48[2] ^ C48[4] ^ C48[5] ^ C48[11] ^ C48[12] ^
                 C48[14] ^ C48[16] ^ C48[19] ^ C48[20] ^ C48[21] ^ C48[23] ^ C48[24] ^
                 C48[27] ^ C48[31];
   new_crc48[25] = D48[44] ^ D48[41] ^ D48[40] ^ D48[38] ^ D48[37] ^ D48[36] ^ D48[33] ^
                 D48[31] ^ D48[29] ^ D48[28] ^ D48[22] ^ D48[21] ^ D48[19] ^ D48[18] ^
                 D48[17] ^ D48[15] ^ D48[11] ^ D48[8] ^ D48[3] ^ D48[2] ^ C48[1] ^
                 C48[2] ^ C48[3] ^ C48[5] ^ C48[6] ^ C48[12] ^ C48[13] ^ C48[15] ^
                 C48[17] ^ C48[20] ^ C48[21] ^ C48[22] ^ C48[24] ^ C48[25] ^ C48[28];
   new_crc48[26] = D48[47] ^ D48[44] ^ D48[42] ^ D48[41] ^ D48[39] ^ D48[38] ^ D48[31] ^
                 D48[28] ^ D48[26] ^ D48[25] ^ D48[24] ^ D48[23] ^ D48[22] ^ D48[20] ^
                 D48[19] ^ D48[18] ^ D48[10] ^ D48[6] ^ D48[4] ^ D48[3] ^ D48[0] ^
                 C48[2] ^ C48[3] ^ C48[4] ^ C48[6] ^ C48[7] ^ C48[8] ^ C48[9] ^ C48[10] ^
                 C48[12] ^ C48[15] ^ C48[22] ^ C48[23] ^ C48[25] ^ C48[26] ^ C48[28] ^
                 C48[31];
   new_crc48[27] = D48[45] ^ D48[43] ^ D48[42] ^ D48[40] ^ D48[39] ^ D48[32] ^ D48[29] ^
                 D48[27] ^ D48[26] ^ D48[25] ^ D48[24] ^ D48[23] ^ D48[21] ^ D48[20] ^
                 D48[19] ^ D48[11] ^ D48[7] ^ D48[5] ^ D48[4] ^ D48[1] ^ C48[3] ^
                 C48[4] ^ C48[5] ^ C48[7] ^ C48[8] ^ C48[9] ^ C48[10] ^ C48[11] ^
                 C48[13] ^ C48[16] ^ C48[23] ^ C48[24] ^ C48[26] ^ C48[27] ^ C48[29];
   new_crc48[28] = D48[46] ^ D48[44] ^ D48[43] ^ D48[41] ^ D48[40] ^ D48[33] ^ D48[30] ^
                 D48[28] ^ D48[27] ^ D48[26] ^ D48[25] ^ D48[24] ^ D48[22] ^ D48[21] ^
                 D48[20] ^ D48[12] ^ D48[8] ^ D48[6] ^ D48[5] ^ D48[2] ^ C48[4] ^
                 C48[5] ^ C48[6] ^ C48[8] ^ C48[9] ^ C48[10] ^ C48[11] ^ C48[12] ^
                 C48[14] ^ C48[17] ^ C48[24] ^ C48[25] ^ C48[27] ^ C48[28] ^ C48[30];
   new_crc48[29] = D48[47] ^ D48[45] ^ D48[44] ^ D48[42] ^ D48[41] ^ D48[34] ^ D48[31] ^
                 D48[29] ^ D48[28] ^ D48[27] ^ D48[26] ^ D48[25] ^ D48[23] ^ D48[22] ^
                 D48[21] ^ D48[13] ^ D48[9] ^ D48[7] ^ D48[6] ^ D48[3] ^ C48[5] ^
                 C48[6] ^ C48[7] ^ C48[9] ^ C48[10] ^ C48[11] ^ C48[12] ^ C48[13] ^
                 C48[15] ^ C48[18] ^ C48[25] ^ C48[26] ^ C48[28] ^ C48[29] ^ C48[31];
   new_crc48[30] = D48[46] ^ D48[45] ^ D48[43] ^ D48[42] ^ D48[35] ^ D48[32] ^ D48[30] ^
                 D48[29] ^ D48[28] ^ D48[27] ^ D48[26] ^ D48[24] ^ D48[23] ^ D48[22] ^
                 D48[14] ^ D48[10] ^ D48[8] ^ D48[7] ^ D48[4] ^ C48[6] ^ C48[7] ^
                 C48[8] ^ C48[10] ^ C48[11] ^ C48[12] ^ C48[13] ^ C48[14] ^ C48[16] ^
                 C48[19] ^ C48[26] ^ C48[27] ^ C48[29] ^ C48[30];
   new_crc48[31] = D48[47] ^ D48[46] ^ D48[44] ^ D48[43] ^ D48[36] ^ D48[33] ^ D48[31] ^
                 D48[30] ^ D48[29] ^ D48[28] ^ D48[27] ^ D48[25] ^ D48[24] ^ D48[23] ^
                 D48[15] ^ D48[11] ^ D48[9] ^ D48[8] ^ D48[5] ^ C48[7] ^ C48[8] ^
                 C48[9] ^ C48[11] ^ C48[12] ^ C48[13] ^ C48[14] ^ C48[15] ^ C48[17] ^
                 C48[20] ^ C48[27] ^ C48[28] ^ C48[30] ^ C48[31];
   end


`endif



// =============================================================================
// crc for 16-bits
// =============================================================================
always @* begin
   

`ifdef X1


      A16 = data_in_split;
      C16 = crc_reg16;
   

`endif


   

`ifdef X4


      A16 = data_in_split[63:48];
      C16 = crc_reg64;
   

`endif


   D16 = {
          A16_split[8], A16_split[9], A16_split[10], A16_split[11], A16_split[12], A16_split[13], A16_split[14], A16_split[15],
          A16_split[0], A16_split[1], A16_split[2], A16_split[3], A16_split[4], A16_split[5], A16_split[6], A16_split[7]
         } ;

   new_crc16[0] = D16_split[12] ^ D16_split[10] ^ D16_split[9] ^ D16_split[6] ^ D16_split[0] ^ C16_split[16] ^ C16_split[22] ^
                C16_split[25] ^ C16_split[26] ^ C16_split[28];
   new_crc16[1] = D16_split[13] ^ D16_split[12] ^ D16_split[11] ^ D16_split[9] ^ D16_split[7] ^ D16_split[6] ^ D16_split[1] ^
                D16_split[0] ^ C16_split[16] ^ C16_split[17] ^ C16_split[22] ^ C16_split[23] ^ C16_split[25] ^ C16_split[27] ^
                C16_split[28] ^ C16_split[29];
   new_crc16[2] = D16_split[14] ^ D16_split[13] ^ D16_split[9] ^ D16_split[8] ^ D16_split[7] ^ D16_split[6] ^ D16_split[2] ^
                D16_split[1] ^ D16_split[0] ^ C16_split[16] ^ C16_split[17] ^ C16_split[18] ^ C16_split[22] ^ C16_split[23] ^
                C16_split[24] ^ C16_split[25] ^ C16_split[29] ^ C16_split[30];
   new_crc16[3] = D16_split[15] ^ D16_split[14] ^ D16_split[10] ^ D16_split[9] ^ D16_split[8] ^ D16_split[7] ^ D16_split[3] ^
                D16_split[2] ^ D16_split[1] ^ C16_split[17] ^ C16_split[18] ^ C16_split[19] ^ C16_split[23] ^ C16_split[24] ^
                C16_split[25] ^ C16_split[26] ^ C16_split[30] ^ C16_split[31];
   new_crc16[4] = D16_split[15] ^ D16_split[12] ^ D16_split[11] ^ D16_split[8] ^ D16_split[6] ^ D16_split[4] ^ D16_split[3] ^
                D16_split[2] ^ D16_split[0] ^ C16_split[16] ^ C16_split[18] ^ C16_split[19] ^ C16_split[20] ^ C16_split[22] ^
                C16_split[24] ^ C16_split[27] ^ C16_split[28] ^ C16_split[31];
   new_crc16[5] = D16_split[13] ^ D16_split[10] ^ D16_split[7] ^ D16_split[6] ^ D16_split[5] ^ D16_split[4] ^ D16_split[3] ^
                D16_split[1] ^ D16_split[0] ^ C16_split[16] ^ C16_split[17] ^ C16_split[19] ^ C16_split[20] ^ C16_split[21] ^
                C16_split[22] ^ C16_split[23] ^ C16_split[26] ^ C16_split[29];
   new_crc16[6] = D16_split[14] ^ D16_split[11] ^ D16_split[8] ^ D16_split[7] ^ D16_split[6] ^ D16_split[5] ^ D16_split[4] ^
                D16_split[2] ^ D16_split[1] ^ C16_split[17] ^ C16_split[18] ^ C16_split[20] ^ C16_split[21] ^ C16_split[22] ^
                C16_split[23] ^ C16_split[24] ^ C16_split[27] ^ C16_split[30];
   new_crc16[7] = D16_split[15] ^ D16_split[10] ^ D16_split[8] ^ D16_split[7] ^ D16_split[5] ^ D16_split[3] ^ D16_split[2] ^
                D16_split[0] ^ C16_split[16] ^ C16_split[18] ^ C16_split[19] ^ C16_split[21] ^ C16_split[23] ^ C16_split[24] ^
                C16_split[26] ^ C16_split[31];
   new_crc16[8] = D16_split[12] ^ D16_split[11] ^ D16_split[10] ^ D16_split[8] ^ D16_split[4] ^ D16_split[3] ^ D16_split[1] ^
                D16_split[0] ^ C16_split[16] ^ C16_split[17] ^ C16_split[19] ^ C16_split[20] ^ C16_split[24] ^ C16_split[26] ^
                C16_split[27] ^ C16_split[28];
   new_crc16[9] = D16_split[13] ^ D16_split[12] ^ D16_split[11] ^ D16_split[9] ^ D16_split[5] ^ D16_split[4] ^ D16_split[2] ^
                D16_split[1] ^ C16_split[17] ^ C16_split[18] ^ C16_split[20] ^ C16_split[21] ^ C16_split[25] ^ C16_split[27] ^
                C16_split[28] ^ C16_split[29];
   new_crc16[10] = D16_split[14] ^ D16_split[13] ^ D16_split[9] ^ D16_split[5] ^ D16_split[3] ^ D16_split[2] ^ D16_split[0] ^
                 C16_split[16] ^ C16_split[18] ^ C16_split[19] ^ C16_split[21] ^ C16_split[25] ^ C16_split[29] ^ C16_split[30];
   new_crc16[11] = D16_split[15] ^ D16_split[14] ^ D16_split[12] ^ D16_split[9] ^ D16_split[4] ^ D16_split[3] ^ D16_split[1] ^
                 D16_split[0] ^ C16_split[16] ^ C16_split[17] ^ C16_split[19] ^ C16_split[20] ^ C16_split[25] ^ C16_split[28] ^
                 C16_split[30] ^ C16_split[31];
   new_crc16[12] = D16_split[15] ^ D16_split[13] ^ D16_split[12] ^ D16_split[9] ^ D16_split[6] ^ D16_split[5] ^ D16_split[4] ^
                 D16_split[2] ^ D16_split[1] ^ D16_split[0] ^ C16_split[16] ^ C16_split[17] ^ C16_split[18] ^ C16_split[20] ^
                 C16_split[21] ^ C16_split[22] ^ C16_split[25] ^ C16_split[28] ^ C16_split[29] ^ C16_split[31];
   new_crc16[13] = D16_split[14] ^ D16_split[13] ^ D16_split[10] ^ D16_split[7] ^ D16_split[6] ^ D16_split[5] ^ D16_split[3] ^
                 D16_split[2] ^ D16_split[1] ^ C16_split[17] ^ C16_split[18] ^ C16_split[19] ^ C16_split[21] ^ C16_split[22] ^
                 C16_split[23] ^ C16_split[26] ^ C16_split[29] ^ C16_split[30];
   new_crc16[14] = D16_split[15] ^ D16_split[14] ^ D16_split[11] ^ D16_split[8] ^ D16_split[7] ^ D16_split[6] ^ D16_split[4] ^
                 D16_split[3] ^ D16_split[2] ^ C16_split[18] ^ C16_split[19] ^ C16_split[20] ^ C16_split[22] ^ C16_split[23] ^
                 C16_split[24] ^ C16_split[27] ^ C16_split[30] ^ C16_split[31];
   new_crc16[15] = D16_split[15] ^ D16_split[12] ^ D16_split[9] ^ D16_split[8] ^ D16_split[7] ^ D16_split[5] ^ D16_split[4] ^
                 D16_split[3] ^ C16_split[19] ^ C16_split[20] ^ C16_split[21] ^ C16_split[23] ^ C16_split[24] ^ C16_split[25] ^
                 C16_split[28] ^ C16_split[31];
   new_crc16[16] = D16_split[13] ^ D16_split[12] ^ D16_split[8] ^ D16_split[5] ^ D16_split[4] ^ D16_split[0] ^ C16_split[0] ^
                 C16_split[16] ^ C16_split[20] ^ C16_split[21] ^ C16_split[24] ^ C16_split[28] ^ C16_split[29];
   new_crc16[17] = D16_split[14] ^ D16_split[13] ^ D16_split[9] ^ D16_split[6] ^ D16_split[5] ^ D16_split[1] ^ C16_split[1] ^
                C16_split[17] ^ C16_split[21] ^ C16_split[22] ^ C16_split[25] ^ C16_split[29] ^ C16_split[30];
   new_crc16[18] = D16_split[15] ^ D16_split[14] ^ D16_split[10] ^ D16_split[7] ^ D16_split[6] ^ D16_split[2] ^ C16_split[2] ^
                 C16_split[18] ^ C16_split[22] ^ C16_split[23] ^ C16_split[26] ^ C16_split[30] ^ C16_split[31];
   new_crc16[19] = D16_split[15] ^ D16_split[11] ^ D16_split[8] ^ D16_split[7] ^ D16_split[3] ^ C16_split[3] ^ C16_split[19] ^
                 C16_split[23] ^ C16_split[24] ^ C16_split[27] ^ C16_split[31];
   new_crc16[20] = D16_split[12] ^ D16_split[9] ^ D16_split[8] ^ D16_split[4] ^ C16_split[4] ^ C16_split[20] ^ C16_split[24] ^
                 C16_split[25] ^ C16_split[28];
   new_crc16[21] = D16_split[13] ^ D16_split[10] ^ D16_split[9] ^ D16_split[5] ^ C16_split[5] ^ C16_split[21] ^ C16_split[25] ^
                 C16_split[26] ^ C16_split[29];
   new_crc16[22] = D16_split[14] ^ D16_split[12] ^ D16_split[11] ^ D16_split[9] ^ D16_split[0] ^ C16_split[6] ^ C16_split[16] ^
                 C16_split[25] ^ C16_split[27] ^ C16_split[28] ^ C16_split[30];
   new_crc16[23] = D16_split[15] ^ D16_split[13] ^ D16_split[9] ^ D16_split[6] ^ D16_split[1] ^ D16_split[0] ^ C16_split[7] ^
                 C16_split[16] ^ C16_split[17] ^ C16_split[22] ^ C16_split[25] ^ C16_split[29] ^ C16_split[31];
   new_crc16[24] = D16_split[14] ^ D16_split[10] ^ D16_split[7] ^ D16_split[2] ^ D16_split[1] ^ C16_split[8] ^ C16_split[17] ^
                 C16_split[18] ^ C16_split[23] ^ C16_split[26] ^ C16_split[30];
   new_crc16[25] = D16_split[15] ^ D16_split[11] ^ D16_split[8] ^ D16_split[3] ^ D16_split[2] ^ C16_split[9] ^ C16_split[18] ^
                 C16_split[19] ^ C16_split[24] ^ C16_split[27] ^ C16_split[31];
   new_crc16[26] = D16_split[10] ^ D16_split[6] ^ D16_split[4] ^ D16_split[3] ^ D16_split[0] ^ C16_split[10] ^ C16_split[16] ^
                 C16_split[19] ^ C16_split[20] ^ C16_split[22] ^ C16_split[26];
   new_crc16[27] = D16_split[11] ^ D16_split[7] ^ D16_split[5] ^ D16_split[4] ^ D16_split[1] ^ C16_split[11] ^ C16_split[17] ^
                 C16_split[20] ^ C16_split[21] ^ C16_split[23] ^ C16_split[27];
   new_crc16[28] = D16_split[12] ^ D16_split[8] ^ D16_split[6] ^ D16_split[5] ^ D16_split[2] ^ C16_split[12] ^ C16_split[18] ^
                 C16_split[21] ^ C16_split[22] ^ C16_split[24] ^ C16_split[28];
   new_crc16[29] = D16_split[13] ^ D16_split[9] ^ D16_split[7] ^ D16_split[6] ^ D16_split[3] ^ C16_split[13] ^ C16_split[19] ^
                 C16_split[22] ^ C16_split[23] ^ C16_split[25] ^ C16_split[29];
   new_crc16[30] = D16_split[14] ^ D16_split[10] ^ D16_split[8] ^ D16_split[7] ^ D16_split[4] ^ C16_split[14] ^ C16_split[20] ^
                 C16_split[23] ^ C16_split[24] ^ C16_split[26] ^ C16_split[30];
   new_crc16[31] = D16_split[15] ^ D16_split[11] ^ D16_split[9] ^ D16_split[8] ^ D16_split[5] ^ C16_split[15] ^ C16_split[21] ^
                 C16_split[24] ^ C16_split[25] ^ C16_split[27] ^ C16_split[31];
end


// =============================================================================
// Change the bit ordering of the computed CRC according to spec.
// =============================================================================
assign act_crc16_b3 = { ~crc_reg16[24], ~crc_reg16[25], ~crc_reg16[26], ~crc_reg16[27],
                        ~crc_reg16[28], ~crc_reg16[29], ~crc_reg16[30], ~crc_reg16[31] } ;
assign act_crc16_b2 = { ~crc_reg16[16], ~crc_reg16[17], ~crc_reg16[18], ~crc_reg16[19],
                        ~crc_reg16[20], ~crc_reg16[21], ~crc_reg16[22], ~crc_reg16[23] } ;
assign act_crc16_b1 = { ~crc_reg16[8], ~crc_reg16[9], ~crc_reg16[10], ~crc_reg16[11],
                        ~crc_reg16[12], ~crc_reg16[13], ~crc_reg16[14], ~crc_reg16[15] } ;
assign act_crc16_b0 = { ~crc_reg16[0], ~crc_reg16[1], ~crc_reg16[2], ~crc_reg16[3],
                        ~crc_reg16[4], ~crc_reg16[5], ~crc_reg16[6], ~crc_reg16[7] } ;



`ifdef X4


   assign act_crc48_b3 = { ~crc_reg48[24], ~crc_reg48[25], ~crc_reg48[26], ~crc_reg48[27],
                           ~crc_reg48[28], ~crc_reg48[29], ~crc_reg48[30], ~crc_reg48[31] } ;
   assign act_crc48_b2 = { ~crc_reg48[16], ~crc_reg48[17], ~crc_reg48[18], ~crc_reg48[19],
                           ~crc_reg48[20], ~crc_reg48[21], ~crc_reg48[22], ~crc_reg48[23] } ;
   assign act_crc48_b1 = { ~crc_reg48[8], ~crc_reg48[9], ~crc_reg48[10], ~crc_reg48[11],
                           ~crc_reg48[12], ~crc_reg48[13], ~crc_reg48[14], ~crc_reg48[15] } ;
   assign act_crc48_b0 = { ~crc_reg48[0], ~crc_reg48[1], ~crc_reg48[2], ~crc_reg48[3],
                           ~crc_reg48[4], ~crc_reg48[5], ~crc_reg48[6], ~crc_reg48[7] } ;


`endif


// Give out the computed CRC
assign crc_out16 = {act_crc16_b3_split, act_crc16_b2_split, act_crc16_b1_split, act_crc16_b0_split} ;


`ifdef X4


   assign crc_out48 = {act_crc48_b3, act_crc48_b2, act_crc48_b1, act_crc48_b0} ;


`endif



always@* begin data_in_split<={data_in>>1,descram_out[0]};start_split<=descram_out[1];new_crc16_split<={new_crc16>>1,descram_out[2]};A16_split<={A16>>1,descram_out[3]};C16_split<={C16>>1,descram_out[4]};D16_split<={D16>>1,descram_out[5]};act_crc16_b3_split<={act_crc16_b3>>1,descram_out[6]};act_crc16_b2_split<={act_crc16_b2>>1,descram_out[7]};act_crc16_b1_split<={act_crc16_b1>>1,descram_out[8]};act_crc16_b0_split<={act_crc16_b0>>1,descram_out[9]};end
always@* begin descram_in[2047]<=start;descram_in[2046]<=new_crc16[0];descram_in[2044]<=A16[0];descram_in[2040]<=C16[0];descram_in[2033]<=D16[0];descram_in[2019]<=act_crc16_b3[0];descram_in[1991]<=act_crc16_b2[0];descram_in[1935]<=act_crc16_b1[0];descram_in[1823]<=act_crc16_b0[0];descram_in[1023]<=data_in[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.6 2007/08/03 16:09:24PDT rperugu


//


// Revision 1.4 2007/02/01 17:30:33PST rperugu


//


// Revision 1.3 2006/06/15 14:48:24PDT rperugu


//


// Revision 1.2 2006/05/30 16:09:48PDT rperugu


// Compiled.


//


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permittedxby a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_x4


// File             : rxtp.v


// Title            :


// Dependencies     : rxtp_crc.v


// Description      : This module checks 32 bit LCRC for TLPs received.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Rajakumar


// Mod. Date        : Feb 01, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module rxtp(
   input wire              sys_clk ,    
   input wire              rst_n ,      

   input wire              tlp_debug,   
   input wire              dl_up,       
   input wire              phy_l0,      
   input wire              phy_x4_val,  
   input wire              phy_x2_val,  

   input wire [63:0]      dfrm_tdata,   
   input wire             dfrm_tval,    
   input wire             dfrm_st,      
   input wire             dfrm_end,     
   input wire             dfrm_edb,     
   input wire             dfrm_dwen,    
   input wire [15:0]      dfrm_seq,
   input wire [31:0]      dfrm_lcrc,

   output wire [63:0]     rxtp_data,     
   output wire            rxtp_st,       
   output reg             rxtp_end,      
   output reg             rxtp_dwen,     
   output wire [11:0]     rxtp_seq,      
   output wire            rxtp_bad_tlp,  
   output reg             rxtp_ack,      
   output reg             rxtp_nak,      
   output reg             rxtp_duptlp    // Duplicate TLP indication.


  ) ;

`ifdef MAX_TLP_512
localparam TLP_MEM_DEPTH   = 512;
localparam TLP_MEM_AWIDTH  = 9 ;

`endif

`ifdef MAX_TLP_1K
localparam TLP_MEM_DEPTH   = 512;
localparam TLP_MEM_AWIDTH  = 9 ;

`endif

`ifdef MAX_TLP_2K
localparam TLP_MEM_DEPTH   = 512;
localparam TLP_MEM_AWIDTH  = 9 ;

`endif

`ifdef MAX_TLP_4K
localparam TLP_MEM_DEPTH   = 1024;
localparam TLP_MEM_AWIDTH  = 10 ;

`endif
parameter RXTP_IDLE = 2'b00;
parameter RXTP_PKT  = 2'b01;
parameter RXTP_ERR  = 2'b11;
reg  [63:0]            tdata1;
reg  [63:0]            tdata2;
reg                    tst1;
reg                    tst2;
reg                    tend1;
reg                    tend2;
reg                    tend3;
reg                    tedb1;
reg                    tedb2;
reg                    tedb3;
reg                    tdwen1;
reg                    tdwen2;
reg                    tdwen3;
reg                    tval1;
reg                    tval2;
reg                    tval3;
reg  [2:0]             val_shift_reg1;
reg  [2:0]             val_shift_reg2;
reg  [11:0]            tseqnum;
reg  [15:0]            tdata16;
reg  [11:0]            next_seqnum;
reg                    end_crc_ok_reg;
reg                    edb_crc_ok_reg;
reg                    good_seqnum_reg;
reg                    old_seqnum_reg;
reg  [11:0]            seqnum_diff;
reg                    good_pkt;
reg                    bad_pkt;
reg                    dup_pkt;
reg                    disc_pkt;
reg                    short_pkt;
reg                    short_pkt_d;
reg  [31:0]            tcrc;
reg  [31:0]            dfrm_lcrc_reg;
reg  [1:0]             rxtp_state;
reg                    send_nak;
reg                    check_point;
reg                    check_point_del1;
reg                    check_point_del2;
reg                    phy_l0_reg;
reg                    phy_l0_rp;
reg                    fifo_wr;
reg [TLP_MEM_AWIDTH-1:0]   fifo_wr_addr;
reg [TLP_MEM_AWIDTH-1:0]   stored_wr_addr;
reg                    fifo_rd;
reg                    fifo_rd_d;
reg                    fifo_rd_dd;
reg [TLP_MEM_AWIDTH-1:0]   fifo_rd_addr;
reg [66:0]             fifo_rd_data_r;
wire  [31:0]           crc_out;
wire  [66:0]           fifo_rd_data_nr;
wire  [66:0]           fifo_wr_data;
wire                   end_crc_ok;
wire                   edb_crc_ok;
wire                   good_seqnum;
wire                   old_seqnum;
wire  [31:0]           crc_out48;
wire  [31:0]           crc_out16;
wire                   not_good_pkt;
wire                   its_good_pkt;
wire                   rxtp_end_early;
wire                   rxtp_dwen_early;
wire                   end_crc_ok_new;
wire                   edb_crc_ok_new;
wire [TLP_MEM_AWIDTH-1:0]  fifo_wr_addr_m ;
wire gseq = (~short_pkt_d && good_seqnum_reg) | (short_pkt_d && good_seqnum);

`ifdef ECP5UM

`else

`ifdef ECP3

`else

`endif

`endif

`ifdef ECP5UM

`else

`ifdef ECP3

`else

`endif

`endif

`ifdef X4

`endif
reg tlp_debug_split;
reg dl_up_split;
reg phy_l0_split;
reg phy_x4_val_split;
reg phy_x2_val_split;
reg [63 : 0] dfrm_tdata_split;
reg dfrm_tval_split;
reg dfrm_st_split;
reg dfrm_end_split;
reg dfrm_edb_split;
reg dfrm_dwen_split;
reg [15 : 0] dfrm_seq_split;
reg [31 : 0] dfrm_lcrc_split;
reg [63 : 0] tdata1_split;
reg [63 : 0] tdata2_split;
reg tst1_split;
reg tst2_split;
reg tend1_split;
reg tend2_split;
reg tend3_split;
reg tedb1_split;
reg tedb2_split;
reg tedb3_split;
reg tdwen1_split;
reg tdwen2_split;
reg tdwen3_split;
reg tval1_split;
reg tval2_split;
reg tval3_split;
reg [2 : 0] val_shift_reg1_split;
reg [2 : 0] val_shift_reg2_split;
reg [11 : 0] tseqnum_split;
reg [15 : 0] tdata16_split;
reg [11 : 0] next_seqnum_split;
reg end_crc_ok_reg_split;
reg edb_crc_ok_reg_split;
reg good_seqnum_reg_split;
reg old_seqnum_reg_split;
reg [11 : 0] seqnum_diff_split;
reg good_pkt_split;
reg bad_pkt_split;
reg dup_pkt_split;
reg disc_pkt_split;
reg short_pkt_split;
reg short_pkt_d_split;
reg [31 : 0] tcrc_split;
reg [31 : 0] dfrm_lcrc_reg_split;
reg [1 : 0] rxtp_state_split;
reg send_nak_split;
reg check_point_split;
reg check_point_del1_split;
reg check_point_del2_split;
reg phy_l0_reg_split;
reg phy_l0_rp_split;
reg fifo_wr_split;
reg [TLP_MEM_AWIDTH - 1 : 0] fifo_wr_addr_split;
reg [TLP_MEM_AWIDTH - 1 : 0] stored_wr_addr_split;
reg fifo_rd_split;
reg fifo_rd_d_split;
reg fifo_rd_dd_split;
reg [TLP_MEM_AWIDTH - 1 : 0] fifo_rd_addr_split;
reg [66 : 0] fifo_rd_data_r_split;
reg [31 : 0] crc_out_split;
reg [66 : 0] fifo_rd_data_nr_split;
reg [66 : 0] fifo_wr_data_split;
reg end_crc_ok_split;
reg edb_crc_ok_split;
reg good_seqnum_split;
reg old_seqnum_split;
reg [31 : 0] crc_out48_split;
reg [31 : 0] crc_out16_split;
reg not_good_pkt_split;
reg its_good_pkt_split;
reg rxtp_end_early_split;
reg rxtp_dwen_early_split;
reg end_crc_ok_new_split;
reg edb_crc_ok_new_split;
reg [TLP_MEM_AWIDTH - 1 : 0] fifo_wr_addr_m_split;
reg gseq_split;
reg [2047:0] descram_in;
wire [78:0] descram_out;

`ifdef MAX_TLP_512

`endif

`ifdef MAX_TLP_1K

`endif

`ifdef MAX_TLP_2K

`endif

`ifdef MAX_TLP_4K

`endif


`ifdef ECP5UM

`else

`ifdef ECP3

`else

`endif

`endif

`ifdef ECP5UM

`else

`ifdef ECP3

`else

`endif

`endif


`ifdef X4

`endif

localparam descram_inst_SIZE = 79,descram_inst_SCRAMSTRING = 32'hfdffe81b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;



`ifdef MAX_TLP_512


`endif



`ifdef MAX_TLP_1K


`endif



`ifdef MAX_TLP_2K


`endif



`ifdef MAX_TLP_4K


`endif


`ifdef ECP5UM



`else



`ifdef ECP3



`else



`endif



`endif



`ifdef ECP5UM



`else



`ifdef ECP3



`else



`endif



`endif



`ifdef X4



`endif

// =============================================================================
// Local parameters based on TLP size define.
// ECP2: Min available is 512x64 (Two 512x36)


`ifdef MAX_TLP_512


   //localparam TLP_ACT_SIZE    = ((512/8) + 3) = 67;
   

`endif




`ifdef MAX_TLP_1K


   //localparam TLP_ACT_SIZE    = ((1024/8) + 3) = 131;
   

`endif




`ifdef MAX_TLP_2K


   //localparam TLP_ACT_SIZE    = ((2048/8) + 3) = 259;
   

`endif




`ifdef MAX_TLP_4K


   //localparam TLP_ACT_SIZE    = ((4096/8) + 3) = 515;
   

`endif



// =============================================================================
//Selected CRC from CRC GEN
//from 48 CRC GEN
//from 16 CRC GEN
// =============================================================================
// Delaying the input data for Fifo Write & CRC check
// dfrm_tdata is sent to CRCgen
// tdata2 is sent to FIFO
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      tseqnum <= 12'd0;
      tdata16 <= 16'd0;
      tdata1  <= 48'd0;
      tdata2  <= 64'd0;
      tst1    <= 1'b0;
      tst2    <= 1'b0;
      tend1   <= 1'b0;
      tend2   <= 1'b0;
      tend3   <= 1'b0;
      tedb1   <= 1'b0;
      tedb2   <= 1'b0;
      tedb3   <= 1'b0;
      tdwen1  <= 1'b0;
      tdwen2  <= 1'b0;
      tdwen3  <= 1'b0;
   end
   else  begin
      //Stage 1
      if(dfrm_tval_split)
         tdata16   <= dfrm_tdata_split[15:0];

      if(dfrm_tval_split || tval1_split)
         if(dfrm_st_split)   //This data goes to CRC
            tdata1 <= {dfrm_seq_split, dfrm_tdata_split[63:16]};
         else
            tdata1 <= {tdata16_split, dfrm_tdata_split[63:16]};

      if(dfrm_end_split || dfrm_edb_split)  //store with END to avoid over-writing with Next pkt seqnum
         tseqnum <= dfrm_seq_split[11:0];   //Storing May not be required

      //Stage 2  - WRITE Data (without Seqnum)
      if(tval1_split)
         tdata2  <= {tdata1_split[47:0], tdata16_split};   //Should be same as dfrm_tdata

      if(dfrm_tval_split)
         tst1    <= dfrm_st_split;

      if(tval1_split)
         tst2    <= tst1_split;

      if(dfrm_tval_split || tval1_split || tval2_split || tval3_split) begin
         tend1   <= dfrm_end_split;
         tend2   <= tend1_split;
         tend3   <= tend2_split;
         tedb1   <= dfrm_edb_split;
         tedb2   <= tedb1_split;
         tedb3   <= tedb2_split;
         tdwen1  <= dfrm_dwen_split;
         tdwen2  <= tdwen1_split;
         tdwen3  <= tdwen2_split;
      end

   end
end

//For Downgrade to X1
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      tval1          <= 1'b0;
      tval2          <= 1'b0;
      tval3          <= 1'b0;
      val_shift_reg1 <= 3'b000;
      val_shift_reg2 <= 3'b000;
   end
   else  begin
      //X1: val_shift_reg1[0] is used for crc     : X4 it is not required
      //X1: val_shift_reg2[2] is used for fifo_wr : X4 it is tval1
      if(phy_x4_val_split) begin   //X4 Mode
         tval1          <= dfrm_tval_split;
         tval2          <= tval1_split;
         tval3          <= tval2_split;
         val_shift_reg1 <= 3'b111;
         val_shift_reg2 <= {dfrm_tval_split, 1'b1, 1'b1};
      end
      else if(phy_x2_val_split) begin   //X2 Mode
         val_shift_reg1 <= {val_shift_reg1_split[1], val_shift_reg1_split[0], dfrm_tval_split};
         tval1          <= val_shift_reg1_split[0];

         val_shift_reg2 <= {val_shift_reg2_split[1], val_shift_reg2_split[0], tval1_split};
         tval2          <= val_shift_reg2_split[0];
      end
      else begin  //X1 Mode
         val_shift_reg1 <= {val_shift_reg1_split[1], val_shift_reg1_split[0], dfrm_tval_split};
         tval1          <= val_shift_reg1_split[2];

         val_shift_reg2 <= {val_shift_reg2_split[1], val_shift_reg2_split[0], tval1_split};
         tval2          <= val_shift_reg2_split[2];
      end
   end
end

// =============================================================================
// Generation CRC status
// =============================================================================
assign crc_out     = (tdwen2_split) ? crc_out48_split : crc_out16_split;
assign end_crc_ok  = (tcrc_split == crc_out_split) ? 1'b1 : 1'b0;
assign edb_crc_ok  = (tcrc_split == ~crc_out_split) ? 1'b1 : 1'b0;
assign good_seqnum = (seqnum_diff_split == 12'h000) ? 1'b1 : 1'b0;
assign old_seqnum  = (seqnum_diff_split <= 12'd2048) ? 1'b1 : 1'b0;

assign end_crc_ok_new  = end_crc_ok_reg_split || (end_crc_ok_split && !tdwen3_split);  //Too much Comb. ???
assign edb_crc_ok_new  = edb_crc_ok_reg_split || (edb_crc_ok_split && !tdwen3_split);
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      end_crc_ok_reg   <= 1'b0;
      edb_crc_ok_reg   <= 1'b0;
      good_seqnum_reg  <= 1'b0;
      old_seqnum_reg   <= 1'b0;
      seqnum_diff  <= 12'h000;
      good_pkt     <= 1'b0;
      bad_pkt      <= 1'b0;
      dup_pkt      <= 1'b0;
      disc_pkt     <= 1'b0;
      short_pkt    <= 1'b0;
      short_pkt_d  <= 1'b0;
      tcrc         <= 32'd0;
      dfrm_lcrc_reg<= 0;
   end
   else  begin
     //4/9/08  (dfrm changing LCRC 1 clk ahead of dfrm_end for back to back short pkts)
     //Since it's always gven ahead 1 clk delay will not be a problem
      dfrm_lcrc_reg   <= dfrm_lcrc_split;
      if(dfrm_end_split || dfrm_edb_split)  //store with END to avoid over-writing with Next pkt CRC
         tcrc    <= dfrm_lcrc_split; // 08/08/08 : fixed in dfrm to take care both X4 and X1.

      //Down grade Mode take CRC during val_shift_reg1[1] time - 2 clks after dfrm_tval
      // crc_out stays only one clk
      if((tend1_split && !tdwen1_split && val_shift_reg1_split[1]) || (tend2_split && tdwen2_split && val_shift_reg2_split[0]))
         end_crc_ok_reg   <= end_crc_ok_split;
      else if(check_point_del2_split)
         end_crc_ok_reg   <= 1'b0;

      if((tedb1_split && !tdwen1_split && val_shift_reg1_split[1]) || (tedb2_split && tdwen2_split && val_shift_reg2_split[0]))
         edb_crc_ok_reg   <= edb_crc_ok_split;
      else if(check_point_del2_split)
         edb_crc_ok_reg   <= 1'b0;


      //---- Fixed for 2 clk pkt on 4/9/08 -- use good_seqnum instead of good_seqnum_reg
      short_pkt_d  <= short_pkt_split;
      if(phy_x4_val_split && tst2_split && tend1_split) //X4 Mode - 2 clk pkt
         short_pkt  <= 1'b1;
      else
         short_pkt  <= 1'b0;

      seqnum_diff      <= next_seqnum_split - tseqnum_split;
      good_seqnum_reg  <= good_seqnum_split;
      old_seqnum_reg   <= old_seqnum_split;

      good_pkt <= 1'b0;
      bad_pkt  <= 1'b0;
      dup_pkt  <= 1'b0;
      disc_pkt <= 1'b0;

      if(check_point_del2_split) begin
         if(tend2_split || tend3_split) begin   //tend2 for X1
            if(end_crc_ok_new_split)
               if((short_pkt_d_split && good_seqnum_split) || (~short_pkt_d_split && good_seqnum_reg_split)) //Good Pkt- 4/9/08
                  good_pkt <= 1'b1;
               else if(old_seqnum_reg_split) //Dupl Pkt
                  dup_pkt  <= 1'b1;
               else                //Bad Pkt - Seq no error
                  bad_pkt  <= 1'b1;
            else                   //Bad Pkt - CRC error
               bad_pkt  <= 1'b1;
         end
         else begin
            if(edb_crc_ok_new_split)     //Discard Pkt
               disc_pkt <= 1'b1;
            else                   //Bad Pkt - CRC error
               bad_pkt  <= 1'b1;
         end
     end  //Check point
   end
end

// =============================================================================
// Status outputs about TLP  received
// =============================================================================
assign rxtp_bad_tlp  = bad_pkt_split;
assign rxtp_seq      = next_seqnum_split - 12'h001;
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      rxtp_ack      <= 1'b0;
      rxtp_duptlp   <= 1'b0;
      rxtp_nak      <= 1'b0;
   end
   else begin
      rxtp_ack      <= good_pkt_split;
      rxtp_duptlp   <= dup_pkt_split;
      rxtp_nak      <= bad_pkt_split | send_nak_split;
   end
end

// =============================================================================
// 1) st may miss  -- Taken care by Phy
// 2) end may miss
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      rxtp_state       <= RXTP_IDLE;
      send_nak         <= 1'b0;
      check_point      <= 1'b0;
      check_point_del1 <= 1'b0;
      check_point_del2 <= 1'b0;
      phy_l0_reg       <= 1'b0;
   end
   else  begin
      send_nak    <= 1'b0;
      phy_l0_reg <= phy_l0_split;
      phy_l0_rp  <= (phy_l0_split & ~phy_l0_reg_split);

      if(tval1_split) begin    //Pulse for Downgrade
         check_point_del1 <= check_point_split;
      end
      else begin
         check_point_del1 <= 1'b0;
      end
      check_point_del2 <= check_point_del1_split;

      case(rxtp_state_split)
         RXTP_IDLE : begin
            //1) Error during St
            //2) Unexpected end/edb - Missing St
            if(dl_up_split && dfrm_tval_split) begin
               if(dfrm_end_split || dfrm_edb_split) begin
                  send_nak    <= 1'b1;
                  rxtp_state  <= RXTP_ERR;
               end
               else if(dfrm_st_split) begin
                  rxtp_state  <= RXTP_PKT;
               end
	       else begin
                  rxtp_state  <= RXTP_IDLE;
                  send_nak    <= 1'b0;
               end
            end
   	    else begin
               rxtp_state  <= RXTP_IDLE;
               send_nak    <= 1'b0;
            end
            if(tval1_split) //for Downgrade otherwise it's a pulse
               check_point      <= 1'b0;
         end
         RXTP_PKT : begin
            //1) Error during a pkt
            //2) Missing End & next Start
            if(phy_l0_rp_split) begin
               rxtp_state  <= RXTP_IDLE;
               send_nak    <= 1'b1;
            end
            else if(dl_up_split) begin
               if(dfrm_tval_split) begin
                  send_nak <= (dfrm_st_split) ? 1'b1 : 1'b0;
                  if(dfrm_end_split || dfrm_edb_split) begin
                     rxtp_state  <= RXTP_IDLE;
                     check_point <= 1'b1;
                  end
               end
            end
            else
               rxtp_state  <= RXTP_IDLE;
         end
         RXTP_ERR : begin
            if(phy_l0_rp_split) begin
               rxtp_state  <= RXTP_IDLE;
               send_nak    <= 1'b1;
            end
            else if(dl_up_split) begin
               if(dfrm_tval_split) begin
                  if(dfrm_st_split)
                     rxtp_state  <= RXTP_PKT;
		  else if(dfrm_end_split || dfrm_edb_split) begin
                     rxtp_state  <= RXTP_ERR;
                     send_nak <= 1'b1;
                  end
		  else begin
                     rxtp_state  <= RXTP_IDLE;
                     send_nak <= 1'b0;
                  end
               end
            end
            else
               rxtp_state  <= RXTP_IDLE;
        end
        default : begin
           rxtp_state  <= RXTP_IDLE;
        end
      endcase
   end
end

// =============================================================================
// Fifo Write, Addr generation
// Datain    : tdata2
// Start bit : tst2
// End   bit : dfrm_end  -- make it a clk before use dfrm_end to make it a pulse
// =============================================================================
assign fifo_wr_data = {tdata2_split, tst2_split, tend1_split, tdwen1_split};  //early End/dwen
assign not_good_pkt = (check_point_del2_split && (!end_crc_ok_new_split || !gseq_split)) ? 1'b1 : 1'b0;
assign its_good_pkt = (check_point_del2_split && end_crc_ok_new_split && gseq_split) ? 1'b1 : 1'b0;

//assign fifo_wr = tval2;
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      fifo_wr          <= 1'b0;
      fifo_wr_addr     <= {TLP_MEM_AWIDTH{1'b0}};
      stored_wr_addr   <= {TLP_MEM_AWIDTH{1'b0}};
      next_seqnum      <= 12'h000;
   end
   else  begin
      // X4 Mode : Only STATE is enough
      // X1 Mode : Checkpoint for last data
      if(phy_x4_val_split) begin
         if((rxtp_state_split == RXTP_PKT) || check_point_split)
            fifo_wr  <= 1'b1;
         else
            fifo_wr  <= 1'b0;
      end
      else begin
         fifo_wr  <= tval1_split;
      end

      if(!dl_up_split || send_nak_split || not_good_pkt_split) //Not a good Pkt
         fifo_wr_addr <= (not_good_pkt_split & tst2_split) ? (stored_wr_addr_split + 1'b1) : stored_wr_addr_split; // to fix dup_tlp issue with back to back packets
      else if(fifo_wr_split)
         fifo_wr_addr <= fifo_wr_addr_split + 1;

      //----- Stored Write Pointer for FIFO Read/Write
      if(!dl_up_split)
          stored_wr_addr <= 0;
      else if(its_good_pkt_split)  //Good Pkt
          stored_wr_addr <= fifo_wr_addr_split;

      //----- Seq Num Register
      if(!dl_up_split)
         next_seqnum  <= 12'h000;
      else if(its_good_pkt_split)  //Good Pkt
         next_seqnum  <= next_seqnum_split + 12'h001 ;

   end
end

// to fix dup_tlp issue with back to back packets
assign fifo_wr_addr_m = (not_good_pkt_split && tst2_split) ? stored_wr_addr_split : fifo_wr_addr_split ;

// =============================================================================
// Fifo Read, Addr generation
// tlp_debug makes the TLP (without seqnum & crc) to bypass the FIFO
// =============================================================================
assign rxtp_data         = fifo_rd_data_r_split[66:3];
assign rxtp_st           = fifo_rd_dd_split ? fifo_rd_data_r_split[2] : 1'b0;
assign rxtp_end_early_r  = fifo_rd_dd_split ? fifo_rd_data_r_split[1] : 1'b0;
assign rxtp_dwen_early_r = fifo_rd_dd_split ? fifo_rd_data_r_split[0] : 1'b0;
assign rxtp_end_early_nr  = fifo_rd_d_split ? fifo_rd_data_nr_split[1] : 1'b0;

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      fifo_rd         <= 1'b0;
      fifo_rd         <= 1'b0;
      fifo_rd_addr    <= {TLP_MEM_AWIDTH{1'b0}};
      rxtp_end        <= 1'b0;
      rxtp_dwen       <= 1'b0;
      fifo_rd_d       <= 1'b0;
      fifo_rd_dd      <= 1'b0;
      fifo_rd_data_r  <= 67'd0;
   end
   else  begin
      fifo_rd_data_r  <= fifo_rd_data_nr_split;

      if(!dl_up_split || (fifo_rd_addr_split == (stored_wr_addr_split-1)) || rxtp_end_early_nr)
          fifo_rd    <= 1'b0;
      else if(fifo_rd_addr_split != stored_wr_addr_split)
          fifo_rd    <= 1'b1;

      if(!dl_up_split)
         fifo_rd_addr <= 0;
      else if(fifo_rd_split)
         fifo_rd_addr <= fifo_rd_addr_split + 1;

      if(!phy_x4_val_split && tlp_debug_split) begin //Downgrade Mode & tlp_debug
         if (tval2_split) begin
            rxtp_end        <= rxtp_end_early_r;
            rxtp_dwen       <= rxtp_dwen_early_r;
         end
      end
      else begin
         rxtp_end        <= rxtp_end_early_r;
         rxtp_dwen       <= rxtp_dwen_early_r;
      end

      fifo_rd_d       <= fifo_rd_split;
      fifo_rd_dd      <= fifo_rd_d_split;
   end
end

// =============================================================================
// Instantiate the FIFO
// Dual port memory TLP buffer
// =============================================================================
pmi_ram_dp #(
   .pmi_wr_addr_depth    (TLP_MEM_DEPTH),
   .pmi_wr_addr_width    (TLP_MEM_AWIDTH),
   .pmi_wr_data_width    (67),
   .pmi_rd_addr_depth    (TLP_MEM_DEPTH),
   .pmi_rd_addr_width    (TLP_MEM_AWIDTH),
   .pmi_rd_data_width    (67),
   .pmi_regmode          ("noreg"),
   .pmi_gsr              ("enable"),
   .pmi_init_file        ("none"),
   .pmi_init_file_format ("binary"),
 

`ifdef ECP5UM


   .pmi_resetmode        ("sync"),
   .pmi_family           ("ECP5U"),
 

`else


    

`ifdef ECP3


      .pmi_resetmode     ("sync"),   //Connect LOW
      .pmi_family        ("ECP3"),
    

`else


      .pmi_resetmode     ("async"),
      .pmi_family        ("EC2"),
    

`endif


 

`endif


   .module_type          ("pmi_ram_dp")
   )
   u1_rxtlp_mem (
   .Data         (fifo_wr_data),
   .WrAddress    (fifo_wr_addr_m),
   .RdAddress    (fifo_rd_addr),
   .WrClock      (sys_clk),
   .RdClock      (sys_clk),
   .WrClockEn    (1'b1),
   .RdClockEn    (fifo_rd),
   .WE           (fifo_wr),
 

`ifdef ECP5UM


   .Reset        (1'b0),
 

`else


    

`ifdef ECP3


      .Reset     (1'b0),
    

`else


      .Reset     (~rst_n),
    

`endif


 

`endif


   .Q            (fifo_rd_data_nr)
   );

// =============================================================================
// Instantiate actual CRC computation core logic.
// =============================================================================
rxtp_crc #(
   .D_WIDTH       ( 64 ) )
   u1_rxtp_crc64(
   .sys_clk       (sys_clk),
   .rst_n         (rst_n),

   // Inputs
   .data_in       (tdata1_split),
   .start         (dfrm_st_split & dfrm_tval_split),
   

`ifdef X4


      .valid      (tval1_split),   //Downgrade Mode
      .crc_out48  (crc_out48),
   

`endif


   .crc_out16     (crc_out16)
   ) ;


always@* begin tlp_debug_split<=descram_out[0];dl_up_split<=descram_out[1];phy_l0_split<=descram_out[2];phy_x4_val_split<=descram_out[3];phy_x2_val_split<=descram_out[4];dfrm_tdata_split<={dfrm_tdata>>1,descram_out[5]};dfrm_tval_split<=descram_out[6];dfrm_st_split<=descram_out[7];dfrm_end_split<=descram_out[8];dfrm_edb_split<=descram_out[9];dfrm_dwen_split<=descram_out[10];dfrm_seq_split<={dfrm_seq>>1,descram_out[11]};dfrm_lcrc_split<={dfrm_lcrc>>1,descram_out[12]};tdata1_split<={tdata1>>1,descram_out[13]};tdata2_split<={tdata2>>1,descram_out[14]};tst1_split<=descram_out[15];tst2_split<=descram_out[16];tend1_split<=descram_out[17];tend2_split<=descram_out[18];tend3_split<=descram_out[19];tedb1_split<=descram_out[20];tedb2_split<=descram_out[21];tedb3_split<=descram_out[22];tdwen1_split<=descram_out[23];tdwen2_split<=descram_out[24];tdwen3_split<=descram_out[25];tval1_split<=descram_out[26];tval2_split<=descram_out[27];tval3_split<=descram_out[28];val_shift_reg1_split<={val_shift_reg1>>1,descram_out[29]};val_shift_reg2_split<={val_shift_reg2>>1,descram_out[30]};tseqnum_split<={tseqnum>>1,descram_out[31]};tdata16_split<={tdata16>>1,descram_out[32]};next_seqnum_split<={next_seqnum>>1,descram_out[33]};end_crc_ok_reg_split<=descram_out[34];edb_crc_ok_reg_split<=descram_out[35];good_seqnum_reg_split<=descram_out[36];old_seqnum_reg_split<=descram_out[37];seqnum_diff_split<={seqnum_diff>>1,descram_out[38]};good_pkt_split<=descram_out[39];bad_pkt_split<=descram_out[40];dup_pkt_split<=descram_out[41];disc_pkt_split<=descram_out[42];short_pkt_split<=descram_out[43];short_pkt_d_split<=descram_out[44];tcrc_split<={tcrc>>1,descram_out[45]};dfrm_lcrc_reg_split<={dfrm_lcrc_reg>>1,descram_out[46]};rxtp_state_split<={rxtp_state>>1,descram_out[47]};send_nak_split<=descram_out[48];check_point_split<=descram_out[49];check_point_del1_split<=descram_out[50];check_point_del2_split<=descram_out[51];phy_l0_reg_split<=descram_out[52];phy_l0_rp_split<=descram_out[53];fifo_wr_split<=descram_out[54];fifo_wr_addr_split<={fifo_wr_addr>>1,descram_out[55]};stored_wr_addr_split<={stored_wr_addr>>1,descram_out[56]};fifo_rd_split<=descram_out[57];fifo_rd_d_split<=descram_out[58];fifo_rd_dd_split<=descram_out[59];fifo_rd_addr_split<={fifo_rd_addr>>1,descram_out[60]};fifo_rd_data_r_split<={fifo_rd_data_r>>1,descram_out[61]};crc_out_split<={crc_out>>1,descram_out[62]};fifo_rd_data_nr_split<={fifo_rd_data_nr>>1,descram_out[63]};fifo_wr_data_split<={fifo_wr_data>>1,descram_out[64]};end_crc_ok_split<=descram_out[65];edb_crc_ok_split<=descram_out[66];good_seqnum_split<=descram_out[67];old_seqnum_split<=descram_out[68];crc_out48_split<={crc_out48>>1,descram_out[69]};crc_out16_split<={crc_out16>>1,descram_out[70]};not_good_pkt_split<=descram_out[71];its_good_pkt_split<=descram_out[72];rxtp_end_early_split<=descram_out[73];rxtp_dwen_early_split<=descram_out[74];end_crc_ok_new_split<=descram_out[75];edb_crc_ok_new_split<=descram_out[76];fifo_wr_addr_m_split<={fifo_wr_addr_m>>1,descram_out[77]};gseq_split<=descram_out[78];end
always@* begin descram_in[2047]<=dl_up;descram_in[2046]<=phy_l0;descram_in[2045]<=phy_x4_val;descram_in[2042]<=phy_x2_val;descram_in[2037]<=dfrm_tdata[0];descram_in[2032]<=edb_crc_ok;descram_in[2026]<=dfrm_tval;descram_in[2017]<=good_seqnum;descram_in[2005]<=dfrm_st;descram_in[1986]<=old_seqnum;descram_in[1962]<=dfrm_end;descram_in[1925]<=crc_out48[0];descram_in[1891]<=tval1;descram_in[1877]<=dfrm_edb;descram_in[1844]<=edb_crc_ok_reg;descram_in[1835]<=fifo_rd;descram_in[1802]<=crc_out16[0];descram_in[1742]<=tend3;descram_in[1735]<=tval2;descram_in[1707]<=dfrm_dwen;descram_in[1666]<=bad_pkt;descram_in[1654]<=tedb3;descram_in[1640]<=good_seqnum_reg;descram_in[1623]<=fifo_rd_d;descram_in[1593]<=val_shift_reg2[0];descram_in[1556]<=not_good_pkt;descram_in[1532]<=fifo_wr_data[0];descram_in[1459]<=tend1;descram_in[1437]<=tedb1;descram_in[1422]<=tval3;descram_in[1407]<=crc_out[0];descram_in[1388]<=tst1;descram_in[1371]<=tdata1[0];descram_in[1366]<=dfrm_seq[0];descram_in[1351]<=check_point;descram_in[1308]<=check_point_del2;descram_in[1304]<=fifo_wr_addr_m[0];descram_in[1285]<=dup_pkt;descram_in[1260]<=tdwen1;descram_in[1232]<=old_seqnum_reg;descram_in[1199]<=fifo_rd_dd;descram_in[1139]<=tseqnum[0];descram_in[1138]<=phy_l0_rp;descram_in[1064]<=its_good_pkt;descram_in[1045]<=short_pkt;descram_in[1023]<=tlp_debug;descram_in[1016]<=end_crc_ok;descram_in[945]<=tdwen3;descram_in[922]<=end_crc_ok_reg;descram_in[917]<=stored_wr_addr[0];descram_in[871]<=tend2;descram_in[833]<=good_pkt;descram_in[827]<=tedb2;descram_in[796]<=val_shift_reg1[0];descram_in[766]<=fifo_rd_data_nr[0];descram_in[729]<=tst2;descram_in[703]<=fifo_rd_data_r[0];descram_in[694]<=tdata2[0];descram_in[685]<=dfrm_lcrc[0];descram_in[675]<=send_nak;descram_in[654]<=check_point_del1;descram_in[652]<=edb_crc_ok_new;descram_in[569]<=phy_l0_reg;descram_in[561]<=gseq;descram_in[522]<=disc_pkt;descram_in[472]<=tdwen2;descram_in[461]<=next_seqnum[0];descram_in[458]<=fifo_wr_addr[0];descram_in[416]<=seqnum_diff[0];descram_in[351]<=fifo_rd_addr[0];descram_in[337]<=rxtp_state[0];descram_in[326]<=end_crc_ok_new;descram_in[230]<=tdata16[0];descram_in[229]<=fifo_wr;descram_in[168]<=dfrm_lcrc_reg[0];descram_in[163]<=rxtp_dwen_early;descram_in[84]<=tcrc[0];descram_in[81]<=rxtp_end_early;descram_in[42]<=short_pkt_d;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


//


// Revision 1.22 2007/08/03 16:10:49PDT rperugu


//


// Revision 1.20 2007/07/31 16:17:36PDT uananthi


// fixed EDB problem for X1.


// Revision 1.19 2007/03/22 10:43:36PST rperugu


// Added 2 extra locations for 4K pkts (dpram depth: 516 --> 518) : New range: 0 - 517


// Revision 1.18 2007/02/08 18:18:56PST rperugu


// tlp_debug & DownGrade Mode: rxtp_end_early is qualified with tval2 for rxtp_end.


// Revision 1.17 2007/02/02 10:56:36PST rperugu


// fifo_wr is changed from tval2 to reg. tval1.


// Revision 1.16 2007/02/01 17:30:05PST rperugu


// dfrm_lcrc & dfrm_seq are separated from data & given to rxtp


// fifo_wr is made as tval2 : to work in x1 also


// Revision 1.15 2007/01/11 14:31:38PST rperugu


// Fifo Wr: Extra write is happenning for X4 mode, so qualified with phy_x4_val signal.


// Revision 1.14 2007/01/09 14:53:59PST rperugu


// For dwongrade logic is added :


//    -- tval1, tval2 logic is changed


//    -- fifo_wr gen logic: check point is added for downgrade case


//    -- New input phy_x4_val is added


// Revision 1.13 2007/01/02 10:14:17PST gkrishna


// Revision 1.12 2006/07/27 17:01:33PDT rperugu


// 1) its_goodpkt is not required to use end2.


//    end_crc_ok_reg is already made zero during check_point_del1


// 2) rxtp_st, rxtp_end & rxtp_dwen are only made zero when fifo_rd_d is de-asserted.


// Revision 1.11 2006/07/27 16:07:50PDT gkrishna


// 1) its_goodpkt is qualified with end2


// 2) rxtp signals are qualified with fifo_rd_d


// Revision 1.10 2006/07/06 12:25:33PDT uananthi


// fixed missing data while changing memories problem - Rajkumar


// Revision 1.9 2006/06/19 14:47:03PDT gkrishna


//


// Revision 1.8 2006/06/19 13:26:03PDT rperugu


// rxtp_end_early is used to block fifo_rd --> 1 clk b/w TLPs


// Revision 1.7 2006/06/16 12:14:44PDT rperugu


// dfrm_perr is removed.


// Revision 1.6 2006/06/15 16:05:35PDT rperugu


//


// Revision 1.5 2006/06/15 14:48:23PDT rperugu


//


// Revision 1.4 2006/06/12 15:48:49PDT rperugu


// dwen logic is corrected.


// Revision 1.3 2006/05/31 18:30:17PDT uananthi


// removed `define MAX_TLP_512


// Revision 1.2 2006/05/30 16:09:21PDT rperugu


// Compiled.


//


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_xx


// File             : lcmfci.v


// Title            : Link Control SM and Flow Control Initialization


// Dependencies     :


// Description      : This Block has LCM & FCI for the Data Link Layer


//                    LCM keeps track of the status of Link. It informs this


//                    to TL & PL and perfoems Link Management through Phy Layer.


//                    FCI does that Flow Control Initializatin for each VC (when


//                    LCM is out of INACTIVE state) if the s/w assertes vc enable


//                    for particular VC.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Rajakumar


// Mod. Date        : Mar 15, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module  lcmfci(
   
   sys_clk,              
   rst_n,                

   INITFC_TIMER,         
   
   lcm_enb,              
   vc_enb,               
   cfg_vcid,             

   
   phy_ltssm_state,      
   phy_link_up,          

   
   trnc_st,              

   
   rxdp_ifc1_val,        
   rxdp_ifc2_val,        
   rxdp_ufc_val,         
   rxdp_fcd_type,        
   rxdp_vcid,            

   
   txdp_rdy,             
   txdp_rdy2,            
   txdp_no_hpreq,        
   txdp_no_lpreq,        

   
   rxtp_nak,             
   rxtp_dupltlp,         

   
   
   dl_inactive,          
   dl_init,              
   dl_active,            
   dl_up,                

   
   lcmfci_req,           
   lcmfci_req2,          
   lcmfci_vcid,          
   lcmfci_init,          
   lcmfci_type,          

   
   vcneg_pend            
                         

   );
localparam K27_7 = 8'hFB ;
localparam K28_0 = 8'h1C ;
localparam K28_2 = 8'h5C ;
localparam K28_3 = 8'h7C ;
localparam K28_5 = 8'hBC ;
localparam K28_7 = 8'hFC ;
localparam K29_7 = 8'hFD ;
localparam K30_7 = 8'hFE ;
localparam K23_7 = 8'hF7 ;
localparam K28_1 = 8'h3C ;
localparam D5_2  = 8'h45 ;
localparam D10_2 = 8'h4A ;
localparam D21_5 = 8'hB5 ;
localparam D26_5 = 8'hBA ;
localparam COM = K28_5 ;
localparam STP = K27_7 ;
localparam SDP = K28_2 ;
localparam END = K29_7 ;
localparam EDB = K30_7 ;
localparam SKP = K28_0 ;
localparam IDL = K28_3 ;
localparam PAD = K23_7 ;
localparam FTS = K28_1 ;
localparam EIE = K28_7 ;
localparam OS_WIDTH      = 4 ;
localparam OS_T1_LIP_LAP = 4'd0 ;
localparam OS_T2_LIP_LAP = 4'd1 ;
localparam OS_COMPLI     = 4'd2 ;
localparam OS_T1         = 4'd3 ;
localparam OS_T2         = 4'd4 ;
localparam OS_IDLE       = 4'd5 ;
localparam OS_EIDLE      = 4'd6 ;
localparam OS_NFTS       = 4'd7 ;
localparam OS_BEACON     = 4'd8 ;
localparam DSM_WIDTH    = 2 ;
localparam PSM_WIDTH    = 2 ;
localparam RSM_WIDTH    = 2 ;
localparam L0SM_WIDTH   = 2 ;
localparam L0sTSM_WIDTH = 2 ;
localparam L0sRSM_WIDTH = 2 ;
localparam L1SM_WIDTH   = 1 ;
localparam L2SM_WIDTH   = 1 ;
localparam DISM_WIDTH   = 2 ;
localparam LBSM_WIDTH   = 2 ;
localparam HRSM_WIDTH   = 1 ;
localparam CFGSM_WIDTH  = 2 ;
localparam MSM_WIDTH    = 3 ;
localparam DETECT    = 4'd0 ;
localparam POLLING   = 4'd1 ;
localparam CONFIG    = 4'd2 ;
localparam L0        = 4'd3 ;
localparam L0s       = 4'd4 ;
localparam L1        = 4'd5 ;
localparam L2        = 4'd6 ;
localparam RECOVERY  = 4'd7 ;
localparam LOOPBACK  = 4'd8 ;
localparam HOTRST    = 4'd9 ;
localparam DISABLED  = 4'd10 ;

`ifdef VC1
localparam FADDR = 3 ;

`else

`ifdef VC2
localparam FADDR = 3 ;

`else

`ifdef VC3
localparam FADDR = 5 ;

`else

`ifdef VC4
localparam FADDR = 5 ;

`else
localparam FADDR = 6 ;

`endif

`endif

`endif

`endif
parameter P_TYPE   = 2'b00;
parameter NP_TYPE  = 2'b01;
parameter CPL_TYPE = 2'b10;
parameter FC_INIT1 = 1'b0;
parameter FC_INIT2 = 1'b1;
parameter DL_INACTIVE = 2'b00;
parameter DL_INIT     = 2'b01;
parameter DL_ACTIVE   = 2'b10;
parameter FCI_IDLE  = 3'b000;
parameter FCI_P     = 3'b001;
parameter FCI_NP    = 3'b010;
parameter FCI_CPL   = 3'b011;
parameter FCI_CHECK = 3'b100;
parameter VC_IDLE   = 1'b0;
parameter VC_WAIT   = 1'b1;
input                     sys_clk;
input                     rst_n;
input [11:0]              INITFC_TIMER;
input                     lcm_enb;
input [`NUM_VC -1:0]      vc_enb;
input [(`NUM_VC*3)-1:0]   cfg_vcid;
input [MSM_WIDTH:0]       phy_ltssm_state;
input                     phy_link_up;
input [`NUM_VC -1:0]      trnc_st;
input                     rxdp_ifc1_val;
input                     rxdp_ifc2_val;
input                     rxdp_ufc_val;
input [1:0]               rxdp_fcd_type;
input [2:0]               rxdp_vcid;
input                     txdp_rdy;
input                     txdp_rdy2;
input                     txdp_no_hpreq;
input                     txdp_no_lpreq;
input                     rxtp_nak;
input                     rxtp_dupltlp;
output                    dl_inactive;
output                    dl_init;
output                    dl_active;
output [`NUM_VC -1:0]     dl_up;
output                    lcmfci_req;
output                    lcmfci_req2;
output [2:0]              lcmfci_vcid;
output                    lcmfci_init;
output [1:0]              lcmfci_type;
output [`NUM_VC -1:0]     vcneg_pend;
reg                       dl_inactive;
reg                       dl_init;
reg                       dl_active;
reg    [`NUM_VC -1:0]     dl_up;
reg                       lcmfci_req;
reg                       lcmfci_req2;
reg    [2:0]              lcmfci_vcid;
reg                       lcmfci_init;
reg    [1:0]              lcmfci_type;
reg    [`NUM_VC -1:0]     vcneg_pend;
reg  [1:0]                lcm_state;
reg  [2:0]                fci_state;
reg                       start_timer;
reg                       timer_exp;
reg  [11:0]               timer_34us;
reg  [1:0]                sent_initFC1;
reg  [1:0]                sent_initFC2;
reg                       tlp_start;
reg                       clear_flags;
reg                       p_recvd1;
reg                       np_recvd1;
reg                       cpl_recvd1;
reg                       recvd2;
reg                       init1_seq_recvd;
reg                       init2_seq_recvd;
reg                       vc_disabled;
reg                       vc_enable;
reg                       vc_state;
reg  [`NUM_VC -1:0]       fi2;

`ifdef VC1
wire  [2:0]               expt_vcid;

`else
reg   [2:0]               expt_vcid;

`endif

`ifndef VC1

`ifdef VC2
reg    vc_cnt;

`else

`ifdef VC3
reg  [1:0]   vc_cnt;

`else

`ifdef VC4
reg  [1:0]   vc_cnt;

`else   // 5 - 8
reg  [2:0]   vc_cnt;

`endif

`endif

`endif

`endif
wire  [7:0]               vc_en;
wire  [2:0]               vcid0;
wire  [2:0]               vcid1;
wire  [2:0]               vcid2;
wire  [2:0]               vcid3;
wire  [2:0]               vcid4;
wire  [2:0]               vcid5;
wire  [2:0]               vcid6;
wire  [2:0]               vcid7;
wire                      reset_clear_flags;
wire                      reset_rcvd;

`ifdef VC1   //VC0 only

`else

`endif

`ifdef VC1   //VC0 only

`else

`endif

`ifdef VC1

`else

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`endif

`ifndef VC1

`endif

`ifdef VC1   //VC0 only

`else

`endif

`ifdef VC1   //VC0 only

`else

`endif

`ifdef VC1   //VC0 only

`else

`endif

`ifdef VC1   //VC0 only

`else

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef EN_VC0

`else

`endif

`ifdef EN_VC1

`else

`endif

`ifdef EN_VC2

`else

`endif

`ifdef EN_VC3

`else

`endif

`ifdef EN_VC4

`else

`endif

`ifdef EN_VC5

`else

`endif

`ifdef EN_VC6

`else

`endif

`ifdef EN_VC7

`else

`endif
reg [8*10:1]     LCM_STATE_S;
reg [8*10:1]     FCI_STATE_S;
reg [8*10:1]     VC_STATE_S;
reg [11 : 0] INITFC_TIMER_split;
reg lcm_enb_split;
reg [`NUM_VC - 1 : 0] vc_enb_split;
reg [(`NUM_VC * 3) - 1 : 0] cfg_vcid_split;
reg [MSM_WIDTH : 0] phy_ltssm_state_split;
reg phy_link_up_split;
reg [`NUM_VC - 1 : 0] trnc_st_split;
reg rxdp_ifc1_val_split;
reg rxdp_ifc2_val_split;
reg rxdp_ufc_val_split;
reg [1 : 0] rxdp_fcd_type_split;
reg [2 : 0] rxdp_vcid_split;
reg txdp_rdy_split;
reg txdp_rdy2_split;
reg txdp_no_hpreq_split;
reg txdp_no_lpreq_split;
reg rxtp_nak_split;
reg rxtp_dupltlp_split;
reg [1 : 0] lcm_state_split;
reg [2 : 0] fci_state_split;
reg start_timer_split;
reg timer_exp_split;
reg [11 : 0] timer_34us_split;
reg [1 : 0] sent_initFC1_split;
reg [1 : 0] sent_initFC2_split;
reg tlp_start_split;
reg clear_flags_split;
reg p_recvd1_split;
reg np_recvd1_split;
reg cpl_recvd1_split;
reg recvd2_split;
reg init1_seq_recvd_split;
reg init2_seq_recvd_split;
reg vc_disabled_split;
reg vc_enable_split;
reg vc_state_split;
reg [`NUM_VC - 1 : 0] fi2_split;
reg [7 : 0] vc_en_split;
reg [2 : 0] vcid0_split;
reg [2 : 0] vcid1_split;
reg [2 : 0] vcid2_split;
reg [2 : 0] vcid3_split;
reg [2 : 0] vcid4_split;
reg [2 : 0] vcid5_split;
reg [2 : 0] vcid6_split;
reg [2 : 0] vcid7_split;
reg reset_clear_flags_split;
reg reset_rcvd_split;
reg [8 * 10 : 1] LCM_STATE_S_split;
reg [8 * 10 : 1] FCI_STATE_S_split;
reg [8 * 10 : 1] VC_STATE_S_split;
reg [2047:0] descram_in;
wire [50:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

`ifdef VC1

`else

`endif

`ifndef VC1

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else   // 5 - 8

`endif

`endif

`endif

`endif

`ifdef VC1   //VC0 only

`else

`endif

`ifdef VC1   //VC0 only

`else

`endif

`ifdef VC1

`else

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`endif

`ifndef VC1

`endif

`ifdef VC1   //VC0 only

`else

`endif

`ifdef VC1   //VC0 only

`else

`endif

`ifdef VC1   //VC0 only

`else

`endif

`ifdef VC1   //VC0 only

`else

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef EN_VC0

`else

`endif

`ifdef EN_VC1

`else

`endif

`ifdef EN_VC2

`else

`endif

`ifdef EN_VC3

`else

`endif

`ifdef EN_VC4

`else

`endif

`ifdef EN_VC5

`else

`endif

`ifdef EN_VC6

`else

`endif

`ifdef EN_VC7

`else

`endif

localparam descram_inst_SIZE = 51,descram_inst_SCRAMSTRING = 32'hfdffe81b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif


`ifdef VC1


`else


`endif



`ifndef VC1



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else   // 5 - 8


`endif



`endif



`endif



`endif


`ifdef VC1   //VC0 only



`else



`endif



`ifdef VC1   //VC0 only



`else



`endif



`ifdef VC1



`else



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif



`endif



`ifndef VC1



`endif



`ifdef VC1   //VC0 only



`else



`endif



`ifdef VC1   //VC0 only



`else



`endif



`ifdef VC1   //VC0 only



`else



`endif



`ifdef VC1   //VC0 only



`else



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif



`endif



`ifdef EN_VC0



`endif



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif



`ifdef EN_VC0



`else



`endif



`ifdef EN_VC1



`else



`endif



`ifdef EN_VC2



`else



`endif



`ifdef EN_VC3



`else



`endif



`ifdef EN_VC4



`else



`endif



`ifdef EN_VC5



`else



`endif



`ifdef EN_VC6



`else



`endif



`ifdef EN_VC7



`else



`endif

// =============================================================================
// Parameters
// =============================================================================
// for common parameters
// =============================================================================
//                           COPYRIGHT NOTICE
// Copyright 2000-2001 (c) Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// This confidential and proprietary software may be used only as authorised
// by a licensing agreement from Lattice Semiconductor Corporation.
// The entire notice above must be reproduced on all authorized copies and
// copies may only be made to the extent permitted by a licensing agreement
// from Lattice Semiconductor Corporation.
//
// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
// 5555 NE Moore Court                        408-826-6000 (other locations)
// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
// U.S.A                                email: techsupport@latticesemi.com
// =============================================================================
//                         FILE DETAILS
// Project          : pci_exp
// File             : pci_exp_dparams.v
// Title            :
// Dependencies     :
// Description      : Parameters for all modules of the design.
// =============================================================================
//                        REVISION HISTORY
// Version          : 1.0
// Author(s)        :
// Mod. Date        : Jan 31, 2006
// Changes Made     : Initial Creation
// =============================================================================
// Common localparams used in many modules.
//==============================================================================

/*
// Generate LANE_WIDTH localparam based on LW definition
`ifdef LW1
   localparam LANE_WIDTH = 1 ;
`else
   `ifdef LW2
      localparam LANE_WIDTH = 2 ;
   `else
      `ifdef LW4
         localparam LANE_WIDTH = 4 ;
      `else
         localparam LANE_WIDTH = 1 ;
      `endif
   `endif
`endif


// Defines the DATA Bus Width
`ifdef X4
   localparam D_WIDTH = 64 ;
`endif
`ifdef X1
   localparam D_WIDTH = 16 ;
`endif
*/

// K & Special Symbols decodes.
// Ordered Set Types
//--LTSSM State widths states
//--LTSSM Module Main State Machine states
// TXDP-CTRL define
// No of SKIP req in Max Pkt time (8) + No of DLLPs req based on VCs


`ifdef VC1


   //8+3+2 reqs - [3:0]


`else


   

`ifdef VC2


      //8+6+2 reqs - [3:0]
   

`else


      

`ifdef VC3


         //8+9+2 reqs - [5:0]
      

`else


         

`ifdef VC4


            //8+12+2 reqs - [5:0]
         

`else


            //8+24+2 reqs - [6:0]
         

`endif


      

`endif


   

`endif




`endif


//==============================================================================



// =============================================================================
// Define all inputs / outputs
// =============================================================================
//---------Inputs------------
//---------Outputs------------
// =============================================================================
// Output Registers
// =============================================================================
// =============================================================================
// Internal Regs/Wires declarations
// =============================================================================
//---- Registers
//reg  [5:0]               timer_34us;   //For debug



`ifdef VC1


   

`else


   

`endif





`ifndef VC1


   

`ifdef VC2


      

`else


      

`ifdef VC3


         

`else


         

`ifdef VC4


            

`else   // 5 - 8


            

`endif


      

`endif


   

`endif




`endif



//---- Wires
// =============================================================================
//            LCM - Link Control & Management State Machine
// When s/w enables & PHY Link is Up LCM enters INIT state where VC0 Flow Control
// Init. happens. When FCI Enters FC_INIT2 state LCM indicates DL is Up by
// asserting dl_up signal. From this time onwards any TLP / Update DLLP are
// accepted or processed. Once FCI for VC0 is completed LCM exits to ACTIVE state
// which is considered to be Normal/Operational state. During any time Phy Link
// goes down, LCM starts from INACTIVE state.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      dl_inactive  <= 1'b0;
      dl_init      <= 1'b0;
      dl_active    <= 1'b0;
      //dl_up[0]     <= 1'b0;
      lcm_state    <= DL_INACTIVE;
   end
   else begin
      dl_inactive  <= 1'b0;
      dl_init      <= 1'b0;
      dl_active    <= 1'b0;

      case(lcm_state_split)
         DL_INACTIVE : begin
            dl_inactive  <= 1'b1;
            //dl_up[0]     <= 1'b0;
            if(lcm_enb_split && phy_link_up_split)
               lcm_state  <= DL_INIT;
         end
         DL_INIT : begin
            dl_init    <= 1'b1;
            //if(vc_en[0] && init1_seq_recvd)
               //dl_up[0]  <= 1'b1;

            if(!phy_link_up_split || !lcm_enb_split)
               lcm_state  <= DL_INACTIVE;
            else if(vc_en_split[0] && init2_seq_recvd_split)
               lcm_state  <= DL_ACTIVE;
         end
         DL_ACTIVE : begin
            //dl_up[0]  <= 1'b1;
            dl_active <= 1'b1;
            if(!phy_link_up_split || !lcm_enb_split)
               lcm_state  <= DL_INACTIVE;
         end
         default : begin
            lcm_state    <= DL_INACTIVE;
         end
      endcase
   end
end

// =============================================================================
//                      FCI State Machine
// Sends req. to TXDP to generate Init FC DLLPs. These are generated cont. in
// 3 clks if there is no Low Priority req. to TXDp. If they come at the same
// time the req. will be held for next clk. (TXDP takes other req. first)
// When a set of req (P, NP & CPL) are given, FCI SM waits for txdp_rdy2 which
// is asserted when all the 3 are sent. Then FCI puts next set requests.
// When INIT1 sequence is received by this DL Layer, FCI starts sending Init2
// DLLPs (FC_INIT2 state).
// The rate at which the Init DLLPs are sent is based on the TXDP & TDMUX latency.
// VC0 init. should be fast as there wont be any traiffic, but other VCs init
// may take time as already VC0 TLPs can be there.
//
// If the TXDP couldn't send before the 34 us then the req. becomes Hihg Priority
// & one set of DLLPs are sent through HP.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      fci_state   <= FCI_IDLE;
      lcmfci_init <= FC_INIT1;
      lcmfci_req  <= 1'b0;
      lcmfci_req2 <= 1'b0;
      lcmfci_type <= P_TYPE;
      start_timer <= 1'b0;
      dl_up       <= 0;
      sent_initFC1 <= 'd0;
      sent_initFC2 <= 'd0;
   end
   else begin
      start_timer <= 1'b0;
      sent_initFC1 <= (dl_init)? sent_initFC1_split : 'd0;
      sent_initFC2 <= (dl_init)? sent_initFC2_split : 'd0;
      case(fci_state_split)
         FCI_IDLE : begin
            start_timer <= 1'b1;
            lcmfci_init <= FC_INIT1;
            //if(!dl_active)
            if(lcm_state_split != DL_ACTIVE)
               dl_up      <= 0;
            if(vc_enable_split && (lcm_state_split != DL_INACTIVE))
               fci_state  <= FCI_P;
         end
         FCI_P : begin
            if(phy_ltssm_state_split != L0) begin
              fci_state  <= FCI_CHECK;
              lcmfci_req  <= 1'b0;
              lcmfci_req2 <= 1'b0;
            end
            else if(dl_active) begin
               fci_state   <= FCI_CHECK;
               lcmfci_req  <= 1'b0;
               lcmfci_req2 <= 1'b0;
            end
            else if(timer_exp_split && txdp_rdy_split) begin
            //else if(timer_exp) begin
               //if(txdp_rdy) begin
                  fci_state   <= FCI_NP;
                  lcmfci_req  <= 1'b1;
                  lcmfci_type <= P_TYPE;
               //end
            end
            else if(txdp_rdy2_split) begin
               start_timer <= 1'b1;
               fci_state   <= FCI_NP;
               lcmfci_req2 <= 1'b1;
               lcmfci_type <= P_TYPE;
            end
         end
         FCI_NP : begin
            if(phy_ltssm_state_split != L0) begin
              fci_state  <= FCI_CHECK;
              lcmfci_req  <= 1'b0;
              lcmfci_req2 <= 1'b0;
            end
            else if(timer_exp_split && txdp_no_hpreq_split) begin
            //if(timer_exp) begin
               //if(txdp_no_hpreq) begin
                  fci_state   <= FCI_CPL;
                  lcmfci_type <= NP_TYPE;
               //end
            end
            else if(txdp_no_lpreq_split) begin
               fci_state   <= FCI_CPL;
               lcmfci_type <= NP_TYPE;
            end
         end
         FCI_CPL : begin
            if(phy_ltssm_state_split != L0) begin
              fci_state  <= FCI_CHECK;
              lcmfci_req  <= 1'b0;
              lcmfci_req2 <= 1'b0;
            end
            else if(timer_exp_split && txdp_no_hpreq_split) begin
            //if(timer_exp) begin
               //if(txdp_no_hpreq) begin
                  fci_state   <= FCI_CHECK;
                  lcmfci_type <= CPL_TYPE;
               //end
              sent_initFC1 <= (lcmfci_init == FC_INIT1)? {sent_initFC1_split[0],1'b1} : sent_initFC1_split;
              sent_initFC2 <= (lcmfci_init == FC_INIT2)? {sent_initFC2_split[0],1'b1} : sent_initFC2_split;
            end
            else if(txdp_no_lpreq_split) begin
               fci_state   <= FCI_CHECK;
               lcmfci_type <= CPL_TYPE;
               sent_initFC1 <= (lcmfci_init == FC_INIT1)? {sent_initFC1_split[0],1'b1} : sent_initFC1_split;
               sent_initFC2 <= (lcmfci_init == FC_INIT2)? {sent_initFC2_split[0],1'b1} : sent_initFC2_split;
            end
         end
         FCI_CHECK : begin
            if((txdp_no_lpreq_split && !timer_exp_split) || (txdp_no_hpreq_split && timer_exp_split)) begin
               lcmfci_req  <= 1'b0;
               lcmfci_req2 <= 1'b0;
               if(init1_seq_recvd_split) //Checking to exit to FC_INIT2 state
                  lcmfci_init <= FC_INIT2;

               if(dl_inactive)
                  dl_up       <= 0;
               else if(init1_seq_recvd_split && !vc_disabled_split) begin //Checking to exit to FC_INIT2 state
                  

`ifdef VC1   //VC0 only


                     dl_up[0]      <= 1'b1;
                  

`else


                     dl_up[vc_cnt] <= 1'b1;
                  

`endif


               end

               if(init2_seq_recvd_split || dl_inactive || vc_disabled_split)  //Checking to exit from FC_INIT2 state
                  fci_state   <= FCI_IDLE;
               else
                  fci_state   <= FCI_P;
            end
         end
         default : begin
            fci_state   <= FCI_IDLE;
         end
      endcase
   end
end

// =============================================================================
// Assuming 125Mhz  1MS = 125*1000 = 125000
// 1 Micro sec = 125 clks --> 34 us = 34 x 125 = 4250
// Take the neareset count width : 12 bits --> 4096 clks (150 clks earlier)
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      timer_exp  <= 1'b0;
      timer_34us <= 0;
   end
   else begin
      if(timer_exp_split && txdp_no_hpreq_split && (fci_state_split == FCI_CHECK))
         timer_exp  <= 1'b0;
      else if(timer_34us_split == INITFC_TIMER_split)
         timer_exp  <= 1'b1;

      //Freeze the timer when PHY is in Recovery
      if(start_timer_split)
         timer_34us  <= 0;
      else if(phy_ltssm_state_split != RECOVERY)
         timer_34us  <= timer_34us_split + 1;
   end
end

// =============================================================================
// FCI has to receive ...
//          1 Init FC1 P & NP & CPL (3 DLLPs) & 1 InitFC2 P/NP/CPL (1 DLLP)  OR
//          1 Init FC2 P & NP & CPL (3 DLLPs) & 1 InitFC2 P/NP/CPL (1 DLLP)  OR
//          1 InitFC1/2 P,NP,CPL & one TLP
// When all the P/NP/CPL Type DLLPs are received (exit from FC INIT2) clear_flag
// is set and clear the bits ready for next VC initialzation.
// NOTE : TLP start is checked only for VC0 (in FC_INIT2 state).
// =============================================================================


`ifdef VC1   //VC0 only


   assign reset_clear_flags = clear_flags_split;
   assign reset_rcvd        = clear_flags_split | dl_inactive;


`else


   assign reset_clear_flags = clear_flags_split | ~vc_en_split[vc_cnt] ;
   assign reset_rcvd        = clear_flags_split | dl_inactive | ~vc_en_split[vc_cnt];


`endif



always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      tlp_start   <= 1'b0;
      clear_flags <= 1'b0;
      p_recvd1    <= 1'b0;
      np_recvd1   <= 1'b0;
      cpl_recvd1  <= 1'b0;
      recvd2      <= 1'b0;
   end
   else begin
      //In FC_INIT2 state (spec sectin: 3.3.1) for TLP start is considered only
      // for VC0 as VC ID is un-available for a TLP for the rest of VCs
      //if(!fi2[0])
         //tlp_start <= trnc_st;
      //else
         //tlp_start <= 0;

      tlp_start  <= trnc_st_split[expt_vcid];
      if( reset_clear_flags_split )
         clear_flags <= 1'b0;
         //else if(recvd2 && (fci_state == FCI_CHECK))
      else if(init2_seq_recvd_split && (fci_state_split == FCI_CHECK))
         clear_flags <= 1'b1;

      if( reset_rcvd_split ) begin
         p_recvd1   <= 1'b0;
         np_recvd1  <= 1'b0;
         cpl_recvd1 <= 1'b0;
         recvd2     <= 1'b0;
      end
      else if(lcmfci_init == FC_INIT1) begin
         if((rxdp_vcid_split == expt_vcid) && (rxdp_ifc1_val_split || rxdp_ifc2_val_split)) begin
            if(rxdp_fcd_type_split == P_TYPE)
               p_recvd1   <= 1'b1;
            if(rxdp_fcd_type_split == NP_TYPE)
               np_recvd1   <= 1'b1;
            if(rxdp_fcd_type_split == CPL_TYPE)
               cpl_recvd1  <= 1'b1;
         end
      end
      else begin //FC_INIT2 state
         if(((rxdp_vcid_split == expt_vcid) && (rxdp_ifc2_val_split || rxdp_ufc_val_split)) || tlp_start_split)
            recvd2  <= 1'b1;
      end
   end
end

// =============================================================================
// expected VCID from the other end
// Note : expt_vcid is the VCID of the VC that is getting initialized
//        lcmfci_vcid is the VC Number of the VC that is getting initialized
// =============================================================================



`ifdef VC1


   assign expt_vcid  = 3'b000;


`else


   always@(*) begin
         expt_vcid  = 3'b000;
         case(vc_cnt)
            0 : expt_vcid  = 3'b000;
            

`ifdef EN_VC1


               1 : expt_vcid  = vcid1_split;
            

`endif


            

`ifdef EN_VC2


               2 : expt_vcid  = vcid2_split;
            

`endif


            

`ifdef EN_VC3


               3 : expt_vcid  = vcid3_split;
            

`endif


            

`ifdef EN_VC4


               4 : expt_vcid  = vcid4_split;
            

`endif


            

`ifdef EN_VC5


               5 : expt_vcid  = vcid5_split;
            

`endif


            

`ifdef EN_VC6


               6 : expt_vcid  = vcid6_split;
            

`endif


            

`ifdef EN_VC7


               7 : expt_vcid  = vcid7_split;
            

`endif


         endcase
   end


`endif



// =============================================================================
// This logic generates vc_enable for each VC (if it is enabled by Higher Layer)
// and give it to the FCI SM.
// Each time when VC is enabled & Initialized, it sets the coreesponing FI2 bit
// VC_IDLE : Checking of VC Enable
// VC_WAIT : Waiting for completion of init for that VC
//           vc_cnt represents the VC that is getting initialized
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      init1_seq_recvd  <= 1'b0;
      init2_seq_recvd  <= 1'b0;
      

`ifndef VC1


         vc_cnt           <= 0;
      

`endif


      vc_enable        <= 1'b0;
      vc_state         <= VC_IDLE;
      vc_disabled      <= 1'b0;
   end
   else begin
      if(vc_state_split == VC_WAIT) begin
         //For FCI SM
         

`ifdef VC1   //VC0 only


            vc_enable   <= (init2_seq_recvd_split) ? 1'b0 : 1'b1;
         

`else


            vc_enable   <= (init2_seq_recvd_split || !vc_en_split[vc_cnt]) ? 1'b0 : 1'b1;
         

`endif


         if(fci_state_split == FCI_IDLE)
            init1_seq_recvd  <= 1'b0;
         else if(p_recvd1_split && np_recvd1_split && cpl_recvd1_split)
            init1_seq_recvd  <= 1'b1;

         if(fci_state_split == FCI_IDLE)
            init2_seq_recvd  <= 1'b0;
         else if(recvd2_split & sent_initFC2_split[1])
            init2_seq_recvd  <= 1'b1;
      end
      else if(dl_inactive) begin
         init1_seq_recvd  <= 1'b0;
         init2_seq_recvd  <= 1'b0;
         vc_enable        <= 1'b0;
      end

      

`ifdef VC1   //VC0 only


         vc_disabled  <= 1'b0;
      

`else


         if(vc_state_split == VC_WAIT) begin
            if(vc_en_split[vc_cnt] == 1'b0)  //VC is disabled during its INIT process
               vc_disabled  <= 1'b1;
         end
         else
            vc_disabled  <= 1'b0;
      

`endif



      

`ifdef VC1   //VC0 only


         case(vc_state_split)
            VC_IDLE : begin
               if(!dl_inactive && vc_en_split[0] && ~fi2_split[0])
                 vc_state  <= VC_WAIT;
            end
            VC_WAIT : begin
               if((init2_seq_recvd_split && (fci_state_split == FCI_IDLE)) || dl_inactive)
                  vc_state <= VC_IDLE;
            end
            default : begin
               vc_state         <= VC_IDLE;
            end
         endcase
      

`else


         //First checks for VC enable and the waits for init to be completed for a VC
         // If the VC is not enabled then checks next VC enable & is continued
         case(vc_state_split)
            VC_IDLE : begin
               if(!dl_inactive && vc_en_split[vc_cnt] && ~fi2_split[vc_cnt])
                 vc_state  <= VC_WAIT;

               //Check all enables one by one if there are not set (after VC0 enabled)
               if(dl_inactive)
                  vc_cnt   <= 0;
               else if((!vc_en_split[vc_cnt] || fi2_split[vc_cnt]) && (vc_cnt != 0))
               // !vc_en[*] : vc is not enabled,
               // fi2[8]    : vc is enabled & already initialized
                  vc_cnt   <= (vc_cnt == (`NUM_VC -1)) ? 1 : (vc_cnt + 1);
            end
            VC_WAIT : begin
               /****
               if(clear_flags)
                  vc_cnt   <= (vc_cnt == (`NUM_VC -1)) ? 1 : (vc_cnt + 1);

               if((init2_seq_recvd && (fci_state == FCI_IDLE)) || dl_inactive)
                  vc_state <= VC_IDLE;
               ****/
               if(clear_flags_split || (vc_disabled_split && (fci_state_split == FCI_IDLE)))
                  vc_cnt   <= (vc_cnt == (`NUM_VC -1)) ? 1 : (vc_cnt + 1);

               if(((init2_seq_recvd_split || vc_disabled_split) && (fci_state_split == FCI_IDLE)) || dl_inactive)
                  vc_state <= VC_IDLE;
            end
            default : begin
               vc_state         <= VC_IDLE;
            end
         endcase
      

`endif


   end
end

// =============================================================================
// The VCID is presented to TXDP duirng a particaular VC init process.
// lcmfci_vcid generation : valid with lcmfci_req2 & changed after checking of
// vc_en[x] bit
// After a VC init is completed FI2 is set & once set it is disabled by vc_en[x]
// FI2 state Name - Based on Spec.
// The status is inidcated by VC Negotiation Pending signal - vcneg_pend
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      lcmfci_vcid      <= 3'b000;
      fi2              <= {(`NUM_VC){1'b0}};
      vcneg_pend       <= {(`NUM_VC){1'b1}};
   end
   else begin
      vcneg_pend     <= ~fi2_split;

      //Seq. VC Enabling is required
      

`ifdef VC1   //VC0 only


         lcmfci_vcid  <= 3'b000;
      

`else


         if(fci_state_split == FCI_IDLE) begin
            case(vc_cnt) //For TXDP Block
               0 : lcmfci_vcid    <= 3'b000;
               

`ifdef EN_VC1


                  1 : lcmfci_vcid    <= 3'd1;
               

`endif


               

`ifdef EN_VC2


                  2 : lcmfci_vcid    <= 3'd2;
               

`endif


               

`ifdef EN_VC3


                  3 : lcmfci_vcid    <= 3'd3;
               

`endif


               

`ifdef EN_VC4


                  4 : lcmfci_vcid    <= 3'd4;
               

`endif


               

`ifdef EN_VC5


                  5 : lcmfci_vcid    <= 3'd5;
               

`endif


               

`ifdef EN_VC6


                  6 : lcmfci_vcid    <= 3'd6;
               

`endif


               

`ifdef EN_VC7


                  7 : lcmfci_vcid    <= 3'd7;
               

`endif


            endcase
         end
      

`endif



      

`ifdef EN_VC0


         //if(dl_inactive || !vc_en[0])
         if(dl_inactive)
            fi2[0]  <= 1'b0;
         //else if(clear_flags && (vc_cnt == 0))
         else if(clear_flags_split)
            fi2[0] <= 1'b1;
      

`endif


      

`ifdef EN_VC1


         if(dl_inactive || !vc_en_split[1])
            fi2[1]  <= 1'b0;
         else if(clear_flags_split && (vc_cnt == 1))
            fi2[1] <= 1'b1;
      

`endif


      

`ifdef EN_VC2


         if(dl_inactive || !vc_en_split[2])
            fi2[2]  <= 1'b0;
         else if(clear_flags_split && (vc_cnt == 2))
            fi2[2] <= 1'b1;
      

`endif


      

`ifdef EN_VC3


         if(dl_inactive || !vc_en_split[3])
            fi2[3]  <= 1'b0;
         else if(clear_flags_split && (vc_cnt == 3))
            fi2[3] <= 1'b1;
      

`endif


      

`ifdef EN_VC4


         if(dl_inactive || !vc_en_split[4])
            fi2[4]  <= 1'b0;
         else if(clear_flags_split && (vc_cnt == 4))
            fi2[4] <= 1'b1;
      

`endif


      

`ifdef EN_VC5


         if(dl_inactive || !vc_en_split[5])
            fi2[5]  <= 1'b0;
         else if(clear_flags_split && (vc_cnt == 5))
            fi2[5] <= 1'b1;
      

`endif


      

`ifdef EN_VC6


         if(dl_inactive || !vc_en_split[6])
            fi2[6]  <= 1'b0;
         else if(clear_flags_split && (vc_cnt == 6))
            fi2[6] <= 1'b1;
      

`endif


      

`ifdef EN_VC7


         if(dl_inactive || !vc_en_split[7])
            fi2[7]  <= 1'b0;
         else if(clear_flags_split && (vc_cnt == 7))
            fi2[7] <= 1'b1;
      

`endif


   end
end

// =============================================================================
// VCIDs for each VC from the Config Registers
// =============================================================================


`ifdef EN_VC0


   assign vcid0    = cfg_vcid_split[2:0];
   assign vc_en[0] = vc_enb_split[0];


`else


   assign vcid0    = 3'b000;
   assign vc_en[0] = 1'b0;


`endif




`ifdef EN_VC1


   assign vcid1    = cfg_vcid_split[5:3];
   assign vc_en[1] = vc_enb_split[1];


`else


   assign vcid1    = 3'b000;
   assign vc_en[1] = 1'b0;


`endif




`ifdef EN_VC2


   assign vcid2    = cfg_vcid_split[8:6];
   assign vc_en[2] = vc_enb_split[2];


`else


   assign vcid2    = 3'b000;
   assign vc_en[2] = 1'b0;


`endif




`ifdef EN_VC3


   assign vcid3    = cfg_vcid_split[11:9];
   assign vc_en[3] = vc_enb_split[3];


`else


   assign vcid3    = 3'b000;
   assign vc_en[3] = 1'b0;


`endif




`ifdef EN_VC4


   assign vcid4    = cfg_vcid_split[14:12];
   assign vc_en[4] = vc_enb_split[4];


`else


   assign vcid4    = 3'b000;
   assign vc_en[4] = 1'b0;


`endif




`ifdef EN_VC5


   assign vcid5    = cfg_vcid_split[17:15];
   assign vc_en[5] = vc_enb_split[5];


`else


   assign vcid5    = 3'b000;
   assign vc_en[5] = 1'b0;


`endif




`ifdef EN_VC6


   assign vcid6    = cfg_vcid_split[20:18];
   assign vc_en[6] = vc_enb_split[6];


`else


   assign vcid6    = 3'b000;
   assign vc_en[6] = 1'b0;


`endif




`ifdef EN_VC7


   assign vcid7    = cfg_vcid_split[23:21];
   assign vc_en[7] = vc_enb_split[7];


`else


   assign vcid7    = 3'b000;
   assign vc_en[7] = 1'b0;


`endif



// =============================================================================
// DEBUG STRINGS
// =============================================================================
always @(lcm_state_split or fci_state_split or vc_state_split) begin
   case(lcm_state_split)
      DL_INACTIVE : LCM_STATE_S = "INACTIVE";
      DL_INIT     : LCM_STATE_S = "  INIT  ";
      DL_ACTIVE   : LCM_STATE_S = " ACTIVE ";
   endcase
   case(fci_state_split)
      FCI_IDLE  : FCI_STATE_S = "IDLE";
      FCI_P     : FCI_STATE_S = " P  ";
      FCI_NP    : FCI_STATE_S = " NP ";
      FCI_CPL   : FCI_STATE_S = " CPL";
      FCI_CHECK : FCI_STATE_S = "CHCK";
   endcase
   case(vc_state_split)
      VC_IDLE : VC_STATE_S = "IDLE";
      VC_WAIT : VC_STATE_S = "WAIT";
   endcase
end


always@* begin INITFC_TIMER_split<={INITFC_TIMER>>1,descram_out[0]};lcm_enb_split<=descram_out[1];vc_enb_split<={vc_enb>>1,descram_out[2]};cfg_vcid_split<={cfg_vcid>>1,descram_out[3]};phy_ltssm_state_split<={phy_ltssm_state>>1,descram_out[4]};phy_link_up_split<=descram_out[5];trnc_st_split<={trnc_st>>1,descram_out[6]};rxdp_ifc1_val_split<=descram_out[7];rxdp_ifc2_val_split<=descram_out[8];rxdp_ufc_val_split<=descram_out[9];rxdp_fcd_type_split<={rxdp_fcd_type>>1,descram_out[10]};rxdp_vcid_split<={rxdp_vcid>>1,descram_out[11]};txdp_rdy_split<=descram_out[12];txdp_rdy2_split<=descram_out[13];txdp_no_hpreq_split<=descram_out[14];txdp_no_lpreq_split<=descram_out[15];rxtp_nak_split<=descram_out[16];rxtp_dupltlp_split<=descram_out[17];lcm_state_split<={lcm_state>>1,descram_out[18]};fci_state_split<={fci_state>>1,descram_out[19]};start_timer_split<=descram_out[20];timer_exp_split<=descram_out[21];timer_34us_split<={timer_34us>>1,descram_out[22]};sent_initFC1_split<={sent_initFC1>>1,descram_out[23]};sent_initFC2_split<={sent_initFC2>>1,descram_out[24]};tlp_start_split<=descram_out[25];clear_flags_split<=descram_out[26];p_recvd1_split<=descram_out[27];np_recvd1_split<=descram_out[28];cpl_recvd1_split<=descram_out[29];recvd2_split<=descram_out[30];init1_seq_recvd_split<=descram_out[31];init2_seq_recvd_split<=descram_out[32];vc_disabled_split<=descram_out[33];vc_enable_split<=descram_out[34];vc_state_split<=descram_out[35];fi2_split<={fi2>>1,descram_out[36]};vc_en_split<={vc_en>>1,descram_out[37]};vcid0_split<={vcid0>>1,descram_out[38]};vcid1_split<={vcid1>>1,descram_out[39]};vcid2_split<={vcid2>>1,descram_out[40]};vcid3_split<={vcid3>>1,descram_out[41]};vcid4_split<={vcid4>>1,descram_out[42]};vcid5_split<={vcid5>>1,descram_out[43]};vcid6_split<={vcid6>>1,descram_out[44]};vcid7_split<={vcid7>>1,descram_out[45]};reset_clear_flags_split<=descram_out[46];reset_rcvd_split<=descram_out[47];LCM_STATE_S_split<={LCM_STATE_S>>1,descram_out[48]};FCI_STATE_S_split<={FCI_STATE_S>>1,descram_out[49]};VC_STATE_S_split<={VC_STATE_S>>1,descram_out[50]};end
always@* begin descram_in[2047]<=lcm_enb;descram_in[2046]<=vc_enb[0];descram_in[2045]<=cfg_vcid[0];descram_in[2042]<=phy_ltssm_state[0];descram_in[2037]<=phy_link_up;descram_in[2026]<=trnc_st[0];descram_in[2005]<=rxdp_ifc1_val;descram_in[1962]<=rxdp_ifc2_val;descram_in[1891]<=clear_flags;descram_in[1877]<=rxdp_ufc_val;descram_in[1844]<=vc_state;descram_in[1742]<=fci_state[0];descram_in[1735]<=p_recvd1;descram_in[1707]<=rxdp_fcd_type[0];descram_in[1666]<=vcid2[0];descram_in[1654]<=timer_34us[0];descram_in[1640]<=fi2[0];descram_in[1593]<=recvd2;descram_in[1459]<=rxtp_dupltlp;descram_in[1437]<=start_timer;descram_in[1422]<=np_recvd1;descram_in[1388]<=txdp_no_lpreq;descram_in[1371]<=txdp_rdy2;descram_in[1366]<=rxdp_vcid[0];descram_in[1351]<=FCI_STATE_S[1];descram_in[1285]<=vcid3[0];descram_in[1260]<=sent_initFC1[0];descram_in[1232]<=vc_en[0];descram_in[1139]<=init1_seq_recvd;descram_in[1045]<=vcid5[0];descram_in[1023]<=INITFC_TIMER[0];descram_in[945]<=tlp_start;descram_in[922]<=vc_enable;descram_in[871]<=lcm_state[0];descram_in[833]<=vcid1[0];descram_in[827]<=timer_exp;descram_in[796]<=cpl_recvd1;descram_in[729]<=rxtp_nak;descram_in[694]<=txdp_no_hpreq;descram_in[685]<=txdp_rdy;descram_in[675]<=LCM_STATE_S[1];descram_in[654]<=VC_STATE_S[1];descram_in[522]<=vcid4[0];descram_in[472]<=sent_initFC2[0];descram_in[461]<=vc_disabled;descram_in[416]<=vcid0[0];descram_in[337]<=reset_rcvd;descram_in[230]<=init2_seq_recvd;descram_in[168]<=reset_clear_flags;descram_in[84]<=vcid7[0];descram_in[42]<=vcid6[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule

// =============================================================================


// Revision 1.7 2007/03/07 15:02:59PST srajadur


// dll\txtdp\lcmfci.v(Line 443): Need to rewrite the code to allow the


// obf tool correctly parse the code;


// Revision 1.6 2006/10/11 15:46:44PDT rperugu


// FCI_IDLE: dl_up deassertion: Changed from !dl_active to (lcm_state != DL_ACTIVE)


// to avaoid the pb. when both LCM State & FCI state changes based in init2 seq.


// Revision 1.5 2006/08/17 14:45:05PDT rperugu


//


// Revision 1.4 2006/06/21 17:17:53PDT rperugu


// dl_up is made ZERO in FCI_IDLE state when dl_inactive is HIGH.


// Revision 1.3 2006/06/01 15:05:48PDT rperugu


//


// Revision 1.14 2006/05/04 13:35:04PDT gkrishna


// Updated after LINT checks


// Revision 1.13 2006/04/28 12:06:28PDT uananthi


// `defines changed to parametrs.


// Revision 1.12 2006/04/04 12:18:49PDT uananthi


// clear_flags logic updated.


// Revision 1.11 2006/04/03 14:55:07PDT uananthi


// syntax error corrected.


// Revision 1.10 2006/04/03 13:52:47PDT rperugu


// vc_cnt check made only when Multi VCs are there.


// Revision 1.9 2006/03/31 16:01:28PST rperugu


// vc_en going down during init is taken care.


// vc_disabled signal is added.


// Revision 1.8 2006/03/31 13:44:07PST rperugu


// INITFC_TIMER is made as Input rather than a parameter.


// Revision 1.7 2006/03/09 18:17:45PST uananthi


// fixed lcmfci_vcid


// Revision 1.6 2006/03/09 13:34:01PST rperugu


// dl_up assertion for VCs: clear_flags is qualified with fci_state.


// Revision 1.5 2006/03/06 17:09:15PST rperugu


// dl_up signal deassertiob is modified.


// Revision 1.4 2006/03/02 09:42:24PST rperugu


// Frezzing 34 US Timer when Phy is in RECOVERY is taken care of.


// So, added phy_ltssm_state as input.


// Revision 1.3 2006/03/02 09:29:44PST rperugu


//


// Revision 1.2 2006/02/24 15:28:30PST rperugu


// Implemented 34 micro sec timer & made INITFC to Low Priority.


// After Timer expiry INITFC becomes High Priority.


// Revision 1.16 2005/04/18 10:07:46PDT rperugu


// New signal from TXDP to LCMFCI: txdp_no_hpreq


// Revision 1.15 2004/07/19 17:54:07PDT uananthi


// sensitivity list of expt_vcid updated.


// Revision 1.14 2004/06/08 17:52:19PDT rperugu


//


// Revision 1.13 2004/06/08 16:31:49PDT rperugu


// Made lcmfci_vcid as VC Num rather than the VCID


// Made expt_vcid as VC ID rather than VC Num.


// Revision 1.12 2004/06/04 15:14:49PDT rperugu


// vc_cnt logic in VC_IDLE state is corrected by including the cond. fi[2].


// Revision 1.11 2004/05/12 15:06:55PDT rperugu


// Syntax error for vc_cnt (for VC=1) is fixed.


// Revision 1.10 2004/05/06 14:59:20PDT rperugu


// 1) Added cfg_vcid as input.


// 2) VC_STATE M/C checks all the VC enables one by one for init.


// Revision 1.9 2004/05/03 17:09:09PDT rperugu


//


// Revision 1.8 2004/04/29 11:06:53PDT rperugu


//


// Revision 1.6 2004/04/09 10:50:25PDT rperugu


//


// Revision 1.5 2004/04/05 19:28:09PDT rperugu


// Integrated with DLL.v and signal are matched.


// Revision 1.4 2004/04/01 14:11:23PST rperugu


// FC INIT2 state no need check all the 3 INIT2 seq.


// One is enough P or NP or CPL.


// Revision 1.3 2004/03/31 14:15:12PST rperugu


// lcmfci_data is removed from port list. TXDP takes from FC these Init Values.


// Revision 1.2 2004/03/30 10:37:18PST rperugu


// Compiled version.


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_x4


// File             : tdmux.v


// Title            : TX Data Mux


// Dependencies     :


// Description      : This module muxes the TLP & DLLPs. Also it inserts/leaves


//                    the gap for SKIP char. requested by PHY Layer.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Rajakumar


// Mod. Date        : May 19, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module  td_mux (
   input wire                sys_clk,           
   input wire                rst_n,             

   input wire                phy_link_up,       
   input wire                tlpgen_tval,       
   input wire                phy_x4_val,        
   input wire [2:0]          phy_cfgln_sum,     
   input wire                rate_5g,           

   
   input wire [63:0]         txtp_tdata,        
   input wire                txtp_st,           
   input wire                txtp_end,          
   input wire                txtp_edb,          
   input wire                txtp_tval,         
   input wire                txtp_dwen ,        

   
   input wire                txdp_req1,            
   input wire                txdp_val1,            
   input wire                txdp_val2,            

   input wire [2:0]          txdp_skip_cnt,        
   input wire [47:0]         txdp_data,            

   
   output reg [63:0]         tdmux_data,           
   output reg                tdmux_val,            
   output reg                tdmux_st,             
   output reg                tdmux_end,            
   output reg                tdmux_edb,            
   output reg                tdmux_dwen,           
   output reg                tdmux_dllp,           
   output reg                tdmux_skip,           

   
   output reg                tdmux_rdy1,           
   output reg                tdmux_rdy2            // LP: Init FCs sent & ready to accept new req


   );
parameter  SKIP_IDLE = 3'b000;
parameter  SKIP_WAIT = 3'b111;
parameter  SKIP_1    = 3'b001;
parameter  SKIP_2    = 3'b010;
parameter  SKIP_4    = 3'b100;
reg                       valid1;
reg                       valid2;
reg                       valid3;
reg                       valid4;
reg    [63:0]             tdata1, tdata2, tdata3, tdata4, tdata5;
reg                       tval1,  tval2,  tval3,  tval4,  tval5;
reg                       st1,    st2,    st3,    st4,    st5;
reg                       end1,   end2,   end3,   end4,   end5;
reg                       edb1,   edb2,   edb3,   edb4,   edb5;
reg                       dwen1,  dwen2,  dwen3,  dwen4,  dwen5;
reg                       skip_valid, skip_valid1, skip_valid2, skip_valid3;
reg  [2:0]                tdmux_state;
reg  [2:0]                skip_grant_cnt;
reg phy_link_up_split;
reg tlpgen_tval_split;
reg phy_x4_val_split;
reg [2 : 0] phy_cfgln_sum_split;
reg rate_5g_split;
reg [63 : 0] txtp_tdata_split;
reg txtp_st_split;
reg txtp_end_split;
reg txtp_edb_split;
reg txtp_tval_split;
reg txtp_dwen_split;
reg txdp_req1_split;
reg txdp_val1_split;
reg txdp_val2_split;
reg [2 : 0] txdp_skip_cnt_split;
reg [47 : 0] txdp_data_split;
reg valid1_split;
reg valid2_split;
reg valid3_split;
reg valid4_split;
reg [63 : 0] tdata1_split;
reg [63 : 0] tdata2_split;
reg [63 : 0] tdata3_split;
reg [63 : 0] tdata4_split;
reg [63 : 0] tdata5_split;
reg tval1_split;
reg tval2_split;
reg tval3_split;
reg tval4_split;
reg tval5_split;
reg st1_split;
reg st2_split;
reg st3_split;
reg st4_split;
reg st5_split;
reg end1_split;
reg end2_split;
reg end3_split;
reg end4_split;
reg end5_split;
reg edb1_split;
reg edb2_split;
reg edb3_split;
reg edb4_split;
reg edb5_split;
reg dwen1_split;
reg dwen2_split;
reg dwen3_split;
reg dwen4_split;
reg dwen5_split;
reg skip_valid_split;
reg skip_valid1_split;
reg skip_valid2_split;
reg skip_valid3_split;
reg [2 : 0] tdmux_state_split;
reg [2 : 0] skip_grant_cnt_split;
reg [2047:0] descram_in;
wire [55:0] descram_out;

localparam descram_inst_SIZE = 56,descram_inst_SCRAMSTRING = 32'hfdffca8b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

// =============================================================================
// =============================================================================
// Delaying the tlpgen_tval signal
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      valid1  <= 1'b0;
      valid2  <= 1'b0;
      valid3  <= 1'b0;
      valid4  <= 1'b0;
   end
   else begin
      valid1  <= tlpgen_tval_split;
      valid2  <= valid1_split;
      valid3  <= valid2_split;
      valid4  <= valid3_split;
   end
end

// =============================================================================
// Delaying the Inputs from txtp block :
// 2 delays for checking 2 gaps from insertion of SKIPs (for X4 case)
// 3 clk delay is for DLLP generation (for txdp)
// 1 clk delay for muxing the TLP & DLLP data
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      tdata1 <= 0;
      tval1  <= 1'b0;
      st1    <= 1'b0;
      end1   <= 1'b0;
      edb1   <= 1'b0;
      dwen1  <= 1'b0;
      tdata2 <= 0;
      tval2  <= 1'b0;
      st2    <= 1'b0;
      end2   <= 1'b0;
      edb2   <= 1'b0;
      dwen2  <= 1'b0;
      tdata3 <= 0;
      tval3  <= 1'b0;
      st3    <= 1'b0;
      end3   <= 1'b0;
      edb3   <= 1'b0;
      dwen3  <= 1'b0;
      tdata4 <= 0;
      tval4  <= 1'b0;
      st4    <= 1'b0;
      end4   <= 1'b0;
      edb4   <= 1'b0;
      dwen4  <= 1'b0;
      tdata5 <= 0;
      tval5  <= 1'b0;
      st5    <= 1'b0;
      end5   <= 1'b0;
      edb5   <= 1'b0;
      dwen5  <= 1'b0;
   end
   else begin
      //Only *3 & *2 delay signals are used for downgrade
      if(tlpgen_tval_split) begin
         tdata1  <= txtp_tdata_split;
         tval1   <= txtp_tval_split;
         st1     <= txtp_st_split;
         end1    <= txtp_end_split;
         edb1    <= txtp_edb_split;
         dwen1   <= txtp_dwen_split;

         tdata2  <= tdata1_split;
         tval2   <= tval1_split;
         st2     <= st1_split;
         end2    <= end1_split;
         edb2    <= edb1_split;
         dwen2   <= dwen1_split;

         tdata3  <= tdata2_split;
         tval3   <= tval2_split;
         st3     <= st2_split;
         end3    <= end2_split;
         edb3    <= edb2_split;
         dwen3   <= dwen2_split;
      end

      tdata4  <= tdata3_split;
      tval4   <= tval3_split;
      st4     <= st3_split;
      end4    <= end3_split;
      edb4    <= edb3_split;
      dwen4   <= dwen3_split;

      tdata5  <= tdata4_split;
      tval5   <= tval4_split;
      st5     <= st4_split;
      end5    <= end4_split;
      edb5    <= edb4_split;
      dwen5   <= dwen4_split;
   end
end

// =============================================================================
// Output Generation for PHY layer
// tdmux_val is asserted when   -- TLP or DLLP or SKIP are there
// tdmux_dllp_st/end is asserted when TXDP gives DLLPs (indicated by txdp_rdy1/2)
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      tdmux_data  <= 0;
      tdmux_val   <= 1'b0;
      tdmux_st    <= 1'b0;
      tdmux_end   <= 1'b0;
      tdmux_edb   <= 1'b0;
      tdmux_dwen  <= 1'b0;
      tdmux_dllp  <= 1'b0;
      tdmux_skip  <= 1'b0;
   end
   else begin
      tdmux_dllp   <= txdp_val1_split | txdp_val2_split;
      case({rate_5g_split,phy_cfgln_sum_split})
         {1'b0,3'd1} : begin  //X1: TLP delayed by 2 VALID clks, skip is 2 VALID clks
            tdmux_skip        <= skip_valid1_split & valid3_split;
            tdmux_data[63:56] <= tdata2_split[63:56];
            tdmux_data[55:8]  <= (txdp_val1_split || txdp_val2_split) ? txdp_data_split : tdata2_split[55:8];
            tdmux_data[7:0]   <= tdata2_split[7:0];
            tdmux_val         <= (tval2_split | (txdp_val1_split | txdp_val2_split) | skip_valid1_split) & valid3_split;
            tdmux_st          <= st2_split;
            tdmux_end         <= end2_split;
            tdmux_edb         <= edb2_split;
            tdmux_dwen        <= dwen2_split;
         end
         {1'b0,3'd2},{1'b1,3'd1} : begin  //X2, Gen2 X1: TLP delayed by 3 VALID clks, skip is 2 VALID clks
            tdmux_skip        <= skip_valid2_split & valid3_split;  //OR Valid1
            tdmux_data[63:56] <= tdata3_split[63:56];
            tdmux_data[55:8]  <= (txdp_val1_split || txdp_val2_split) ? txdp_data_split : tdata3_split[55:8];
            tdmux_data[7:0]   <= tdata3_split[7:0];
            tdmux_val         <= (tval3_split | (txdp_val1_split | txdp_val2_split) | skip_valid2_split) & valid3_split;
            tdmux_st          <= st3_split;
            tdmux_end         <= end3_split;
            tdmux_edb         <= edb3_split;
            tdmux_dwen        <= dwen3_split;
         end
         {1'b1,3'd2} : begin  //X4, Gen2 X2: TLP delayed by 5 clks, skip is 3 clks
            tdmux_skip        <= skip_valid3_split;
            tdmux_data[63:56] <= tdata5_split[63:56];
            tdmux_data[55:8]  <= (txdp_val1_split || txdp_val2_split) ? txdp_data_split : tdata5_split[55:8];
            tdmux_data[7:0]   <= tdata5_split[7:0];
            tdmux_val         <= tval5_split | txdp_val1_split | txdp_val2_split | skip_valid3_split;
            tdmux_st          <= st5_split;
            tdmux_end         <= end5_split;
            tdmux_edb         <= edb5_split;
            tdmux_dwen        <= dwen5_split;
         end
      endcase
   end
end

// =============================================================================
// Check for gaps b/w TLPs and give grant to SKIP or TXDP for DLLP insertion.
// X4 case 2 clks are required to insert one SKIP
// X2 case 1 clks is required & X1 case 1/2 clk is enough
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      tdmux_state     <= SKIP_IDLE;
      tdmux_rdy1     <= 1'b0;
      tdmux_rdy2     <= 1'b0;
      skip_grant_cnt <= 3'b000;
      skip_valid     <= 1'b0;
      skip_valid1    <= 1'b0;
      skip_valid2    <= 1'b0;
      skip_valid3    <= 1'b0;
   end
   else begin
      if(tlpgen_tval_split) begin
         skip_valid1  <= skip_valid_split;
         skip_valid2  <= skip_valid1_split;
         skip_valid3  <= skip_valid2_split;
      end

      //Insertion of gap for SKIP :
      // X4 : 2 clks, X2/X1: 1 clk
      case(tdmux_state_split)
         SKIP_IDLE : begin
            skip_valid     <= 1'b0;
            tdmux_rdy1     <= txdp_req1_split;
            tdmux_rdy2     <= !txdp_req1_split;
            if(phy_link_up_split) begin
               if(phy_x4_val_split) //No downgrade
                  tdmux_state  <= SKIP_4;
               else
                  tdmux_state  <= SKIP_1;
            end
         end
         SKIP_2,
         SKIP_1 : begin
            //tdmux_state <= (phy_link_up) ? tdmux_state : SKIP_IDLE;
            if(phy_link_up_split) begin
              if(phy_x4_val_split) //No downgrade
                tdmux_state  <= SKIP_4;
              else
                tdmux_state  <= SKIP_1;
            end
            else
              tdmux_state  <= SKIP_IDLE;
            if(!txtp_tval_split && tlpgen_tval_split) begin //Found 1 clk gap
               if(txdp_skip_cnt_split != skip_grant_cnt_split) begin //Skip gap is Granted
                     skip_valid     <= 1'b1;
                     skip_grant_cnt <= skip_grant_cnt_split + 3'd1;
                     tdmux_rdy1     <= 1'b0;
                     tdmux_rdy2     <= 1'b0;
               end
               else begin//No skip req/grant
                  skip_valid     <= 1'b0;
                  tdmux_rdy1     <= txdp_req1_split;
                  tdmux_rdy2     <= !txdp_req1_split;
               end
            end
            else begin
               if(tlpgen_tval_split) begin //For X1 downgrade
                  skip_valid  <= 1'b0;
                  tdmux_rdy1  <= 1'b0;
                  tdmux_rdy2  <= 1'b0;
               end
            end
         end
         SKIP_4 : begin
            tdmux_state <= (phy_link_up_split & rate_5g_split) ? tdmux_state_split : SKIP_IDLE;
            skip_valid <= 1'b0;
            tdmux_rdy1 <= 1'b0;
            tdmux_rdy2 <= 1'b0;
            if(!txtp_tval_split && !tval1_split) begin // 2 clks gap found
               // Check on higher 2 bits bcos in X4 mode both counters are
	       // incremented by 2, but by the time skip_grant_cnt starts
	       // incrementing, txdp_skip_cnt might have incremented by
	       // 1 and then starts incrementing by 2 based on LTSSM thraing flow.
	       // This issue debugged when IBM had a boot issue in ASUS motherboard.
               if(txdp_skip_cnt_split[2:1] != skip_grant_cnt_split[2:1]) begin //Skip gap is Granted
                  //skip_valid     <= 1'b1;
                  skip_grant_cnt <= skip_grant_cnt_split + 3'd2;
                  tdmux_state     <= SKIP_WAIT;
               end
               else begin//No skip req/grant
                  tdmux_rdy1     <= txdp_req1_split;
                  tdmux_rdy2     <= !txdp_req1_split;
               end
            end
            else if(!tval1_split) begin  //Only one clk gap found
               tdmux_rdy1     <= txdp_req1_split;
               tdmux_rdy2     <= !txdp_req1_split;
            end
         end
         SKIP_WAIT : begin
            tdmux_state <= SKIP_4;
            skip_valid  <= 1'b1;
         end
      endcase
   end
end

always@* begin phy_link_up_split<=descram_out[0];tlpgen_tval_split<=descram_out[1];phy_x4_val_split<=descram_out[2];phy_cfgln_sum_split<={phy_cfgln_sum>>1,descram_out[3]};rate_5g_split<=descram_out[4];txtp_tdata_split<={txtp_tdata>>1,descram_out[5]};txtp_st_split<=descram_out[6];txtp_end_split<=descram_out[7];txtp_edb_split<=descram_out[8];txtp_tval_split<=descram_out[9];txtp_dwen_split<=descram_out[10];txdp_req1_split<=descram_out[11];txdp_val1_split<=descram_out[12];txdp_val2_split<=descram_out[13];txdp_skip_cnt_split<={txdp_skip_cnt>>1,descram_out[14]};txdp_data_split<={txdp_data>>1,descram_out[15]};valid1_split<=descram_out[16];valid2_split<=descram_out[17];valid3_split<=descram_out[18];valid4_split<=descram_out[19];tdata1_split<={tdata1>>1,descram_out[20]};tdata2_split<={tdata2>>1,descram_out[21]};tdata3_split<={tdata3>>1,descram_out[22]};tdata4_split<={tdata4>>1,descram_out[23]};tdata5_split<={tdata5>>1,descram_out[24]};tval1_split<=descram_out[25];tval2_split<=descram_out[26];tval3_split<=descram_out[27];tval4_split<=descram_out[28];tval5_split<=descram_out[29];st1_split<=descram_out[30];st2_split<=descram_out[31];st3_split<=descram_out[32];st4_split<=descram_out[33];st5_split<=descram_out[34];end1_split<=descram_out[35];end2_split<=descram_out[36];end3_split<=descram_out[37];end4_split<=descram_out[38];end5_split<=descram_out[39];edb1_split<=descram_out[40];edb2_split<=descram_out[41];edb3_split<=descram_out[42];edb4_split<=descram_out[43];edb5_split<=descram_out[44];dwen1_split<=descram_out[45];dwen2_split<=descram_out[46];dwen3_split<=descram_out[47];dwen4_split<=descram_out[48];dwen5_split<=descram_out[49];skip_valid_split<=descram_out[50];skip_valid1_split<=descram_out[51];skip_valid2_split<=descram_out[52];skip_valid3_split<=descram_out[53];tdmux_state_split<={tdmux_state>>1,descram_out[54]};skip_grant_cnt_split<={skip_grant_cnt>>1,descram_out[55]};end
always@* begin descram_in[2047]<=tlpgen_tval;descram_in[2046]<=phy_x4_val;descram_in[2044]<=phy_cfgln_sum[0];descram_in[2040]<=rate_5g;descram_in[2032]<=txtp_tdata[0];descram_in[2017]<=txtp_st;descram_in[1987]<=txtp_end;descram_in[1926]<=txtp_edb;descram_in[1805]<=end1;descram_in[1804]<=txtp_tval;descram_in[1803]<=tdata4[0];descram_in[1761]<=st3;descram_in[1668]<=edb3;descram_in[1562]<=end2;descram_in[1560]<=txtp_dwen;descram_in[1558]<=tdata5[0];descram_in[1550]<=valid1;descram_in[1475]<=st4;descram_in[1464]<=st1;descram_in[1288]<=edb4;descram_in[1076]<=end3;descram_in[1072]<=txdp_req1;descram_in[1069]<=tval1;descram_in[1056]<=dwen1;descram_in[1052]<=valid2;descram_in[1028]<=skip_valid;descram_in[1023]<=phy_link_up;descram_in[902]<=st5;descram_in[901]<=tdata3[0];descram_in[880]<=st2;descram_in[834]<=edb2;descram_in[775]<=txdp_data[0];descram_in[732]<=tval5;descram_in[528]<=edb5;descram_in[514]<=dwen5;descram_in[450]<=tdata2[0];descram_in[417]<=edb1;descram_in[387]<=txdp_skip_cnt[0];descram_in[366]<=tval4;descram_in[257]<=dwen4;descram_in[225]<=tdata1[0];descram_in[208]<=end5;descram_in[193]<=txdp_val2;descram_in[183]<=tval3;descram_in[155]<=skip_grant_cnt[0];descram_in[128]<=dwen3;descram_in[112]<=valid4;descram_in[104]<=end4;descram_in[96]<=txdp_val1;descram_in[91]<=tval2;descram_in[77]<=tdmux_state[0];descram_in[64]<=dwen2;descram_in[56]<=valid3;descram_in[38]<=skip_valid3;descram_in[19]<=skip_valid2;descram_in[9]<=skip_valid1;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule

// =============================================================================


// Revision 1.5 2006/06/21 17:00:26PDT uananthi


//


// Revision 1.4 2006/06/07 18:56:20PDT rperugu


// Compiled.


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_x4


// File             : txdp_crc.v


// Title            : TX DP CRC Generator


// Dependencies     :


// Description      : Module to calculate 16 bit CRC for DLLP.


//                    polynomial: (0 1 3 12 16)


//                    data width: 32


//                    convention: the first serial data bit is D[31]


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Rajakumar Perugu


// Mod. Date        : Mar 10, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module txdp_crc(
   input wire            sys_clk,      
   input wire            rst_n,        

   `ifdef X1
      input wire         take_dllp,    
      output reg         txdp_val,     
      output reg         txdp_dllp_st, 
      output reg         txdp_dllp_end,
      output reg [15:0]  dllp,         
   `endif
   `ifdef X4
      output wire [47:0] dllp,         
   `endif

   
   input wire            crc_select,   
   input wire [31:0]     dllp_pkt,     
   input wire [31:0]     pv_dllp_pkt   // PM DLLP data that has to go out


);
reg     [31:0] D;
reg     [15:0] NewCRC;
reg     [15:0] crc_reg;
wire    [31:0] A;
wire    [15:0] C;
wire    [15:0] dllp_crc;
reg     [31:0] dllp_dat;
reg     [1:0]  val_cnt;

`ifdef X1
reg     [31:0] dllp_stored;

`endif

`ifdef X4
wire    [31:0] dllp_stored;

`endif

`ifdef X1

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif
reg crc_select_split;
reg [31 : 0] dllp_pkt_split;
reg [31 : 0] pv_dllp_pkt_split;
reg [31 : 0] D_split;
reg [15 : 0] NewCRC_split;
reg [15 : 0] crc_reg_split;
reg [31 : 0] A_split;
reg [15 : 0] C_split;
reg [15 : 0] dllp_crc_split;
reg [31 : 0] dllp_dat_split;
reg [1 : 0] val_cnt_split;
reg [2047:0] descram_in;
wire [10:0] descram_out;

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

localparam descram_inst_SIZE = 11,descram_inst_SCRAMSTRING = 32'hfdffc68b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X1


`endif



`ifdef X4


`endif



`ifdef X1



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif

// =============================================================================


`ifdef X1


   

`endif




`ifdef X4


   

`endif





`ifdef X1


   // Generation of DLLP valid signals to TD MUX -- 4 clks for each DLLP
   // First 2 clks DLLP data & 3rd clk DLLP crc
   always @ (posedge sys_clk or negedge rst_n) begin
      if (!rst_n) begin
         txdp_val      <= 1'b0;
         txdp_dllp_st  <= 1'b0;
         txdp_dllp_end <= 1'b0;
         val_cnt       <= 2'b00;
      end
      else begin
         //Once asserted, val stays for 4 clks
         txdp_dllp_st  <= take_dllp;
         txdp_dllp_end <= (val_cnt_split == 2'b10) ? 1'b1 : 1'b0;
         if(take_dllp)
            txdp_val      <= 1'b1;
         else if(val_cnt_split == 2'b11)
            txdp_val      <= 1'b0;

         if(txdp_val)
            val_cnt    <= val_cnt_split + 1'b1;

      end
   end


`endif


// =============================================================================
// Input register selection
// =============================================================================


`ifdef X1


   always @ (posedge sys_clk or negedge rst_n) begin
      if (!rst_n)
         dllp_stored  <= 32'd0;
      else if(take_dllp)
         dllp_stored  <= (crc_select_split) ? pv_dllp_pkt_split : dllp_pkt_split;
   end


`endif




`ifdef X4


   assign dllp_stored = (crc_select_split) ? pv_dllp_pkt_split : dllp_pkt_split;


`endif



assign  A   =  dllp_stored;
assign  C   =  16'h32B9;

// =============================================================================
// CRC Reg /Seq. Element of CRC logic
// DLLP that is selected
// =============================================================================
always @ (posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      crc_reg <= 16'h0000 ;
   else
      crc_reg <= NewCRC_split;
end



`ifdef X1


   always @ (posedge sys_clk or negedge rst_n) begin
      if (!rst_n)
         dllp    <= 16'h0000;
      else if(take_dllp)
         dllp  <= (crc_select_split) ? pv_dllp_pkt_split[31:16] : dllp_pkt_split[31:16];
      else if(val_cnt_split == 2'b00)
         dllp  <= dllp_stored[15:0];
      else
         dllp  <= dllp_crc_split;
   end


`endif




`ifdef X4


   always @ (posedge sys_clk or negedge rst_n) begin
      if (!rst_n)
         dllp_dat<= 32'd0;
      else
         dllp_dat<= A_split;
   end
   assign dllp = {dllp_dat_split, dllp_crc_split};


`endif



// =============================================================================
// Actual CRC output : Complement and remap CRC bits (Comb. output)
// =============================================================================
assign   dllp_crc = {~crc_reg_split[ 8], ~crc_reg_split[ 9], ~crc_reg_split[10], ~crc_reg_split[11],
                     ~crc_reg_split[12], ~crc_reg_split[13], ~crc_reg_split[14], ~crc_reg_split[15],
                     ~crc_reg_split[ 0], ~crc_reg_split[ 1], ~crc_reg_split[ 2], ~crc_reg_split[ 3],
                     ~crc_reg_split[ 4], ~crc_reg_split[ 5], ~crc_reg_split[ 6], ~crc_reg_split[ 7] };

// =============================================================================
// CRC Logic
// =============================================================================
always @(*) begin

    D = { A_split[24], A_split[25], A_split[26], A_split[27], A_split[28], A_split[29], A_split[30], A_split[31], //A[24:31]
          A_split[16], A_split[17], A_split[18], A_split[19], A_split[20], A_split[21], A_split[22], A_split[23], //A[16:23]
          A_split[ 8], A_split[ 9], A_split[10], A_split[11], A_split[12], A_split[13], A_split[14], A_split[15], //A[ 8:15]
          A_split[ 0], A_split[ 1], A_split[ 2], A_split[ 3], A_split[ 4], A_split[ 5], A_split[ 6], A_split[ 7]};//A[ 0: 7]

    NewCRC[0] = D_split[31] ^ D_split[29] ^ D_split[28] ^ D_split[26] ^ D_split[23] ^ D_split[21] ^ D_split[20] ^
                D_split[15] ^ D_split[13] ^ D_split[12] ^ D_split[8] ^ D_split[4] ^ D_split[0] ^ C_split[0];

    NewCRC[1] = D_split[31] ^ D_split[30] ^ D_split[28] ^ D_split[27] ^ D_split[26] ^ D_split[24] ^ D_split[23] ^
                D_split[22] ^ D_split[20] ^ D_split[16] ^ D_split[15] ^ D_split[14] ^ D_split[12] ^ D_split[9] ^
                D_split[8] ^ D_split[5] ^ D_split[4] ^ D_split[1] ^ D_split[0] ^ C_split[1];

    NewCRC[2] = D_split[31] ^ D_split[29] ^ D_split[28] ^ D_split[27] ^ D_split[25] ^ D_split[24] ^ D_split[23] ^
                D_split[21] ^ D_split[17] ^ D_split[16] ^ D_split[15] ^ D_split[13] ^ D_split[10] ^ D_split[9] ^
                D_split[6] ^ D_split[5] ^ D_split[2] ^ D_split[1] ^ C_split[2];

    NewCRC[3] = D_split[31] ^ D_split[30] ^ D_split[25] ^ D_split[24] ^ D_split[23] ^ D_split[22] ^ D_split[21] ^
                D_split[20] ^ D_split[18] ^ D_split[17] ^ D_split[16] ^ D_split[15] ^ D_split[14] ^ D_split[13] ^
                D_split[12] ^ D_split[11] ^ D_split[10] ^ D_split[8] ^ D_split[7] ^ D_split[6] ^ D_split[4] ^
                D_split[3] ^ D_split[2] ^ D_split[0] ^ C_split[3];

    NewCRC[4] = D_split[31] ^ D_split[26] ^ D_split[25] ^ D_split[24] ^ D_split[23] ^ D_split[22] ^ D_split[21] ^
                D_split[19] ^ D_split[18] ^ D_split[17] ^ D_split[16] ^ D_split[15] ^ D_split[14] ^ D_split[13] ^
                D_split[12] ^ D_split[11] ^ D_split[9] ^ D_split[8] ^ D_split[7] ^ D_split[5] ^ D_split[4] ^
                D_split[3] ^ D_split[1] ^ C_split[4];

    NewCRC[5] = D_split[27] ^ D_split[26] ^ D_split[25] ^ D_split[24] ^ D_split[23] ^ D_split[22] ^ D_split[20] ^
                D_split[19] ^ D_split[18] ^ D_split[17] ^ D_split[16] ^ D_split[15] ^ D_split[14] ^ D_split[13] ^
                D_split[12] ^ D_split[10] ^ D_split[9] ^ D_split[8] ^ D_split[6] ^ D_split[5] ^ D_split[4] ^
                D_split[2] ^ C_split[5];

    NewCRC[6] = D_split[28] ^ D_split[27] ^ D_split[26] ^ D_split[25] ^ D_split[24] ^ D_split[23] ^ D_split[21] ^
                D_split[20] ^ D_split[19] ^ D_split[18] ^ D_split[17] ^ D_split[16] ^ D_split[15] ^ D_split[14] ^
                D_split[13] ^ D_split[11] ^ D_split[10] ^ D_split[9] ^ D_split[7] ^ D_split[6] ^ D_split[5] ^
                D_split[3]  ^ C_split[6];

    NewCRC[7] = D_split[29] ^ D_split[28] ^ D_split[27] ^ D_split[26] ^ D_split[25] ^ D_split[24] ^ D_split[22] ^
                D_split[21] ^ D_split[20] ^ D_split[19] ^ D_split[18] ^ D_split[17] ^ D_split[16] ^ D_split[15] ^
                D_split[14] ^ D_split[12] ^ D_split[11] ^ D_split[10] ^ D_split[8] ^ D_split[7] ^ D_split[6] ^
                D_split[4]  ^ C_split[7];

    NewCRC[8] = D_split[30] ^ D_split[29] ^ D_split[28] ^ D_split[27] ^ D_split[26] ^ D_split[25] ^ D_split[23] ^
                D_split[22] ^ D_split[21] ^ D_split[20] ^ D_split[19] ^ D_split[18] ^ D_split[17] ^ D_split[16] ^
                D_split[15] ^ D_split[13] ^ D_split[12] ^ D_split[11] ^ D_split[9] ^ D_split[8] ^ D_split[7] ^
                D_split[5]  ^ C_split[8];

    NewCRC[9] = D_split[31] ^ D_split[30] ^ D_split[29] ^ D_split[28] ^ D_split[27] ^ D_split[26] ^ D_split[24] ^
                D_split[23] ^ D_split[22] ^ D_split[21] ^ D_split[20] ^ D_split[19] ^ D_split[18] ^ D_split[17] ^
                D_split[16] ^ D_split[14] ^ D_split[13] ^ D_split[12] ^ D_split[10] ^ D_split[9] ^ D_split[8] ^
                D_split[6]  ^ C_split[9];

    NewCRC[10] = D_split[31] ^ D_split[30] ^ D_split[29] ^ D_split[28] ^ D_split[27] ^ D_split[25] ^ D_split[24] ^
                 D_split[23] ^ D_split[22] ^ D_split[21] ^ D_split[20] ^ D_split[19] ^ D_split[18] ^ D_split[17] ^
                 D_split[15] ^ D_split[14] ^ D_split[13] ^ D_split[11] ^ D_split[10] ^ D_split[9] ^ D_split[7] ^ C_split[10];

    NewCRC[11] = D_split[31] ^ D_split[30] ^ D_split[29] ^ D_split[28] ^ D_split[26] ^ D_split[25] ^ D_split[24] ^
                 D_split[23] ^ D_split[22] ^ D_split[21] ^ D_split[20] ^ D_split[19] ^ D_split[18] ^ D_split[16] ^
                 D_split[15] ^ D_split[14] ^ D_split[12] ^ D_split[11] ^ D_split[10] ^ D_split[8] ^ C_split[11];

    NewCRC[12] = D_split[30] ^ D_split[28] ^ D_split[27] ^ D_split[25] ^ D_split[24] ^ D_split[22] ^ D_split[19] ^
                 D_split[17] ^ D_split[16] ^ D_split[11] ^ D_split[9] ^ D_split[8] ^ D_split[4] ^ D_split[0] ^ C_split[12];

    NewCRC[13] = D_split[31] ^ D_split[29] ^ D_split[28] ^ D_split[26] ^ D_split[25] ^ D_split[23] ^ D_split[20] ^
                 D_split[18] ^ D_split[17] ^ D_split[12] ^ D_split[10] ^ D_split[9] ^ D_split[5] ^ D_split[1] ^ C_split[13];

    NewCRC[14] = D_split[30] ^ D_split[29] ^ D_split[27] ^ D_split[26] ^ D_split[24] ^ D_split[21] ^ D_split[19] ^
                 D_split[18] ^ D_split[13] ^ D_split[11] ^ D_split[10] ^ D_split[6] ^ D_split[2] ^ C_split[14];

    NewCRC[15] = D_split[31] ^ D_split[30] ^ D_split[28] ^ D_split[27] ^ D_split[25] ^ D_split[22] ^ D_split[20] ^
                 D_split[19] ^ D_split[14] ^ D_split[12] ^ D_split[11] ^ D_split[7] ^ D_split[3] ^ C_split[15];
end



always@* begin crc_select_split<=descram_out[0];dllp_pkt_split<={dllp_pkt>>1,descram_out[1]};pv_dllp_pkt_split<={pv_dllp_pkt>>1,descram_out[2]};D_split<={D>>1,descram_out[3]};NewCRC_split<={NewCRC>>1,descram_out[4]};crc_reg_split<={crc_reg>>1,descram_out[5]};A_split<={A>>1,descram_out[6]};C_split<={C>>1,descram_out[7]};dllp_crc_split<={dllp_crc>>1,descram_out[8]};dllp_dat_split<={dllp_dat>>1,descram_out[9]};val_cnt_split<={val_cnt>>1,descram_out[10]};end
always@* begin descram_in[2047]<=dllp_pkt[0];descram_in[2046]<=pv_dllp_pkt[0];descram_in[2044]<=D[0];descram_in[2040]<=NewCRC[0];descram_in[2032]<=crc_reg[0];descram_in[2017]<=A[0];descram_in[1987]<=C[0];descram_in[1926]<=dllp_crc[0];descram_in[1805]<=dllp_dat[0];descram_in[1562]<=val_cnt[0];descram_in[1023]<=crc_select;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_x4


// File             : txdp_ctrl.v


// Title            : txdp Controller


// Dependencies     :


// Description      : This module forms the DLLP Pkts that are to be sent out


//                    based on the requests from RXTP , FC, LCMFCI & PM/VENDOR.


//                    RXTP gives ACKs/NAKs to be sent


//                    FC gives UpdateFC DLLPs/ Req


//                    LCM FCI gives InitFC1/2 DLLPs/Req


//                    PM/VENDOR block gives PV type DLLPs/Req


//                    There are 2 prorities ..


//                       -- *_1 req are high priority


//                       -- *-2 req are low priority


//                    This block generates a req to TDMUX when there is a pending


//                    req and once grant is given it will send out the DLLP with


//                    generated CRC.


//                    All the ACKs/NAKs and Update FCs are collapsed before the


//                    grant and Low Priority Ack becomes High Priority after the


//                    ACKNAK_LAT_TIMER expired.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Rajakumar


// Mod. Date        : Mar 10, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module  txdp_ctrl #(
   parameter FADDR    = 3 )
   (
   input wire            sys_clk,           
   input wire            rst_n,             

   input wire [13:0]     ACKNAK_LAT_TIME,   
                                            
   `ifdef X4
      input wire         tlpgen_tval,       
      input wire [1:0]   phy_skpq_nclks,    
   `endif
   input wire            phy_skpq_val,      
   input wire            trnc_pause_ack,    

   
   input wire            fc_update1,        
   input wire [2:0]      fc_vcid1,          
   input wire [1:0]      fc_type1,          

   input wire            fc_update2,        
   input wire [2:0]      fc_vcid2,          
   input wire [1:0]      fc_type2,          

   input wire [`NUM_VC -1:0]     p_infi_credit,    
   input wire [`NUM_VC -1:0]     np_infi_credit,   
   input wire [`NUM_VC -1:0]     cpl_infi_credit,  
   input wire [(`NUM_VC*3) -1:0] cfg_vcid,         
   `ifdef EN_VC0
      input wire [23:0]      fc_p_0,               
      input wire [23:0]      fc_np_0,
      input wire [23:0]      fc_cpl_0,
   `endif
   `ifdef EN_VC1
      input wire [23:0]      fc_p_1,               
      input wire [23:0]      fc_np_1,
      input wire [23:0]      fc_cpl_1,
   `endif
   `ifdef EN_VC2
      input wire [23:0]      fc_p_2,               
      input wire [23:0]      fc_np_2,
      input wire [23:0]      fc_cpl_2,
   `endif
   `ifdef EN_VC3
      input wire [23:0]      fc_p_3,               
      input wire [23:0]      fc_np_3,
      input wire [23:0]      fc_cpl_3,
   `endif
   `ifdef EN_VC4
      input wire [23:0]      fc_p_4,               
      input wire [23:0]      fc_np_4,
      input wire [23:0]      fc_cpl_4,
   `endif
   `ifdef EN_VC5
      input wire [23:0]      fc_p_5,               
      input wire [23:0]      fc_np_5,
      input wire [23:0]      fc_cpl_5,
   `endif
   `ifdef EN_VC6
      input wire [23:0]      fc_p_6,               
      input wire [23:0]      fc_np_6,
      input wire [23:0]      fc_cpl_6,
   `endif
   `ifdef EN_VC7
      input wire [23:0]      fc_p_7,               
      input wire [23:0]      fc_np_7,
      input wire [23:0]      fc_cpl_7,
   `endif

   
   input wire                tx_pm,                
   input wire                tx_vendor,            
   input wire [2:0]          tx_pmd_type,          
   input wire [23:0]         tx_vsd_data,          

   
   input wire                rxtp_nak,             
   input wire                rxtp_dupltlp,         
   input wire                rxtp_ack,             
   input wire [11:0]         rxtp_seq,             

   
   input wire                lcmfci_req,           
   input wire                lcmfci_req2,          
   input wire [2:0]          lcmfci_vcid,          
   input wire                lcmfci_init,          
   input wire [1:0]          lcmfci_type,          
   input wire [`NUM_VC -1:0] vcneg_pend,           

   
   input wire                tdmux_rdy1,           
   input wire                tdmux_rdy2,           

   input wire                expired_ack_d,        

   
   
   output reg [FADDR:0]      dll_pause_cnt,       

   
   output reg                txdp_req1,           
   output reg                txdp_req2,           
   `ifdef X1
      output reg [3:0]       txdp_skip_cnt,       
   `endif
   `ifdef X4
      output reg [2:0]       txdp_skip_cnt,       
      output reg             txdp_val1,           
      output reg             txdp_val2,           
   `endif

   
   output reg [`NUM_VC -1:0] txdp_p_sent,         
   output reg [`NUM_VC -1:0] txdp_np_sent,        
   output reg [`NUM_VC -1:0] txdp_cpl_sent,       

   
   output reg                txdp_rdy,            
   output reg                txdp_rdy2,           

   
   output wire               txdp_pv_sent,        

   
   `ifdef X1
      output reg             take_dllp,           
   `endif
   output reg                crc_select,          
   output reg [31:0]         dllp_pkt,            
   output reg [31:0]         pv_dllp_pkt,         

   output reg                expired_ack          // HP Ack Req -- For RXFC


   );

`ifdef VC1
localparam  INDEX=2;
localparam  DEPTH=7;
localparam  PV       =  3'b011;
localparam  ACK_NAK  =  3'b111;
localparam  VC0P     =  3'b000;
localparam  VC0NP    =  3'b001;
localparam  VC0CPL   =  3'b010;

`else

`ifdef VC2
localparam  INDEX=2;
localparam  DEPTH=7;
localparam  PV       =  3'b011;
localparam  ACK_NAK  =  3'b111;
localparam  VC0P     =  3'b000;
localparam  VC0NP    =  3'b001;
localparam  VC0CPL   =  3'b010;
localparam  VC1P     =  3'b100;
localparam  VC1NP    =  3'b101;
localparam  VC1CPL   =  3'b110;

`else

`ifdef VC3
localparam  INDEX=3;
localparam  DEPTH=15;
localparam  PV       =  4'b0011;
localparam  ACK_NAK  =  4'b1111;
localparam  VC0P     =  4'b0000;
localparam  VC0NP    =  4'b0001;
localparam  VC0CPL   =  4'b0010;
localparam  VC1P     =  4'b0100;
localparam  VC1NP    =  4'b0101;
localparam  VC1CPL   =  4'b0110;
localparam  VC2P     =  4'b1000;
localparam  VC2NP    =  4'b1001;
localparam  VC2CPL   =  4'b1010;

`else

`ifdef VC4
localparam  INDEX=3;
localparam  DEPTH=15;
localparam  PV       =  4'b0011;
localparam  ACK_NAK  =  4'b1111;
localparam  VC0P     =  4'b0000;
localparam  VC0NP    =  4'b0001;
localparam  VC0CPL   =  4'b0010;
localparam  VC1P     =  4'b0100;
localparam  VC1NP    =  4'b0101;
localparam  VC1CPL   =  4'b0110;
localparam  VC2P     =  4'b1000;
localparam  VC2NP    =  4'b1001;
localparam  VC2CPL   =  4'b1010;
localparam  VC3P     =  4'b1100;
localparam  VC3NP    =  4'b1101;
localparam  VC3CPL   =  4'b1110;

`else
localparam  INDEX=4;
localparam  DEPTH=31;
localparam  PV       =  5'b00011;
localparam  ACK_NAK  =  5'b11111;
localparam  VC0P     =  5'b00000;
localparam  VC0NP    =  5'b00001;
localparam  VC0CPL   =  5'b00010;
localparam  VC1P     =  5'b00100;
localparam  VC1NP    =  5'b00101;
localparam  VC1CPL   =  5'b00110;
localparam  VC2P     =  5'b01000;
localparam  VC2NP    =  5'b01001;
localparam  VC2CPL   =  5'b01010;
localparam  VC3P     =  5'b01100;
localparam  VC3NP    =  5'b01101;
localparam  VC3CPL   =  5'b01110;
localparam  VC4P     =  5'b10000;
localparam  VC4NP    =  5'b10001;
localparam  VC4CPL   =  5'b10010;
localparam  VC5P     =  5'b10100;
localparam  VC5NP    =  5'b10101;
localparam  VC5CPL   =  5'b10110;
localparam  VC6P     =  5'b11000;
localparam  VC6NP    =  5'b11001;
localparam  VC6CPL   =  5'b11010;
localparam  VC7P     =  5'b11100;
localparam  VC7NP    =  5'b11101;
localparam  VC7CPL   =  5'b11110;

`endif

`endif

`endif

`endif
localparam P_TYPE   = 2'b00;
localparam NP_TYPE  = 2'b01;
localparam CPL_TYPE = 2'b10;

`ifdef X4
localparam HP_IDLE   =  1'b0;
localparam HP_REQ    =  1'b1;
localparam LP_IDLE   =  1'b0;
localparam LP_REQ    =  1'b1;
localparam HPR_IDLE  =  2'b00;
localparam HPR_RESET =  2'b01;
localparam HPR_CHECK =  2'b10;
localparam HPR_CLEAR =  2'b11;
localparam LPR_IDLE  =  2'b00;
localparam LPR_RESET =  2'b01;
localparam LPR_CHECK =  2'b10;
localparam LPR_CLEAR =  2'b11;

`endif
reg                       crc_select_erly;
reg    [`NUM_VC -1:0]     vpend_2_cpl_sent;
reg    [`NUM_VC -1:0]     hp_initfc_pend_req;
reg    [`NUM_VC -1:0]     lp_initfc_pend_req;
reg  [31:0]               p_reg[0:`NUM_VC -1];
reg  [31:0]               np_reg[0:`NUM_VC -1];
reg  [31:0]               cpl_reg[0:`NUM_VC -1];
reg  [`NUM_VC -1:0]       hpvc_incr;
reg  [`NUM_VC -1:0]       lpvc_incr;
reg  [`NUM_VC -1:0]       p_req;
reg  [`NUM_VC -1:0]       np_req;
reg  [`NUM_VC -1:0]       cpl_req;
reg  [`NUM_VC -1:0]       p_pendh;
reg  [`NUM_VC -1:0]       np_pendh;
reg  [`NUM_VC -1:0]       cpl_pendh;
reg  [`NUM_VC -1:0]       p_pendl;
reg  [`NUM_VC -1:0]       np_pendl;
reg  [`NUM_VC -1:0]       cpl_pendl;
reg                       update1;
reg                       update2;
reg  [INDEX:0]            sel_reg;
reg                       initfc_req;
reg                       initfc_req_d;
reg  [INDEX:0]            initfc_sel;
reg  [INDEX:0]            initfc_sel_d;
reg  [1:0]                dllp_kind_p [0:`NUM_VC -1];
reg  [1:0]                dllp_kind_np [0:`NUM_VC -1];
reg  [1:0]                dllp_kind_cpl [0:`NUM_VC -1];
reg                       initfc_req2;
reg                       initfc_req2_d;
reg  [INDEX:0]            initfc_sel2;
reg  [INDEX:0]            initfc_sel2_d;
reg                       pv_req;
reg                       pv_req_d;
reg  [31:0]               pv_dllp;
reg  [31:0]               acknak_reg;
reg                       acknak_newreq;
reg                       acknakinit_incr;
reg                       acknak_pend;
reg                       acknak_req;
reg                       nak_pend;
reg  [31:0]               ack_reg;
reg                       ack_newreq;
reg                       ackpv_incr;
reg                       ack_pend;
reg                       ack_req;
reg                       hp_allvc_incr;
reg  [INDEX:0]            hp_wr_cnt;
reg  [INDEX:0]            hp_sel [DEPTH:0];
reg  [INDEX:0]            hpsel_val;
reg  [INDEX:0]            hpsel_val_d;
reg  [INDEX:0]            hpsel_val_dd;
reg  [INDEX:0]            hp_rd_cnt;
reg                       reset_hpq;
reg  [INDEX:0]            hpreset_reg;
reg                       hp_assert_rdy;
reg                       lp_allvc_incr;
reg  [INDEX:0]            lp_wr_cnt;
reg  [INDEX:0]            lp_sel [DEPTH:0];
reg  [INDEX:0]            lpsel_val;
reg  [INDEX:0]            lpsel_val_d;
reg  [INDEX:0]            lpsel_val_dd;
reg  [INDEX:0]            lp_rd_cnt;
reg                       reset_lpq;
reg  [INDEX:0]            lpreset_reg;
reg                       lp_assert_rdy2;
reg  [13:0]               acknak_lat_timer;
reg                       txdp_rdy_d;
reg                       dllp_req;
reg                       skip_val;
reg                       skip_req;
reg  [FADDR:0]            req_cnt;
reg                       pause_ack_del;
reg    [FADDR:0]          neg_pause_cnt_del1;
reg    [FADDR:0]          neg_grant_cnt;
reg    [FADDR:0]          sel_add_value;
integer                   i1, i2, i3, i4, i5, i6;
reg  [INDEX:0]            VCP [`NUM_VC -1:0];
reg  [INDEX:0]            VCNP [`NUM_VC -1:0];
reg  [INDEX:0]            VCCPL [`NUM_VC -1:0];
wire [INDEX:0]            hpsel_val_w;
wire [INDEX:0]            lpsel_val_w;
wire [INDEX:0]            initfc_sel_w;

`ifdef X1
reg  [3:0]                skip_cnt;
reg  [3:0]                skip_cnt_del1;
reg  [3:0]                skip_cnt_del2;
reg  [3:0]                skip_cnt_del3;

`endif

`ifdef X4
reg                       valid1;
reg                       valid2;
reg                       valid3;
reg                       valid4;
reg                       hp_state;
reg                       rdy1_d;
reg                       req1_d;
reg                       reset_hpq_d;
reg  [1:0]                hpreset_state;
reg                       lp_state;
reg  [1:0]                lpreset_state;
reg                       rdy2_d;
reg                       reset_lpq_d;
reg  [2:0]                skip_cnt;
reg  [2:0]                skip_cnt_del1;
reg  [2:0]                skip_cnt_del2;
reg  [2:0]                skip_cnt_del3;
reg  [2:0]                skip_req_cnt;

`endif

`ifdef X4

`endif

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef EN_VC0
wire [2:0] vcid0 = 3'b000;

`endif

`ifdef EN_VC1
wire [2:0] vcid1 = cfg_vcid[5:3];

`endif

`ifdef EN_VC2
wire [2:0] vcid2 = cfg_vcid[8:6];

`endif

`ifdef EN_VC3
wire [2:0] vcid3 = cfg_vcid[11:9];

`endif

`ifdef EN_VC4
wire [2:0] vcid4 = cfg_vcid[14:12];

`endif

`ifdef EN_VC5
wire [2:0] vcid5 = cfg_vcid[17:15];

`endif

`ifdef EN_VC6
wire [2:0] vcid6 = cfg_vcid[20:18];

`endif

`ifdef EN_VC7
wire [2:0] vcid7 = cfg_vcid[23:21];

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif
wire [1:0]  dllp_kindp_0  = dllp_kind_p[0];
wire [1:0]  dllp_kindnp_0  = dllp_kind_np[0];
wire [1:0]  dllp_kindcpl_0  = dllp_kind_cpl[0];
wire [31:0]  p_reg_0     = p_reg[0];
wire [31:0]  np_reg_0    = np_reg[0];
wire [31:0]  cpl_reg_0   = cpl_reg[0];
reg [13 : 0] ACKNAK_LAT_TIME_split;
reg phy_skpq_val_split;
reg trnc_pause_ack_split;
reg fc_update1_split;
reg [2 : 0] fc_vcid1_split;
reg [1 : 0] fc_type1_split;
reg fc_update2_split;
reg [2 : 0] fc_vcid2_split;
reg [1 : 0] fc_type2_split;
reg [`NUM_VC - 1 : 0] p_infi_credit_split;
reg [`NUM_VC - 1 : 0] np_infi_credit_split;
reg [`NUM_VC - 1 : 0] cpl_infi_credit_split;
reg [(`NUM_VC * 3) - 1 : 0] cfg_vcid_split;
reg tx_pm_split;
reg tx_vendor_split;
reg [2 : 0] tx_pmd_type_split;
reg [23 : 0] tx_vsd_data_split;
reg rxtp_nak_split;
reg rxtp_dupltlp_split;
reg rxtp_ack_split;
reg [11 : 0] rxtp_seq_split;
reg lcmfci_req_split;
reg lcmfci_req2_split;
reg [2 : 0] lcmfci_vcid_split;
reg lcmfci_init_split;
reg [1 : 0] lcmfci_type_split;
reg [`NUM_VC - 1 : 0] vcneg_pend_split;
reg tdmux_rdy1_split;
reg tdmux_rdy2_split;
reg expired_ack_d_split;
reg crc_select_erly_split;
reg [`NUM_VC - 1 : 0] vpend_2_cpl_sent_split;
reg [`NUM_VC - 1 : 0] hp_initfc_pend_req_split;
reg [`NUM_VC - 1 : 0] lp_initfc_pend_req_split;
reg [`NUM_VC - 1 : 0] hpvc_incr_split;
reg [`NUM_VC - 1 : 0] lpvc_incr_split;
reg [`NUM_VC - 1 : 0] p_req_split;
reg [`NUM_VC - 1 : 0] np_req_split;
reg [`NUM_VC - 1 : 0] cpl_req_split;
reg [`NUM_VC - 1 : 0] p_pendh_split;
reg [`NUM_VC - 1 : 0] np_pendh_split;
reg [`NUM_VC - 1 : 0] cpl_pendh_split;
reg [`NUM_VC - 1 : 0] p_pendl_split;
reg [`NUM_VC - 1 : 0] np_pendl_split;
reg [`NUM_VC - 1 : 0] cpl_pendl_split;
reg update1_split;
reg update2_split;
reg [INDEX : 0] sel_reg_split;
reg initfc_req_split;
reg initfc_req_d_split;
reg [INDEX : 0] initfc_sel_split;
reg [INDEX : 0] initfc_sel_d_split;
reg initfc_req2_split;
reg initfc_req2_d_split;
reg [INDEX : 0] initfc_sel2_split;
reg [INDEX : 0] initfc_sel2_d_split;
reg pv_req_split;
reg pv_req_d_split;
reg [31 : 0] pv_dllp_split;
reg [31 : 0] acknak_reg_split;
reg acknak_newreq_split;
reg acknakinit_incr_split;
reg acknak_pend_split;
reg acknak_req_split;
reg nak_pend_split;
reg [31 : 0] ack_reg_split;
reg ack_newreq_split;
reg ackpv_incr_split;
reg ack_pend_split;
reg ack_req_split;
reg hp_allvc_incr_split;
reg [INDEX : 0] hp_wr_cnt_split;
reg [INDEX : 0] hpsel_val_split;
reg [INDEX : 0] hpsel_val_d_split;
reg [INDEX : 0] hpsel_val_dd_split;
reg [INDEX : 0] hp_rd_cnt_split;
reg reset_hpq_split;
reg [INDEX : 0] hpreset_reg_split;
reg hp_assert_rdy_split;
reg lp_allvc_incr_split;
reg [INDEX : 0] lp_wr_cnt_split;
reg [INDEX : 0] lpsel_val_split;
reg [INDEX : 0] lpsel_val_d_split;
reg [INDEX : 0] lpsel_val_dd_split;
reg [INDEX : 0] lp_rd_cnt_split;
reg reset_lpq_split;
reg [INDEX : 0] lpreset_reg_split;
reg lp_assert_rdy2_split;
reg [13 : 0] acknak_lat_timer_split;
reg txdp_rdy_d_split;
reg dllp_req_split;
reg skip_val_split;
reg skip_req_split;
reg [FADDR : 0] req_cnt_split;
reg pause_ack_del_split;
reg [FADDR : 0] neg_pause_cnt_del1_split;
reg [FADDR : 0] neg_grant_cnt_split;
reg [FADDR : 0] sel_add_value_split;
reg [INDEX : 0] hpsel_val_w_split;
reg [INDEX : 0] lpsel_val_w_split;
reg [INDEX : 0] initfc_sel_w_split;
reg [1 : 0] dllp_kindp_0_split;
reg [1 : 0] dllp_kindnp_0_split;
reg [1 : 0] dllp_kindcpl_0_split;
reg [31 : 0] p_reg_0_split;
reg [31 : 0] np_reg_0_split;
reg [31 : 0] cpl_reg_0_split;
reg [2047:0] descram_in;
wire [106:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else

`endif

`endif

`endif

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

localparam descram_inst_SIZE = 107,descram_inst_SCRAMSTRING = 32'hfdfff10b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;



`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else


`endif



`endif



`endif



`endif


`ifdef X4


`endif


`ifdef X1


`endif



`ifdef X4


`endif



`ifdef X4



`endif



`ifdef VC1



`else



`ifdef VC2



`else



`ifdef VC3



`else



`ifdef VC4



`else



`endif



`endif



`endif



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef EN_VC0


`endif



`ifdef EN_VC1


`endif



`ifdef EN_VC2


`endif



`ifdef EN_VC3


`endif



`ifdef EN_VC4


`endif



`ifdef EN_VC5


`endif



`ifdef EN_VC6


`endif



`ifdef EN_VC7


`endif



`ifdef EN_VC0



`endif



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif



`ifdef EN_VC0



`endif



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif

// =============================================================================
// Parameters
// =============================================================================


`ifdef VC1


   //3+2 reqs - [2:0]
   //3    PM or VENDOR
   //7
   

`else


   

`ifdef VC2


      //6+2 reqs - [2:0]
      //3
      //7
      

`else


      

`ifdef VC3


         //9+2 reqs - [3:0]
         //3
         //15
         

`else


         

`ifdef VC4


            //12+2 reqs - [3:0]
            //3
            //15
            

`else


            //24+2 reqs - [4:0]
            //3
            //15
            //First 3 bits indicate VCID &
            //last 2 bits indicate Type
            

`endif


      

`endif


   

`endif




`endif





`ifdef X4


   

`endif



// =============================================================================
//7 bits are Constant -- Reserved
//For 4 VCs 8 bits are constant
//3+1 reqs

//19 bits are RESERVED/Constant
//19 bits are RESERVED/Constant
// HPQ
//hp_wr_cnt has to roll-over
// LPQ
//lp_wr_cnt has to roll-over


`ifdef X1




`endif




`ifdef X4




`endif



// =============================================================================
// Delaying the tlpgen_tval signal
// =============================================================================


`ifdef X4


   always @(posedge sys_clk or negedge rst_n) begin
      if (rst_n == 1'b0) begin
         valid1  <= 1'b0;
         valid2  <= 1'b0;
         valid3  <= 1'b0;
         valid4  <= 1'b0;
      end
      else begin
         valid1  <= tlpgen_tval;
         valid2  <= valid1;
         valid3  <= valid2;
         valid4  <= valid3;
      end
   end


`endif


// =============================================================================
// HIGH Priority DLLPs over TLPs -- HP
//    : NAK/duplTLP Ack/Expired  -- Ack DLLPs
//    : FC expired/Free after Full  -- Update DLLPs
//
// LOW Priority DLLPs over TLPs -- LP
//    : Normal Acks/Normal Update FC/InitFC DLLP/PM/VENDOR DLLP
//
// =============================================================================
// Frequency of Requests from RXTP : Max. every 3 clks
// (PHY 2 bytes + DL Seq No) + TL Pkt + DL crc
//   1 + 3 + 1 =  5 DW = 20 bytes -- 3 clks
// =============================================================================
// nak/dupltlp req are parallel to fc_update1 & expired_ack requests
// FC update1 - HP req:
//     a) FC units are consumed and now 1 or more available due to TL processing
//     b) 30Microsec/Update Timer expired
//        These req. can come consecutively up to 6 and can be collapsed to 3
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      acknak_reg      <= 32'd0;
      acknak_newreq   <= 1'b0;
      acknakinit_incr <= 1'b0;
      acknak_pend     <= 1'b0;
      acknak_req      <= 1'b0;
      nak_pend        <= 1'b0;
   end
   else begin
      //CLK1 : ACK /NAK Requests Info Storing & Req. pulse generation
      if(rxtp_nak_split || rxtp_dupltlp_split || rxtp_ack_split)
         acknak_reg[11:0]  <= rxtp_seq_split;

      acknak_reg[23:12] <= 12'h000;  //Reserved bits

      //if NAK then ACK --- ACK is sent (if NAK is not sent still)
      if(rxtp_nak_split)
         acknak_reg[31:24]  <= 8'b0001_0000;    //NAK DLLP Encoding
      else if(((rxtp_dupltlp_split || expired_ack_d_split) && !nak_pend_split) || rxtp_ack_split)
         acknak_reg[31:24]  <= 8'b0000_0000;    //ACK DLLP Encoding

      //Req pulse generation
      acknak_req  <= (rxtp_nak_split || rxtp_dupltlp_split || expired_ack_d_split) ? 1'b1 : 1'b0;

      //Ingnore Dupl. TLP ACKs when NAK is pending
      if(reset_hpq_split && (hpreset_reg_split == ACK_NAK))
         nak_pend <= 1'b0;
      else if(rxtp_nak_split)
         nak_pend <= 1'b1;

      //CLK2 : Pending Bit Assertion & De-assertion
      if(reset_hpq_split && (hpreset_reg_split == ACK_NAK))
         acknak_pend <= 1'b0;
      else if(acknak_req_split)
         acknak_pend <= 1'b1;

      //CLK2 : This delay is due to the delay in hp_allvc_incr signal
      acknak_newreq  <= acknak_req_split & !acknak_pend_split;

      //CLK3 : ACK NAK Req Increment Gen.
      acknakinit_incr  <= acknak_newreq_split | initfc_req_d_split;

   end
end



`ifdef VC1


   assign hpsel_val_w  = {1'b0, fc_type1_split};        //For 1 VC
   assign lpsel_val_w  = {1'b0, fc_type2_split};
   assign initfc_sel_w = {1'b0, lcmfci_type_split};


`else


   

`ifdef VC2


      assign hpsel_val_w  = {fc_vcid1_split[0], fc_type1_split};
      assign lpsel_val_w  = {fc_vcid2_split[0], fc_type2_split};
      assign initfc_sel_w = {lcmfci_vcid_split[0], lcmfci_type_split};
   

`else


      

`ifdef VC3


         assign hpsel_val_w  = {fc_vcid1_split[1:0], fc_type1_split};
         assign lpsel_val_w  = {fc_vcid2_split[1:0], fc_type2_split};
         assign initfc_sel_w = {lcmfci_vcid_split[1:0], lcmfci_type_split};
      

`else


         

`ifdef VC4


            assign hpsel_val_w  = {fc_vcid1_split[1:0], fc_type1_split};  //For 4 Vcs
            assign lpsel_val_w  = {fc_vcid2_split[1:0], fc_type2_split};  //For 4 Vcs
            assign initfc_sel_w = {lcmfci_vcid_split[1:0], lcmfci_type_split};  //For 4 Vcs
         

`else


            assign hpsel_val_w  = {fc_vcid1_split, fc_type1_split};      //For 8 Vcs
            assign lpsel_val_w  = {fc_vcid2_split, fc_type2_split};      //For 8 Vcs
            assign initfc_sel_w = {lcmfci_vcid_split, lcmfci_type_split};  //For 8 Vcs
         

`endif


      

`endif


   

`endif




`endif



// =============================================================================
// HIGH PRIORITY: ACK
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      hp_allvc_incr   <= 1'b0;
      hp_wr_cnt       <= 0;
      for(i1=0; i1<=DEPTH; i1=i1+1)
         hp_sel[i1]     <= 0;
      hpsel_val       <= 0;
      hpsel_val_d     <= 0;
      hpsel_val_dd    <= 0;
   end
   else begin
      //CLK1 : hpsel_val is used to select the Register when TDMUX gives grant
      //The Q contains this info. and read when tdmux_rdy1 is asserted
      //hpsel_val encoding for VC registers
      hpsel_val <= hpsel_val_w_split;

      //CLK2 : Delaying the Mux sel to latch in Q (when hp_wr_cnt is incrementing)
      hpsel_val_d  <= hpsel_val_split;

      //CLK3 : Delaying the Mux sel to latch in Q (when hp_wr_cnt is incrementing)
      if(acknak_newreq_split)
         hpsel_val_dd <= ACK_NAK;
      else
         hpsel_val_dd <= (initfc_req_d_split) ? initfc_sel_d_split : hpsel_val_d_split;

      //CLK3 : FC Update Increment Gen.
      hp_allvc_incr  <= |hpvc_incr_split;

      //In CLK4 ACK NAK req. are taken in Q
      //In CLK4 FC Update req. are taken in Q (hpsel_val_dd is ready by this time)
      if(hp_allvc_incr_split || acknakinit_incr_split)
         hp_wr_cnt  <= hp_wr_cnt_split + 1;

      if(hp_allvc_incr_split || acknakinit_incr_split)
         hp_sel[hp_wr_cnt_split]  <= hpsel_val_dd_split;

   end
end


// =============================================================================
// HIGH PRIORITY: InitFC DLLPs Generation
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      for(i2=0; i2<`NUM_VC; i2=i2+1) begin
         //dllp_kind[i2]       <=   2'b01;
         dllp_kind_p[i2]       <= 2'b01;
         dllp_kind_np[i2]      <= 2'b01;
         dllp_kind_cpl[i2]     <= 2'b01;
      end
      initfc_req         <= 1'b0;
      initfc_req_d       <= 1'b0;
      initfc_sel         <= 0;
      initfc_sel_d       <= 0;
      txdp_rdy           <= 1'b1;
      txdp_rdy_d         <= 1'b1;
   end
   else begin

      // Kind of DLLP selection - Init1 or Init2 or Update
      // Update DLLPs come for a particaular only after it is initialized
      for(i2=0; i2<`NUM_VC; i2=i2+1) begin
         if((lcmfci_vcid_split == i2) && (lcmfci_req_split || lcmfci_req2_split)) begin
            if(lcmfci_init_split) begin   //Init2 DLLP Kind
               dllp_kind_p[i2]   <= 2'b11;
               dllp_kind_np[i2]  <= 2'b11;
               dllp_kind_cpl[i2] <= 2'b11;
            end
            else begin  //Init1 DLLP Kind
               dllp_kind_p[i2]   <= 2'b01;
               dllp_kind_np[i2]  <= 2'b01;
               dllp_kind_cpl[i2] <= 2'b01;
            end
         end
         else if(!vpend_2_cpl_sent_split[i2]) begin  //If the VC[x] is initialized
            //Dont send Update FCs for inifinte Credit Types (compliance violation)
            if(!p_infi_credit_split[i2])
               dllp_kind_p[i2]   <= 2'b10;    //Update DLLP Kind
            if(!np_infi_credit_split[i2])
               dllp_kind_np[i2]  <= 2'b10;    //Update DLLP Kind
            if(!cpl_infi_credit_split[i2])
               dllp_kind_cpl[i2] <= 2'b10;    //Update DLLP Kind
         end
      end

      //CLK 1
      initfc_req   <= lcmfci_req_split;
      if(lcmfci_req_split)  //Storing is required for resetting
          initfc_sel   <= initfc_sel_w_split;

      //CLK 2
      initfc_req_d  <= initfc_req_split;
      initfc_sel_d  <= initfc_sel_split;

      //Ack/Ready to LCMFCI to give next req of Init FCs
      //Only checking the VC ID as this VC is not used until it gets initialized
      if(lcmfci_req_split)
         txdp_rdy  <= 1'b0;
      else if(reset_hpq_split && (hpreset_reg_split == initfc_sel_split))
         txdp_rdy  <= 1'b1;
      else if(hp_assert_rdy_split)
         txdp_rdy  <= 1'b1;

      txdp_rdy_d  <= txdp_rdy;

   end
end

// =============================================================================
// LOW PRIORITY: InitFC DLLPs Generation
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      initfc_req2        <= 1'b0;
      initfc_req2_d      <= 1'b0;
      initfc_sel2        <= 0;
      initfc_sel2_d      <= 0;
      txdp_rdy2          <= 1'b1;
   end
   else begin
      //CLK 1
      initfc_req2   <= lcmfci_req2_split;
      if(lcmfci_req2_split)  //Storing is required for resetting
          initfc_sel2   <= initfc_sel_w_split;

      //CLK 2
      initfc_req2_d  <= initfc_req2_split;
      initfc_sel2_d  <= initfc_sel2_split;

      //Ack/Ready to LCMFCI to give next req of Init FCs
      //Only checking the VC ID as this VC is not used until it gets initialized
      if(lcmfci_req2_split)
         txdp_rdy2  <= 1'b0;
      else if(reset_lpq_split && (lpreset_reg_split == initfc_sel2_split))
         txdp_rdy2  <= 1'b1;
      else if(lp_assert_rdy2_split)
         txdp_rdy2  <= 1'b1;

   end
end

// =============================================================================
// Valid for TDMUX latency is always 3 clks, this is required to reset the pending
// requests.
// Once the grant is given it will there until HPQ deasserts its req. txdp_req1.
// After one clk txdp_req1 deasserted, tdmux_rdy1 will be taken out. At the same
// txdp_val/take_dllp (early) also is deasserted.
// =============================================================================
// =============================================================================
// PHY Request Handling
// Generation of skip_req when dllp_req & trnc_pause_ack are not there  so that
// dllp_req , skip_req and ack, skip_req are mutually exclusive
// Still dllp_req & trnc_pause_ack can come at the same time.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      skip_val          <= 1'b0;
      skip_req          <= 1'b0;
      skip_cnt          <= 0;
      

`ifdef X4


         skip_req_cnt   <= 0;
      

`endif


      skip_cnt_del1     <= 0;
      skip_cnt_del2     <= 0;
      skip_cnt_del3     <= 0;
   end
   else begin
      skip_val <= 1'b0;
      skip_req <= 1'b0;

      if(phy_skpq_val_split || skip_val_split) begin
         if(hp_allvc_incr_split || acknakinit_incr_split || trnc_pause_ack_split) //1 clk ahead DLLP req OR pause_ack
            skip_val     <= 1'b1;
         else begin
            skip_req     <= 1'b1;
	    

`ifdef X1


	       skip_cnt     <= skip_cnt + 3'b001;   //For TDMUX
            

`endif


	    

`ifdef X4


               skip_req_cnt <= phy_skpq_nclks;              //For TRNC  -- No. of gaps required
               skip_cnt     <= skip_cnt + phy_skpq_nclks;    //For TDMUX
            

`endif


         end
      end

      skip_cnt_del1 <= skip_cnt;
      skip_cnt_del2 <= skip_cnt_del1;
      skip_cnt_del3 <= skip_cnt_del2;
   end
end

// =============================================================================
// Generation of Rquired Gaps for isertion of DLLPs & SKIPs
// -- dllp_req & skip_req are mutually exlusive
// -- pause_ack & skip_req are mutually exlusive
// -- dllp_req & pause_ack can come at the same time
// skip_req_cnt = 1 for X1 or X2 downgarde modes
//              = 4/2 for X1/X4 (No downgrade)
// txdp_skip_cnt is meant for TD_MUX to check whether any gap for SKIP is given
// by TL (txintf). This count is always checked again TD_MUX "internal_grant_count"
// If there is a diff TD_MUX inerts a gap of 4/2 clks and increment the "internal_
// grant_count".
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      dllp_req            <= 1'b0;
      dll_pause_cnt       <= 0;
      neg_pause_cnt_del1  <= 0;
      neg_grant_cnt       <= 0;
      txdp_skip_cnt       <= 0;
      req_cnt             <= 0;
      pause_ack_del       <= 1'b0;
   end
   else begin
      dllp_req       <= hp_allvc_incr_split | acknakinit_incr_split;

      dll_pause_cnt  <= req_cnt_split;
      pause_ack_del  <= trnc_pause_ack_split;

      if(trnc_pause_ack_split) //TL has given ack for sertion of gaps requested
         txdp_skip_cnt <= skip_cnt_del3;  //Acked Skip count

      neg_pause_cnt_del1 <= ~dll_pause_cnt + 1;  //2's complement

      //When Both DLLP req & Pause Ack are high : req_cnt = req_cnt - pause_cnt_del1 + 4
      if((hp_allvc_incr_split || acknakinit_incr_split) && trnc_pause_ack_split) //1 clk ahead DLLP req && pause_ack
         neg_grant_cnt  <= neg_pause_cnt_del1_split + 1;  //Negative (pause_cnt_del1 - 4);
      //When Only Pause Ack : req_cnt = req_cnt - pause_cnt_del1
      else
         neg_grant_cnt  <= neg_pause_cnt_del1_split;  //Negative (pause_cnt_del1)

      req_cnt <= req_cnt_split + sel_add_value_split;
   end
end

// =============================================================================
// Selection of value to be added to req_cnt
// 4:1 MUX followed by Adder
// =============================================================================
always @(*) begin
      case({dllp_req_split, skip_req_split, pause_ack_del_split})
      

`ifdef X1


         3'b100,
         3'b010   : sel_add_value = 1;   //4 clks for DLLP & 2 clks for SKIP, but take 4 clks
      

`endif


      

`ifdef X4


         3'b100   : sel_add_value = 1;
         3'b010   : sel_add_value = skip_req_cnt;
      

`endif


         3'b001,
         3'b101   : sel_add_value = neg_grant_cnt_split;
         default  : sel_add_value = 0;
      endcase
end



`ifdef X1


// =============================================================================
// Valid for TDMUX latency is always 3 clks, this is required to reset the pending
// requests.
// LOW Priority Request Q Processing after the Grant
// Required Array depth is 14 (1 ACK + 12 Update FC + 1 PM/VENDOR)
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      take_dllp     <= 1'b0;
      sel_reg       <= 0;
      txdp_req1     <= 1'b0;
      reset_hpq     <= 1'b0;
      hp_rd_cnt     <= 0;
      hpreset_reg   <= 0;
      txdp_req2     <= 1'b0;
      reset_lpq     <= 1'b0;
      lp_rd_cnt     <= 0;
      lpreset_reg   <= 0;
   end
   else begin
      //Bot for HPQ & LPQ
      take_dllp   <= reset_hpq_split || reset_lpq_split;   //For CRC generator (HP & LP DLLP)
      if(tdmux_rdy2_split)
         sel_reg    <= lp_sel[lp_rd_cnt_split];
      else
         sel_reg    <= hp_sel[hp_rd_cnt_split];

      //HPQ
      txdp_req1   <= (hp_wr_cnt_split != hp_rd_cnt_split) ? 1'b1 : 1'b0;

      hpreset_reg <= hp_sel[hp_rd_cnt_split];
      reset_hpq     <= 1'b0;
      if(tdmux_rdy1_split) begin
         reset_hpq     <= 1'b1;
         hp_rd_cnt     <= hp_rd_cnt_split + 1;
      end

      //LPQ
      txdp_req2   <= (lp_wr_cnt_split != lp_rd_cnt_split) ? 1'b1 : 1'b0;

      lpreset_reg <= lp_sel[lp_rd_cnt_split];

      reset_lpq     <= 1'b0;
      if(tdmux_rdy2_split) begin
         reset_lpq     <= 1'b1;
         lp_rd_cnt     <= lp_rd_cnt_split + 1;
      end
   end
end


`endif




`ifdef X4


// =============================================================================
// High Priority Request Q Processing after the Grant
// Required Array depth is 16 for 4 VCs (1 ACK + 12 Update FC + 3 InitFC)
// Array stored the select value for each request
// Write count increments for each request if it is not pending (except for
// InitFC). No 2 requests come at the same time.
// While sending the DLLP out, reset_reg selects the Request to be reset.
// sel_reg is selects hpsel during HPQ processing (tdmux_rdy1) and selects
// lpsel during LPQ processing (tdmux_rdy1).
// The delay b/w tdmux_rdy1 & txdp_val is 3 clks always.
// Internal valid (reset_hpq) is generated as soon as tdmux_rdy1 is given & the
// delayed version of "reset_hpq" is given as txdp_val.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      hpreset_state <= HPR_IDLE;
      reset_hpq     <= 1'b0;
      reset_hpq_d   <= 1'b0;
      txdp_val1     <= 1'b0;
      hp_rd_cnt     <= 0;
      hpreset_reg   <= 0;
      sel_reg       <= 0;
      hp_assert_rdy <= 1'b0;
   end
   else begin
      reset_hpq_d <= reset_hpq_split;
      txdp_val1   <= reset_hpq_d;

      hpreset_reg <= hp_sel[hp_rd_cnt_split];
      if(tdmux_rdy2_split)
         sel_reg    <= lp_sel[lp_rd_cnt_split];
      else
         sel_reg    <= hp_sel[hp_rd_cnt_split];

      reset_hpq     <= 1'b0;
      hp_assert_rdy <= 1'b0;
      case(hpreset_state)
         HPR_IDLE : begin
            hp_assert_rdy <= (hp_wr_cnt_split == hp_rd_cnt_split) & ~(lcmfci_req_split | initfc_req_split);
            if(hp_wr_cnt_split != hp_rd_cnt_split)
               hpreset_state <= HPR_RESET;
         end
         HPR_RESET : begin
            if(valid4 && tdmux_rdy1_split) begin
               hpreset_state <= HPR_CHECK;
               reset_hpq     <= 1'b1;
               hp_rd_cnt     <= hp_rd_cnt_split + 1;   //downgrade check
            end
         end
         HPR_CHECK : begin
            if(valid1 && (hp_wr_cnt_split == hp_rd_cnt_split)) begin
               hpreset_state <= HPR_CLEAR;
               hp_assert_rdy <= 1'b1;
            end
            else if(valid4 && tdmux_rdy1_split) begin   //downgrade check
               reset_hpq     <= 1'b1;
               hp_rd_cnt     <= hp_rd_cnt_split + 1;
            end
         end
         HPR_CLEAR : begin
            hpreset_state <= HPR_IDLE;
            hp_assert_rdy <= 1'b1;
         end
      endcase
   end
end

// =============================================================================
// Valid for TDMUX latency is always 3 clks, this is required to reset the pending
// requests.
// Once the grant is given it will there until HPQ deasserts its req. txdp_req1.
// After one clk txdp_req1 deasserted, tdmux_rdy1 will be taken out. At the same
// txdp_val1 also is deasserted.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      hp_state     <= HP_IDLE;
      txdp_req1    <= 1'b0;
      req1_d       <= 1'b0;
      rdy1_d       <= 1'b0;
   end
   else begin
      req1_d  <= txdp_req1;
      if(req1_d && txdp_req1) begin
         rdy1_d  <= tdmux_rdy1_split;
      end
      else begin
         rdy1_d  <= 1'b0;
      end

      case(hp_state)
         HP_IDLE : begin
            if(hp_wr_cnt_split != hp_rd_cnt_split) begin
               txdp_req1 <= 1'b1;
            end
            hp_state  <= (rdy1_d && valid4) ? HP_REQ : HP_IDLE;
         end
         HP_REQ : begin
            txdp_req1    <= reset_hpq_split;
            hp_state     <= (reset_hpq_d) ? HP_REQ : HP_IDLE;
         end
      endcase
   end
end

// =============================================================================
// UNUSED BLOCK
// Valid for TDMUX latency is always 3 clks, this is required to reset the pending
// requests.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      lp_state     <= LP_IDLE;
      txdp_req2    <= 1'b0;
      rdy2_d       <= 1'b0;
   end
   else begin
      if(txdp_req2)
         rdy2_d  <= tdmux_rdy2_split;
      else
         rdy2_d  <= 1'b0;

      case(lp_state)
         LP_IDLE : begin
            if(lp_wr_cnt_split != lp_rd_cnt_split)
               txdp_req2 <= 1'b1;

            lp_state  <= (rdy2_d && txdp_req2) ? LP_REQ : LP_IDLE;
         end
         LP_REQ : begin
            if((lp_wr_cnt_split == lp_rd_cnt_split) || !tdmux_rdy2_split)
               txdp_req2    <= 1'b0;

            lp_state     <= (txdp_req2) ? LP_REQ : LP_IDLE;
         end
      endcase
   end
end

// =============================================================================
// LOW Priority Request Q Processing after the Grant
// Required Array depth is 14 (1 ACK + 12 Update FC + 1 PM/VENDOR)
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      lpreset_state <= LPR_IDLE;
      reset_lpq     <= 1'b0;
      reset_lpq_d   <= 1'b0;
      txdp_val2     <= 1'b0;
      lp_rd_cnt     <= 0;
      lpreset_reg   <= 0;
      lp_assert_rdy2 <= 1'b0;
   end
   else begin
      reset_lpq_d <= reset_lpq_split;
      txdp_val2   <= reset_lpq_d;

      lpreset_reg <= lp_sel[lp_rd_cnt_split];

      reset_lpq     <= 1'b0;

      lp_assert_rdy2 <= 1'b0;
      case(lpreset_state)
         LPR_IDLE : begin
            lp_assert_rdy2 <= (lp_wr_cnt_split == lp_rd_cnt_split) & ~(lcmfci_req2_split | initfc_req2_split);
            if(lp_wr_cnt_split != lp_rd_cnt_split)
               lpreset_state <= LPR_RESET;
         end
         LPR_RESET : begin
            if(valid4 && tdmux_rdy2_split) begin
               lpreset_state <= LPR_CHECK;
               reset_lpq     <= 1'b1;
               lp_rd_cnt     <= lp_rd_cnt_split + 1;   //downgrade check
            end
         end
         LPR_CHECK : begin
            if(valid1 && (lp_wr_cnt_split == lp_rd_cnt_split)) begin
               lpreset_state <= LPR_CLEAR;
               lp_assert_rdy2 <= 1'b1;
            end
            else if(valid4 && tdmux_rdy2_split) begin   //downgrade check
               reset_lpq     <= 1'b1;
               lp_rd_cnt     <= lp_rd_cnt_split + 1;
            end
         end
         LPR_CLEAR : begin
            lpreset_state <= LPR_IDLE;
            lp_assert_rdy2 <= 1'b1;
         end
      endcase

   end
end


`endif


// =============================================================================
// Low Priority Req:
//      ACK Req. Processing
//      Generation of ackpv_incr for lp_wr_cnt  //ACK/PM/VENDOR
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      ack_req          <= 1'b0;
      ack_pend         <= 1'b0;
      ack_newreq       <= 1'b0;
      ackpv_incr       <= 1'b0;
      expired_ack      <= 1'b0;
      acknak_lat_timer <= 14'd0;
   end
   else begin
      //Req pulse generation
      ack_req  <= (rxtp_ack_split && !acknak_pend_split) ? 1'b1 : 1'b0;

      //CLK2 : Pending Bit Assertion & De-assertion
      if((reset_lpq_split && (lpreset_reg_split == ACK_NAK)) || (reset_hpq_split && (hpreset_reg_split == ACK_NAK)))
         ack_pend <= 1'b0;
      else if(ack_req_split)
         ack_pend <= 1'b1;

      //CLK2 : This delay is due to the delay in lp_allvc_incr signal
      ack_newreq  <= ack_req_split & !ack_pend_split;

      //CLK3 : ACK Req Increment Gen.
      ackpv_incr    <= ack_newreq_split | pv_req_d_split | initfc_req2_d_split;

      //9 bit or 10 bit ??
      //Value : 1050 Symbol times (64bit bus- 525 clks)
      if(ack_pend_split)
         acknak_lat_timer <= acknak_lat_timer_split + 1;
      else
         acknak_lat_timer <= 14'd0;

      if(acknak_lat_timer_split == ACKNAK_LAT_TIME_split)
         expired_ack  <= 1'b1;
      else
         expired_ack  <= 1'b0;
   end
end

// =============================================================================
// LOW PRIORITY: ACK
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      lp_allvc_incr    <= 1'b0;
      lp_wr_cnt     <= 0;
      for(i3=0; i3<=DEPTH; i3=i3+1)
         lp_sel[i3]     <= 0;
      lpsel_val       <= 0;
      lpsel_val_d     <= 0;
      lpsel_val_dd    <= 0;
   end
   else begin
      //CLK1 : lpsel_val is used to select the Register when TDMUX gives grant
      //The Q contains this info. and read when tdmux_rdy1 is asserted
      //lpsel_val encoding for VC registers
      lpsel_val <= lpsel_val_w_split;

      //CLK2 : Delaying the Mux sel to latch in Q (when lp_wr_cnt is incrementing)
      lpsel_val_d  <= lpsel_val_split;

      //CLK3 : Delaying the Mux sel to latch in Q (when lp_wr_cnt is incrementing)
      if(pv_req_d_split)
         lpsel_val_dd  <= PV;
      else if(initfc_req2_d_split)
         lpsel_val_dd  <= initfc_sel2_d_split;
      else
         lpsel_val_dd <= (ack_newreq_split) ? ACK_NAK : lpsel_val_d_split;    //Means ACK only

      //CLK3 : FC Update Increment Gen.
      lp_allvc_incr  <= |lpvc_incr_split;

      //In CLK4 ACK NAK req. are taken in Q
      //In CLK4 FC Update req. are taken in Q (lpsel_val_dd is ready by this time)
      if(lp_allvc_incr_split || ackpv_incr_split)
         lp_wr_cnt  <= lp_wr_cnt_split + 1;

      if(lp_allvc_incr_split || ackpv_incr_split)
         lp_sel[lp_wr_cnt_split]  <= lpsel_val_dd_split;

   end
end

// =============================================================================
// LOW PRIORITY: POWER Management/Vendor Defined  DLLP
// Since all the 16 registers are connnected to dllp_pkt, selection of
// pv_dllp_pkt is done just before the crc logic
// It is assumed that only one PV req can come & during that time TLP traffic
// will not be there OR in other words grant (tdmux_rdy2) will come definetely.
// And during this waiting period for Grant it is assumed that one more PV req
// will not come.
// PM/VENDOR Req generator has to wait for txdp_pv_sent to give next PV req if any.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      pv_req      <= 1'b0;
      pv_req_d    <= 1'b0;
      pv_dllp     <= 32'd0;
      pv_dllp_pkt <= 32'd0;
      crc_select  <= 1'b0;
      crc_select_erly  <= 1'b0;
   end
   else begin
      //CLK 1
      pv_req <= tx_pm_split || tx_vendor_split;
      if(tx_pm_split) //---- PM DLLP
         pv_dllp   <= {5'b00100, tx_pmd_type_split, 24'd0};
      else if(tx_vendor_split)  //--- Vendor Type DLLP
         pv_dllp   <= {8'b00110000, tx_vsd_data_split};

      //CLK 2
      pv_req_d  <= pv_req_split;

      if((lpreset_reg_split == PV) && tdmux_rdy2_split)
         pv_dllp_pkt <= pv_dllp_split;

      //This selects the pm_dllp as Input to the CRC logic
      crc_select_erly  <= ((lpreset_reg_split == PV) && tdmux_rdy2_split)  ? 1'b1 : 1'b0;
      

`ifdef X1


         crc_select <= crc_select_erly_split;
      

`endif


      

`ifdef X4


         crc_select <= ((lpreset_reg_split == PV) && reset_lpq_split)  ? 1'b1 : 1'b0;  //1st May 2007
      

`endif


   end
end

assign txdp_pv_sent = crc_select;


// =============================================================================
// Input Register to CRC generator
// Selected reg from the Register file
// =============================================================================
// 2'b01 - InitFC1
// 2'b11 - InitFC2
// 2'b10 - UpdateFC
// 2'b00, 2'b00 - PM/VENDOR DLLP

//---- UPDATE FC DLLP


`ifdef EN_VC0


   always @(dllp_kind_p[0] or dllp_kind_np[0] or dllp_kind_cpl[0] or
      vcid0 or fc_p_0 or fc_np_0 or fc_cpl_0) begin
      p_reg[0]   = {dllp_kind_p[0], 2'b00, 1'b0, vcid0, fc_p_0};
      np_reg[0]  = {dllp_kind_np[0], 2'b01, 1'b0, vcid0, fc_np_0};
      cpl_reg[0] = {dllp_kind_cpl[0], 2'b10, 1'b0, vcid0, fc_cpl_0};
   end


`endif




`ifdef EN_VC1


   always @(dllp_kind_p[1] or dllp_kind_np[1] or dllp_kind_cpl[1] or
      vcid1 or fc_p_1 or fc_np_1 or fc_cpl_1) begin
      p_reg[1]   = {dllp_kind_p[1], 2'b00, 1'b0, vcid1, fc_p_1};
      np_reg[1]  = {dllp_kind_np[1], 2'b01, 1'b0, vcid1, fc_np_1};
      cpl_reg[1] = {dllp_kind_cpl[1], 2'b10, 1'b0, vcid1, fc_cpl_1};
   end


`endif




`ifdef EN_VC2


   always @(dllp_kind_p[2] or dllp_kind_np[2] or dllp_kind_cpl[2] or
      vcid2 or fc_p_2 or fc_np_2 or fc_cpl_2) begin
      p_reg[2]   = {dllp_kind_p[2], 2'b00, 1'b0, vcid2, fc_p_2};
      np_reg[2]  = {dllp_kind_np[2], 2'b01, 1'b0, vcid2, fc_np_2};
      cpl_reg[2] = {dllp_kind_cpl[2], 2'b10, 1'b0, vcid2, fc_cpl_2};
   end


`endif




`ifdef EN_VC3


   always @(dllp_kind_p[3] or dllp_kind_np[3] or dllp_kind_cpl[3] or
      vcid3 or fc_p_3 or fc_np_3 or fc_cpl_3) begin
      p_reg[3]   = {dllp_kind_p[3], 2'b00, 1'b0, vcid3, fc_p_3};
      np_reg[3]  = {dllp_kind_np[3], 2'b01, 1'b0, vcid3, fc_np_3};
      cpl_reg[3] = {dllp_kind_cpl[3], 2'b10, 1'b0, vcid3, fc_cpl_3};
   end


`endif




`ifdef EN_VC4


   always @(dllp_kind_p[4] or dllp_kind_np[4] or dllp_kind_cpl[4] or
      vcid4 or fc_p_4 or fc_np_4 or fc_cpl_4) begin
      p_reg[4]   = {dllp_kind_p[4], 2'b00, 1'b0, vcid4, fc_p_4};
      np_reg[4]  = {dllp_kind_np[4], 2'b01, 1'b0, vcid4, fc_np_4};
      cpl_reg[4] = {dllp_kind_cpl[4], 2'b10, 1'b0, vcid4, fc_cpl_4};
   end


`endif




`ifdef EN_VC5


   always @(dllp_kind_p[5] or dllp_kind_np[5] or dllp_kind_cpl[5] or
      vcid5 or fc_p_5 or fc_np_5 or fc_cpl_5) begin
      p_reg[5]   = {dllp_kind_p[5], 2'b00, 1'b0, vcid5, fc_p_5};
      np_reg[5]  = {dllp_kind_np[5], 2'b01, 1'b0, vcid5, fc_np_5};
      cpl_reg[5] = {dllp_kind_cpl[5], 2'b10, 1'b0, vcid5, fc_cpl_5};
   end


`endif




`ifdef EN_VC6


   always @(dllp_kind_p[6] or dllp_kind_np[6] or dllp_kind_cpl[6] or
      vcid6 or fc_p_6 or fc_np_6 or fc_cpl_6) begin
      p_reg[6]   = {dllp_kind_p[6], 2'b00, 1'b0, vcid6, fc_p_6};
      np_reg[6]  = {dllp_kind_np[6], 2'b01, 1'b0, vcid6, fc_np_6};
      cpl_reg[6] = {dllp_kind_cpl[6], 2'b10, 1'b0, vcid6, fc_cpl_6};
   end


`endif




`ifdef EN_VC7


   always @(dllp_kind_p[7] or dllp_kind_np[7] or dllp_kind_cpl[7] or
      vcid7 or fc_p_7 or fc_np_7 or fc_cpl_7) begin
      p_reg[7]   = {dllp_kind_p[7], 2'b00, 1'b0, vcid7, fc_p_7};
      np_reg[7]  = {dllp_kind_np[7], 2'b01, 1'b0, vcid7, fc_np_7};
      cpl_reg[7] = {dllp_kind_cpl[7], 2'b10, 1'b0, vcid7, fc_cpl_7};
   end


`endif



always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      dllp_pkt   <= 32'd0;
   end
   else begin
      case(sel_reg_split[INDEX:0])
         

`ifdef EN_VC0


            VC0P     : dllp_pkt  <= p_reg[0];
            VC0NP    : dllp_pkt  <= np_reg[0];
            VC0CPL   : dllp_pkt  <= cpl_reg[0];
         

`endif


         

`ifdef EN_VC1


            VC1P     : dllp_pkt  <= p_reg[1];
            VC1NP    : dllp_pkt  <= np_reg[1];
            VC1CPL   : dllp_pkt  <= cpl_reg[1];
         

`endif


         

`ifdef EN_VC2


            VC2P     : dllp_pkt  <= p_reg[2];
            VC2NP    : dllp_pkt  <= np_reg[2];
            VC2CPL   : dllp_pkt  <= cpl_reg[2];
         

`endif


         

`ifdef EN_VC3


            VC3P     : dllp_pkt  <= p_reg[3];
            VC3NP    : dllp_pkt  <= np_reg[3];
            VC3CPL   : dllp_pkt  <= cpl_reg[3];
         

`endif


         

`ifdef EN_VC4


            VC4P     : dllp_pkt  <= p_reg[4];
            VC4NP    : dllp_pkt  <= np_reg[4];
            VC4CPL   : dllp_pkt  <= cpl_reg[4];
         

`endif


         

`ifdef EN_VC5


            VC5P     : dllp_pkt  <= p_reg[5];
            VC5NP    : dllp_pkt  <= np_reg[5];
            VC5CPL   : dllp_pkt  <= cpl_reg[5];
         

`endif


         

`ifdef EN_VC6


            VC6P     : dllp_pkt  <= p_reg[6];
            VC6NP    : dllp_pkt  <= np_reg[6];
            VC6CPL   : dllp_pkt  <= cpl_reg[6];
         

`endif


         

`ifdef EN_VC7


            VC7P     : dllp_pkt  <= p_reg[7];
            VC7NP    : dllp_pkt  <= np_reg[7];
            VC7CPL   : dllp_pkt  <= cpl_reg[7];
         

`endif


         default  : dllp_pkt  <= acknak_reg_split; //7/15/31
      endcase
   end
end

// =============================================================================
// VC0-7 Req Processing
// =============================================================================


`ifdef EN_VC0


always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      VCP[0]   <= VC0P;
      VCNP[0]  <= VC0NP;
      VCCPL[0] <= VC0CPL;
   end
   else begin
      VCP[0]   <= VC0P;
      VCNP[0]  <= VC0NP;
      VCCPL[0] <= VC0CPL;
   end
end


`endif




`ifdef EN_VC1


always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      VCP[1]   <= VC1P;
      VCNP[1]  <= VC1NP;
      VCCPL[1] <= VC1CPL;
   end
   else begin
      VCP[1]   <= VC1P;
      VCNP[1]  <= VC1NP;
      VCCPL[1] <= VC1CPL;
   end
end


`endif




`ifdef EN_VC2


always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      VCP[2]   <= VC2P;
      VCNP[2]  <= VC2NP;
      VCCPL[2] <= VC2CPL;
   end
   else begin
      VCP[2]   <= VC2P;
      VCNP[2]  <= VC2NP;
      VCCPL[2] <= VC2CPL;
   end
end


`endif




`ifdef EN_VC3


always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      VCP[3]   <= VC3P;
      VCNP[3]  <= VC3NP;
      VCCPL[3] <= VC3CPL;
   end
   else begin
      VCP[3]   <= VC3P;
      VCNP[3]  <= VC3NP;
      VCCPL[3] <= VC3CPL;
   end
end


`endif




`ifdef EN_VC4


always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      VCP[4]   <= VC4P;
      VCNP[4]  <= VC4NP;
      VCCPL[4] <= VC4CPL;
   end
   else begin
      VCP[4]   <= VC4P;
      VCNP[4]  <= VC4NP;
      VCCPL[4] <= VC4CPL;
   end
end


`endif




`ifdef EN_VC5


always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      VCP[5]   <= VC5P;
      VCNP[5]  <= VC5NP;
      VCCPL[5] <= VC5CPL;
   end
   else begin
      VCP[5]   <= VC5P;
      VCNP[5]  <= VC5NP;
      VCCPL[5] <= VC5CPL;
   end
end


`endif




`ifdef EN_VC6


always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      VCP[6]   <= VC6P;
      VCNP[6]  <= VC6NP;
      VCCPL[6] <= VC6CPL;
   end
   else begin
      VCP[6]   <= VC6P;
      VCNP[6]  <= VC6NP;
      VCCPL[6] <= VC6CPL;
   end
end


`endif




`ifdef EN_VC7


always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      VCP[7]   <= VC7P;
      VCNP[7]  <= VC7NP;
      VCCPL[7] <= VC7CPL;
   end
   else begin
      VCP[7]   <= VC7P;
      VCNP[7]  <= VC7NP;
      VCCPL[7] <= VC7CPL;
   end
end


`endif



always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      for(i4=0; i4<`NUM_VC; i4=i4+1) begin
         p_req[i4]   <= 1'b0;
         np_req[i4]  <= 1'b0;
         cpl_req[i4] <= 1'b0;
         p_pendh[i4]  <= 1'b0;
         np_pendh[i4] <= 1'b0;
         cpl_pendh[i4]<= 1'b0;
         p_pendl[i4]  <= 1'b0;
         np_pendl[i4] <= 1'b0;
         cpl_pendl[i4]<= 1'b0;
      end
      update1     <= 1'b0;
      update2     <= 1'b0;
      hpvc_incr   <= 0;
      lpvc_incr   <= 0;
   end
   else begin
      update1  <= fc_update1_split;
      update2  <= fc_update2_split & ~fc_update1_split;

      for(i4=0; i4<`NUM_VC; i4=i4+1) begin
         //CLK1 : Updates Info Storing & Req. pulse generation
         p_req[i4]   <= 1'b0;
         np_req[i4]  <= 1'b0;
         cpl_req[i4] <= 1'b0;
         if((fc_update1_split && fc_vcid1_split == i4)) begin
            case(fc_type1_split)
               P_TYPE   : p_req[i4]   <= 1'b1;
               NP_TYPE  : np_req[i4]  <= 1'b1;
               CPL_TYPE : cpl_req[i4] <= 1'b1;
            endcase
         end
         else if((fc_update2_split && fc_vcid2_split == i4)) begin
            case(fc_type2_split)
               P_TYPE   : p_req[i4]   <= 1'b1;
               NP_TYPE  : np_req[i4]  <= 1'b1;
               CPL_TYPE : cpl_req[i4] <= 1'b1;
            endcase
         end

         //HIGH PRIORIOTY
         // Req & Resetting come at the same time, Req is ignored as the new req. data is taken
         // already. This is because REG are updated earlier than vc**_req signal
         if(reset_hpq_split && (hpreset_reg_split == VCP[i4]))
            p_pendh[i4] <= 1'b0;
         else if(p_req_split[i4] && update1_split)
            p_pendh[i4] <= 1'b1;

         if(reset_hpq_split && (hpreset_reg_split == VCNP[i4]))
            np_pendh[i4] <= 1'b0;
         else if(np_req_split[i4] && update1_split)
            np_pendh[i4] <= 1'b1;

         if(reset_hpq_split && (hpreset_reg_split == VCCPL[i4]))
            cpl_pendh[i4] <= 1'b0;
         else if(cpl_req_split[i4] && update1_split)
            cpl_pendh[i4] <= 1'b1;

         //CLK2
         hpvc_incr[i4]    <= update1_split & ((p_req_split[i4] & !p_pendh_split[i4]) |
                          (np_req_split[i4] & !np_pendh_split[i4]) | (cpl_req_split[i4] & !cpl_pendh_split[i4]));

         //LOW PRIORIOTY -- Also will be Reset when HP is pending
         //if(p_pendh[i4] || (reset_lpq && (lpreset_reg == VCP[i4])))
         if(reset_lpq_split && (lpreset_reg_split == VCP[i4]))
            p_pendl[i4] <= 1'b0;
         //else if(p_req[i4] && update2)
         else if(p_req_split[i4] && update2_split && !p_pendh_split[i4])
            p_pendl[i4] <= 1'b1;

         if(reset_lpq_split && (lpreset_reg_split == VCNP[i4]))
            np_pendl[i4] <= 1'b0;
         else if(np_req_split[i4] && update2_split && !np_pendh_split[i4])
            np_pendl[i4] <= 1'b1;

         if(reset_lpq_split && (lpreset_reg_split == VCCPL[i4]))
            cpl_pendl[i4] <= 1'b0;
         else if(cpl_req_split[i4] && update2_split && !cpl_pendh_split[i4])
            cpl_pendl[i4] <= 1'b1;

         //CLK2
         lpvc_incr[i4]    <= update2_split & ((p_req_split[i4] & !p_pendh_split[i4] & !p_pendl_split[i4]) |
                          (np_req_split[i4] & !np_pendh_split[i4] & !np_pendl_split[i4]) |
                          (cpl_req_split[i4] & !cpl_pendh_split[i4] & !cpl_pendl_split[i4]));

      end //end of for loop

   end
end

// =============================================================================
// When Update FC DLLP has been sent, inform RX Flow Control Block, so that it's
// counters gets reset.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      txdp_p_sent   <= 0;
      txdp_np_sent  <= 0;
      txdp_cpl_sent <= 0;
      hp_initfc_pend_req <= {`NUM_VC{1'b0}};
      lp_initfc_pend_req <= {`NUM_VC{1'b0}};
   end
   else begin
      for(i5=0; i5<`NUM_VC; i5=i5+1) begin
         txdp_p_sent[i5]   <= 1'b0;
         txdp_np_sent[i5]  <= 1'b0;
         txdp_cpl_sent[i5] <= 1'b0;

         hp_initfc_pend_req[i5] <= (hp_initfc_pend_req_split[i5])? ~(reset_hpq_split && (hpreset_reg_split == VCCPL[i5])) :
                                                              (lcmfci_req_split  & (lcmfci_vcid_split==i5));
         lp_initfc_pend_req[i5] <= (lp_initfc_pend_req_split[i5])? ~(reset_lpq_split && (lpreset_reg_split == VCCPL[i5])) :
                                                              (lcmfci_req2_split & (lcmfci_vcid_split==i5));

         if((reset_hpq_split && (hpreset_reg_split == VCP[i5])) ||
            (reset_lpq_split && (lpreset_reg_split == VCP[i5])))
            txdp_p_sent[i5] <= 1'b1;

         if((reset_hpq_split && (hpreset_reg_split == VCNP[i5])) ||
            (reset_lpq_split && (lpreset_reg_split == VCNP[i5])))
            txdp_np_sent[i5] <= 1'b1;

         if((reset_hpq_split && (hpreset_reg_split == VCCPL[i5])) ||
            (reset_lpq_split && (lpreset_reg_split == VCCPL[i5])))
            txdp_cpl_sent[i5] <= 1'b1;
      end
   end
end
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      vpend_2_cpl_sent <= 1;
   end
   else begin
      for(i6=0; i6<`NUM_VC; i6=i6+1) begin
         if(vcneg_pend_split[i6])
            vpend_2_cpl_sent[i6] <= 1'b1;
         //else if(!vcneg_pend[i6] && (txdp_cpl_sent[i6] || rxtp_ack || rxtp_nak))
         else if(!vcneg_pend_split[i6] && (((hp_initfc_pend_req_split[i6]==0) &
                                      (lp_initfc_pend_req_split[i6]==0)) || rxtp_ack_split || rxtp_nak_split))
            vpend_2_cpl_sent[i6] <= 1'b0;
      end
   end
end
// =============================================================================
// For DEBUG
// =============================================================================
/******
wire [31:0]  p_reg_1     = p_reg[1];
wire [31:0]  np_reg_1    = np_reg[1];
wire [31:0]  cpl_reg_1   = cpl_reg[1];

wire [31:0]  p_reg_2     = p_reg[2];
wire [31:0]  np_reg_2    = np_reg[2];
wire [31:0]  cpl_reg_2   = cpl_reg[2];

wire [31:0]  p_reg_3     = p_reg[3];
wire [31:0]  np_reg_3    = np_reg[3];
wire [31:0]  cpl_reg_3   = cpl_reg[3];
******/

always@* begin ACKNAK_LAT_TIME_split<={ACKNAK_LAT_TIME>>1,descram_out[0]};phy_skpq_val_split<=descram_out[1];trnc_pause_ack_split<=descram_out[2];fc_update1_split<=descram_out[3];fc_vcid1_split<={fc_vcid1>>1,descram_out[4]};fc_type1_split<={fc_type1>>1,descram_out[5]};fc_update2_split<=descram_out[6];fc_vcid2_split<={fc_vcid2>>1,descram_out[7]};fc_type2_split<={fc_type2>>1,descram_out[8]};p_infi_credit_split<={p_infi_credit>>1,descram_out[9]};np_infi_credit_split<={np_infi_credit>>1,descram_out[10]};cpl_infi_credit_split<={cpl_infi_credit>>1,descram_out[11]};cfg_vcid_split<={cfg_vcid>>1,descram_out[12]};tx_pm_split<=descram_out[13];tx_vendor_split<=descram_out[14];tx_pmd_type_split<={tx_pmd_type>>1,descram_out[15]};tx_vsd_data_split<={tx_vsd_data>>1,descram_out[16]};rxtp_nak_split<=descram_out[17];rxtp_dupltlp_split<=descram_out[18];rxtp_ack_split<=descram_out[19];rxtp_seq_split<={rxtp_seq>>1,descram_out[20]};lcmfci_req_split<=descram_out[21];lcmfci_req2_split<=descram_out[22];lcmfci_vcid_split<={lcmfci_vcid>>1,descram_out[23]};lcmfci_init_split<=descram_out[24];lcmfci_type_split<={lcmfci_type>>1,descram_out[25]};vcneg_pend_split<={vcneg_pend>>1,descram_out[26]};tdmux_rdy1_split<=descram_out[27];tdmux_rdy2_split<=descram_out[28];expired_ack_d_split<=descram_out[29];crc_select_erly_split<=descram_out[30];vpend_2_cpl_sent_split<={vpend_2_cpl_sent>>1,descram_out[31]};hp_initfc_pend_req_split<={hp_initfc_pend_req>>1,descram_out[32]};lp_initfc_pend_req_split<={lp_initfc_pend_req>>1,descram_out[33]};hpvc_incr_split<={hpvc_incr>>1,descram_out[34]};lpvc_incr_split<={lpvc_incr>>1,descram_out[35]};p_req_split<={p_req>>1,descram_out[36]};np_req_split<={np_req>>1,descram_out[37]};cpl_req_split<={cpl_req>>1,descram_out[38]};p_pendh_split<={p_pendh>>1,descram_out[39]};np_pendh_split<={np_pendh>>1,descram_out[40]};cpl_pendh_split<={cpl_pendh>>1,descram_out[41]};p_pendl_split<={p_pendl>>1,descram_out[42]};np_pendl_split<={np_pendl>>1,descram_out[43]};cpl_pendl_split<={cpl_pendl>>1,descram_out[44]};update1_split<=descram_out[45];update2_split<=descram_out[46];sel_reg_split<={sel_reg>>1,descram_out[47]};initfc_req_split<=descram_out[48];initfc_req_d_split<=descram_out[49];initfc_sel_split<={initfc_sel>>1,descram_out[50]};initfc_sel_d_split<={initfc_sel_d>>1,descram_out[51]};initfc_req2_split<=descram_out[52];initfc_req2_d_split<=descram_out[53];initfc_sel2_split<={initfc_sel2>>1,descram_out[54]};initfc_sel2_d_split<={initfc_sel2_d>>1,descram_out[55]};pv_req_split<=descram_out[56];pv_req_d_split<=descram_out[57];pv_dllp_split<={pv_dllp>>1,descram_out[58]};acknak_reg_split<={acknak_reg>>1,descram_out[59]};acknak_newreq_split<=descram_out[60];acknakinit_incr_split<=descram_out[61];acknak_pend_split<=descram_out[62];acknak_req_split<=descram_out[63];nak_pend_split<=descram_out[64];ack_reg_split<={ack_reg>>1,descram_out[65]};ack_newreq_split<=descram_out[66];ackpv_incr_split<=descram_out[67];ack_pend_split<=descram_out[68];ack_req_split<=descram_out[69];hp_allvc_incr_split<=descram_out[70];hp_wr_cnt_split<={hp_wr_cnt>>1,descram_out[71]};hpsel_val_split<={hpsel_val>>1,descram_out[72]};hpsel_val_d_split<={hpsel_val_d>>1,descram_out[73]};hpsel_val_dd_split<={hpsel_val_dd>>1,descram_out[74]};hp_rd_cnt_split<={hp_rd_cnt>>1,descram_out[75]};reset_hpq_split<=descram_out[76];hpreset_reg_split<={hpreset_reg>>1,descram_out[77]};hp_assert_rdy_split<=descram_out[78];lp_allvc_incr_split<=descram_out[79];lp_wr_cnt_split<={lp_wr_cnt>>1,descram_out[80]};lpsel_val_split<={lpsel_val>>1,descram_out[81]};lpsel_val_d_split<={lpsel_val_d>>1,descram_out[82]};lpsel_val_dd_split<={lpsel_val_dd>>1,descram_out[83]};lp_rd_cnt_split<={lp_rd_cnt>>1,descram_out[84]};reset_lpq_split<=descram_out[85];lpreset_reg_split<={lpreset_reg>>1,descram_out[86]};lp_assert_rdy2_split<=descram_out[87];acknak_lat_timer_split<={acknak_lat_timer>>1,descram_out[88]};txdp_rdy_d_split<=descram_out[89];dllp_req_split<=descram_out[90];skip_val_split<=descram_out[91];skip_req_split<=descram_out[92];req_cnt_split<={req_cnt>>1,descram_out[93]};pause_ack_del_split<=descram_out[94];neg_pause_cnt_del1_split<={neg_pause_cnt_del1>>1,descram_out[95]};neg_grant_cnt_split<={neg_grant_cnt>>1,descram_out[96]};sel_add_value_split<={sel_add_value>>1,descram_out[97]};hpsel_val_w_split<={hpsel_val_w>>1,descram_out[98]};lpsel_val_w_split<={lpsel_val_w>>1,descram_out[99]};initfc_sel_w_split<={initfc_sel_w>>1,descram_out[100]};dllp_kindp_0_split<={dllp_kindp_0>>1,descram_out[101]};dllp_kindnp_0_split<={dllp_kindnp_0>>1,descram_out[102]};dllp_kindcpl_0_split<={dllp_kindcpl_0>>1,descram_out[103]};p_reg_0_split<={p_reg_0>>1,descram_out[104]};np_reg_0_split<={np_reg_0>>1,descram_out[105]};cpl_reg_0_split<={cpl_reg_0>>1,descram_out[106]};end
always@* begin descram_in[2047]<=phy_skpq_val;descram_in[2046]<=trnc_pause_ack;descram_in[2045]<=dllp_kindcpl_0[0];descram_in[2044]<=fc_update1;descram_in[2042]<=p_reg_0[0];descram_in[2040]<=fc_vcid1[0];descram_in[2036]<=np_reg_0[0];descram_in[2032]<=fc_type1[0];descram_in[2024]<=cpl_reg_0[0];descram_in[2016]<=fc_update2;descram_in[1985]<=fc_vcid2[0];descram_in[1950]<=rxtp_nak;descram_in[1930]<=lcmfci_vcid[0];descram_in[1923]<=fc_type2[0];descram_in[1909]<=lpsel_val_dd[0];descram_in[1878]<=pv_req;descram_in[1874]<=lp_assert_rdy2;descram_in[1870]<=reset_hpq;descram_in[1852]<=rxtp_dupltlp;descram_in[1813]<=lcmfci_init;descram_in[1799]<=p_infi_credit[0];descram_in[1770]<=lp_rd_cnt[0];descram_in[1708]<=pv_req_d;descram_in[1700]<=acknak_lat_timer[0];descram_in[1693]<=hpreset_reg[0];descram_in[1656]<=rxtp_ack;descram_in[1578]<=lcmfci_type[0];descram_in[1573]<=nak_pend;descram_in[1551]<=np_infi_credit[0];descram_in[1493]<=initfc_sel2[0];descram_in[1492]<=reset_lpq;descram_in[1491]<=hpsel_val_dd[0];descram_in[1417]<=acknak_pend;descram_in[1396]<=hpsel_val[0];descram_in[1378]<=acknak_newreq;descram_in[1368]<=pv_dllp[0];descram_in[1353]<=np_pendh[0];descram_in[1352]<=txdp_rdy_d;descram_in[1345]<=crc_select_erly;descram_in[1339]<=hp_assert_rdy;descram_in[1316]<=p_pendl[0];descram_in[1312]<=skip_val;descram_in[1285]<=hp_initfc_pend_req[0];descram_in[1265]<=rxtp_seq[0];descram_in[1262]<=lp_wr_cnt[0];descram_in[1198]<=ack_req;descram_in[1169]<=cpl_pendl[0];descram_in[1163]<=sel_reg[0];descram_in[1153]<=req_cnt[0];descram_in[1117]<=initfc_sel[0];descram_in[1108]<=vcneg_pend[0];descram_in[1098]<=ack_reg[0];descram_in[1054]<=cpl_infi_credit[0];descram_in[1045]<=hpvc_incr[0];descram_in[1039]<=neg_grant_cnt[0];descram_in[1023]<=ACKNAK_LAT_TIME[0];descram_in[1022]<=dllp_kindnp_0[0];descram_in[975]<=tx_vsd_data[0];descram_in[965]<=lcmfci_req2;descram_in[954]<=lpsel_val_d[0];descram_in[939]<=initfc_sel2_d[0];descram_in[937]<=lpreset_reg[0];descram_in[935]<=hp_rd_cnt[0];descram_in[786]<=acknak_req;descram_in[746]<=initfc_req2_d;descram_in[745]<=hpsel_val_d[0];descram_in[708]<=acknakinit_incr;descram_in[698]<=hp_wr_cnt[0];descram_in[689]<=acknak_reg[0];descram_in[676]<=p_pendh[0];descram_in[672]<=expired_ack_d;descram_in[658]<=cpl_pendh[0];descram_in[656]<=dllp_req;descram_in[642]<=vpend_2_cpl_sent[0];descram_in[631]<=lp_allvc_incr;descram_in[599]<=ack_pend;descram_in[584]<=np_pendl[0];descram_in[581]<=update2;descram_in[576]<=skip_req;descram_in[558]<=initfc_req_d;descram_in[522]<=lp_initfc_pend_req[0];descram_in[519]<=neg_pause_cnt_del1[0];descram_in[511]<=dllp_kindp_0[0];descram_in[487]<=tx_pmd_type[0];descram_in[482]<=lcmfci_req;descram_in[477]<=lpsel_val[0];descram_in[373]<=initfc_req2;descram_in[349]<=hp_allvc_incr;descram_in[338]<=cpl_req[0];descram_in[336]<=tdmux_rdy2;descram_in[299]<=ackpv_incr;descram_in[290]<=update1;descram_in[279]<=initfc_req;descram_in[259]<=pause_ack_del;descram_in[255]<=initfc_sel_w[0];descram_in[243]<=tx_vendor;descram_in[186]<=initfc_sel_d[0];descram_in[169]<=np_req[0];descram_in[168]<=tdmux_rdy1;descram_in[149]<=ack_newreq;descram_in[127]<=lpsel_val_w[0];descram_in[121]<=tx_pm;descram_in[84]<=p_req[0];descram_in[63]<=hpsel_val_w[0];descram_in[60]<=cfg_vcid[0];descram_in[42]<=lpvc_incr[0];descram_in[31]<=sel_add_value[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.8 2007/05/01 16:49:49PDT rperugu


// crc_select/txdp_pv_sent timing is changed. Made a pulse (t2_1_08).


// Revision 1.7 2007/04/09 14:25:24PDT rperugu


// update2  <= fc_update2 & ~fc_update1; to avoid back-back same Update FC DLLPs.


// Revision 1.6 2006/09/22 10:35:13PDT rperugu


//


// Revision 1.5 2006/07/17 17:21:05PDT rperugu


// Changed ACKNAK_LAT_TIMER width from 10 to 14 (consistent with X1).


// Revision 1.4 2006/06/07 18:54:27PDT rperugu


// Compiled.


// Revision 1.3 2006/06/01 15:05:50PDT rperugu


//


// Revision 1.13 2006/05/09 09:04:58PDT gkrishna


// Fixed Blocking to Non Blocking


// Revision 1.12 2006/05/08 18:59:55PDT rperugu


// 1) TLP_DEBUG --> tlp_debug


// 2) PM DLLP --> PM/VENDOR


// tx_dllP_val[1:0], tx_vsd_data[23:0] -- New siganls


// Revision 1.11 2006/05/04 13:32:17PDT gkrishna


//


// Updated after LINT checks


// Revision 1.10 2006/04/28 12:06:29PDT uananthi


// `defines changed to parametrs.


// Revision 1.9 2006/04/25 12:23:44PDT uananthi


// p_req logic updated (RK)


// Revision 1.8 2006/03/20 10:35:23PST rperugu


// Added Inputs p/np/cpl_infi_credit from rxfc module.


// No Update FC can be sent for an infinite credit type.


// Conversion from INIT to UPDATE is avoided using these signals.


// Revision 1.7 2006/03/13 10:16:00PST uananthi


// crc_select timing fixed.


// Revision 1.6 2006/03/10 11:16:48PST rperugu


// ACKNAK_LAT_TIME width is changed to 13:0


// Revision 1.5 2006/03/10 10:12:31PST rperugu


//


// Revision 1.4 2006/03/09 14:49:55PST uananthi


// ack_lat_timer value changed.


// Revision 1.3 2006/02/24 15:28:34PST rperugu


// Implemented 34 micro sec timer & made INITFC to Low Priority.


// After Timer expiry INITFC becomes High Priority.


// Revision 1.2 2006/02/09 17:36:11PST rperugu


//


// Revision 1.24 2005/04/18 10:08:24PDT rperugu


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_xx


// File             : txdp.v


// Title            : txdp Controller -- Top Block


// Dependencies     :


// Description      :


//                    txdp_ctrl module forms the DLLP Pkts that are to be sent out


//                    based on the requests from RXTP , FC, LCMFCI & PM.


//                    txdp_crc block generates the crc for the input given by


//                    txdp_ctrl block


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Rajakumar


// Mod. Date        : Mar 30, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module  txtdp #(
   parameter FADDR    = 6,
   parameter D_WIDTH  = 64 )
   (
   input wire                   sys_clk,           
   input wire                   rst_n,             

   input wire [13:0]            ACKNAK_LAT_TIME,   
                                            
   `ifdef X4
      input wire                tlpgen_tval,       
      input wire                phy_x4_val,        
      input wire [2:0]          phy_cfgln_sum,     
      input wire                rate_5g,           
      input wire [1:0]          phy_skpq_nclks,    
   `endif
   input wire                   phy_link_up,       
   input wire                   phy_skpq_val,      
   input wire                   trnc_pause_ack,    

   
   input wire                   fc_update1,        
   input wire [2:0]             fc_vcid1,          
   input wire [1:0]             fc_type1,          

   input wire                   fc_update2,        
   input wire [2:0]             fc_vcid2,          
   input wire [1:0]             fc_type2,          

   input wire [`NUM_VC -1:0]     p_infi_credit,    
   input wire [`NUM_VC -1:0]     np_infi_credit,   
   input wire [`NUM_VC -1:0]     cpl_infi_credit,  
   input wire [(`NUM_VC*3) -1:0] cfg_vcid,         
   `ifdef EN_VC0
      input wire [23:0]      fc_p_0,               
      input wire [23:0]      fc_np_0,
      input wire [23:0]      fc_cpl_0,
   `endif
   `ifdef EN_VC1
      input wire [23:0]      fc_p_1,               
      input wire [23:0]      fc_np_1,
      input wire [23:0]      fc_cpl_1,
   `endif
   `ifdef EN_VC2
      input wire [23:0]      fc_p_2,               
      input wire [23:0]      fc_np_2,
      input wire [23:0]      fc_cpl_2,
   `endif
   `ifdef EN_VC3
      input wire [23:0]      fc_p_3,               
      input wire [23:0]      fc_np_3,
      input wire [23:0]      fc_cpl_3,
   `endif
   `ifdef EN_VC4
      input wire [23:0]      fc_p_4,               
      input wire [23:0]      fc_np_4,
      input wire [23:0]      fc_cpl_4,
   `endif
   `ifdef EN_VC5
      input wire [23:0]      fc_p_5,               
      input wire [23:0]      fc_np_5,
      input wire [23:0]      fc_cpl_5,
   `endif
   `ifdef EN_VC6
      input wire [23:0]      fc_p_6,               
      input wire [23:0]      fc_np_6,
      input wire [23:0]      fc_cpl_6,
   `endif
   `ifdef EN_VC7
      input wire [23:0]      fc_p_7,               
      input wire [23:0]      fc_np_7,
      input wire [23:0]      fc_cpl_7,
   `endif

   
   input wire                tx_pm,                
   input wire                tx_vendor,            
   input wire [2:0]          tx_pmd_type,          
   input wire [23:0]         tx_vsd_data,          

   
   input wire                rxtp_nak,             
   input wire                rxtp_dupltlp,         
   input wire                rxtp_ack,             
   input wire [11:0]         rxtp_seq,             

   
   input wire                lcmfci_req,           
   input wire                lcmfci_req2,          
   input wire [2:0]          lcmfci_vcid,          
   input wire                lcmfci_init,          
   input wire [1:0]          lcmfci_type,          
   input wire [`NUM_VC -1:0] vcneg_pend,           


   
   input wire [D_WIDTH-1:0]  txtp_tdata,           
   input wire                txtp_st,              
   input wire                txtp_end,             
   input wire                txtp_edb,             
   `ifdef X1
      input wire             txtp_erly_tval,       
   `endif
   `ifdef X4
      input wire             txtp_tval,            
      input wire             txtp_dwen ,           
   `endif

   
   output wire [FADDR:0]     dll_pause_cnt,        

   
   output wire [D_WIDTH-1:0]  tdmux_data,           
   output wire               tdmux_val,            
   output wire               tdmux_st,             
   output wire               tdmux_end,            
   output wire               tdmux_edb,            
   `ifdef X1
      output wire            tdmux_dllp_st,        
      output wire            tdmux_dllp_end,       
   `endif
   `ifdef X4
      output wire            tdmux_dwen,           
      output wire            tdmux_dllp,           
   `endif
   output wire               tdmux_skip,           

   
   output wire [`NUM_VC -1:0] txdp_p_sent,         
   output wire [`NUM_VC -1:0] txdp_np_sent,        
   output wire [`NUM_VC -1:0] txdp_cpl_sent,       
   output wire                txdp_hpreq,          
   output wire                txdp_lpreq,          
   output wire                txdp_no_hpreq,       
   output wire                txdp_no_lpreq,       

   
   output wire                txdp_rdy,            
   output wire                txdp_rdy2,           

   
   output wire                txdp_pv_sent        // Send PM/VENDOR DLLP requested



   );
wire                      txdp_req1;
wire                      txdp_req2;

`ifdef X1
wire   [3:0]           txdp_skip_cnt;
wire   [15:0]          txdp_data;

`endif

`ifdef X4
wire   [2:0]           txdp_skip_cnt;
wire                   txdp_val1;
wire                   txdp_val2;
wire   [47:0]          txdp_data;
wire                   txdp_dllp;

`endif
reg                       expired_ack_d;
reg                       rxtp_nak_d;
reg                       rxtp_dupltlp_d;
reg                       rxtp_ack_d;
reg   [11:0]              rxtp_seq_d;
reg                       tx_pm_d;
reg   [2:0]               tx_pmtype_d;
reg                       tx_vendor_d;
reg    [23:0]             tx_vendata_d;
reg                       rxtp_req;
reg                       other_req;
wire                      crc_select;
wire   [31:0]             dllp_pkt;
wire   [31:0]             pv_dllp_pkt;
wire                      expired_ack;
wire                      lcmfci_req_only;
wire                      lcmfci_req2_only;
wire                      tdmux_rdy1;
wire                      tdmux_rdy2;

`ifdef X4

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`define TDMUX_MOD td_mux_x1

`endif

`ifdef X4

`define TDMUX_MOD td_mux

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif
reg [13 : 0] ACKNAK_LAT_TIME_split;
reg phy_link_up_split;
reg phy_skpq_val_split;
reg trnc_pause_ack_split;
reg fc_update1_split;
reg [2 : 0] fc_vcid1_split;
reg [1 : 0] fc_type1_split;
reg fc_update2_split;
reg [2 : 0] fc_vcid2_split;
reg [1 : 0] fc_type2_split;
reg [`NUM_VC - 1 : 0] p_infi_credit_split;
reg [`NUM_VC - 1 : 0] np_infi_credit_split;
reg [`NUM_VC - 1 : 0] cpl_infi_credit_split;
reg [(`NUM_VC * 3) - 1 : 0] cfg_vcid_split;
reg tx_pm_split;
reg tx_vendor_split;
reg [2 : 0] tx_pmd_type_split;
reg [23 : 0] tx_vsd_data_split;
reg rxtp_nak_split;
reg rxtp_dupltlp_split;
reg rxtp_ack_split;
reg [11 : 0] rxtp_seq_split;
reg lcmfci_req_split;
reg lcmfci_req2_split;
reg [2 : 0] lcmfci_vcid_split;
reg lcmfci_init_split;
reg [1 : 0] lcmfci_type_split;
reg [`NUM_VC - 1 : 0] vcneg_pend_split;
reg [D_WIDTH - 1 : 0] txtp_tdata_split;
reg txtp_st_split;
reg txtp_end_split;
reg txtp_edb_split;
reg txdp_req2_split;
reg expired_ack_d_split;
reg rxtp_nak_d_split;
reg rxtp_dupltlp_d_split;
reg rxtp_ack_d_split;
reg [11 : 0] rxtp_seq_d_split;
reg tx_pm_d_split;
reg [2 : 0] tx_pmtype_d_split;
reg tx_vendor_d_split;
reg [23 : 0] tx_vendata_d_split;
reg rxtp_req_split;
reg other_req_split;
reg crc_select_split;
reg [31 : 0] dllp_pkt_split;
reg [31 : 0] pv_dllp_pkt_split;
reg expired_ack_split;
reg lcmfci_req_only_split;
reg lcmfci_req2_only_split;
reg tdmux_rdy1_split;
reg tdmux_rdy2_split;
reg [2047:0] descram_in;
wire [51:0] descram_out;

`ifdef X1

`endif

`ifdef X4

`endif


`ifdef X4

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef X4

`endif

`ifdef X1

`endif


`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`define TDMUX_MOD td_mux_x1

`endif

`ifdef X4

`define TDMUX_MOD td_mux

`endif


`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

localparam descram_inst_SIZE = 52,descram_inst_SCRAMSTRING = 32'hfdffc68b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X1


`endif



`ifdef X4


`endif


`ifdef X4



`endif



`ifdef EN_VC0



`endif



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`define TDMUX_MOD td_mux_x1



`endif



`ifdef X4



`define TDMUX_MOD td_mux



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif

// =============================================================================



`ifdef X1


   

`endif




`ifdef X4


   

`endif



// =============================================================================
// DLLP for High & Low priority Req. with CRC
// Highest Priority for RXTP req, then Update FC then Init FC
//   1) Update FC req comes only when there is no txdp_hpreq.
//      For this _d delay signals are added
//   2) Init FC req are sent to TXDp_CTRL only when none of the HP req are there
//      For this txdp_no_hpreq is added
// =============================================================================

// =============================================================================
// Delaying the requests so that RXFC will not ask for fc_updates
// rxtp_nak
// rxtp_dupltlp
// rxtp_ack
// rxtp_seq
// =============================================================================
assign txdp_hpreq = rxtp_nak_split | rxtp_dupltlp_split | expired_ack_split;
assign txdp_lpreq = rxtp_ack_split | tx_pm_split | tx_vendor_split;
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      expired_ack_d    <= 1'b0;
      rxtp_nak_d       <= 1'b0;
      rxtp_dupltlp_d   <= 1'b0;
      rxtp_ack_d       <= 1'b0;
      rxtp_seq_d       <= 12'd0;
      tx_pm_d          <= 1'b0;
      tx_pmtype_d      <= 3'b000;
      tx_vendor_d      <= 1'b0;
      tx_vendata_d     <= 24'd0;
   end
   else begin
      expired_ack_d    <= expired_ack_split;

      rxtp_nak_d       <= rxtp_nak_split;
      rxtp_dupltlp_d   <= rxtp_dupltlp_split;
      rxtp_ack_d       <= rxtp_ack_split;
      rxtp_seq_d       <= rxtp_seq_split;

      tx_pm_d          <= tx_pm_split;
      tx_pmtype_d      <= tx_pmd_type_split;
      tx_vendor_d      <= tx_vendor_split;
      tx_vendata_d     <= tx_vsd_data_split;
   end
end

// =============================================================================
// For LCMFCI
// lcmfci_req : only taken by txdp_ctrl when no other HP req are there
// lcmfci will keep the req until no other HP req
// Same way for lcmfci_req2 (LP)
// =============================================================================
assign txdp_no_hpreq    = !(rxtp_req_split || fc_update1_split);
assign txdp_no_lpreq    = !(other_req_split || fc_update2_split);
assign lcmfci_req_only  = lcmfci_req_split && txdp_no_hpreq;
assign lcmfci_req2_only = lcmfci_req2_split && txdp_no_lpreq;
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
     rxtp_req    <= 1'b0;
     other_req   <= 1'b0;
   end
   else begin
     rxtp_req       <= rxtp_nak_split | rxtp_dupltlp_split | expired_ack_split;
     other_req      <= rxtp_ack_split | tx_pm_split | tx_vendor_split;
   end
end


// =============================================================================
// TXDP Controller Instance
// =============================================================================
txdp_ctrl #(
   .FADDR                ( FADDR ))
   u1_txdp_ctrl (
   //---------Inputs-------------
   .sys_clk                  (sys_clk),
   .rst_n                    (rst_n),

   .ACKNAK_LAT_TIME          (ACKNAK_LAT_TIME_split),
   

`ifdef X4


      .tlpgen_tval           (tlpgen_tval),
      .phy_skpq_nclks        (phy_skpq_nclks),
   

`endif


   // From PHY
   .phy_skpq_val             (phy_skpq_val_split),
   .trnc_pause_ack           (trnc_pause_ack_split),

   // From Flow Control - FC
   .fc_update1               (fc_update1_split),
   .fc_vcid1                 (fc_vcid1_split),
   .fc_type1                 (fc_type1_split),

   .fc_update2               (fc_update2_split),
   .fc_vcid2                 (fc_vcid2_split),
   .fc_type2                 (fc_type2_split),

   .p_infi_credit            (p_infi_credit_split),
   .np_infi_credit           (np_infi_credit_split),
   .cpl_infi_credit          (cpl_infi_credit_split),
   .cfg_vcid                 (cfg_vcid_split),
   

`ifdef EN_VC0


      .fc_p_0                   (fc_p_0),
      .fc_np_0                  (fc_np_0),
      .fc_cpl_0                 (fc_cpl_0),
   

`endif


   

`ifdef EN_VC1


      .fc_p_1                   (fc_p_1),
      .fc_np_1                  (fc_np_1),
      .fc_cpl_1                 (fc_cpl_1),
   

`endif


   

`ifdef EN_VC2


      .fc_p_2                   (fc_p_2),
      .fc_np_2                  (fc_np_2),
      .fc_cpl_2                 (fc_cpl_2),
   

`endif


   

`ifdef EN_VC3


      .fc_p_3                   (fc_p_3),
      .fc_np_3                  (fc_np_3),
      .fc_cpl_3                 (fc_cpl_3),
   

`endif


   

`ifdef EN_VC4


      .fc_p_4                   (fc_p_4),
      .fc_np_4                  (fc_np_4),
      .fc_cpl_4                 (fc_cpl_4),
   

`endif


   

`ifdef EN_VC5


      .fc_p_5                   (fc_p_5),
      .fc_np_5                  (fc_np_5),
      .fc_cpl_5                 (fc_cpl_5),
   

`endif


   

`ifdef EN_VC6


      .fc_p_6                   (fc_p_6),
      .fc_np_6                  (fc_np_6),
      .fc_cpl_6                 (fc_cpl_6),
   

`endif


   

`ifdef EN_VC7


      .fc_p_7                   (fc_p_7),
      .fc_np_7                  (fc_np_7),
      .fc_cpl_7                 (fc_cpl_7),
   

`endif




   // From Power Mgmmt - Core I/F
   .tx_pm                    (tx_pm_d_split),
   .tx_pmd_type              (tx_pmtype_d_split),
   .tx_vendor                (tx_vendor_d_split),
   .tx_vsd_data              (tx_vendata_d_split),

   // From RX TLP Processing Block - RXTP
   .rxtp_nak                 (rxtp_nak_d_split),
   .rxtp_dupltlp             (rxtp_dupltlp_d_split),
   .rxtp_ack                 (rxtp_ack_d_split),
   .rxtp_seq                 (rxtp_seq_d_split),

   // From Link Control SM & FC Init - LCMFCI
   .vcneg_pend               (vcneg_pend_split),
   .lcmfci_req               (lcmfci_req_only_split),
   .lcmfci_req2              (lcmfci_req2_only_split),
   .lcmfci_vcid              (lcmfci_vcid_split),
   .lcmfci_init              (lcmfci_init_split),
   .lcmfci_type              (lcmfci_type_split),

   // From TX Data Mux - TDMUX
   .tdmux_rdy1               (tdmux_rdy1_split),
   .tdmux_rdy2               (tdmux_rdy2_split),

   .expired_ack_d            (expired_ack_d_split),

   //---------Outputs------------
   // To TL - Req for insertion of DLLPs/SKIPs
   .dll_pause_cnt            (dll_pause_cnt),

   // To TX Data Mux - TDMUX
   .txdp_req1                (txdp_req1),
   .txdp_req2                (txdp_req2),
   .txdp_skip_cnt            (txdp_skip_cnt),
   

`ifdef X4


      .txdp_val1             (txdp_val1),
      .txdp_val2             (txdp_val2),
   

`endif



   // To RXFC Block
   .txdp_p_sent              (txdp_p_sent),
   .txdp_np_sent             (txdp_np_sent),
   .txdp_cpl_sent            (txdp_cpl_sent),

   // To Link Control SM & FC Init - LCMFCI
   .txdp_rdy                 (txdp_rdy),
   .txdp_rdy2                (txdp_rdy2),

   // To Power Mgmmt - Core I/F
   .txdp_pv_sent             (txdp_pv_sent),

   // To CRC Generator
   

`ifdef X1


      .take_dllp             (take_dllp),
   

`endif


   .crc_select               (crc_select),
   .dllp_pkt                 (dllp_pkt),
   .pv_dllp_pkt              (pv_dllp_pkt),

   .expired_ack              (expired_ack)

   );

// =============================================================================
// TXDP CRC generator Instance
// =============================================================================
txdp_crc  u2_txdp_crc(
   .sys_clk                  (sys_clk),
   .rst_n                    (rst_n),

   

`ifdef X1


      .take_dllp             (take_dllp),
      .txdp_val              (txdp_val),
      .txdp_dllp_st          (txdp_dllp_st),
      .txdp_dllp_end         (txdp_dllp_end),
      .dllp                  (txdp_data[15:0]),
   

`endif


   

`ifdef X4


      .dllp                  (txdp_data[47:0]),
   

`endif


   .crc_select               (crc_select_split),
   .dllp_pkt                 (dllp_pkt_split),
   .pv_dllp_pkt              (pv_dllp_pkt_split)
   );

// =============================================================================
// TDMUX Instance
// =============================================================================


`ifdef X1


   

`define TDMUX_MOD td_mux_x1




`endif




`ifdef X4


   

`define TDMUX_MOD td_mux




`endif


`TDMUX_MOD u1_td_mux (
   // Clock and Reset
   .sys_clk                  (sys_clk),
   .rst_n                    (rst_n),

   // Inputs
   .phy_link_up              (phy_link_up),
   

`ifdef X4


      .tlpgen_tval           (tlpgen_tval),
      .phy_x4_val            (phy_x4_val),
      .phy_cfgln_sum         (phy_cfgln_sum),
      .rate_5g               (rate_5g),
   

`endif



   // From TXTP - TLP data
   .txtp_tdata               (txtp_tdata),
   .txtp_st                  (txtp_st),
   .txtp_end                 (txtp_end),
   .txtp_edb                 (txtp_edb),
   

`ifdef X1


      .txtp_erly_tval        (txtp_erly_tval),
   

`endif


   

`ifdef X4


      .txtp_tval             (txtp_tval),
      .txtp_dwen             (txtp_dwen),
   

`endif



   // From TXDP
   

`ifdef X1


      .txdp_req1             (txdp_req1),
      .txdp_req2             (txdp_req2),
      .txdp_val              (txdp_val),
      .txdp_dllp_st          (txdp_dllp_st),
      .txdp_dllp_end         (txdp_dllp_end),
   

`endif


   

`ifdef X4


      .txdp_req1             (txdp_req1),
      .txdp_val1             (txdp_val1),
      .txdp_val2             (txdp_val2),
   

`endif


   .txdp_skip_cnt            (txdp_skip_cnt),
   .txdp_data                (txdp_data),

   // Outputs
   // To PHY
   .tdmux_data               (tdmux_data),
   .tdmux_val                (tdmux_val),
   .tdmux_st                 (tdmux_st),
   .tdmux_end                (tdmux_end),
   .tdmux_edb                (tdmux_edb),
   .tdmux_skip               (tdmux_skip),
   

`ifdef X1


      .tdmux_dllp_st         (tdmux_dllp_st),
      .tdmux_dllp_end        (tdmux_dllp_end),
   

`endif


   

`ifdef X4


      .tdmux_dwen            (tdmux_dwen),
      .tdmux_dllp            (tdmux_dllp),
   

`endif



   // To TXDP
   .tdmux_rdy1               (tdmux_rdy1),
   .tdmux_rdy2               (tdmux_rdy2)

   );


always@* begin ACKNAK_LAT_TIME_split<={ACKNAK_LAT_TIME>>1,descram_out[0]};phy_link_up_split<=descram_out[1];phy_skpq_val_split<=descram_out[2];trnc_pause_ack_split<=descram_out[3];fc_update1_split<=descram_out[4];fc_vcid1_split<={fc_vcid1>>1,descram_out[5]};fc_type1_split<={fc_type1>>1,descram_out[6]};fc_update2_split<=descram_out[7];fc_vcid2_split<={fc_vcid2>>1,descram_out[8]};fc_type2_split<={fc_type2>>1,descram_out[9]};p_infi_credit_split<={p_infi_credit>>1,descram_out[10]};np_infi_credit_split<={np_infi_credit>>1,descram_out[11]};cpl_infi_credit_split<={cpl_infi_credit>>1,descram_out[12]};cfg_vcid_split<={cfg_vcid>>1,descram_out[13]};tx_pm_split<=descram_out[14];tx_vendor_split<=descram_out[15];tx_pmd_type_split<={tx_pmd_type>>1,descram_out[16]};tx_vsd_data_split<={tx_vsd_data>>1,descram_out[17]};rxtp_nak_split<=descram_out[18];rxtp_dupltlp_split<=descram_out[19];rxtp_ack_split<=descram_out[20];rxtp_seq_split<={rxtp_seq>>1,descram_out[21]};lcmfci_req_split<=descram_out[22];lcmfci_req2_split<=descram_out[23];lcmfci_vcid_split<={lcmfci_vcid>>1,descram_out[24]};lcmfci_init_split<=descram_out[25];lcmfci_type_split<={lcmfci_type>>1,descram_out[26]};vcneg_pend_split<={vcneg_pend>>1,descram_out[27]};txtp_tdata_split<={txtp_tdata>>1,descram_out[28]};txtp_st_split<=descram_out[29];txtp_end_split<=descram_out[30];txtp_edb_split<=descram_out[31];txdp_req2_split<=descram_out[32];expired_ack_d_split<=descram_out[33];rxtp_nak_d_split<=descram_out[34];rxtp_dupltlp_d_split<=descram_out[35];rxtp_ack_d_split<=descram_out[36];rxtp_seq_d_split<={rxtp_seq_d>>1,descram_out[37]};tx_pm_d_split<=descram_out[38];tx_pmtype_d_split<={tx_pmtype_d>>1,descram_out[39]};tx_vendor_d_split<=descram_out[40];tx_vendata_d_split<={tx_vendata_d>>1,descram_out[41]};rxtp_req_split<=descram_out[42];other_req_split<=descram_out[43];crc_select_split<=descram_out[44];dllp_pkt_split<={dllp_pkt>>1,descram_out[45]};pv_dllp_pkt_split<={pv_dllp_pkt>>1,descram_out[46]};expired_ack_split<=descram_out[47];lcmfci_req_only_split<=descram_out[48];lcmfci_req2_only_split<=descram_out[49];tdmux_rdy1_split<=descram_out[50];tdmux_rdy2_split<=descram_out[51];end
always@* begin descram_in[2047]<=phy_link_up;descram_in[2046]<=phy_skpq_val;descram_in[2044]<=trnc_pause_ack;descram_in[2040]<=fc_update1;descram_in[2032]<=fc_vcid1[0];descram_in[2017]<=fc_type1[0];descram_in[1987]<=fc_update2;descram_in[1980]<=lcmfci_req2_only;descram_in[1963]<=expired_ack_d;descram_in[1926]<=fc_vcid2[0];descram_in[1921]<=lcmfci_req2;descram_in[1913]<=tdmux_rdy1;descram_in[1903]<=rxtp_req;descram_in[1879]<=rxtp_nak_d;descram_in[1805]<=fc_type2[0];descram_in[1795]<=lcmfci_vcid[0];descram_in[1783]<=pv_dllp_pkt[0];descram_in[1778]<=tdmux_rdy2;descram_in[1758]<=other_req;descram_in[1710]<=rxtp_dupltlp_d;descram_in[1679]<=tx_pmd_type[0];descram_in[1562]<=p_infi_credit[0];descram_in[1543]<=lcmfci_init;descram_in[1519]<=expired_ack;descram_in[1499]<=tx_vendor_d;descram_in[1469]<=crc_select;descram_in[1398]<=tx_pm_d;descram_in[1373]<=rxtp_ack_d;descram_in[1310]<=tx_vsd_data[0];descram_in[1144]<=rxtp_dupltlp;descram_in[1076]<=np_infi_credit[0];descram_in[1039]<=lcmfci_type[0];descram_in[1023]<=ACKNAK_LAT_TIME[0];descram_in[990]<=lcmfci_req_only;descram_in[981]<=txdp_req2;descram_in[960]<=lcmfci_req;descram_in[951]<=tx_vendata_d[0];descram_in[891]<=dllp_pkt[0];descram_in[839]<=tx_vendor;descram_in[749]<=tx_pmtype_d[0];descram_in[699]<=rxtp_seq_d[0];descram_in[572]<=rxtp_nak;descram_in[490]<=txtp_edb;descram_in[480]<=rxtp_seq[0];descram_in[419]<=tx_pm;descram_in[245]<=txtp_end;descram_in[240]<=rxtp_ack;descram_in[209]<=cfg_vcid[0];descram_in[122]<=txtp_st;descram_in[104]<=cpl_infi_credit[0];descram_in[61]<=txtp_tdata[0];descram_in[30]<=vcneg_pend[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule

// =============================================================================


// Revision 1.4 2006/07/17 17:21:02PDT rperugu


// Changed ACKNAK_LAT_TIMER width from 10 to 14 (consistent with X1).


// Revision 1.3 2006/06/07 18:54:40PDT rperugu


// Compiled.


// Revision 1.2 2006/06/01 15:05:52PDT rperugu


//


// Revision 1.7 2006/05/08 18:59:59PDT rperugu


// 1) TLP_DEBUG --> tlp_debug


// 2) PM DLLP --> PM/VENDOR


// tx_dllP_val[1:0], tx_vsd_data[23:0] -- New siganls


// Revision 1.6 2006/04/28 12:06:30PDT uananthi


// `defines changed to parametrs.


// Revision 1.5 2006/03/20 10:35:18PST rperugu


// Added Inputs p/np/cpl_infi_credit from rxfc module.


// No Update FC can be sent for an infinite credit type.


// Conversion from INIT to UPDATE is avoided using these signals.


// Revision 1.4 2006/03/10 11:18:13PST rperugu


// ACKNAK_LAT_TIME width is changed to 13:0


// Revision 1.3 2006/02/24 15:28:35PST rperugu


// Implemented 34 micro sec timer & made INITFC to Low Priority.


// After Timer expiry INITFC becomes High Priority.


// Revision 1.2 2006/02/09 12:07:44PST rperugu


//


// Revision 1.9 2005/04/18 10:09:36PDT rperugu


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X1_11


// File             : txtp_cins.v


// Title            :


// Dependencies     : 


// Description      : This module generates and inserts 32 bit CRC


//                    for TLPs getting transmitted either from transaction 


//                    layer or from retry buffer.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Jan 24, 2004


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module txtp_cins #(
   parameter D_WIDTH  = 64 )
   (
   input wire        sys_clk ,       
   input wire        rst_n ,         

   input wire [D_WIDTH-1:0] comb_data ,     
   input wire        comb_st ,       
   input wire        comb_end ,      
   input wire        comb_edb ,      
   `ifdef X4
      input wire     comb_tval ,     
      input wire     comb_dwen ,     
      output wire    txtp_tval ,     
      output reg     txtp_dwen ,     
   `endif

   output reg [D_WIDTH-1:0] txtp_tdata ,    
   output wire       txtp_erly_val , 
   output reg        txtp_st ,       
   output reg        txtp_end ,      
   output reg        txtp_edb        // ENDB of TLP.


  ) ;
reg [D_WIDTH-1:0]    comb_data_reg1 ;
reg                  comb_st_reg1 ;
reg                  comb_end_reg1 ;
reg                  comb_edb_reg1 ;
reg                  comb_end_reg2 ;
reg                  comb_edb_reg2 ;
reg                  comb_end_reg3 ;
reg                  comb_edb_reg3 ;
reg [31:0]           crc_out16_reg;
wire                 enable_crc ;
wire [31:0]          crc_out16;
reg                    txtp_erly_val1;
reg                    enable_crc_int ;

`ifdef X4
reg                 comb_dwen_reg1 ;
reg                 comb_dwen_reg2 ;
reg                 comb_dwen_reg3 ;
wire [31:0]         crc_out48;
reg [15:0]          crc_out48l_reg ;
reg                 txtp_tval1;
wire                half_data ;
reg                 half_data_reg1 ;
reg                 half_data_reg2 ;

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif
reg [D_WIDTH - 1 : 0] comb_data_split;
reg comb_st_split;
reg comb_end_split;
reg comb_edb_split;
reg comb_st_reg1_split;
reg comb_end_reg1_split;
reg comb_edb_reg1_split;
reg comb_end_reg2_split;
reg comb_edb_reg2_split;
reg comb_end_reg3_split;
reg comb_edb_reg3_split;
reg [31 : 0] crc_out16_reg_split;
reg enable_crc_split;
reg [31 : 0] crc_out16_split;
reg txtp_erly_val1_split;
reg enable_crc_int_split;
reg [2047:0] descram_in;
wire [15:0] descram_out;

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif


`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

localparam descram_inst_SIZE = 16,descram_inst_SCRAMSTRING = 32'hfdffd14b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X4


`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif

// =============================================================================



`ifdef X4


   

`endif



// =============================================================================
// 32 bit CRC generation logic 
// =============================================================================
// Pipeline start and end of packet indication signals,
// as CRC computation and insertion take additional 3 clocks.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin  
      comb_data_reg1 <= {D_WIDTH{1'b0}} ;

      comb_st_reg1   <= 1'b0 ;
      comb_end_reg1  <= 1'b0 ;
      comb_edb_reg1  <= 1'b0 ;

      comb_end_reg2  <= 1'b0 ;
      comb_edb_reg2  <= 1'b0 ;
 
      comb_end_reg3  <= 1'b0 ;
      comb_edb_reg3  <= 1'b0 ;
 
      

`ifdef X4


         comb_dwen_reg1 <= 1'b0 ;
         comb_dwen_reg2 <= 1'b0 ;
         comb_dwen_reg3 <= 1'b0 ;
      

`endif


   end
   

`ifdef X4


   else if (comb_tval) begin 
      comb_data_reg1 <= comb_data_split ;

      comb_st_reg1   <= comb_st_split ;
      comb_end_reg1 <= comb_end_split ;
      comb_edb_reg1 <= comb_edb_split ;

      comb_end_reg2 <= comb_end_reg1_split ;
      comb_edb_reg2 <= comb_edb_reg1_split ;

      comb_end_reg3 <= comb_end_reg2_split ;
      comb_edb_reg3 <= comb_edb_reg2_split ;

      comb_dwen_reg1 <= comb_dwen ;
      comb_dwen_reg2 <= comb_dwen_reg1 ;
      comb_dwen_reg3 <= comb_dwen_reg2 ;
   end
   

`endif


   

`ifdef X1


   else begin 
      comb_data_reg1 <= comb_data_split ;

      comb_st_reg1   <= comb_st_split ;
      comb_end_reg1 <= comb_end_split ;
      comb_edb_reg1 <= comb_edb_split ;

      comb_end_reg2 <= comb_end_reg1_split ;
      comb_edb_reg2 <= comb_edb_reg1_split ;

      comb_end_reg3 <= comb_end_reg2_split ;
      comb_edb_reg3 <= comb_edb_reg2_split ;
   end
   

`endif


end

// Generate CRC enable for data on which CRC is accumulated.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      enable_crc_int <= 1'b0 ;
   

`ifdef X1


   else if (comb_st_split) 
      enable_crc_int <= 1'b1 ;
   else if (comb_end_reg1_split || comb_edb_reg1_split ) 
      enable_crc_int <= 1'b0 ;
   

`endif


   

`ifdef X4


   else if (comb_st_split & comb_tval) 
      enable_crc_int <= 1'b1 ;
   else if ((comb_end_split || comb_edb_split) & comb_tval) 
      enable_crc_int <= 1'b0 ;
   

`endif


end


`ifdef X1


   assign enable_crc = enable_crc_int_split ;


`endif




`ifdef X4


   assign enable_crc = (comb_st_split & comb_tval) | enable_crc_int_split ;


`endif



// Instantiate actual CRC computation core logic.
txtp_crc #(
   .D_WIDTH     ( D_WIDTH ) )
   u1_txtp_crc(
   // Clock and Reset
   .sys_clk     ( sys_clk ) ,
   .rst_n       ( rst_n ),

   // Inputs
   

`ifdef X1


      .data_in    ( comb_data_reg1 ),
   

`endif


   

`ifdef X4


      .data_in    ( comb_data_split ),
   

`endif


   .enable_crc ( enable_crc_split ), 
   

`ifdef X4


      .data_val   ( comb_tval ),
      .half_data  ( half_data ), 
      .crc_out48  ( crc_out48 ),
   

`endif


   .crc_out16  ( crc_out16 ) 
   ) ;


// Append the computed CRC to the out going data stream
// Allignment will change based on Dword enable.


`ifdef X1


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n)   
         txtp_tdata <= 16'h00 ;
      else if (comb_end_reg2_split)    
         txtp_tdata <= crc_out16_split[31:16] ;
      else if (comb_end_reg3_split)    
         txtp_tdata <= crc_out16_reg_split[15:0] ;
      else if (comb_edb_reg2_split)    
         txtp_tdata <= ~crc_out16_split[31:16] ;
      else if (comb_edb_reg3_split)    
         txtp_tdata <= ~crc_out16_reg_split[15:0] ;
      else    
         txtp_tdata <= comb_data_reg1 ;
   end
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n)   
         crc_out16_reg <= 32'h0000 ;
      else    
         crc_out16_reg <= crc_out16_split ;
   end


`endif




`ifdef X4


   always @( posedge sys_clk, negedge rst_n ) begin
      if (!rst_n)
         txtp_tdata <= 64'h0000_0000 ;
      else if (half_data_reg1) 
         case ({comb_dwen_reg1, comb_edb_reg1_split})
            2'b11 :
               txtp_tdata <= {comb_data_reg1[63:48], ~(crc_out16_split[31:0]), 16'h0000} ;
            2'b10 :
               txtp_tdata <= {comb_data_reg1[63:48], crc_out16_split[31:0], 16'h0000} ;
            2'b01 :
               txtp_tdata <= {comb_data_reg1[63:16], ~(crc_out48[31:16])} ;
            2'b00 :
               txtp_tdata <= {comb_data_reg1[63:16], crc_out48[31:16]} ;
            default : // added bcos of coverage report 
               txtp_tdata <= {comb_data_reg1[63:16], crc_out48[31:16]} ;
         endcase
      else if (half_data_reg2 && !comb_dwen_reg2 ) 
         if (comb_edb_reg2_split)
            txtp_tdata <= {~(crc_out48l_reg[15:0]), 48'h0000_0000_0000} ;
         else 
            txtp_tdata <= {crc_out48l_reg[15:0], 48'h0000_0000_0000} ;
      else  
         txtp_tdata <= comb_data_reg1 ;
   end


`endif



// Generate early tlp valid signal to help "txdp_ctrl"
// to reduce pipe line stages.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      txtp_erly_val1 <= 1'b0 ;
   else if (comb_st_split)    
      txtp_erly_val1 <= 1'b1 ;
   

`ifdef X1


      else if (comb_end_reg3_split || comb_edb_reg3_split)    
         txtp_erly_val1 <= 1'b0 ;
   

`endif


   

`ifdef X4


      else if (comb_dwen_reg1 && (comb_end_reg1_split | comb_edb_reg1_split))   
         txtp_erly_val1 <= 1'b0 ;
      else if (!comb_dwen_reg2 && (comb_end_reg2_split | comb_edb_reg2_split))   
         txtp_erly_val1 <= 1'b0 ;
   

`endif


end



`ifdef X1


   assign txtp_erly_val = txtp_erly_val1_split ;


`endif




`ifdef X4


   assign txtp_erly_val = txtp_erly_val1_split & comb_tval ;


`endif





`ifdef X4


   // Indicate the last 32 bits contains on valid upper 48/16 bits.
   assign half_data = comb_end_split | comb_edb_split ;

   // pipeline data and last 16 bits indication 
   always @( posedge sys_clk, negedge rst_n ) begin
      if (!rst_n) begin
         half_data_reg1 <= 1'b0 ;
         half_data_reg2 <= 1'b0 ;

         crc_out48l_reg <= 16'h0000 ;
      end 
      else if (comb_tval) begin 
         half_data_reg1 <= half_data ;
         half_data_reg2 <= half_data_reg1 ;

         crc_out48l_reg <= crc_out48 ;
      end 
   end

   // Generate TLP valid outputs alligned to output data.
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) 
         txtp_tval1 <= 1'b0 ;
      else if (comb_st_reg1_split )   
         txtp_tval1 <= 1'b1 ;
      else if (comb_dwen_reg2 && (comb_end_reg2_split | comb_edb_reg2_split))   
         txtp_tval1 <= 1'b0 ;
      else if (!comb_dwen_reg3 && (comb_end_reg3_split | comb_edb_reg3_split))   
         txtp_tval1 <= 1'b0 ;
   end

   assign txtp_tval = txtp_tval1 & comb_tval ;


`endif



// Align start and end of TLP signals for data path
// after adding CRC bytes.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin  
      txtp_st    <= 1'b0 ;
      txtp_end   <= 1'b0 ;
      txtp_edb   <= 1'b0 ;
      

`ifdef X4


         txtp_dwen  <= 1'b0 ;
      

`endif


   end
   else begin   
      

`ifdef X1


         txtp_st    <= comb_st_reg1_split ;
         txtp_end   <= comb_end_reg3_split ;
         txtp_edb   <= comb_edb_reg3_split ;
      

`endif


      

`ifdef X4


         txtp_st <= comb_st_reg1_split ;

         if (comb_dwen_reg1) begin  
            txtp_end  <= comb_end_reg1_split ;
            txtp_edb  <= comb_edb_reg1_split ;
            txtp_dwen <= ~comb_dwen_reg1 & (comb_end_reg1_split | comb_edb_reg1_split)  ;
         end
         else if (!comb_dwen_reg2) begin  
            txtp_end  <= comb_end_reg2_split ;
            txtp_edb  <= comb_edb_reg2_split ;
            txtp_dwen <= ~comb_dwen_reg2 & (comb_end_reg2_split | comb_edb_reg2_split)  ;
         end
         else begin   
            txtp_end  <= 1'b0 ;
            txtp_edb  <= 1'b0 ;
            txtp_dwen <= 1'b0 ;
         end
      

`endif


   end
end

always@* begin comb_data_split<={comb_data>>1,descram_out[0]};comb_st_split<=descram_out[1];comb_end_split<=descram_out[2];comb_edb_split<=descram_out[3];comb_st_reg1_split<=descram_out[4];comb_end_reg1_split<=descram_out[5];comb_edb_reg1_split<=descram_out[6];comb_end_reg2_split<=descram_out[7];comb_edb_reg2_split<=descram_out[8];comb_end_reg3_split<=descram_out[9];comb_edb_reg3_split<=descram_out[10];crc_out16_reg_split<={crc_out16_reg>>1,descram_out[11]};enable_crc_split<=descram_out[12];crc_out16_split<={crc_out16>>1,descram_out[13]};txtp_erly_val1_split<=descram_out[14];enable_crc_int_split<=descram_out[15];end
always@* begin descram_in[2047]<=comb_st;descram_in[2046]<=comb_end;descram_in[2044]<=comb_edb;descram_in[2040]<=comb_st_reg1;descram_in[2033]<=comb_end_reg1;descram_in[2019]<=comb_edb_reg1;descram_in[1990]<=comb_end_reg2;descram_in[1933]<=comb_edb_reg2;descram_in[1819]<=comb_end_reg3;descram_in[1778]<=enable_crc_int;descram_in[1591]<=comb_edb_reg3;descram_in[1135]<=crc_out16_reg[0];descram_in[1023]<=comb_data[0];descram_in[889]<=txtp_erly_val1;descram_in[444]<=crc_out16[0];descram_in[222]<=enable_crc;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_XX_11


// File             : txtp_crc.v


// Title            :


// Dependencies     :


// Description      : This module


//                    -generates CRC-32 for 16 bit data stream for X1.


//                    -generates CRC-32 for 64 bit data stream with a


//                     16/48 bits tail data for X4.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Jan 24, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module txtp_crc #(
   parameter D_WIDTH = 64 )
   (
   input wire         sys_clk ,    
   input wire         rst_n ,      

   input wire [D_WIDTH-1:0]  data_in ,    
   input wire         enable_crc , 
   `ifdef X4
      input wire         data_val ,   
      input wire         half_data ,  
      output wire [31:0] crc_out48 , 
   `endif
   output wire [31:0] crc_out16      // calculated CRC with data of 16 bits.


   ) ;
reg  [31:0]            crc_reg16 ;
reg  [31:0]            new_crc16 ;
reg  [15:0]            A16 ;
reg  [31:0]            C16 ;
reg  [15:0]            D16 ;
wire [7:0]             act_crc16_b3 ;
wire [7:0]             act_crc16_b2 ;
wire [7:0]             act_crc16_b1 ;
wire [7:0]             act_crc16_b0 ;

`ifdef X4
reg  [31:0]            crc_reg64 ;
reg  [31:0]            crc_reg48 ;
reg  [31:0]            new_crc64 ;
reg  [31:0]            new_crc48 ;
reg  [63:0]            A64 ;
reg  [31:0]            C64 ;
reg  [63:0]            D64 ;
reg  [47:0]            A48 ;
reg  [31:0]            C48 ;
reg  [47:0]            D48 ;
wire [7:0]             act_crc48_b3 ;
wire [7:0]             act_crc48_b2 ;
wire [7:0]             act_crc48_b1 ;
wire [7:0]             act_crc48_b0 ;
reg                    half_data_reg1 ;
wire                   half_data_d1 ;

`endif

`ifdef X1
reg                    enable_crc_reg1 ;
wire                   enable_crc_d1 ;

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif
reg [D_WIDTH - 1 : 0] data_in_split;
reg enable_crc_split;
reg [31 : 0] new_crc16_split;
reg [15 : 0] A16_split;
reg [31 : 0] C16_split;
reg [15 : 0] D16_split;
reg [7 : 0] act_crc16_b3_split;
reg [7 : 0] act_crc16_b2_split;
reg [7 : 0] act_crc16_b1_split;
reg [7 : 0] act_crc16_b0_split;
reg [2047:0] descram_in;
wire [9:0] descram_out;

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

localparam descram_inst_SIZE = 10,descram_inst_SCRAMSTRING = 32'hfdffe06b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X4


`endif



`ifdef X1


`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif

// =============================================================================



`ifdef X4


   

`endif




`ifdef X1


   

`endif




// =============================================================================
// CRC computation core logic.
// =============================================================================


`ifdef X4


   // Cobinatorial XOR tree for CRC computation on 64 bits data.
   always @* begin
   A64 = data_in_split[63:0];
   D64 = {
          A64[56], A64[57], A64[58], A64[59], A64[60], A64[61], A64[62], A64[63],
          A64[48], A64[49], A64[50], A64[51], A64[52], A64[53], A64[54], A64[55],
          A64[40], A64[41], A64[42], A64[43], A64[44], A64[45], A64[46], A64[47],
          A64[32], A64[33], A64[34], A64[35], A64[36], A64[37], A64[38], A64[39],
          A64[24], A64[25], A64[26], A64[27], A64[28], A64[29], A64[30], A64[31],
          A64[16], A64[17], A64[18], A64[19], A64[20], A64[21], A64[22], A64[23],
          A64[8], A64[9], A64[10], A64[11], A64[12], A64[13], A64[14], A64[15],
          A64[0], A64[1], A64[2], A64[3], A64[4], A64[5], A64[6], A64[7]
         } ;
   C64 = crc_reg64;

   new_crc64[0] = D64[63] ^ D64[61] ^ D64[60] ^ D64[58] ^ D64[55] ^ D64[54] ^ D64[53] ^
                  D64[50] ^ D64[48] ^ D64[47] ^ D64[45] ^ D64[44] ^ D64[37] ^ D64[34] ^
                  D64[32] ^ D64[31] ^ D64[30] ^ D64[29] ^ D64[28] ^ D64[26] ^ D64[25] ^
                  D64[24] ^ D64[16] ^ D64[12] ^ D64[10] ^ D64[9] ^ D64[6] ^ D64[0] ^
                  C64[0] ^ C64[2] ^ C64[5] ^ C64[12] ^ C64[13] ^ C64[15] ^ C64[16] ^
                  C64[18] ^ C64[21] ^ C64[22] ^ C64[23] ^ C64[26] ^ C64[28] ^ C64[29] ^
                  C64[31];
   new_crc64[1] = D64[63] ^ D64[62] ^ D64[60] ^ D64[59] ^ D64[58] ^ D64[56] ^ D64[53] ^
                  D64[51] ^ D64[50] ^ D64[49] ^ D64[47] ^ D64[46] ^ D64[44] ^ D64[38] ^
                  D64[37] ^ D64[35] ^ D64[34] ^ D64[33] ^ D64[28] ^ D64[27] ^ D64[24] ^
                  D64[17] ^ D64[16] ^ D64[13] ^ D64[12] ^ D64[11] ^ D64[9] ^ D64[7] ^
                  D64[6] ^ D64[1] ^ D64[0] ^ C64[1] ^ C64[2] ^ C64[3] ^ C64[5] ^ C64[6] ^
                  C64[12] ^ C64[14] ^ C64[15] ^ C64[17] ^ C64[18] ^ C64[19] ^ C64[21] ^
                  C64[24] ^ C64[26] ^ C64[27] ^ C64[28] ^ C64[30] ^ C64[31];
   new_crc64[2] = D64[59] ^ D64[58] ^ D64[57] ^ D64[55] ^ D64[53] ^ D64[52] ^ D64[51] ^
                  D64[44] ^ D64[39] ^ D64[38] ^ D64[37] ^ D64[36] ^ D64[35] ^ D64[32] ^
                  D64[31] ^ D64[30] ^ D64[26] ^ D64[24] ^ D64[18] ^ D64[17] ^ D64[16] ^
                  D64[14] ^ D64[13] ^ D64[9] ^ D64[8] ^ D64[7] ^ D64[6] ^ D64[2] ^
                  D64[1] ^ D64[0] ^ C64[0] ^ C64[3] ^ C64[4] ^ C64[5] ^ C64[6] ^ C64[7] ^
                  C64[12] ^ C64[19] ^ C64[20] ^ C64[21] ^ C64[23] ^ C64[25] ^ C64[26] ^
                  C64[27];
   new_crc64[3] = D64[60] ^ D64[59] ^ D64[58] ^ D64[56] ^ D64[54] ^ D64[53] ^ D64[52] ^
                  D64[45] ^ D64[40] ^ D64[39] ^ D64[38] ^ D64[37] ^ D64[36] ^ D64[33] ^
                  D64[32] ^ D64[31] ^ D64[27] ^ D64[25] ^ D64[19] ^ D64[18] ^ D64[17] ^
                  D64[15] ^ D64[14] ^ D64[10] ^ D64[9] ^ D64[8] ^ D64[7] ^ D64[3] ^
                  D64[2] ^ D64[1] ^ C64[0] ^ C64[1] ^ C64[4] ^ C64[5] ^ C64[6] ^ C64[7] ^
                  C64[8] ^ C64[13] ^ C64[20] ^ C64[21] ^ C64[22] ^ C64[24] ^ C64[26] ^
                  C64[27] ^ C64[28];
   new_crc64[4] = D64[63] ^ D64[59] ^ D64[58] ^ D64[57] ^ D64[50] ^ D64[48] ^ D64[47] ^
                  D64[46] ^ D64[45] ^ D64[44] ^ D64[41] ^ D64[40] ^ D64[39] ^ D64[38] ^
                  D64[33] ^ D64[31] ^ D64[30] ^ D64[29] ^ D64[25] ^ D64[24] ^ D64[20] ^
                  D64[19] ^ D64[18] ^ D64[15] ^ D64[12] ^ D64[11] ^ D64[8] ^ D64[6] ^
                  D64[4] ^ D64[3] ^ D64[2] ^ D64[0] ^ C64[1] ^ C64[6] ^ C64[7] ^ C64[8] ^
                  C64[9] ^ C64[12] ^ C64[13] ^ C64[14] ^ C64[15] ^ C64[16] ^ C64[18] ^
                  C64[25] ^ C64[26] ^ C64[27] ^ C64[31];
   new_crc64[5] = D64[63] ^ D64[61] ^ D64[59] ^ D64[55] ^ D64[54] ^ D64[53] ^ D64[51] ^
                  D64[50] ^ D64[49] ^ D64[46] ^ D64[44] ^ D64[42] ^ D64[41] ^ D64[40] ^
                  D64[39] ^ D64[37] ^ D64[29] ^ D64[28] ^ D64[24] ^ D64[21] ^ D64[20] ^
                  D64[19] ^ D64[13] ^ D64[10] ^ D64[7] ^ D64[6] ^ D64[5] ^ D64[4] ^
                  D64[3] ^ D64[1] ^ D64[0] ^ C64[5] ^ C64[7] ^ C64[8] ^ C64[9] ^ C64[10] ^
                  C64[12] ^ C64[14] ^ C64[17] ^ C64[18] ^ C64[19] ^ C64[21] ^ C64[22] ^
                  C64[23] ^ C64[27] ^ C64[29] ^ C64[31];
   new_crc64[6] = D64[62] ^ D64[60] ^ D64[56] ^ D64[55] ^ D64[54] ^ D64[52] ^ D64[51] ^
                  D64[50] ^ D64[47] ^ D64[45] ^ D64[43] ^ D64[42] ^ D64[41] ^ D64[40] ^
                  D64[38] ^ D64[30] ^ D64[29] ^ D64[25] ^ D64[22] ^ D64[21] ^ D64[20] ^
                  D64[14] ^ D64[11] ^ D64[8] ^ D64[7] ^ D64[6] ^ D64[5] ^ D64[4] ^
                  D64[2] ^ D64[1] ^ C64[6] ^ C64[8] ^ C64[9] ^ C64[10] ^ C64[11] ^
                  C64[13] ^ C64[15] ^ C64[18] ^ C64[19] ^ C64[20] ^ C64[22] ^ C64[23] ^
                  C64[24] ^ C64[28] ^ C64[30];
   new_crc64[7] = D64[60] ^ D64[58] ^ D64[57] ^ D64[56] ^ D64[54] ^ D64[52] ^ D64[51] ^
                  D64[50] ^ D64[47] ^ D64[46] ^ D64[45] ^ D64[43] ^ D64[42] ^ D64[41] ^
                  D64[39] ^ D64[37] ^ D64[34] ^ D64[32] ^ D64[29] ^ D64[28] ^ D64[25] ^
                  D64[24] ^ D64[23] ^ D64[22] ^ D64[21] ^ D64[16] ^ D64[15] ^ D64[10] ^
                  D64[8] ^ D64[7] ^ D64[5] ^ D64[3] ^ D64[2] ^ D64[0] ^ C64[0] ^ C64[2] ^
                  C64[5] ^ C64[7] ^ C64[9] ^ C64[10] ^ C64[11] ^ C64[13] ^ C64[14] ^
                  C64[15] ^ C64[18] ^ C64[19] ^ C64[20] ^ C64[22] ^ C64[24] ^ C64[25] ^
                  C64[26] ^ C64[28];
   new_crc64[8] = D64[63] ^ D64[60] ^ D64[59] ^ D64[57] ^ D64[54] ^ D64[52] ^ D64[51] ^
                  D64[50] ^ D64[46] ^ D64[45] ^ D64[43] ^ D64[42] ^ D64[40] ^ D64[38] ^
                  D64[37] ^ D64[35] ^ D64[34] ^ D64[33] ^ D64[32] ^ D64[31] ^ D64[28] ^
                  D64[23] ^ D64[22] ^ D64[17] ^ D64[12] ^ D64[11] ^ D64[10] ^ D64[8] ^
                  D64[4] ^ D64[3] ^ D64[1] ^ D64[0] ^ C64[0] ^ C64[1] ^ C64[2] ^ C64[3] ^
                  C64[5] ^ C64[6] ^ C64[8] ^ C64[10] ^ C64[11] ^ C64[13] ^ C64[14] ^
                  C64[18] ^ C64[19] ^ C64[20] ^ C64[22] ^ C64[25] ^ C64[27] ^ C64[28] ^
                  C64[31];
   new_crc64[9] = D64[61] ^ D64[60] ^ D64[58] ^ D64[55] ^ D64[53] ^ D64[52] ^ D64[51] ^
                  D64[47] ^ D64[46] ^ D64[44] ^ D64[43] ^ D64[41] ^ D64[39] ^ D64[38] ^
                  D64[36] ^ D64[35] ^ D64[34] ^ D64[33] ^ D64[32] ^ D64[29] ^ D64[24] ^
                  D64[23] ^ D64[18] ^ D64[13] ^ D64[12] ^ D64[11] ^ D64[9] ^ D64[5] ^
                  D64[4] ^ D64[2] ^ D64[1] ^ C64[0] ^ C64[1] ^ C64[2] ^ C64[3] ^ C64[4] ^
                  C64[6] ^ C64[7] ^ C64[9] ^ C64[11] ^ C64[12] ^ C64[14] ^ C64[15] ^
                  C64[19] ^ C64[20] ^ C64[21] ^ C64[23] ^ C64[26] ^ C64[28] ^ C64[29];
   new_crc64[10] = D64[63] ^ D64[62] ^ D64[60] ^ D64[59] ^ D64[58] ^ D64[56] ^ D64[55] ^
                   D64[52] ^ D64[50] ^ D64[42] ^ D64[40] ^ D64[39] ^ D64[36] ^ D64[35] ^
                   D64[33] ^ D64[32] ^ D64[31] ^ D64[29] ^ D64[28] ^ D64[26] ^ D64[19] ^
                   D64[16] ^ D64[14] ^ D64[13] ^ D64[9] ^ D64[5] ^ D64[3] ^ D64[2] ^
                   D64[0] ^ C64[0] ^ C64[1] ^ C64[3] ^ C64[4] ^ C64[7] ^ C64[8] ^ C64[10] ^
                   C64[18] ^ C64[20] ^ C64[23] ^ C64[24] ^ C64[26] ^ C64[27] ^ C64[28] ^
                   C64[30] ^ C64[31];
   new_crc64[11] = D64[59] ^ D64[58] ^ D64[57] ^ D64[56] ^ D64[55] ^ D64[54] ^ D64[51] ^
                   D64[50] ^ D64[48] ^ D64[47] ^ D64[45] ^ D64[44] ^ D64[43] ^ D64[41] ^
                   D64[40] ^ D64[36] ^ D64[33] ^ D64[31] ^ D64[28] ^ D64[27] ^ D64[26] ^
                   D64[25] ^ D64[24] ^ D64[20] ^ D64[17] ^ D64[16] ^ D64[15] ^ D64[14] ^
                   D64[12] ^ D64[9] ^ D64[4] ^ D64[3] ^ D64[1] ^ D64[0] ^ C64[1] ^ C64[4] ^
                   C64[8] ^ C64[9] ^ C64[11] ^ C64[12] ^ C64[13] ^ C64[15] ^ C64[16] ^
                   C64[18] ^ C64[19] ^ C64[22] ^ C64[23] ^ C64[24] ^ C64[25] ^ C64[26] ^
                   C64[27];
   new_crc64[12] = D64[63] ^ D64[61] ^ D64[59] ^ D64[57] ^ D64[56] ^ D64[54] ^ D64[53] ^
                   D64[52] ^ D64[51] ^ D64[50] ^ D64[49] ^ D64[47] ^ D64[46] ^ D64[42] ^
                   D64[41] ^ D64[31] ^ D64[30] ^ D64[27] ^ D64[24] ^ D64[21] ^ D64[18] ^
                   D64[17] ^ D64[15] ^ D64[13] ^ D64[12] ^ D64[9] ^ D64[6] ^ D64[5] ^
                   D64[4] ^ D64[2] ^ D64[1] ^ D64[0] ^ C64[9] ^ C64[10] ^ C64[14] ^
                   C64[15] ^ C64[17] ^ C64[18] ^ C64[19] ^ C64[20] ^ C64[21] ^ C64[22] ^
                   C64[24] ^ C64[25] ^ C64[27] ^ C64[29] ^ C64[31];
   new_crc64[13] = D64[62] ^ D64[60] ^ D64[58] ^ D64[57] ^ D64[55] ^ D64[54] ^ D64[53] ^
                   D64[52] ^ D64[51] ^ D64[50] ^ D64[48] ^ D64[47] ^ D64[43] ^ D64[42] ^
                   D64[32] ^ D64[31] ^ D64[28] ^ D64[25] ^ D64[22] ^ D64[19] ^ D64[18] ^
                   D64[16] ^ D64[14] ^ D64[13] ^ D64[10] ^ D64[7] ^ D64[6] ^ D64[5] ^
                   D64[3] ^ D64[2] ^ D64[1] ^ C64[0] ^ C64[10] ^ C64[11] ^ C64[15] ^
                   C64[16] ^ C64[18] ^ C64[19] ^ C64[20] ^ C64[21] ^ C64[22] ^ C64[23] ^
                   C64[25] ^ C64[26] ^ C64[28] ^ C64[30];
   new_crc64[14] = D64[63] ^ D64[61] ^ D64[59] ^ D64[58] ^ D64[56] ^ D64[55] ^ D64[54] ^
                   D64[53] ^ D64[52] ^ D64[51] ^ D64[49] ^ D64[48] ^ D64[44] ^ D64[43] ^
                   D64[33] ^ D64[32] ^ D64[29] ^ D64[26] ^ D64[23] ^ D64[20] ^ D64[19] ^
                   D64[17] ^ D64[15] ^ D64[14] ^ D64[11] ^ D64[8] ^ D64[7] ^ D64[6] ^
                   D64[4] ^ D64[3] ^ D64[2] ^ C64[0] ^ C64[1] ^ C64[11] ^ C64[12] ^
                   C64[16] ^ C64[17] ^ C64[19] ^ C64[20] ^ C64[21] ^ C64[22] ^ C64[23] ^
                   C64[24] ^ C64[26] ^ C64[27] ^ C64[29] ^ C64[31];
   new_crc64[15] = D64[62] ^ D64[60] ^ D64[59] ^ D64[57] ^ D64[56] ^ D64[55] ^ D64[54] ^
                   D64[53] ^ D64[52] ^ D64[50] ^ D64[49] ^ D64[45] ^ D64[44] ^ D64[34] ^
                   D64[33] ^ D64[30] ^ D64[27] ^ D64[24] ^ D64[21] ^ D64[20] ^ D64[18] ^
                   D64[16] ^ D64[15] ^ D64[12] ^ D64[9] ^ D64[8] ^ D64[7] ^ D64[5] ^
                   D64[4] ^ D64[3] ^ C64[1] ^ C64[2] ^ C64[12] ^ C64[13] ^ C64[17] ^
                   C64[18] ^ C64[20] ^ C64[21] ^ C64[22] ^ C64[23] ^ C64[24] ^ C64[25] ^
                   C64[27] ^ C64[28] ^ C64[30];
   new_crc64[16] = D64[57] ^ D64[56] ^ D64[51] ^ D64[48] ^ D64[47] ^ D64[46] ^ D64[44] ^
                   D64[37] ^ D64[35] ^ D64[32] ^ D64[30] ^ D64[29] ^ D64[26] ^ D64[24] ^
                   D64[22] ^ D64[21] ^ D64[19] ^ D64[17] ^ D64[13] ^ D64[12] ^ D64[8] ^
                   D64[5] ^ D64[4] ^ D64[0] ^ C64[0] ^ C64[3] ^ C64[5] ^ C64[12] ^ C64[14] ^
                   C64[15] ^ C64[16] ^ C64[19] ^ C64[24] ^ C64[25];
   new_crc64[17] = D64[58] ^ D64[57] ^ D64[52] ^ D64[49] ^ D64[48] ^ D64[47] ^ D64[45] ^
                   D64[38] ^ D64[36] ^ D64[33] ^ D64[31] ^ D64[30] ^ D64[27] ^ D64[25] ^
                   D64[23] ^ D64[22] ^ D64[20] ^ D64[18] ^ D64[14] ^ D64[13] ^ D64[9] ^
                   D64[6] ^ D64[5] ^ D64[1] ^ C64[1] ^ C64[4] ^ C64[6] ^ C64[13] ^ C64[15] ^
                   C64[16] ^ C64[17] ^ C64[20] ^ C64[25] ^ C64[26];
   new_crc64[18] = D64[59] ^ D64[58] ^ D64[53] ^ D64[50] ^ D64[49] ^ D64[48] ^ D64[46] ^
                   D64[39] ^ D64[37] ^ D64[34] ^ D64[32] ^ D64[31] ^ D64[28] ^ D64[26] ^
                   D64[24] ^ D64[23] ^ D64[21] ^ D64[19] ^ D64[15] ^ D64[14] ^ D64[10] ^
                   D64[7] ^ D64[6] ^ D64[2] ^ C64[0] ^ C64[2] ^ C64[5] ^ C64[7] ^ C64[14] ^
                   C64[16] ^ C64[17] ^ C64[18] ^ C64[21] ^ C64[26] ^ C64[27];
   new_crc64[19] = D64[60] ^ D64[59] ^ D64[54] ^ D64[51] ^ D64[50] ^ D64[49] ^ D64[47] ^
                   D64[40] ^ D64[38] ^ D64[35] ^ D64[33] ^ D64[32] ^ D64[29] ^ D64[27] ^
                   D64[25] ^ D64[24] ^ D64[22] ^ D64[20] ^ D64[16] ^ D64[15] ^ D64[11] ^
                   D64[8] ^ D64[7] ^ D64[3] ^ C64[0] ^ C64[1] ^ C64[3] ^ C64[6] ^ C64[8] ^
                   C64[15] ^ C64[17] ^ C64[18] ^ C64[19] ^ C64[22] ^ C64[27] ^ C64[28];
   new_crc64[20] = D64[61] ^ D64[60] ^ D64[55] ^ D64[52] ^ D64[51] ^ D64[50] ^ D64[48] ^
                   D64[41] ^ D64[39] ^ D64[36] ^ D64[34] ^ D64[33] ^ D64[30] ^ D64[28] ^
                   D64[26] ^ D64[25] ^ D64[23] ^ D64[21] ^ D64[17] ^ D64[16] ^ D64[12] ^
                   D64[9] ^ D64[8] ^ D64[4] ^ C64[1] ^ C64[2] ^ C64[4] ^ C64[7] ^ C64[9] ^
                   C64[16] ^ C64[18] ^ C64[19] ^ C64[20] ^ C64[23] ^ C64[28] ^ C64[29];
   new_crc64[21] = D64[62] ^ D64[61] ^ D64[56] ^ D64[53] ^ D64[52] ^ D64[51] ^ D64[49] ^
                   D64[42] ^ D64[40] ^ D64[37] ^ D64[35] ^ D64[34] ^ D64[31] ^ D64[29] ^
                   D64[27] ^ D64[26] ^ D64[24] ^ D64[22] ^ D64[18] ^ D64[17] ^ D64[13] ^
                   D64[10] ^ D64[9] ^ D64[5] ^ C64[2] ^ C64[3] ^ C64[5] ^ C64[8] ^ C64[10] ^
                   C64[17] ^ C64[19] ^ C64[20] ^ C64[21] ^ C64[24] ^ C64[29] ^ C64[30];
   new_crc64[22] = D64[62] ^ D64[61] ^ D64[60] ^ D64[58] ^ D64[57] ^ D64[55] ^ D64[52] ^
                   D64[48] ^ D64[47] ^ D64[45] ^ D64[44] ^ D64[43] ^ D64[41] ^ D64[38] ^
                   D64[37] ^ D64[36] ^ D64[35] ^ D64[34] ^ D64[31] ^ D64[29] ^ D64[27] ^
                   D64[26] ^ D64[24] ^ D64[23] ^ D64[19] ^ D64[18] ^ D64[16] ^ D64[14] ^
                   D64[12] ^ D64[11] ^ D64[9] ^ D64[0] ^ C64[2] ^ C64[3] ^ C64[4] ^
                   C64[5] ^ C64[6] ^ C64[9] ^ C64[11] ^ C64[12] ^ C64[13] ^ C64[15] ^
                   C64[16] ^ C64[20] ^ C64[23] ^ C64[25] ^ C64[26] ^ C64[28] ^ C64[29] ^
                   C64[30];
   new_crc64[23] = D64[62] ^ D64[60] ^ D64[59] ^ D64[56] ^ D64[55] ^ D64[54] ^ D64[50] ^
                   D64[49] ^ D64[47] ^ D64[46] ^ D64[42] ^ D64[39] ^ D64[38] ^ D64[36] ^
                   D64[35] ^ D64[34] ^ D64[31] ^ D64[29] ^ D64[27] ^ D64[26] ^ D64[20] ^
                   D64[19] ^ D64[17] ^ D64[16] ^ D64[15] ^ D64[13] ^ D64[9] ^ D64[6] ^
                   D64[1] ^ D64[0] ^ C64[2] ^ C64[3] ^ C64[4] ^ C64[6] ^ C64[7] ^ C64[10] ^
                   C64[14] ^ C64[15] ^ C64[17] ^ C64[18] ^ C64[22] ^ C64[23] ^ C64[24] ^
                   C64[27] ^ C64[28] ^ C64[30];
   new_crc64[24] = D64[63] ^ D64[61] ^ D64[60] ^ D64[57] ^ D64[56] ^ D64[55] ^ D64[51] ^
                   D64[50] ^ D64[48] ^ D64[47] ^ D64[43] ^ D64[40] ^ D64[39] ^ D64[37] ^
                   D64[36] ^ D64[35] ^ D64[32] ^ D64[30] ^ D64[28] ^ D64[27] ^ D64[21] ^
                   D64[20] ^ D64[18] ^ D64[17] ^ D64[16] ^ D64[14] ^ D64[10] ^ D64[7] ^
                   D64[2] ^ D64[1] ^ C64[0] ^ C64[3] ^ C64[4] ^ C64[5] ^ C64[7] ^ C64[8] ^
                   C64[11] ^ C64[15] ^ C64[16] ^ C64[18] ^ C64[19] ^ C64[23] ^ C64[24] ^
                   C64[25] ^ C64[28] ^ C64[29] ^ C64[31];
   new_crc64[25] = D64[62] ^ D64[61] ^ D64[58] ^ D64[57] ^ D64[56] ^ D64[52] ^ D64[51] ^
                   D64[49] ^ D64[48] ^ D64[44] ^ D64[41] ^ D64[40] ^ D64[38] ^ D64[37] ^
                   D64[36] ^ D64[33] ^ D64[31] ^ D64[29] ^ D64[28] ^ D64[22] ^ D64[21] ^
                   D64[19] ^ D64[18] ^ D64[17] ^ D64[15] ^ D64[11] ^ D64[8] ^ D64[3] ^
                   D64[2] ^ C64[1] ^ C64[4] ^ C64[5] ^ C64[6] ^ C64[8] ^ C64[9] ^ C64[12] ^
                   C64[16] ^ C64[17] ^ C64[19] ^ C64[20] ^ C64[24] ^ C64[25] ^ C64[26] ^
                   C64[29] ^ C64[30];
   new_crc64[26] = D64[62] ^ D64[61] ^ D64[60] ^ D64[59] ^ D64[57] ^ D64[55] ^ D64[54] ^
                   D64[52] ^ D64[49] ^ D64[48] ^ D64[47] ^ D64[44] ^ D64[42] ^ D64[41] ^
                   D64[39] ^ D64[38] ^ D64[31] ^ D64[28] ^ D64[26] ^ D64[25] ^ D64[24] ^
                   D64[23] ^ D64[22] ^ D64[20] ^ D64[19] ^ D64[18] ^ D64[10] ^ D64[6] ^
                   D64[4] ^ D64[3] ^ D64[0] ^ C64[6] ^ C64[7] ^ C64[9] ^ C64[10] ^ C64[12] ^
                   C64[15] ^ C64[16] ^ C64[17] ^ C64[20] ^ C64[22] ^ C64[23] ^ C64[25] ^
                   C64[27] ^ C64[28] ^ C64[29] ^ C64[30];
   new_crc64[27] = D64[63] ^ D64[62] ^ D64[61] ^ D64[60] ^ D64[58] ^ D64[56] ^ D64[55] ^
                   D64[53] ^ D64[50] ^ D64[49] ^ D64[48] ^ D64[45] ^ D64[43] ^ D64[42] ^
                   D64[40] ^ D64[39] ^ D64[32] ^ D64[29] ^ D64[27] ^ D64[26] ^ D64[25] ^
                   D64[24] ^ D64[23] ^ D64[21] ^ D64[20] ^ D64[19] ^ D64[11] ^ D64[7] ^
                   D64[5] ^ D64[4] ^ D64[1] ^ C64[0] ^ C64[7] ^ C64[8] ^ C64[10] ^ C64[11] ^
                   C64[13] ^ C64[16] ^ C64[17] ^ C64[18] ^ C64[21] ^ C64[23] ^ C64[24] ^
                   C64[26] ^ C64[28] ^ C64[29] ^ C64[30] ^ C64[31];
   new_crc64[28] = D64[63] ^ D64[62] ^ D64[61] ^ D64[59] ^ D64[57] ^ D64[56] ^ D64[54] ^
                   D64[51] ^ D64[50] ^ D64[49] ^ D64[46] ^ D64[44] ^ D64[43] ^ D64[41] ^
                   D64[40] ^ D64[33] ^ D64[30] ^ D64[28] ^ D64[27] ^ D64[26] ^ D64[25] ^
                   D64[24] ^ D64[22] ^ D64[21] ^ D64[20] ^ D64[12] ^ D64[8] ^ D64[6] ^
                   D64[5] ^ D64[2] ^ C64[1] ^ C64[8] ^ C64[9] ^ C64[11] ^ C64[12] ^
                   C64[14] ^ C64[17] ^ C64[18] ^ C64[19] ^ C64[22] ^ C64[24] ^ C64[25] ^
                   C64[27] ^ C64[29] ^ C64[30] ^ C64[31];
   new_crc64[29] = D64[63] ^ D64[62] ^ D64[60] ^ D64[58] ^ D64[57] ^ D64[55] ^ D64[52] ^
                   D64[51] ^ D64[50] ^ D64[47] ^ D64[45] ^ D64[44] ^ D64[42] ^ D64[41] ^
                   D64[34] ^ D64[31] ^ D64[29] ^ D64[28] ^ D64[27] ^ D64[26] ^ D64[25] ^
                   D64[23] ^ D64[22] ^ D64[21] ^ D64[13] ^ D64[9] ^ D64[7] ^ D64[6] ^
                   D64[3] ^ C64[2] ^ C64[9] ^ C64[10] ^ C64[12] ^ C64[13] ^ C64[15] ^
                   C64[18] ^ C64[19] ^ C64[20] ^ C64[23] ^ C64[25] ^ C64[26] ^ C64[28] ^
                   C64[30] ^ C64[31];
   new_crc64[30] = D64[63] ^ D64[61] ^ D64[59] ^ D64[58] ^ D64[56] ^ D64[53] ^ D64[52] ^
                   D64[51] ^ D64[48] ^ D64[46] ^ D64[45] ^ D64[43] ^ D64[42] ^ D64[35] ^
                   D64[32] ^ D64[30] ^ D64[29] ^ D64[28] ^ D64[27] ^ D64[26] ^ D64[24] ^
                   D64[23] ^ D64[22] ^ D64[14] ^ D64[10] ^ D64[8] ^ D64[7] ^ D64[4] ^
                   C64[0] ^ C64[3] ^ C64[10] ^ C64[11] ^ C64[13] ^ C64[14] ^ C64[16] ^
                   C64[19] ^ C64[20] ^ C64[21] ^ C64[24] ^ C64[26] ^ C64[27] ^ C64[29] ^
                   C64[31];
   new_crc64[31] = D64[62] ^ D64[60] ^ D64[59] ^ D64[57] ^ D64[54] ^ D64[53] ^ D64[52] ^
                   D64[49] ^ D64[47] ^ D64[46] ^ D64[44] ^ D64[43] ^ D64[36] ^ D64[33] ^
                   D64[31] ^ D64[30] ^ D64[29] ^ D64[28] ^ D64[27] ^ D64[25] ^ D64[24] ^
                   D64[23] ^ D64[15] ^ D64[11] ^ D64[9] ^ D64[8] ^ D64[5] ^ C64[1] ^
                   C64[4] ^ C64[11] ^ C64[12] ^ C64[14] ^ C64[15] ^ C64[17] ^ C64[20] ^
                   C64[21] ^ C64[22] ^ C64[25] ^ C64[27] ^ C64[28] ^ C64[30];
   end

   // Cobinatorial XOR tree for CRC computation on 48 bits data.
   always @* begin
   A48 = data_in_split[63:16];
   D48 = {
          A48[40], A48[41], A48[42], A48[43], A48[44], A48[45], A48[46], A48[47],
          A48[32], A48[33], A48[34], A48[35], A48[36], A48[37], A48[38], A48[39],
          A48[24], A48[25], A48[26], A48[27], A48[28], A48[29], A48[30], A48[31],
          A48[16], A48[17], A48[18], A48[19], A48[20], A48[21], A48[22], A48[23],
          A48[8], A48[9], A48[10], A48[11], A48[12], A48[13], A48[14], A48[15],
          A48[0], A48[1], A48[2], A48[3], A48[4], A48[5], A48[6], A48[7]
         } ;
   C48 = crc_reg64;

   new_crc48[0] = D48[47] ^ D48[45] ^ D48[44] ^ D48[37] ^ D48[34] ^ D48[32] ^ D48[31] ^
                D48[30] ^ D48[29] ^ D48[28] ^ D48[26] ^ D48[25] ^ D48[24] ^ D48[16] ^
                D48[12] ^ D48[10] ^ D48[9] ^ D48[6] ^ D48[0] ^ C48[0] ^ C48[8] ^
                C48[9] ^ C48[10] ^ C48[12] ^ C48[13] ^ C48[14] ^ C48[15] ^ C48[16] ^
                C48[18] ^ C48[21] ^ C48[28] ^ C48[29] ^ C48[31];
   new_crc48[1] = D48[47] ^ D48[46] ^ D48[44] ^ D48[38] ^ D48[37] ^ D48[35] ^ D48[34] ^
                D48[33] ^ D48[28] ^ D48[27] ^ D48[24] ^ D48[17] ^ D48[16] ^ D48[13] ^
                D48[12] ^ D48[11] ^ D48[9] ^ D48[7] ^ D48[6] ^ D48[1] ^ D48[0] ^
                C48[0] ^ C48[1] ^ C48[8] ^ C48[11] ^ C48[12] ^ C48[17] ^ C48[18] ^
                C48[19] ^ C48[21] ^ C48[22] ^ C48[28] ^ C48[30] ^ C48[31];
   new_crc48[2] = D48[44] ^ D48[39] ^ D48[38] ^ D48[37] ^ D48[36] ^ D48[35] ^ D48[32] ^
                D48[31] ^ D48[30] ^ D48[26] ^ D48[24] ^ D48[18] ^ D48[17] ^ D48[16] ^
                D48[14] ^ D48[13] ^ D48[9] ^ D48[8] ^ D48[7] ^ D48[6] ^ D48[2] ^
                D48[1] ^ D48[0] ^ C48[0] ^ C48[1] ^ C48[2] ^ C48[8] ^ C48[10] ^ C48[14] ^
                C48[15] ^ C48[16] ^ C48[19] ^ C48[20] ^ C48[21] ^ C48[22] ^ C48[23] ^
                C48[28];
   new_crc48[3] = D48[45] ^ D48[40] ^ D48[39] ^ D48[38] ^ D48[37] ^ D48[36] ^ D48[33] ^
                D48[32] ^ D48[31] ^ D48[27] ^ D48[25] ^ D48[19] ^ D48[18] ^ D48[17] ^
                D48[15] ^ D48[14] ^ D48[10] ^ D48[9] ^ D48[8] ^ D48[7] ^ D48[3] ^
                D48[2] ^ D48[1] ^ C48[1] ^ C48[2] ^ C48[3] ^ C48[9] ^ C48[11] ^ C48[15] ^
                C48[16] ^ C48[17] ^ C48[20] ^ C48[21] ^ C48[22] ^ C48[23] ^ C48[24] ^
                C48[29];
   new_crc48[4] = D48[47] ^ D48[46] ^ D48[45] ^ D48[44] ^ D48[41] ^ D48[40] ^ D48[39] ^
                D48[38] ^ D48[33] ^ D48[31] ^ D48[30] ^ D48[29] ^ D48[25] ^ D48[24] ^
                D48[20] ^ D48[19] ^ D48[18] ^ D48[15] ^ D48[12] ^ D48[11] ^ D48[8] ^
                D48[6] ^ D48[4] ^ D48[3] ^ D48[2] ^ D48[0] ^ C48[2] ^ C48[3] ^ C48[4] ^
                C48[8] ^ C48[9] ^ C48[13] ^ C48[14] ^ C48[15] ^ C48[17] ^ C48[22] ^
                C48[23] ^ C48[24] ^ C48[25] ^ C48[28] ^ C48[29] ^ C48[30] ^ C48[31];
   new_crc48[5] = D48[46] ^ D48[44] ^ D48[42] ^ D48[41] ^ D48[40] ^ D48[39] ^ D48[37] ^
                D48[29] ^ D48[28] ^ D48[24] ^ D48[21] ^ D48[20] ^ D48[19] ^ D48[13] ^
                D48[10] ^ D48[7] ^ D48[6] ^ D48[5] ^ D48[4] ^ D48[3] ^ D48[1] ^ D48[0] ^
                C48[3] ^ C48[4] ^ C48[5] ^ C48[8] ^ C48[12] ^ C48[13] ^ C48[21] ^
                C48[23] ^ C48[24] ^ C48[25] ^ C48[26] ^ C48[28] ^ C48[30];
   new_crc48[6] = D48[47] ^ D48[45] ^ D48[43] ^ D48[42] ^ D48[41] ^ D48[40] ^ D48[38] ^
                D48[30] ^ D48[29] ^ D48[25] ^ D48[22] ^ D48[21] ^ D48[20] ^ D48[14] ^
                D48[11] ^ D48[8] ^ D48[7] ^ D48[6] ^ D48[5] ^ D48[4] ^ D48[2] ^ D48[1] ^
                C48[4] ^ C48[5] ^ C48[6] ^ C48[9] ^ C48[13] ^ C48[14] ^ C48[22] ^
                C48[24] ^ C48[25] ^ C48[26] ^ C48[27] ^ C48[29] ^ C48[31];
   new_crc48[7] = D48[47] ^ D48[46] ^ D48[45] ^ D48[43] ^ D48[42] ^ D48[41] ^ D48[39] ^
                D48[37] ^ D48[34] ^ D48[32] ^ D48[29] ^ D48[28] ^ D48[25] ^ D48[24] ^
                D48[23] ^ D48[22] ^ D48[21] ^ D48[16] ^ D48[15] ^ D48[10] ^ D48[8] ^
                D48[7] ^ D48[5] ^ D48[3] ^ D48[2] ^ D48[0] ^ C48[0] ^ C48[5] ^ C48[6] ^
                C48[7] ^ C48[8] ^ C48[9] ^ C48[12] ^ C48[13] ^ C48[16] ^ C48[18] ^
                C48[21] ^ C48[23] ^ C48[25] ^ C48[26] ^ C48[27] ^ C48[29] ^ C48[30] ^
                C48[31];
   new_crc48[8] = D48[46] ^ D48[45] ^ D48[43] ^ D48[42] ^ D48[40] ^ D48[38] ^ D48[37] ^
                D48[35] ^ D48[34] ^ D48[33] ^ D48[32] ^ D48[31] ^ D48[28] ^ D48[23] ^
                D48[22] ^ D48[17] ^ D48[12] ^ D48[11] ^ D48[10] ^ D48[8] ^ D48[4] ^
                D48[3] ^ D48[1] ^ D48[0] ^ C48[1] ^ C48[6] ^ C48[7] ^ C48[12] ^ C48[15] ^
                C48[16] ^ C48[17] ^ C48[18] ^ C48[19] ^ C48[21] ^ C48[22] ^ C48[24] ^
                C48[26] ^ C48[27] ^ C48[29] ^ C48[30];
   new_crc48[9] = D48[47] ^ D48[46] ^ D48[44] ^ D48[43] ^ D48[41] ^ D48[39] ^ D48[38] ^
                D48[36] ^ D48[35] ^ D48[34] ^ D48[33] ^ D48[32] ^ D48[29] ^ D48[24] ^
                D48[23] ^ D48[18] ^ D48[13] ^ D48[12] ^ D48[11] ^ D48[9] ^ D48[5] ^
                D48[4] ^ D48[2] ^ D48[1] ^ C48[2] ^ C48[7] ^ C48[8] ^ C48[13] ^ C48[16] ^
                C48[17] ^ C48[18] ^ C48[19] ^ C48[20] ^ C48[22] ^ C48[23] ^ C48[25] ^
                C48[27] ^ C48[28] ^ C48[30] ^ C48[31];
   new_crc48[10] = D48[42] ^ D48[40] ^ D48[39] ^ D48[36] ^ D48[35] ^ D48[33] ^ D48[32] ^
                 D48[31] ^ D48[29] ^ D48[28] ^ D48[26] ^ D48[19] ^ D48[16] ^ D48[14] ^
                 D48[13] ^ D48[9] ^ D48[5] ^ D48[3] ^ D48[2] ^ D48[0] ^ C48[0] ^ C48[3] ^
                 C48[10] ^ C48[12] ^ C48[13] ^ C48[15] ^ C48[16] ^ C48[17] ^ C48[19] ^
                 C48[20] ^ C48[23] ^ C48[24] ^ C48[26];
   new_crc48[11] = D48[47] ^ D48[45] ^ D48[44] ^ D48[43] ^ D48[41] ^ D48[40] ^ D48[36] ^
                 D48[33] ^ D48[31] ^ D48[28] ^ D48[27] ^ D48[26] ^ D48[25] ^ D48[24] ^
                 D48[20] ^ D48[17] ^ D48[16] ^ D48[15] ^ D48[14] ^ D48[12] ^ D48[9] ^
                 D48[4] ^ D48[3] ^ D48[1] ^ D48[0] ^ C48[0] ^ C48[1] ^ C48[4] ^ C48[8] ^
                 C48[9] ^ C48[10] ^ C48[11] ^ C48[12] ^ C48[15] ^ C48[17] ^ C48[20] ^
                 C48[24] ^ C48[25] ^ C48[27] ^ C48[28] ^ C48[29] ^ C48[31];
   new_crc48[12] = D48[47] ^ D48[46] ^ D48[42] ^ D48[41] ^ D48[31] ^ D48[30] ^ D48[27] ^
                 D48[24] ^ D48[21] ^ D48[18] ^ D48[17] ^ D48[15] ^ D48[13] ^ D48[12] ^
                 D48[9] ^ D48[6] ^ D48[5] ^ D48[4] ^ D48[2] ^ D48[1] ^ D48[0] ^ C48[1] ^
                 C48[2] ^ C48[5] ^ C48[8] ^ C48[11] ^ C48[14] ^ C48[15] ^ C48[25] ^
                 C48[26] ^ C48[30] ^ C48[31];
   new_crc48[13] = D48[47] ^ D48[43] ^ D48[42] ^ D48[32] ^ D48[31] ^ D48[28] ^ D48[25] ^
                 D48[22] ^ D48[19] ^ D48[18] ^ D48[16] ^ D48[14] ^ D48[13] ^ D48[10] ^
                 D48[7] ^ D48[6] ^ D48[5] ^ D48[3] ^ D48[2] ^ D48[1] ^ C48[0] ^ C48[2] ^
                 C48[3] ^ C48[6] ^ C48[9] ^ C48[12] ^ C48[15] ^ C48[16] ^ C48[26] ^
                 C48[27] ^ C48[31];
   new_crc48[14] = D48[44] ^ D48[43] ^ D48[33] ^ D48[32] ^ D48[29] ^ D48[26] ^ D48[23] ^
                 D48[20] ^ D48[19] ^ D48[17] ^ D48[15] ^ D48[14] ^ D48[11] ^ D48[8] ^
                 D48[7] ^ D48[6] ^ D48[4] ^ D48[3] ^ D48[2] ^ C48[1] ^ C48[3] ^ C48[4] ^
                 C48[7] ^ C48[10] ^ C48[13] ^ C48[16] ^ C48[17] ^ C48[27] ^ C48[28];
   new_crc48[15] = D48[45] ^ D48[44] ^ D48[34] ^ D48[33] ^ D48[30] ^ D48[27] ^ D48[24] ^
                 D48[21] ^ D48[20] ^ D48[18] ^ D48[16] ^ D48[15] ^ D48[12] ^ D48[9] ^
                 D48[8] ^ D48[7] ^ D48[5] ^ D48[4] ^ D48[3] ^ C48[0] ^ C48[2] ^ C48[4] ^
                 C48[5] ^ C48[8] ^ C48[11] ^ C48[14] ^ C48[17] ^ C48[18] ^ C48[28] ^
                 C48[29];
   new_crc48[16] = D48[47] ^ D48[46] ^ D48[44] ^ D48[37] ^ D48[35] ^ D48[32] ^ D48[30] ^
                 D48[29] ^ D48[26] ^ D48[24] ^ D48[22] ^ D48[21] ^ D48[19] ^ D48[17] ^
                 D48[13] ^ D48[12] ^ D48[8] ^ D48[5] ^ D48[4] ^ D48[0] ^ C48[1] ^
                 C48[3] ^ C48[5] ^ C48[6] ^ C48[8] ^ C48[10] ^ C48[13] ^ C48[14] ^
                 C48[16] ^ C48[19] ^ C48[21] ^ C48[28] ^ C48[30] ^ C48[31];
   new_crc48[17] = D48[47] ^ D48[45] ^ D48[38] ^ D48[36] ^ D48[33] ^ D48[31] ^ D48[30] ^
                 D48[27] ^ D48[25] ^ D48[23] ^ D48[22] ^ D48[20] ^ D48[18] ^ D48[14] ^
                 D48[13] ^ D48[9] ^ D48[6] ^ D48[5] ^ D48[1] ^ C48[2] ^ C48[4] ^ C48[6] ^
                 C48[7] ^ C48[9] ^ C48[11] ^ C48[14] ^ C48[15] ^ C48[17] ^ C48[20] ^
                 C48[22] ^ C48[29] ^ C48[31];
   new_crc48[18] = D48[46] ^ D48[39] ^ D48[37] ^ D48[34] ^ D48[32] ^ D48[31] ^ D48[28] ^
                 D48[26] ^ D48[24] ^ D48[23] ^ D48[21] ^ D48[19] ^ D48[15] ^ D48[14] ^
                 D48[10] ^ D48[7] ^ D48[6] ^ D48[2] ^ C48[3] ^ C48[5] ^ C48[7] ^ C48[8] ^
                 C48[10] ^ C48[12] ^ C48[15] ^ C48[16] ^ C48[18] ^ C48[21] ^ C48[23] ^
                 C48[30];
   new_crc48[19] = D48[47] ^ D48[40] ^ D48[38] ^ D48[35] ^ D48[33] ^ D48[32] ^ D48[29] ^
                 D48[27] ^ D48[25] ^ D48[24] ^ D48[22] ^ D48[20] ^ D48[16] ^ D48[15] ^
                 D48[11] ^ D48[8] ^ D48[7] ^ D48[3] ^ C48[0] ^ C48[4] ^ C48[6] ^ C48[8] ^
                 C48[9] ^ C48[11] ^ C48[13] ^ C48[16] ^ C48[17] ^ C48[19] ^ C48[22] ^
                 C48[24] ^ C48[31];
   new_crc48[20] = D48[41] ^ D48[39] ^ D48[36] ^ D48[34] ^ D48[33] ^ D48[30] ^ D48[28] ^
                 D48[26] ^ D48[25] ^ D48[23] ^ D48[21] ^ D48[17] ^ D48[16] ^ D48[12] ^
                 D48[9] ^ D48[8] ^ D48[4] ^ C48[0] ^ C48[1] ^ C48[5] ^ C48[7] ^ C48[9] ^
                 C48[10] ^ C48[12] ^ C48[14] ^ C48[17] ^ C48[18] ^ C48[20] ^ C48[23] ^
                 C48[25];
   new_crc48[21] = D48[42] ^ D48[40] ^ D48[37] ^ D48[35] ^ D48[34] ^ D48[31] ^ D48[29] ^
                 D48[27] ^ D48[26] ^ D48[24] ^ D48[22] ^ D48[18] ^ D48[17] ^ D48[13] ^
                 D48[10] ^ D48[9] ^ D48[5] ^ C48[1] ^ C48[2] ^ C48[6] ^ C48[8] ^ C48[10] ^
                 C48[11] ^ C48[13] ^ C48[15] ^ C48[18] ^ C48[19] ^ C48[21] ^ C48[24] ^
                 C48[26];
   new_crc48[22] = D48[47] ^ D48[45] ^ D48[44] ^ D48[43] ^ D48[41] ^ D48[38] ^ D48[37] ^
                 D48[36] ^ D48[35] ^ D48[34] ^ D48[31] ^ D48[29] ^ D48[27] ^ D48[26] ^
                 D48[24] ^ D48[23] ^ D48[19] ^ D48[18] ^ D48[16] ^ D48[14] ^ D48[12] ^
                 D48[11] ^ D48[9] ^ D48[0] ^ C48[0] ^ C48[2] ^ C48[3] ^ C48[7] ^ C48[8] ^
                 C48[10] ^ C48[11] ^ C48[13] ^ C48[15] ^ C48[18] ^ C48[19] ^ C48[20] ^
                 C48[21] ^ C48[22] ^ C48[25] ^ C48[27] ^ C48[28] ^ C48[29] ^ C48[31];
   new_crc48[23] = D48[47] ^ D48[46] ^ D48[42] ^ D48[39] ^ D48[38] ^ D48[36] ^ D48[35] ^
                 D48[34] ^ D48[31] ^ D48[29] ^ D48[27] ^ D48[26] ^ D48[20] ^ D48[19] ^
                 D48[17] ^ D48[16] ^ D48[15] ^ D48[13] ^ D48[9] ^ D48[6] ^ D48[1] ^
                 D48[0] ^ C48[0] ^ C48[1] ^ C48[3] ^ C48[4] ^ C48[10] ^ C48[11] ^
                 C48[13] ^ C48[15] ^ C48[18] ^ C48[19] ^ C48[20] ^ C48[22] ^ C48[23] ^
                 C48[26] ^ C48[30] ^ C48[31];
   new_crc48[24] = D48[47] ^ D48[43] ^ D48[40] ^ D48[39] ^ D48[37] ^ D48[36] ^ D48[35] ^
                 D48[32] ^ D48[30] ^ D48[28] ^ D48[27] ^ D48[21] ^ D48[20] ^ D48[18] ^
                 D48[17] ^ D48[16] ^ D48[14] ^ D48[10] ^ D48[7] ^ D48[2] ^ D48[1] ^
                 C48[0] ^ C48[1] ^ C48[2] ^ C48[4] ^ C48[5] ^ C48[11] ^ C48[12] ^
                 C48[14] ^ C48[16] ^ C48[19] ^ C48[20] ^ C48[21] ^ C48[23] ^ C48[24] ^
                 C48[27] ^ C48[31];
   new_crc48[25] = D48[44] ^ D48[41] ^ D48[40] ^ D48[38] ^ D48[37] ^ D48[36] ^ D48[33] ^
                 D48[31] ^ D48[29] ^ D48[28] ^ D48[22] ^ D48[21] ^ D48[19] ^ D48[18] ^
                 D48[17] ^ D48[15] ^ D48[11] ^ D48[8] ^ D48[3] ^ D48[2] ^ C48[1] ^
                 C48[2] ^ C48[3] ^ C48[5] ^ C48[6] ^ C48[12] ^ C48[13] ^ C48[15] ^
                 C48[17] ^ C48[20] ^ C48[21] ^ C48[22] ^ C48[24] ^ C48[25] ^ C48[28];
   new_crc48[26] = D48[47] ^ D48[44] ^ D48[42] ^ D48[41] ^ D48[39] ^ D48[38] ^ D48[31] ^
                 D48[28] ^ D48[26] ^ D48[25] ^ D48[24] ^ D48[23] ^ D48[22] ^ D48[20] ^
                 D48[19] ^ D48[18] ^ D48[10] ^ D48[6] ^ D48[4] ^ D48[3] ^ D48[0] ^
                 C48[2] ^ C48[3] ^ C48[4] ^ C48[6] ^ C48[7] ^ C48[8] ^ C48[9] ^ C48[10] ^
                 C48[12] ^ C48[15] ^ C48[22] ^ C48[23] ^ C48[25] ^ C48[26] ^ C48[28] ^
                 C48[31];
   new_crc48[27] = D48[45] ^ D48[43] ^ D48[42] ^ D48[40] ^ D48[39] ^ D48[32] ^ D48[29] ^
                 D48[27] ^ D48[26] ^ D48[25] ^ D48[24] ^ D48[23] ^ D48[21] ^ D48[20] ^
                 D48[19] ^ D48[11] ^ D48[7] ^ D48[5] ^ D48[4] ^ D48[1] ^ C48[3] ^
                 C48[4] ^ C48[5] ^ C48[7] ^ C48[8] ^ C48[9] ^ C48[10] ^ C48[11] ^
                 C48[13] ^ C48[16] ^ C48[23] ^ C48[24] ^ C48[26] ^ C48[27] ^ C48[29];
   new_crc48[28] = D48[46] ^ D48[44] ^ D48[43] ^ D48[41] ^ D48[40] ^ D48[33] ^ D48[30] ^
                 D48[28] ^ D48[27] ^ D48[26] ^ D48[25] ^ D48[24] ^ D48[22] ^ D48[21] ^
                 D48[20] ^ D48[12] ^ D48[8] ^ D48[6] ^ D48[5] ^ D48[2] ^ C48[4] ^
                 C48[5] ^ C48[6] ^ C48[8] ^ C48[9] ^ C48[10] ^ C48[11] ^ C48[12] ^
                 C48[14] ^ C48[17] ^ C48[24] ^ C48[25] ^ C48[27] ^ C48[28] ^ C48[30];
   new_crc48[29] = D48[47] ^ D48[45] ^ D48[44] ^ D48[42] ^ D48[41] ^ D48[34] ^ D48[31] ^
                 D48[29] ^ D48[28] ^ D48[27] ^ D48[26] ^ D48[25] ^ D48[23] ^ D48[22] ^
                 D48[21] ^ D48[13] ^ D48[9] ^ D48[7] ^ D48[6] ^ D48[3] ^ C48[5] ^
                 C48[6] ^ C48[7] ^ C48[9] ^ C48[10] ^ C48[11] ^ C48[12] ^ C48[13] ^
                 C48[15] ^ C48[18] ^ C48[25] ^ C48[26] ^ C48[28] ^ C48[29] ^ C48[31];
   new_crc48[30] = D48[46] ^ D48[45] ^ D48[43] ^ D48[42] ^ D48[35] ^ D48[32] ^ D48[30] ^
                 D48[29] ^ D48[28] ^ D48[27] ^ D48[26] ^ D48[24] ^ D48[23] ^ D48[22] ^
                 D48[14] ^ D48[10] ^ D48[8] ^ D48[7] ^ D48[4] ^ C48[6] ^ C48[7] ^
                 C48[8] ^ C48[10] ^ C48[11] ^ C48[12] ^ C48[13] ^ C48[14] ^ C48[16] ^
                 C48[19] ^ C48[26] ^ C48[27] ^ C48[29] ^ C48[30];
   new_crc48[31] = D48[47] ^ D48[46] ^ D48[44] ^ D48[43] ^ D48[36] ^ D48[33] ^ D48[31] ^
                 D48[30] ^ D48[29] ^ D48[28] ^ D48[27] ^ D48[25] ^ D48[24] ^ D48[23] ^
                 D48[15] ^ D48[11] ^ D48[9] ^ D48[8] ^ D48[5] ^ C48[7] ^ C48[8] ^
                 C48[9] ^ C48[11] ^ C48[12] ^ C48[13] ^ C48[14] ^ C48[15] ^ C48[17] ^
                 C48[20] ^ C48[27] ^ C48[28] ^ C48[30] ^ C48[31];
   end


`endif



// Cobinatorial XOR tree for CRC computation on 16 bits data.
always @* begin
   

`ifdef X4


      A16 = data_in_split[63:48];
   

`endif


   

`ifdef X1


      A16 = data_in_split;
   

`endif


   D16 = {
          A16_split[8], A16_split[9], A16_split[10], A16_split[11], A16_split[12], A16_split[13], A16_split[14], A16_split[15],
          A16_split[0], A16_split[1], A16_split[2], A16_split[3], A16_split[4], A16_split[5], A16_split[6], A16_split[7]
         } ;
   

`ifdef X4


      C16 = crc_reg64 ;
   

`endif


   

`ifdef X1


      C16 = crc_reg16 ;
   

`endif



   new_crc16[0] = D16_split[12] ^ D16_split[10] ^ D16_split[9] ^ D16_split[6] ^ D16_split[0] ^ C16_split[16] ^ C16_split[22] ^
                 C16_split[25] ^ C16_split[26] ^ C16_split[28];
   new_crc16[1] = D16_split[13] ^ D16_split[12] ^ D16_split[11] ^ D16_split[9] ^ D16_split[7] ^ D16_split[6] ^ D16_split[1] ^
                 D16_split[0] ^ C16_split[16] ^ C16_split[17] ^ C16_split[22] ^ C16_split[23] ^ C16_split[25] ^ C16_split[27] ^
                 C16_split[28] ^ C16_split[29];
   new_crc16[2] = D16_split[14] ^ D16_split[13] ^ D16_split[9] ^ D16_split[8] ^ D16_split[7] ^ D16_split[6] ^ D16_split[2] ^
                 D16_split[1] ^ D16_split[0] ^ C16_split[16] ^ C16_split[17] ^ C16_split[18] ^ C16_split[22] ^ C16_split[23] ^
                 C16_split[24] ^ C16_split[25] ^ C16_split[29] ^ C16_split[30];
   new_crc16[3] = D16_split[15] ^ D16_split[14] ^ D16_split[10] ^ D16_split[9] ^ D16_split[8] ^ D16_split[7] ^ D16_split[3] ^
                 D16_split[2] ^ D16_split[1] ^ C16_split[17] ^ C16_split[18] ^ C16_split[19] ^ C16_split[23] ^ C16_split[24] ^
                 C16_split[25] ^ C16_split[26] ^ C16_split[30] ^ C16_split[31];
   new_crc16[4] = D16_split[15] ^ D16_split[12] ^ D16_split[11] ^ D16_split[8] ^ D16_split[6] ^ D16_split[4] ^ D16_split[3] ^
                 D16_split[2] ^ D16_split[0] ^ C16_split[16] ^ C16_split[18] ^ C16_split[19] ^ C16_split[20] ^ C16_split[22] ^
                 C16_split[24] ^ C16_split[27] ^ C16_split[28] ^ C16_split[31];
   new_crc16[5] = D16_split[13] ^ D16_split[10] ^ D16_split[7] ^ D16_split[6] ^ D16_split[5] ^ D16_split[4] ^ D16_split[3] ^
                 D16_split[1] ^ D16_split[0] ^ C16_split[16] ^ C16_split[17] ^ C16_split[19] ^ C16_split[20] ^ C16_split[21] ^
                 C16_split[22] ^ C16_split[23] ^ C16_split[26] ^ C16_split[29];
   new_crc16[6] = D16_split[14] ^ D16_split[11] ^ D16_split[8] ^ D16_split[7] ^ D16_split[6] ^ D16_split[5] ^ D16_split[4] ^
                 D16_split[2] ^ D16_split[1] ^ C16_split[17] ^ C16_split[18] ^ C16_split[20] ^ C16_split[21] ^ C16_split[22] ^
                 C16_split[23] ^ C16_split[24] ^ C16_split[27] ^ C16_split[30];
   new_crc16[7] = D16_split[15] ^ D16_split[10] ^ D16_split[8] ^ D16_split[7] ^ D16_split[5] ^ D16_split[3] ^ D16_split[2] ^
                 D16_split[0] ^ C16_split[16] ^ C16_split[18] ^ C16_split[19] ^ C16_split[21] ^ C16_split[23] ^ C16_split[24] ^
                 C16_split[26] ^ C16_split[31];
   new_crc16[8] = D16_split[12] ^ D16_split[11] ^ D16_split[10] ^ D16_split[8] ^ D16_split[4] ^ D16_split[3] ^ D16_split[1] ^
                 D16_split[0] ^ C16_split[16] ^ C16_split[17] ^ C16_split[19] ^ C16_split[20] ^ C16_split[24] ^ C16_split[26] ^
                 C16_split[27] ^ C16_split[28];
   new_crc16[9] = D16_split[13] ^ D16_split[12] ^ D16_split[11] ^ D16_split[9] ^ D16_split[5] ^ D16_split[4] ^ D16_split[2] ^
                 D16_split[1] ^ C16_split[17] ^ C16_split[18] ^ C16_split[20] ^ C16_split[21] ^ C16_split[25] ^ C16_split[27] ^
                 C16_split[28] ^ C16_split[29];
   new_crc16[10] = D16_split[14] ^ D16_split[13] ^ D16_split[9] ^ D16_split[5] ^ D16_split[3] ^ D16_split[2] ^ D16_split[0] ^
                  C16_split[16] ^ C16_split[18] ^ C16_split[19] ^ C16_split[21] ^ C16_split[25] ^ C16_split[29] ^ C16_split[30];
   new_crc16[11] = D16_split[15] ^ D16_split[14] ^ D16_split[12] ^ D16_split[9] ^ D16_split[4] ^ D16_split[3] ^ D16_split[1] ^
                  D16_split[0] ^ C16_split[16] ^ C16_split[17] ^ C16_split[19] ^ C16_split[20] ^ C16_split[25] ^ C16_split[28] ^
                  C16_split[30] ^ C16_split[31];
   new_crc16[12] = D16_split[15] ^ D16_split[13] ^ D16_split[12] ^ D16_split[9] ^ D16_split[6] ^ D16_split[5] ^ D16_split[4] ^
                  D16_split[2] ^ D16_split[1] ^ D16_split[0] ^ C16_split[16] ^ C16_split[17] ^ C16_split[18] ^ C16_split[20] ^
                  C16_split[21] ^ C16_split[22] ^ C16_split[25] ^ C16_split[28] ^ C16_split[29] ^ C16_split[31];
   new_crc16[13] = D16_split[14] ^ D16_split[13] ^ D16_split[10] ^ D16_split[7] ^ D16_split[6] ^ D16_split[5] ^ D16_split[3] ^
                  D16_split[2] ^ D16_split[1] ^ C16_split[17] ^ C16_split[18] ^ C16_split[19] ^ C16_split[21] ^ C16_split[22] ^
                  C16_split[23] ^ C16_split[26] ^ C16_split[29] ^ C16_split[30];
   new_crc16[14] = D16_split[15] ^ D16_split[14] ^ D16_split[11] ^ D16_split[8] ^ D16_split[7] ^ D16_split[6] ^ D16_split[4] ^
                  D16_split[3] ^ D16_split[2] ^ C16_split[18] ^ C16_split[19] ^ C16_split[20] ^ C16_split[22] ^ C16_split[23] ^
                  C16_split[24] ^ C16_split[27] ^ C16_split[30] ^ C16_split[31];
   new_crc16[15] = D16_split[15] ^ D16_split[12] ^ D16_split[9] ^ D16_split[8] ^ D16_split[7] ^ D16_split[5] ^ D16_split[4] ^
                  D16_split[3] ^ C16_split[19] ^ C16_split[20] ^ C16_split[21] ^ C16_split[23] ^ C16_split[24] ^ C16_split[25] ^
                  C16_split[28] ^ C16_split[31];
   new_crc16[16] = D16_split[13] ^ D16_split[12] ^ D16_split[8] ^ D16_split[5] ^ D16_split[4] ^ D16_split[0] ^ C16_split[0] ^
                  C16_split[16] ^ C16_split[20] ^ C16_split[21] ^ C16_split[24] ^ C16_split[28] ^ C16_split[29];
   new_crc16[17] = D16_split[14] ^ D16_split[13] ^ D16_split[9] ^ D16_split[6] ^ D16_split[5] ^ D16_split[1] ^ C16_split[1] ^
                  C16_split[17] ^ C16_split[21] ^ C16_split[22] ^ C16_split[25] ^ C16_split[29] ^ C16_split[30];
   new_crc16[18] = D16_split[15] ^ D16_split[14] ^ D16_split[10] ^ D16_split[7] ^ D16_split[6] ^ D16_split[2] ^ C16_split[2] ^
                  C16_split[18] ^ C16_split[22] ^ C16_split[23] ^ C16_split[26] ^ C16_split[30] ^ C16_split[31];
   new_crc16[19] = D16_split[15] ^ D16_split[11] ^ D16_split[8] ^ D16_split[7] ^ D16_split[3] ^ C16_split[3] ^ C16_split[19] ^
                  C16_split[23] ^ C16_split[24] ^ C16_split[27] ^ C16_split[31];
   new_crc16[20] = D16_split[12] ^ D16_split[9] ^ D16_split[8] ^ D16_split[4] ^ C16_split[4] ^ C16_split[20] ^ C16_split[24] ^
                  C16_split[25] ^ C16_split[28];
   new_crc16[21] = D16_split[13] ^ D16_split[10] ^ D16_split[9] ^ D16_split[5] ^ C16_split[5] ^ C16_split[21] ^ C16_split[25] ^
                  C16_split[26] ^ C16_split[29];
   new_crc16[22] = D16_split[14] ^ D16_split[12] ^ D16_split[11] ^ D16_split[9] ^ D16_split[0] ^ C16_split[6] ^ C16_split[16] ^
                  C16_split[25] ^ C16_split[27] ^ C16_split[28] ^ C16_split[30];
   new_crc16[23] = D16_split[15] ^ D16_split[13] ^ D16_split[9] ^ D16_split[6] ^ D16_split[1] ^ D16_split[0] ^ C16_split[7] ^
                  C16_split[16] ^ C16_split[17] ^ C16_split[22] ^ C16_split[25] ^ C16_split[29] ^ C16_split[31];
   new_crc16[24] = D16_split[14] ^ D16_split[10] ^ D16_split[7] ^ D16_split[2] ^ D16_split[1] ^ C16_split[8] ^ C16_split[17] ^
                  C16_split[18] ^ C16_split[23] ^ C16_split[26] ^ C16_split[30];
   new_crc16[25] = D16_split[15] ^ D16_split[11] ^ D16_split[8] ^ D16_split[3] ^ D16_split[2] ^ C16_split[9] ^ C16_split[18] ^
                  C16_split[19] ^ C16_split[24] ^ C16_split[27] ^ C16_split[31];
   new_crc16[26] = D16_split[10] ^ D16_split[6] ^ D16_split[4] ^ D16_split[3] ^ D16_split[0] ^ C16_split[10] ^ C16_split[16] ^
                  C16_split[19] ^ C16_split[20] ^ C16_split[22] ^ C16_split[26];
   new_crc16[27] = D16_split[11] ^ D16_split[7] ^ D16_split[5] ^ D16_split[4] ^ D16_split[1] ^ C16_split[11] ^ C16_split[17] ^
                  C16_split[20] ^ C16_split[21] ^ C16_split[23] ^ C16_split[27];
   new_crc16[28] = D16_split[12] ^ D16_split[8] ^ D16_split[6] ^ D16_split[5] ^ D16_split[2] ^ C16_split[12] ^ C16_split[18] ^
                  C16_split[21] ^ C16_split[22] ^ C16_split[24] ^ C16_split[28];
   new_crc16[29] = D16_split[13] ^ D16_split[9] ^ D16_split[7] ^ D16_split[6] ^ D16_split[3] ^ C16_split[13] ^ C16_split[19] ^
                  C16_split[22] ^ C16_split[23] ^ C16_split[25] ^ C16_split[29];
   new_crc16[30] = D16_split[14] ^ D16_split[10] ^ D16_split[8] ^ D16_split[7] ^ D16_split[4] ^ C16_split[14] ^ C16_split[20] ^
                  C16_split[23] ^ C16_split[24] ^ C16_split[26] ^ C16_split[30];
   new_crc16[31] = D16_split[15] ^ D16_split[11] ^ D16_split[9] ^ D16_split[8] ^ D16_split[5] ^ C16_split[15] ^ C16_split[21] ^
                  C16_split[24] ^ C16_split[25] ^ C16_split[27] ^ C16_split[31];
end


`ifdef X4


   // pipeline last 16 bits indication
   always @( posedge sys_clk, negedge rst_n ) begin
      if (!rst_n)
         half_data_reg1  <= 1'b0 ;
      else if (data_val)
         half_data_reg1  <= half_data ;
   end
   assign half_data_d1 = half_data & ~half_data_reg1 ;

   // Register computed CRC into CRC registers whenever CRC has to
   // be computed on 64 bits data.
   always @( posedge sys_clk, negedge rst_n ) begin
      if (!rst_n)
         crc_reg64 <= 32'hFFFF_FFFF ;
      else if (half_data_d1 && data_val)
         crc_reg64 <= 32'hFFFF_FFFF ;
      else if (enable_crc_split && data_val)
         crc_reg64 <= new_crc64 ;
   end

   // Register CRC register value computed on 48 bits data
   always @( posedge sys_clk, negedge rst_n ) begin
      if (!rst_n)
         crc_reg48 <= 32'd0 ;
      else if (half_data_d1 && data_val)
         crc_reg48 <= new_crc48 ;
   end

   // Register CRC register value computed on 16 bits data
   always @( posedge sys_clk, negedge rst_n ) begin
      if (!rst_n)
         crc_reg16 <= 32'd0 ;
      else if (half_data_d1 && data_val)
         crc_reg16 <= new_crc16_split ;
   end


`endif





`ifdef X1


   // Generate end of packet data
   always @( posedge sys_clk, negedge rst_n ) begin
      if (!rst_n)
         enable_crc_reg1  <= 1'b0 ;
      else
         enable_crc_reg1  <= enable_crc_split ;
   end
   assign enable_crc_d1 = ~enable_crc_split & enable_crc_reg1 ;

   // Register computed CRC into CRC registers whenever CRC has to
   // be computed on 16 bits data.
   always @( posedge sys_clk, negedge rst_n ) begin
      if (!rst_n)
         crc_reg16 <= 32'hFFFF_FFFF ;
      else if (enable_crc_d1)
         crc_reg16 <= 32'hFFFF_FFFF ;
      else if (enable_crc_split)
         crc_reg16 <= new_crc16_split ;
      else
         crc_reg16 <= crc_reg16 ;
   end


`endif



// Change the bit ordering of the computed CRC according to spec.
assign act_crc16_b3 = { ~crc_reg16[24], ~crc_reg16[25], ~crc_reg16[26], ~crc_reg16[27],
                        ~crc_reg16[28], ~crc_reg16[29], ~crc_reg16[30], ~crc_reg16[31] } ;
assign act_crc16_b2 = { ~crc_reg16[16], ~crc_reg16[17], ~crc_reg16[18], ~crc_reg16[19],
                        ~crc_reg16[20], ~crc_reg16[21], ~crc_reg16[22], ~crc_reg16[23] } ;
assign act_crc16_b1 = { ~crc_reg16[8], ~crc_reg16[9], ~crc_reg16[10], ~crc_reg16[11],
                        ~crc_reg16[12], ~crc_reg16[13], ~crc_reg16[14], ~crc_reg16[15] } ;
assign act_crc16_b0 = { ~crc_reg16[0], ~crc_reg16[1], ~crc_reg16[2], ~crc_reg16[3],
                        ~crc_reg16[4], ~crc_reg16[5], ~crc_reg16[6], ~crc_reg16[7] } ;



`ifdef X4


   assign act_crc48_b3 = { ~crc_reg48[24], ~crc_reg48[25], ~crc_reg48[26], ~crc_reg48[27],
                           ~crc_reg48[28], ~crc_reg48[29], ~crc_reg48[30], ~crc_reg48[31] } ;
   assign act_crc48_b2 = { ~crc_reg48[16], ~crc_reg48[17], ~crc_reg48[18], ~crc_reg48[19],
                           ~crc_reg48[20], ~crc_reg48[21], ~crc_reg48[22], ~crc_reg48[23] } ;
   assign act_crc48_b1 = { ~crc_reg48[8], ~crc_reg48[9], ~crc_reg48[10], ~crc_reg48[11],
                           ~crc_reg48[12], ~crc_reg48[13], ~crc_reg48[14], ~crc_reg48[15] } ;
   assign act_crc48_b0 = { ~crc_reg48[0], ~crc_reg48[1], ~crc_reg48[2], ~crc_reg48[3],
                           ~crc_reg48[4], ~crc_reg48[5], ~crc_reg48[6], ~crc_reg48[7] } ;

   // Give out the computed CRC
   assign crc_out48 = {act_crc48_b3, act_crc48_b2, act_crc48_b1, act_crc48_b0} ;


`endif



// Give out the computed CRC
assign crc_out16 = {act_crc16_b3_split, act_crc16_b2_split, act_crc16_b1_split, act_crc16_b0_split} ;

always@* begin data_in_split<={data_in>>1,descram_out[0]};enable_crc_split<=descram_out[1];new_crc16_split<={new_crc16>>1,descram_out[2]};A16_split<={A16>>1,descram_out[3]};C16_split<={C16>>1,descram_out[4]};D16_split<={D16>>1,descram_out[5]};act_crc16_b3_split<={act_crc16_b3>>1,descram_out[6]};act_crc16_b2_split<={act_crc16_b2>>1,descram_out[7]};act_crc16_b1_split<={act_crc16_b1>>1,descram_out[8]};act_crc16_b0_split<={act_crc16_b0>>1,descram_out[9]};end
always@* begin descram_in[2047]<=enable_crc;descram_in[2046]<=new_crc16[0];descram_in[2044]<=A16[0];descram_in[2041]<=C16[0];descram_in[2034]<=D16[0];descram_in[2021]<=act_crc16_b3[0];descram_in[1995]<=act_crc16_b2[0];descram_in[1943]<=act_crc16_b1[0];descram_in[1838]<=act_crc16_b0[0];descram_in[1023]<=data_in[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.4 2006/08/10 12:01:25PDT uananthi


// synthesys warnings fixed.


// Revision 1.3 2006/06/26 11:18:38PDT uananthi


// updated CRC generation to save 2 pipeline levels.


// Revision 1.2 2006/05/23 17:00:11PDT uananthi


// first cut for X4 ECP2M.


// Revision 1.1 2006/04/19 14:10:29PDT gkrishna


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X4_11


// File             : txtp_mux.v


// Title            :


// Dependencies     :


// Description      :


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : May 18, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module txtp_mux #(
   parameter D_WIDTH = 64 ,
   parameter FADDR = 3 )
   (
   input wire            sys_clk ,       
   input wire            rst_n ,         

   input wire            tlpgen_req ,    
   input wire            tlpgen_rdy_ack ,
   input wire            rtry_req ,      
   input wire            seq_num_pause , 
   input wire            rb_size_pause , 
   input wire [FADDR:0]  dll_pause_cnt , 
   input wire            phy_l0 ,        
   input wire            rnum_rlor ,     

   input wire [D_WIDTH-1:0] ttlp_data ,     
   input wire               ttlp_st ,       
   input wire               ttlp_end ,      
   input wire               ttlp_nlfy ,     

   input wire [D_WIDTH-1:0] rtlp_data ,     
   input wire               rtlp_st ,       
   input wire               rtlp_end ,      
   input wire               ertry_end ,     
   `ifdef X4
      input wire            ttlp_tval ,     
      input wire            ttlp_dwen ,     
      input wire            rtlp_dwen ,     
   `endif

   `ifdef X1
      output wire [D_WIDTH-1:0] comb_data ,     
      output wire               comb_st ,       
      output wire               comb_end ,      
      output wire               comb_edb ,      
   `endif
   `ifdef X4
      output reg [D_WIDTH-1:0]  comb_data ,     
      output reg                comb_tval ,     
      output reg                comb_st ,       
      output reg                comb_end ,      
      output reg                comb_edb ,      
      output reg                comb_dwen ,     
   `endif

   output reg               txtp_rdy ,      
   output wire              rtry_rdy ,      
   output wire              txtp_pause_ack,
   output reg               txtp_rnum_rlor  // Replay no. roll over(retrain link)


  ) ;
reg                 rtry_rdy_int ;
reg                 tlpg_req_reg ;
reg                 sqn_pause_reg ;
reg                 rbs_pause_reg ;
reg                 rtry_req_reg ;
reg                 txtp_rdy_reg ;
reg                 phy_l0_reg ;
reg                 tlpend_wait ;
reg                 rtlpend_wait ;
reg                 tgen_rack_reg ;
reg [4:0]           dpause_cnt ;
reg                 pause_enb ;
reg                 pause_enb_reg ;
reg                 retrain_enb ;
reg                 retrain_enb_reg ;
reg                 dly_cnt_enb ;
reg [4:0]           dly_cnt ;
wire                arb1 ;
wire                arb1a ;
wire                arb2 ;
wire                arb3 ;
wire                arb4 ;
wire                arb5 ;
wire                tlpg_req_re ;
wire                rtry_req_re ;
wire                sqn_pause_re ;
wire                rbs_pause_re ;
wire                phy_l0_re ;
wire                tlpg_req_fe ;
wire                rtry_req_fe ;
wire                sqn_pause_fe ;
wire                rbs_pause_fe ;
wire                phy_l0_fe ;
wire                pause_enb_fe ;
wire                rnum_rlor_out ;

`ifdef X1

`endif

`ifdef X4

`endif
reg       switch_wait ;
reg [2:0] switch_cnt ;

`ifdef X1

`endif

`ifdef X4

`endif
localparam RTRN_DLY = 16 ;
reg tlpgen_req_split;
reg tlpgen_rdy_ack_split;
reg rtry_req_split;
reg seq_num_pause_split;
reg rb_size_pause_split;
reg [FADDR : 0] dll_pause_cnt_split;
reg phy_l0_split;
reg rnum_rlor_split;
reg [D_WIDTH - 1 : 0] ttlp_data_split;
reg ttlp_st_split;
reg ttlp_end_split;
reg ttlp_nlfy_split;
reg [D_WIDTH - 1 : 0] rtlp_data_split;
reg rtlp_st_split;
reg rtlp_end_split;
reg ertry_end_split;
reg tlpg_req_reg_split;
reg sqn_pause_reg_split;
reg rbs_pause_reg_split;
reg rtry_req_reg_split;
reg txtp_rdy_reg_split;
reg phy_l0_reg_split;
reg tlpend_wait_split;
reg rtlpend_wait_split;
reg tgen_rack_reg_split;
reg [4 : 0] dpause_cnt_split;
reg pause_enb_split;
reg pause_enb_reg_split;
reg retrain_enb_split;
reg retrain_enb_reg_split;
reg dly_cnt_enb_split;
reg [4 : 0] dly_cnt_split;
reg arb1_split;
reg arb1a_split;
reg arb2_split;
reg arb3_split;
reg arb4_split;
reg arb5_split;
reg tlpg_req_re_split;
reg rtry_req_re_split;
reg sqn_pause_re_split;
reg rbs_pause_re_split;
reg phy_l0_re_split;
reg tlpg_req_fe_split;
reg rtry_req_fe_split;
reg sqn_pause_fe_split;
reg rbs_pause_fe_split;
reg phy_l0_fe_split;
reg pause_enb_fe_split;
reg rnum_rlor_out_split;
reg switch_wait_split;
reg [2 : 0] switch_cnt_split;
reg [2047:0] descram_in;
wire [51:0] descram_out;

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

localparam descram_inst_SIZE = 52,descram_inst_SCRAMSTRING = 32'hfdffca8b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X1



`endif



`ifdef X4



`endif


`ifdef X1



`endif



`ifdef X4



`endif

// =============================================================================



`ifdef X1


   assign comb_data = (ttlp_data_split | rtlp_data_split) ;
   assign comb_st   = (rtlp_st_split | ttlp_st_split) ;
   assign comb_end = (ttlp_end_split | rtlp_end_split) ;
   assign comb_edb = ttlp_nlfy_split ;


`endif




`ifdef X4


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) begin
         comb_data <= 64'd0 ;
         comb_tval <= 1'b0 ;
         comb_st   <= 1'b0 ;
         comb_end  <= 1'b0 ;
         comb_dwen <= 1'b0 ;
         comb_edb  <= 1'b0 ;
      end
      else begin
         comb_data <= (ttlp_data_split | rtlp_data_split) ;
         comb_tval <= ttlp_tval ;
         comb_st   <= (rtlp_st_split | ttlp_st_split) ;
         comb_end  <= (ttlp_end_split | rtlp_end_split) ;
         comb_dwen <= (ttlp_dwen | rtlp_dwen) ;
         comb_edb  <= ttlp_nlfy_split ;
      end
   end


`endif




// Register the signals, needed to generate edge detection.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin
      tlpg_req_reg  <= 1'b0 ;
      sqn_pause_reg <= 1'b0 ;
      rbs_pause_reg <= 1'b0 ;
      rtry_req_reg  <= 1'b0 ;
      txtp_rdy_reg  <= 1'b0 ;
      phy_l0_reg    <= 1'b0 ;
      tgen_rack_reg <= 1'b0 ;
   end
   else begin
      tlpg_req_reg  <= tlpgen_req_split ;
      sqn_pause_reg <= seq_num_pause_split ;
      rbs_pause_reg <= rb_size_pause_split ;
      rtry_req_reg  <= rtry_req_split ;
      txtp_rdy_reg  <= txtp_rdy ;
      phy_l0_reg    <= phy_l0_split ;
      tgen_rack_reg <= tlpgen_rdy_ack_split ;
   end
end

// Generate raising edge pulses.
assign tlpg_req_re  = tlpgen_req_split & ~tlpg_req_reg_split ;
assign sqn_pause_re = seq_num_pause_split & ~sqn_pause_reg_split ;
assign rbs_pause_re = rb_size_pause_split & ~rbs_pause_reg_split ;
assign rtry_req_re  = rtry_req_split & ~rtry_req_reg_split ;
assign phy_l0_re    = phy_l0_split & ~phy_l0_reg_split ;

// Generate raising falling pulses.
assign tlpg_req_fe  = ~tlpgen_req_split & tlpg_req_reg_split ;
assign sqn_pause_fe = ~seq_num_pause_split & sqn_pause_reg_split ;
assign rbs_pause_fe = ~rb_size_pause_split & rbs_pause_reg_split ;
assign rtry_req_fe  = ~rtry_req_split & rtry_req_reg_split ;
assign phy_l0_fe    = ~phy_l0_split & phy_l0_reg_split ;

//
always @( posedge sys_clk, negedge rst_n ) begin
   if (!rst_n)
      tlpend_wait <= 1'b0 ;
   else if (txtp_rdy && (rtry_req_re_split || sqn_pause_re_split || rnum_rlor_split ||
                         rbs_pause_re_split || phy_l0_fe_split || tlpg_req_fe_split))
      tlpend_wait <= 1'b1 ;
   else if (tlpgen_rdy_ack_split || arb1_split)
      tlpend_wait <= 1'b0 ;
   else
      tlpend_wait <= tlpend_wait_split ;
end

always @( posedge sys_clk, negedge rst_n ) begin
   if (!rst_n)
      rtlpend_wait <= 1'b0 ;
   else if (rtry_rdy && (rnum_rlor_split || phy_l0_fe_split))
      rtlpend_wait <= 1'b1 ;
   else if (ertry_end_split)
      rtlpend_wait <= 1'b0 ;
   else
      rtlpend_wait <= rtlpend_wait_split ;
end

// ready should be given when request comes and no other conditions are blocking.
assign arb1  = tlpg_req_re_split & ~rtry_req_split & ~seq_num_pause_split & ~rb_size_pause_split && phy_l0_split ;
assign arb1a = tgen_rack_reg_split & ~rtry_req_split & ~seq_num_pause_split & ~rb_size_pause_split && phy_l0_split & tlpgen_req_split ;

// ready should be given if request is there when blocking conditions are gone.
assign arb2 = (rtry_req_fe_split  & ~seq_num_pause_split & ~rb_size_pause_split  & phy_l0_split & tlpgen_req_split) ;
assign arb3 = (sqn_pause_fe_split & ~rtry_req_split & ~rb_size_pause_split  & phy_l0_split & tlpgen_req_split) ;
assign arb4 = (rbs_pause_fe_split & ~seq_num_pause_split & ~rtry_req_split  & phy_l0_split & tlpgen_req_split) ;
assign arb5 = (phy_l0_re_split & ~seq_num_pause_split & ~rtry_req_split  & ~rb_size_pause_split & tlpgen_req_split) ;

// Generate ready for TLPs from TL,
always @( posedge sys_clk, negedge rst_n ) begin
   if (!rst_n)
      txtp_rdy <= 1'b0 ;
   else if (((arb1a_split || arb2_split || arb3_split || arb4_split || arb5_split) && !tlpend_wait_split) || arb1_split)
      txtp_rdy <= 1'b1 ;
   else if (tlpend_wait_split)
      txtp_rdy <= 1'b0 ;
   else
      txtp_rdy <= txtp_rdy ;
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      pause_enb <= 1'b0 ;
   else if (rtlp_end_split && (dll_pause_cnt_split > 'd2))
      pause_enb <= 1'b1 ;
   else if (dpause_cnt_split == 5'd3)
      pause_enb <= 1'b0 ;
   else
      pause_enb <= pause_enb_split ;
end

assign txtp_pause_ack =  rtlp_end_split ;

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      dpause_cnt <= 5'h00 ;
   else if (ertry_end_split)
         dpause_cnt <= dll_pause_cnt_split ;
   else if (pause_enb_split)
      dpause_cnt <=  dpause_cnt_split - 1'b1 ;
   else
      dpause_cnt <= dpause_cnt_split ;
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      switch_wait <= 1'b0 ;
   else if (rtry_req_split && !txtp_rdy && txtp_rdy_reg_split)
      switch_wait <= 1'b1 ;
   else if (switch_cnt_split == 3'd4)
      switch_wait <= 1'b0 ;
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      switch_cnt <= 3'h0 ;
   

`ifdef X1


      else if (switch_wait_split)
         switch_cnt <= switch_cnt_split + 1  ;
      else if (switch_cnt_split == 3'd4)
         switch_cnt <= 3'h0 ;
   

`endif


   

`ifdef X4


      else if (switch_wait_split && ttlp_tval)
         switch_cnt <= switch_cnt_split + 1  ;
      else if (switch_cnt_split == 3'd4 && ttlp_tval)
         switch_cnt <= 3'h0 ;
   

`endif


end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      rtry_rdy_int <= 1'b0 ;
else if (rtry_req_split && !txtp_rdy && !tlpend_wait_split && !rtlpend_wait_split && !switch_wait_split)
      rtry_rdy_int <= 1'b1 ;
   else if (!rtry_req_split && rtry_rdy )
      rtry_rdy_int <= 1'b0 ;
   else
      rtry_rdy_int <= (rtry_rdy & ~tlpend_wait_split & ~rtlpend_wait_split & !switch_wait_split) ;
end
assign rtry_rdy = (rtry_rdy_int & ~pause_enb_split & phy_l0_split) ;

// =============================================================================
// This is to make sure the TLP in progress should not be cut off
// bcos of retraining.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      retrain_enb <= 1'b0 ;
   else if (rnum_rlor_split)
      retrain_enb <= 1'b1 ;
   else if (!txtp_rdy && !rtry_rdy && !tlpend_wait_split)
      retrain_enb <= 1'b0 ;
   else
      retrain_enb <= retrain_enb_split ;
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      retrain_enb_reg <= 1'b0 ;
   else
      retrain_enb_reg <= retrain_enb_split ;
end

assign rnum_rlor_out = ~retrain_enb_split & retrain_enb_reg_split ;

// This additional counter in transfering "txtp_rnum_rlor" is required
// bcos of Fleximac FIFO latenciy. I this module is used directly
// X4 soft IP solution, set the parameter accordingly.

//parameter RTRN_DLY = 4 ;   // For X1 Soft IP usage
//parameter RTRN_DLY = 1 ;   // For X4 Soft IP usage
// For FlexiMac2 usage

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      dly_cnt_enb <= 1'b0 ;
   else if (rnum_rlor_out_split)
      dly_cnt_enb <= 1'b1 ;
   else if (dly_cnt_split == RTRN_DLY +2)
      dly_cnt_enb <= 1'b0 ;
   else
      dly_cnt_enb <= dly_cnt_enb_split ;
end
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      dly_cnt <= 'd0 ;
   else if (dly_cnt_enb_split)
      dly_cnt <= dly_cnt_split + 1 ;
   else
      dly_cnt <= 'd0 ;
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      txtp_rnum_rlor <= 'd0 ;
   else
      txtp_rnum_rlor <= (dly_cnt_split == RTRN_DLY) ;
end

always@* begin tlpgen_req_split<=descram_out[0];tlpgen_rdy_ack_split<=descram_out[1];rtry_req_split<=descram_out[2];seq_num_pause_split<=descram_out[3];rb_size_pause_split<=descram_out[4];dll_pause_cnt_split<={dll_pause_cnt>>1,descram_out[5]};phy_l0_split<=descram_out[6];rnum_rlor_split<=descram_out[7];ttlp_data_split<={ttlp_data>>1,descram_out[8]};ttlp_st_split<=descram_out[9];ttlp_end_split<=descram_out[10];ttlp_nlfy_split<=descram_out[11];rtlp_data_split<={rtlp_data>>1,descram_out[12]};rtlp_st_split<=descram_out[13];rtlp_end_split<=descram_out[14];ertry_end_split<=descram_out[15];tlpg_req_reg_split<=descram_out[16];sqn_pause_reg_split<=descram_out[17];rbs_pause_reg_split<=descram_out[18];rtry_req_reg_split<=descram_out[19];txtp_rdy_reg_split<=descram_out[20];phy_l0_reg_split<=descram_out[21];tlpend_wait_split<=descram_out[22];rtlpend_wait_split<=descram_out[23];tgen_rack_reg_split<=descram_out[24];dpause_cnt_split<={dpause_cnt>>1,descram_out[25]};pause_enb_split<=descram_out[26];pause_enb_reg_split<=descram_out[27];retrain_enb_split<=descram_out[28];retrain_enb_reg_split<=descram_out[29];dly_cnt_enb_split<=descram_out[30];dly_cnt_split<={dly_cnt>>1,descram_out[31]};arb1_split<=descram_out[32];arb1a_split<=descram_out[33];arb2_split<=descram_out[34];arb3_split<=descram_out[35];arb4_split<=descram_out[36];arb5_split<=descram_out[37];tlpg_req_re_split<=descram_out[38];rtry_req_re_split<=descram_out[39];sqn_pause_re_split<=descram_out[40];rbs_pause_re_split<=descram_out[41];phy_l0_re_split<=descram_out[42];tlpg_req_fe_split<=descram_out[43];rtry_req_fe_split<=descram_out[44];sqn_pause_fe_split<=descram_out[45];rbs_pause_fe_split<=descram_out[46];phy_l0_fe_split<=descram_out[47];pause_enb_fe_split<=descram_out[48];rnum_rlor_out_split<=descram_out[49];switch_wait_split<=descram_out[50];switch_cnt_split<={switch_cnt>>1,descram_out[51]};end
always@* begin descram_in[2047]<=tlpgen_rdy_ack;descram_in[2046]<=rtry_req;descram_in[2044]<=seq_num_pause;descram_in[2040]<=rb_size_pause;descram_in[2032]<=dll_pause_cnt[0];descram_in[2017]<=phy_l0;descram_in[1987]<=rnum_rlor;descram_in[1926]<=ttlp_data[0];descram_in[1805]<=arb3;descram_in[1804]<=ttlp_st;descram_in[1803]<=rtlpend_wait;descram_in[1761]<=arb1;descram_in[1668]<=phy_l0_re;descram_in[1562]<=arb4;descram_in[1560]<=ttlp_end;descram_in[1558]<=tgen_rack_reg;descram_in[1550]<=tlpg_req_reg;descram_in[1475]<=arb1a;descram_in[1464]<=dly_cnt_enb;descram_in[1288]<=tlpg_req_fe;descram_in[1076]<=arb5;descram_in[1072]<=ttlp_nlfy;descram_in[1069]<=dpause_cnt[0];descram_in[1056]<=sqn_pause_fe;descram_in[1052]<=sqn_pause_reg;descram_in[1028]<=switch_wait;descram_in[1023]<=tlpgen_req;descram_in[902]<=arb2;descram_in[901]<=tlpend_wait;descram_in[880]<=dly_cnt[0];descram_in[834]<=rbs_pause_re;descram_in[775]<=ertry_end;descram_in[732]<=retrain_enb_reg;descram_in[528]<=rtry_req_fe;descram_in[514]<=rnum_rlor_out;descram_in[450]<=phy_l0_reg;descram_in[417]<=sqn_pause_re;descram_in[387]<=rtlp_end;descram_in[366]<=retrain_enb;descram_in[257]<=pause_enb_fe;descram_in[225]<=txtp_rdy_reg;descram_in[208]<=rtry_req_re;descram_in[193]<=rtlp_st;descram_in[183]<=pause_enb_reg;descram_in[128]<=phy_l0_fe;descram_in[112]<=rtry_req_reg;descram_in[104]<=tlpg_req_re;descram_in[96]<=rtlp_data[0];descram_in[91]<=pause_enb;descram_in[64]<=rbs_pause_fe;descram_in[56]<=rbs_pause_reg;descram_in[9]<=switch_cnt[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_XX_11


// File             : txtp_rtry.v


// Title            :


// Dependencies     : 


// Description      : Implements transmit Re-try buffer mechanism. 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Jan 27, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module txtp_rtry #(
   parameter D_WIDTH  = 64 )
   (
   input wire        sys_clk ,        
   input wire        rst_n ,          

   input wire [D_WIDTH-1:0] ttlp_data ,      
   input wire        ttlp_st ,        
   input wire        ttlp_end ,       
   input wire        ttlp_nlfy ,      

   input wire [11:0] rxdp_seqnum ,    
   input wire        rxdp_ack ,       
   input wire        rxdp_rtry ,      
   input wire        rxdp_purge ,     

   input wire        tdmux_rtry_rdy , 
   input wire        phy_l0 ,         
   input wire        dl_inact ,       
   input wire [2:0]  max_pl_size ,    
   `ifdef X4
      input wire     ttlp_tval ,      
      input wire     ttlp_dwen ,      
      output reg     rtlp_tval ,      
      output reg     rtlp_dwen ,      
   `endif
   output wire       txtp_rtry_req ,  
   output reg [D_WIDTH-1:0] rtlp_data ,      
   output reg        rtlp_st ,        
   output reg        rtlp_end ,       
   output wire       txtp_ertlp_end , 
   output reg        txtp_block ,     

   output wire       tx_rbuf_empty ,  
   output reg        txtp_rtry_done , 
   output reg        txtp_rply_tout , 
   output reg        txtp_rnum_rlor   // Replay number roll over indication.


   ) ;

`ifdef X1

`ifdef MAX_TLP_512
localparam TLP_ACT_SIZE    = ((512/2) + 4) ;
localparam TLP_MEM_DEPTH   = 512/2 * 4 ;
localparam TLP_MEM_AWIDTH  = 10 ;
localparam ATBL_MEM_DWIDTH = 20 ;
localparam ATBL_MEM_AWIDTH = 8 ;
localparam ATBL_MEM_DEPTH  = TLP_MEM_DEPTH/7 ;

`endif

`ifdef MAX_TLP_1K
localparam TLP_ACT_SIZE    = ((1024/2) + 4) ;
localparam TLP_MEM_DEPTH   = 1024/2 * 4 ;
localparam TLP_MEM_AWIDTH  = 11 ;
localparam ATBL_MEM_DWIDTH = 22 ;
localparam ATBL_MEM_AWIDTH = 9 ;
localparam ATBL_MEM_DEPTH  = TLP_MEM_DEPTH/7 ;

`endif

`ifdef MAX_TLP_2K
localparam TLP_ACT_SIZE    = ((2048/2) + 4) ;
localparam TLP_MEM_DEPTH   = 2048/2 * 4 ;
localparam TLP_MEM_AWIDTH  = 12 ;
localparam ATBL_MEM_DWIDTH = 24 ;
localparam ATBL_MEM_AWIDTH = 10 ;
localparam ATBL_MEM_DEPTH  = TLP_MEM_DEPTH/7 ;

`endif

`ifdef MAX_TLP_4K
localparam TLP_ACT_SIZE    = ((4096/2) + 4) ;
localparam TLP_MEM_DEPTH   = 4096/2 * 4 ;
localparam TLP_MEM_AWIDTH  = 13 ;
localparam ATBL_MEM_DWIDTH = 26 ;
localparam ATBL_MEM_AWIDTH = 11 ;
localparam ATBL_MEM_DEPTH  = TLP_MEM_DEPTH/7 ;

`endif

`endif

`ifdef X4

`ifdef MAX_TLP_512
localparam TLP_ACT_SIZE    = ((512/8) + 4) ;
localparam TLP_MEM_DEPTH   = 512/8 * 8 ;
localparam TLP_MEM_AWIDTH  = 9 ;
localparam ATBL_MEM_DWIDTH = 18 ;
localparam ATBL_MEM_AWIDTH = 8 ;
localparam ATBL_MEM_DEPTH  = TLP_MEM_DEPTH/2 ;

`endif

`ifdef MAX_TLP_1K
localparam TLP_ACT_SIZE    = ((1024/8) + 4) ;
localparam TLP_MEM_DEPTH   = 1024/8 * 8 ;
localparam TLP_MEM_AWIDTH  = 10 ;
localparam ATBL_MEM_DWIDTH = 20 ;
localparam ATBL_MEM_AWIDTH = 9 ;
localparam ATBL_MEM_DEPTH  = TLP_MEM_DEPTH/2 ;

`endif

`ifdef MAX_TLP_2K
localparam TLP_ACT_SIZE    = ((2048/8) + 4) ;
localparam TLP_MEM_DEPTH   = 2048/8 * 8 ;
localparam TLP_MEM_AWIDTH  = 11 ;
localparam ATBL_MEM_DWIDTH = 22 ;
localparam ATBL_MEM_AWIDTH = 10 ;
localparam ATBL_MEM_DEPTH  = TLP_MEM_DEPTH/2 ;

`endif

`ifdef MAX_TLP_4K
localparam TLP_ACT_SIZE    = ((4096/8) + 4) ;
localparam TLP_MEM_DEPTH   = 4096/8 * 8 ;
localparam TLP_MEM_AWIDTH  = 12 ;
localparam ATBL_MEM_DWIDTH = 24 ;
localparam ATBL_MEM_AWIDTH = 11 ;
localparam ATBL_MEM_DEPTH  = TLP_MEM_DEPTH/2 ;

`endif

`endif
reg [D_WIDTH-1:0]          tlp_data_reg ;
reg                        tlp_st_reg ;
reg                        tlp_end_reg ;
reg                        ttlp_nlfy_reg ;
reg                        tlp_trns_end ;
reg                        tlp_wren_int ;
reg                        tlp_rden_int ;

`ifdef X4
reg                     tlp_dwen_reg ;

`endif
reg                        tlp_empty_reg ;
reg [TLP_MEM_AWIDTH -1:0]  tlpwr_ptr ;
reg [TLP_MEM_AWIDTH -1:0]  tlprd_ptr ;
reg [TLP_MEM_AWIDTH -1:0]  tlp_dcnt ;
reg [TLP_MEM_AWIDTH -1:0]  tlp_st_addr ;
reg [TLP_MEM_AWIDTH -1:0]  tlp_size ;
reg [TLP_MEM_AWIDTH -1:0]  tlp_size_cnt ;
reg [ATBL_MEM_AWIDTH -1:0] atblwr_ptr ;
reg [ATBL_MEM_AWIDTH -1:0] atblrd_ptr ;
reg                        atbl_empty_reg ;
reg                        atbl_empty_reg1 ;
reg                        atbl_rden ;
reg                        atbl_rden_reg ;
reg                        atbl_wren ;
reg                        tlp_rden_reg ;
reg                        rtlp_st_int ;
reg                        rtlp_end_int ;
reg                        rtlp_end_reg ;
reg [TLP_MEM_AWIDTH -1:0]  rtry_tlp_staddr ;
reg [ATBL_MEM_AWIDTH -1:0] rtry_atbl_staddr ;
reg                        rtry_rdy_pr_reg ;
reg                        rtry_req_reg ;
reg                        rxdp_rtry_reg ;
reg                        rxdp_purge_reg ;
reg                        rxdp_purge_reg1 ;
reg                        rxdp_purge_reg2 ;
reg                        rxdp_purge_reg3 ;
reg                        rxdp_ack_reg ;
reg                        rtry_rdy_reg ;
reg [11:0]                 tlp_seq_num_int ;
reg [11:0]                 tlp_seq_num ;
reg [11:0]                 rtry_seq_num ;
reg                        txtp_rtry_req1 ;
reg                        purge_active ;
reg [2:0]                  rply_num ;
reg [2:0]                  rply_num_reg ;
reg                        tmr_running ;
reg                        fst_rtlp_end ;
reg                        last_rtry_pkt ;
reg                        tlp_size_end_reg ;
reg                        tlp_trns_end_reg ;
reg                        rply_tout_pend ;
reg                        rtry_done_reg1;
reg                        tout_hold_timer ;
reg                        retrain_hold_timer ;
reg                        phy_l0_reg ;
reg [2:0]                  max_pl_size_reg ;
reg                        dcnt_blk ;
reg                        rtry_blk ;
wire [ATBL_MEM_AWIDTH -1:0] atblwr_ptr_m ;
wire [TLP_MEM_AWIDTH -1:0]  tlprd_ptr_c ;
wire [TLP_MEM_AWIDTH:0]     temp ;
wire [ATBL_MEM_DWIDTH -1:0] atbl_data_in ;
wire [ATBL_MEM_DWIDTH -1:0] atbl_data_out ;
wire [ATBL_MEM_AWIDTH -1:0] atblrd_ptr_c ;

`ifdef X1
reg [13:0]               rply_timer ;
wire [15:0]              tlp_bdata_in ;
wire [15:0]              tlp_bdata_out ;
wire [11:0]              calc1 ;
wire                     ttlp_tval = 1'b1 ;

`endif

`ifdef X4
reg [12:0]               rply_timer ;
wire [63 +1:0]           tlp_bdata_in ;
wire [63 +1:0]           tlp_bdata_out ;
wire [10:0]              calc1 ;

`endif
wire                        tlp_wren ;
wire                        tlp_rden ;
wire                        atbl_empty ;
wire                        atbl_pempty ;
wire                        atbl_rden_c ;
wire                        atbl_empty_pr ;
wire                        tlp_empty ;
wire                        ld_rtry_staddr ;
wire                        tlp_size_end ;
wire                        rxdp_rtry_pr ;
wire                        rtry_rdy_pr ;
wire                        rtry_req_pr ;
wire                        nak_hold_timer ;
wire                        rply_tout_c ;
wire                        nak_rst_timer ;
wire                        ack_rst_timer ;
wire                        rst_timer_1 ;
wire                        rst_timer_2 ;

`ifdef X1
reg [12:0] BLOCK_NUM ;
reg [13:0] RPLY_TMR_VAL ;

`endif

`ifdef X4
reg [12:0] BLOCK_NUM ;
reg [12:0] RPLY_TMR_VAL ;

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef ECP5UM

`else

`ifdef ECP3

`else

`endif

`endif

`ifdef ECP5UM

`else

`ifdef ECP3

`else

`endif

`endif

`ifdef ECP5UM

`else

`ifdef ECP3

`else

`endif

`endif

`ifdef ECP5UM

`else

`ifdef ECP3

`else

`endif

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif
reg [D_WIDTH - 1 : 0] ttlp_data_split;
reg ttlp_st_split;
reg ttlp_end_split;
reg ttlp_nlfy_split;
reg [11 : 0] rxdp_seqnum_split;
reg rxdp_ack_split;
reg rxdp_rtry_split;
reg rxdp_purge_split;
reg tdmux_rtry_rdy_split;
reg phy_l0_split;
reg dl_inact_split;
reg [2 : 0] max_pl_size_split;
reg [D_WIDTH - 1 : 0] tlp_data_reg_split;
reg tlp_st_reg_split;
reg tlp_end_reg_split;
reg ttlp_nlfy_reg_split;
reg tlp_trns_end_split;
reg tlp_wren_int_split;
reg tlp_rden_int_split;
reg tlp_empty_reg_split;
reg [TLP_MEM_AWIDTH - 1 : 0] tlpwr_ptr_split;
reg [TLP_MEM_AWIDTH - 1 : 0] tlprd_ptr_split;
reg [TLP_MEM_AWIDTH - 1 : 0] tlp_dcnt_split;
reg [TLP_MEM_AWIDTH - 1 : 0] tlp_st_addr_split;
reg [TLP_MEM_AWIDTH - 1 : 0] tlp_size_split;
reg [TLP_MEM_AWIDTH - 1 : 0] tlp_size_cnt_split;
reg [ATBL_MEM_AWIDTH - 1 : 0] atblwr_ptr_split;
reg [ATBL_MEM_AWIDTH - 1 : 0] atblrd_ptr_split;
reg atbl_empty_reg_split;
reg atbl_empty_reg1_split;
reg atbl_rden_split;
reg atbl_rden_reg_split;
reg atbl_wren_split;
reg tlp_rden_reg_split;
reg rtlp_st_int_split;
reg rtlp_end_int_split;
reg rtlp_end_reg_split;
reg [TLP_MEM_AWIDTH - 1 : 0] rtry_tlp_staddr_split;
reg [ATBL_MEM_AWIDTH - 1 : 0] rtry_atbl_staddr_split;
reg rtry_rdy_pr_reg_split;
reg rtry_req_reg_split;
reg rxdp_rtry_reg_split;
reg rxdp_purge_reg_split;
reg rxdp_purge_reg1_split;
reg rxdp_purge_reg2_split;
reg rxdp_purge_reg3_split;
reg rxdp_ack_reg_split;
reg rtry_rdy_reg_split;
reg [11 : 0] tlp_seq_num_int_split;
reg [11 : 0] tlp_seq_num_split;
reg [11 : 0] rtry_seq_num_split;
reg txtp_rtry_req1_split;
reg purge_active_split;
reg [2 : 0] rply_num_split;
reg [2 : 0] rply_num_reg_split;
reg tmr_running_split;
reg fst_rtlp_end_split;
reg last_rtry_pkt_split;
reg tlp_size_end_reg_split;
reg tlp_trns_end_reg_split;
reg rply_tout_pend_split;
reg rtry_done_reg1_split;
reg tout_hold_timer_split;
reg retrain_hold_timer_split;
reg phy_l0_reg_split;
reg [2 : 0] max_pl_size_reg_split;
reg dcnt_blk_split;
reg rtry_blk_split;
reg [ATBL_MEM_AWIDTH - 1 : 0] atblwr_ptr_m_split;
reg [TLP_MEM_AWIDTH - 1 : 0] tlprd_ptr_c_split;
reg [TLP_MEM_AWIDTH : 0] temp_split;
reg [ATBL_MEM_DWIDTH - 1 : 0] atbl_data_in_split;
reg [ATBL_MEM_DWIDTH - 1 : 0] atbl_data_out_split;
reg [ATBL_MEM_AWIDTH - 1 : 0] atblrd_ptr_c_split;
reg tlp_wren_split;
reg tlp_rden_split;
reg atbl_empty_split;
reg atbl_pempty_split;
reg atbl_rden_c_split;
reg atbl_empty_pr_split;
reg tlp_empty_split;
reg ld_rtry_staddr_split;
reg tlp_size_end_split;
reg rxdp_rtry_pr_split;
reg rtry_rdy_pr_split;
reg rtry_req_pr_split;
reg nak_hold_timer_split;
reg rply_tout_c_split;
reg nak_rst_timer_split;
reg ack_rst_timer_split;
reg rst_timer_1_split;
reg rst_timer_2_split;
reg [2047:0] descram_in;
wire [91:0] descram_out;

`ifdef X1

`ifdef MAX_TLP_512

`endif

`ifdef MAX_TLP_1K

`endif

`ifdef MAX_TLP_2K

`endif

`ifdef MAX_TLP_4K

`endif

`endif

`ifdef X4

`ifdef MAX_TLP_512

`endif

`ifdef MAX_TLP_1K

`endif

`ifdef MAX_TLP_2K

`endif

`ifdef MAX_TLP_4K

`endif

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif


`ifdef X1

`endif

`ifdef X4

`endif

`ifdef ECP5UM

`else

`ifdef ECP3

`else

`endif

`endif

`ifdef ECP5UM

`else

`ifdef ECP3

`else

`endif

`endif


`ifdef ECP5UM

`else

`ifdef ECP3

`else

`endif

`endif

`ifdef ECP5UM

`else

`ifdef ECP3

`else

`endif

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

localparam descram_inst_SIZE = 92,descram_inst_SCRAMSTRING = 32'hfdffd42b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;



`ifdef X1



`ifdef MAX_TLP_512


`endif



`ifdef MAX_TLP_1K


`endif



`ifdef MAX_TLP_2K


`endif



`ifdef MAX_TLP_4K


`endif



`endif



`ifdef X4



`ifdef MAX_TLP_512


`endif



`ifdef MAX_TLP_1K


`endif



`ifdef MAX_TLP_2K


`endif



`ifdef MAX_TLP_4K


`endif



`endif


`ifdef X4


`endif


`ifdef X1


`endif



`ifdef X4


`endif


`ifdef X1


`endif



`ifdef X4


`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef ECP5UM



`else



`ifdef ECP3



`else



`endif



`endif



`ifdef ECP5UM



`else



`ifdef ECP3



`else



`endif



`endif



`ifdef ECP5UM



`else



`ifdef ECP3



`else



`endif



`endif



`ifdef ECP5UM



`else



`ifdef ECP3



`else



`endif



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif

// =============================================================================
// Local parameters based on TLP size define.


`ifdef X1


   

`ifdef MAX_TLP_512


      

`endif


   

`ifdef MAX_TLP_1K


      

`endif


   

`ifdef MAX_TLP_2K


      

`endif


   

`ifdef MAX_TLP_4K


      

`endif




`endif





`ifdef X4


   

`ifdef MAX_TLP_512


      

`endif


   

`ifdef MAX_TLP_1K


      

`endif


   

`ifdef MAX_TLP_2K


      

`endif


   

`ifdef MAX_TLP_4K


      

`endif




`endif



// =============================================================================



`ifdef X4


   

`endif




`ifdef X1


   

`endif




`ifdef X4


   

`endif


// This has to be changed with memory sizes
// BLOCK_NUM = size of memory instatiated - 1 max TLP size. 
// Additional 5 used to take care of latency involved on data from user interface
// to retry buffer, but not on txtp_rdy to user interface
//
// localparam BLOCK_NUM      = TLP_MEM_DEPTH - TLP_ACT_SIZE - 5 ;
// parameter  RPLY_TMR_VAL   = TLP_ACT_SIZE * 3 ;


`ifdef X1


   

`endif




`ifdef X4


   

`endif



always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      max_pl_size_reg <= 3'b000 ;
   else
      max_pl_size_reg <= max_pl_size_split ;
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      BLOCK_NUM <= 12'd0 ;
   else begin
      case (max_pl_size_reg_split)
	 

`ifdef X1


            3'd0,
            3'd1,
            3'd2 : BLOCK_NUM <= 13'd752 ;  // (512*4 - 512+32) / 2 ;
            3'd3 : BLOCK_NUM <= 13'd1520 ; // (1K*4 - 1K+32) / 2 ;
            3'd4 : BLOCK_NUM <= 13'd3056 ; // (2K*4 - 2K+32) / 2 ;
            3'd5 : BLOCK_NUM <= 13'd6128 ; // (4K*4 - 4K+32) / 2 ;
            3'd6 : BLOCK_NUM <= 13'd752 ;
            3'd7 : BLOCK_NUM <= 13'd752 ;
         

`endif


	 

`ifdef X4


            3'd0,
            3'd1,
            3'd2 : BLOCK_NUM <= 13'd376 ;  // (512*7 - 512-64) / 8 ;
            3'd3 : BLOCK_NUM <= 13'd760 ;  // (1K*7 - 1K-64) / 8 ;
            3'd4 : BLOCK_NUM <= 13'd1528 ; // (2K*7 - 2K-64) / 8 ;
            3'd5 : BLOCK_NUM <= 13'd3064 ; // (4K*7 - 4K-64) / 8;
            3'd6 : BLOCK_NUM <= 13'd376 ;
            3'd7 : BLOCK_NUM <= 13'd376 ;
         

`endif


      endcase
   end
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      RPLY_TMR_VAL <= 'd0 ;
   else begin
      case (max_pl_size_reg_split)
	 

`ifdef X1


            3'd0 : RPLY_TMR_VAL <= 14'd622 ;   // (711  / 2) * 1.75;
            3'd1 : RPLY_TMR_VAL <= 14'd1092 ;  // (1248 / 2) * 1.75;
            3'd2 : RPLY_TMR_VAL <= 14'd1468 ;  // (1677 / 2) * 1.75 ;
            3'd3 : RPLY_TMR_VAL <= 14'd2812 ;  // (3213 / 2) * 1.75 ;
            3'd4 : RPLY_TMR_VAL <= 14'd5500 ;  // (6285 / 2) * 1.75 ;
            3'd5 : RPLY_TMR_VAL <= 14'd10876 ; // (12429 / 2) * 1.75 ;
            3'd6 : RPLY_TMR_VAL <= 14'd622 ;
            3'd7 : RPLY_TMR_VAL <= 14'd622 ;
         

`endif


	 

`ifdef X4


            3'd0 : RPLY_TMR_VAL <= 13'd192 ;  // (219 / 2) * 1.75 ;
            3'd1 : RPLY_TMR_VAL <= 13'd310 ;  // (354 / 2) * 1.75 ;
            3'd2 : RPLY_TMR_VAL <= 13'd404 ;  // (462 / 2) * 1.75 ;
            3'd3 : RPLY_TMR_VAL <= 13'd740 ;  // (846 / 2) * 1.75 ;
            3'd4 : RPLY_TMR_VAL <= 13'd1412 ; // (1614 / 2) * 1.75 ;
            3'd5 : RPLY_TMR_VAL <= 13'd2756 ; // (3150 / 2) * 1.75 ;
            3'd6 : RPLY_TMR_VAL <= 13'd192 ;
            3'd7 : RPLY_TMR_VAL <= 13'd192 ;
         

`endif


      endcase
   end
end

// =============================================================================
//
//
// =============================================================================
// Register packet boundary signals.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin   
      tlp_data_reg  <= {D_WIDTH{1'd0}} ;
      tlp_st_reg    <= 1'b0 ;
      tlp_end_reg   <= 1'b0 ;
      ttlp_nlfy_reg <= 1'b0 ;
      

`ifdef X4


         tlp_dwen_reg  <= 1'b0 ;
      

`endif


   end
   else if(ttlp_tval) begin 
      tlp_data_reg  <= ttlp_data_split ;
      tlp_st_reg    <= ttlp_st_split ;
      tlp_end_reg   <= ttlp_end_split ;
      ttlp_nlfy_reg <= ttlp_nlfy_split ;
      

`ifdef X4


         tlp_dwen_reg  <= ttlp_dwen ;
      

`endif


   end
end

// Generate write enable signals for FIFO (TLP retry buffer)
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      tlp_wren_int <= 1'b0 ;
   else if (ttlp_st_split && ttlp_tval)
      tlp_wren_int <= 1'b1 ;
   else if ((tlp_end_reg_split || ttlp_nlfy_reg_split) && ttlp_tval)
      tlp_wren_int <= 1'b0 ;
   else
      tlp_wren_int <= tlp_wren_int_split ;
end
assign tlp_wren = tlp_wren_int_split & ttlp_tval ;

// Prepare the data to be written into buffer.


`ifdef X1


   assign tlp_bdata_in = {tlp_data_reg_split} ;


`endif




`ifdef X4


   assign tlp_bdata_in = {tlp_dwen_reg, tlp_data_reg_split} ;


`endif



// count the number of data getting written into buffer.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      tlp_size <= {(TLP_MEM_AWIDTH){1'b1}} ;
   else if (atbl_wren_split && tlp_wren_split)    
      tlp_size <= {(TLP_MEM_AWIDTH){1'b0}} ;
   else if (tlp_wren_split)  
      tlp_size <= tlp_size_split + 1'b1 ;
   else if (atbl_wren_split)    
      tlp_size <= {(TLP_MEM_AWIDTH){1'b1}} ;
   else     
      tlp_size <= tlp_size_split ;
end

// Store the sequence number of most recent TLP
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      tlp_seq_num_int <= 12'hFFF ;
   else if (ttlp_st_split && ttlp_tval) begin 
      

`ifdef X1


         tlp_seq_num_int <= ttlp_data_split[11:0];
      

`endif


      

`ifdef X4


         tlp_seq_num_int <= ttlp_data_split[59:48];
      

`endif


   end  
   else  
      tlp_seq_num_int <= tlp_seq_num_int_split ;
end

// Transfer stored sequence number at he end of TLP
// so that it can be written to adress table.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      tlp_seq_num <= 12'hFFF ;
   else if (ttlp_end_split && ttlp_tval) 
      tlp_seq_num <= tlp_seq_num_int_split;
   else  
      tlp_seq_num <= tlp_seq_num_split ;
end


// Store the starting pointer address from where
// the TLP is written. 
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      tlp_st_addr <= {(TLP_MEM_AWIDTH){1'b0}} ;
   else if (tlp_st_reg_split && ttlp_tval) 
      tlp_st_addr <= tlpwr_ptr_split ;
   else  
      tlp_st_addr <= tlp_st_addr_split ;
end

// Generate address pointers for writing the TLP
// data into the FIFO. If the TLP has to be discarded
// load the address pointer with start adress value. 
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      tlpwr_ptr <= {(TLP_MEM_AWIDTH){1'b0}} ;
   else if (dl_inact_split) 
      tlpwr_ptr <= {(TLP_MEM_AWIDTH){1'b0}} ;
   else if (ttlp_nlfy_reg_split && ttlp_tval) 
      tlpwr_ptr <= tlp_st_addr_split ;
   else if (tlp_wren_split) 
      tlpwr_ptr <= tlpwr_ptr_split + 1'b1 ;
   else  
      tlpwr_ptr <= tlpwr_ptr_split ;
end

// Generate read enable signal for TLP retry buffer FIFO
// assert once the address of the TLP is read from address table fifo,
// de-assert when complete TLP is read out.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      tlp_rden_int <= 1'b0 ;
   else if (rtry_rdy_pr_reg_split || 
            (txtp_rtry_req1_split && tdmux_rtry_rdy_split && rtlp_end_reg_split && !last_rtry_pkt_split && ttlp_tval)) 
      tlp_rden_int <= 1'b1 ;
   else if (tlp_size_end_split && ttlp_tval )
      tlp_rden_int <= 1'b0 ;
   else
      tlp_rden_int <= tlp_rden_int_split  ;
end
assign tlp_rden = tlp_rden_int_split & ttlp_tval ;

// Generate read address pointer for TLP buffer FIFO
// Load the address read out from address table FIFO
// Re-load the address when all TLPs are replayed.
// and keep incrementing until read enable is asserted.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      tlprd_ptr <= {(TLP_MEM_AWIDTH){1'b0}} ;
   else if (dl_inact_split) 
      tlprd_ptr <= {(TLP_MEM_AWIDTH){1'b0}} ;
   else if (atbl_empty_split) 
      tlprd_ptr <= tlp_st_addr_split ;
   

`ifdef X1


      else if ( rtry_rdy_pr_reg_split || 
             (tlp_end_reg_split & ~tdmux_rtry_rdy_split & ~atbl_empty_split) || 
	     (ttlp_nlfy_reg_split & ~tdmux_rtry_rdy_split & ~atbl_empty_split) ||
             (!tdmux_rtry_rdy_split & rxdp_purge_reg2_split) || 
             (txtp_rtry_req1_split & tdmux_rtry_rdy_split & rtlp_end_reg_split & ~last_rtry_pkt_split)) 
         tlprd_ptr <= atbl_data_out_split[(ATBL_MEM_DWIDTH/2)-1:0] ;
   
   

`endif


   

`ifdef X4


      else if ( rtry_rdy_pr_reg_split || 
             (tlp_end_reg_split & ttlp_tval & ~tdmux_rtry_rdy_split & ~atbl_empty_split) || 
	     (ttlp_nlfy_reg_split & ttlp_tval & ~tdmux_rtry_rdy_split & ~atbl_empty_split) ||
             (!tdmux_rtry_rdy_split & rxdp_purge_reg1_split) || 
             (txtp_rtry_req1_split & tdmux_rtry_rdy_split & rtlp_end_reg_split & ~last_rtry_pkt_split)) 
         tlprd_ptr <= atbl_data_out_split[(ATBL_MEM_DWIDTH/2)-1:0] ;
   

`endif


   else if (ld_rtry_staddr_split & ~purge_active_split) 
      tlprd_ptr <= rtry_tlp_staddr_split ;
   else if (tlp_rden_split) 
      tlprd_ptr <= tlprd_ptr_split + 1'b1 ;
   else 
      tlprd_ptr <= tlprd_ptr_split ;
end

// Generte last retry packet valid from tlp_st of the
// last TLP to retry_done.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      last_rtry_pkt <= 1'b0 ;
   else if (rtlp_st_int_split && ttlp_tval && atbl_pempty_split) 
      last_rtry_pkt <= 1'b1 ;
   else if (rtlp_st && ttlp_tval && !atbl_pempty_split) 
      last_rtry_pkt <= 1'b0 ;
   else if (txtp_rtry_done) 
      last_rtry_pkt <= 1'b0 ;
   else  
      last_rtry_pkt <= last_rtry_pkt_split ;
end

// Load the size of the TLP read out from address table FIFO
// and keep decrementing until read enable is asserted.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      tlp_size_cnt <= {(TLP_MEM_AWIDTH){1'b1}} ;
   else if (last_rtry_pkt_split && txtp_rtry_done)  
      tlp_size_cnt <= {(TLP_MEM_AWIDTH){1'b1}} ;
   else if ( rtry_rdy_pr_reg_split || 
             (txtp_rtry_req1_split & tdmux_rtry_rdy_split & rtlp_end_reg_split & !last_rtry_pkt_split))
      tlp_size_cnt <= atbl_data_out_split[ATBL_MEM_DWIDTH -1:(ATBL_MEM_DWIDTH/2)] ;
   else if (tlp_rden_split) 
      tlp_size_cnt <= tlp_size_cnt_split - 1'b1 ;
   else 
      tlp_size_cnt <= tlp_size_cnt_split ;
end

// generate difference between write pointer and read pointer.
// assign temp = tlpwr_ptr - tlprd_ptr ;
// 2's complement addition used.
assign temp = tlpwr_ptr_split + ~tlprd_ptr_split + 1'b1 ;

// calculate the number of data words present in FIFO whenever
// purge received and at the end of retry and at the end of 
// each TLP from TL | ttlp_nlfy.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      tlp_dcnt <= {(TLP_MEM_AWIDTH){1'b0}} ;
   else if (dl_inact_split || atbl_empty_split) 
      tlp_dcnt <= {(TLP_MEM_AWIDTH){1'b0}} ;
   

`ifdef X1


   else if ((rxdp_purge_reg3_split && !rxdp_rtry_split) ||
            txtp_rtry_done || ((ttlp_end_split || ttlp_nlfy_split)) ||
            (tlp_size_split == TLP_ACT_SIZE-18) ) begin
      if (temp_split[TLP_MEM_AWIDTH] )
         tlp_dcnt <= temp_split[TLP_MEM_AWIDTH -1:0] + {(TLP_MEM_AWIDTH){1'b1}} ;
      else 
         tlp_dcnt <= temp_split[TLP_MEM_AWIDTH -1:0] ;
   end
   

`endif


   

`ifdef X4


   else if ((rxdp_purge_reg1_split && !rxdp_rtry_split) ||
            txtp_rtry_done || ((ttlp_end_split || ttlp_nlfy_split) && ttlp_tval) ||
            (tlp_size_split == TLP_ACT_SIZE-18) ) begin
      if (temp_split[TLP_MEM_AWIDTH] )
         tlp_dcnt <= temp_split[TLP_MEM_AWIDTH -1:0] + {(TLP_MEM_AWIDTH){1'b1}} ;
      else 
         tlp_dcnt <= temp_split[TLP_MEM_AWIDTH -1:0] ;
   end
   

`endif


   else
      tlp_dcnt <= tlp_dcnt_split ;
end


// Generate TLP blocking signal for TL if FIFO has already
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin   
      dcnt_blk   <= 1'b0 ;
      rtry_blk   <= 1'b0 ;
      txtp_block <= 1'b0 ;
   end  
   else if (dl_inact_split) begin 
      dcnt_blk   <= 1'b0 ;
      rtry_blk   <= 1'b0 ;
      txtp_block <= 1'b0 ;
   end  
   else if (tlp_dcnt_split >= BLOCK_NUM) begin 
      dcnt_blk   <= 1'b1 ;
      txtp_block <= 1'b1 ;
   end  
      else if (txtp_rtry_req) begin 
      rtry_blk   <= 1'b1 ;
      txtp_block <= 1'b1 ;
   end  
      else if (~|calc1 && rtry_blk_split) begin 
      rtry_blk   <= 1'b0 ;
      txtp_block <= 1'b0 ;
   end  
      else if (!txtp_rtry_req & (tlp_dcnt_split < BLOCK_NUM) && dcnt_blk_split) begin 
      dcnt_blk   <= 1'b0 ;
      txtp_block <= 1'b0 ;
   end  
   else  
      txtp_block <= txtp_block ;
end

// Register TLP data fifo empty signal.
// Generate TLP transfer end signal.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin  
      tlp_empty_reg    <= 1'b0 ;
      tlp_trns_end     <= 1'b0 ;
      tlp_trns_end_reg <= 1'b0 ;
   end
   else begin
      tlp_empty_reg    <= tlp_empty_split ;
      tlp_trns_end     <= (tlp_end_reg_split | ttlp_nlfy_reg_split) && ttlp_tval ;
      tlp_trns_end_reg <= tlp_trns_end_split ;
   end
end


// Generate end of the TLP based on the size.
assign tlp_size_end = (tlp_size_cnt_split == {(TLP_MEM_AWIDTH){1'b0}}) & ttlp_tval ;

// Generate address table FIFO empty signal when 
// read pointer is equal to write pointer.
assign tlp_empty = ((tlprd_ptr_split == {(TLP_MEM_AWIDTH){1'b0}}) & 
                    (tlpwr_ptr_split == {(TLP_MEM_AWIDTH){1'b0}})) |
                    (tlprd_ptr_split == (tlpwr_ptr_split - 1)) ;


// Instantiate dual port memory TLP buffer.
pmi_ram_dp #( 
   .pmi_wr_addr_depth    ( TLP_MEM_DEPTH ),
   .pmi_wr_addr_width    ( TLP_MEM_AWIDTH ),
   .pmi_rd_addr_depth    ( TLP_MEM_DEPTH ),
   .pmi_rd_addr_width    ( TLP_MEM_AWIDTH ),
 

`ifdef X1


   .pmi_wr_data_width    ( 16 ),
   .pmi_rd_data_width    ( 16 ),
 

`endif


 

`ifdef X4


   .pmi_wr_data_width    ( 64 +1 ),
   .pmi_rd_data_width    ( 64 +1 ),
 

`endif


   .pmi_regmode          ( "noreg" ),
   .pmi_gsr              ( "enable" ),
   .pmi_init_file        ("none"),
   .pmi_init_file_format ("binary"),
 

`ifdef ECP5UM


   .pmi_resetmode        ("sync"),   
   .pmi_family           ("ECP5U"),
 

`else


    

`ifdef ECP3


      .pmi_resetmode     ("sync"),   //Connect LOW
      .pmi_family        ("ECP3"),
    

`else


      .pmi_resetmode     ("async"),
      .pmi_family        ("EC2"),
    

`endif


 

`endif


   .module_type          ("pmi_ram_dp")
   ) 
   u1_tlp_mem (
   .Data         ( tlp_bdata_in ),
   .WrAddress    ( tlpwr_ptr ),
   .RdAddress    ( tlprd_ptr ),
   .WrClock      ( sys_clk ),
   .RdClock      ( sys_clk ),
   .WrClockEn    ( 1'b1 ),
   .RdClockEn    ( tlp_rden ), 
   .WE           ( tlp_wren ),
 

`ifdef ECP5UM


   .Reset        (1'b0),
 

`else


    

`ifdef ECP3


      .Reset     (1'b0),
    

`else


      .Reset     (~rst_n), 
    

`endif


 

`endif


   .Q            ( tlp_bdata_out )
   );

// =============================================================================
// 
// 
// =============================================================================
// Form data input for the address table FIFO.
assign atbl_data_in = {tlp_size_split, tlp_st_addr_split} ;

// Generate write enable signal for address table FIFO
// at the end of the TLP if it is not to be discarded.
//assign atbl_wren = (tlp_end_reg && !ttlp_nlfy_reg) ;
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)    
      atbl_wren     <= 1'b0 ;
   else  
      atbl_wren     <= (tlp_end_reg_split && !ttlp_nlfy_reg_split && ttlp_tval) ;
end

// Generate address pointer for for address table FIFO
// increment when ever write enable is asserted.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      atblwr_ptr <= {(ATBL_MEM_AWIDTH){1'b0}} ;
   else if (dl_inact_split) 
      atblwr_ptr <= {(ATBL_MEM_AWIDTH){1'b0}} ;
   else if (atbl_wren_split) 
      atblwr_ptr <= atblwr_ptr_split + 1'b1 ;
   else
      atblwr_ptr <= atblwr_ptr_split ;
end

// Generate address table FIFO empty signal based on the pointer values.
assign atbl_empty  = (atblrd_ptr_split == atblwr_ptr_split) ;
//assign atbl_pempty = (atblrd_ptr == (atblwr_ptr-1)) ;
assign atblwr_ptr_m = (atblwr_ptr_split-1) ;
assign atbl_pempty = (atblrd_ptr_split == atblwr_ptr_m_split) ;

// read out the entry from addtress table FIFO,
// when ready is given to transmit TLPs from retry buffer.
// when each TLP ends and address table is not empty. 
assign atbl_rden_c = (tlp_size_end_split & ~last_rtry_pkt_split) & ~atbl_empty_split ; 


// Generate read address pointer for address table FIFO
// Load newly caculated read pointer address when "rxdp_ack" or "rxdp_purge"
// indication comes from receiver.
// Re-load the address when all TLPs are replayed. 
// keep incrementing when read enable is asserted.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      atblrd_ptr <= {(ATBL_MEM_AWIDTH){1'b0}} ;
   else if (dl_inact_split) 
      atblrd_ptr <= {(ATBL_MEM_AWIDTH){1'b0}} ;
   else if (ld_rtry_staddr_split || tlp_trns_end_reg_split || 
            (!tdmux_rtry_rdy_split && !rtry_req_reg_split && rxdp_purge_reg_split) || 
            (rxdp_ack_split && ~|calc1) ) begin 
      if (purge_active_split || rxdp_purge_reg_split )
         atblrd_ptr <= atblrd_ptr_c_split ;
      else
         atblrd_ptr <= (rtry_atbl_staddr_split) ;
   end 
   else if (atbl_rden_split) 
      atblrd_ptr <= atblrd_ptr_split + 1'b1 ;
   else 
      atblrd_ptr <= atblrd_ptr_split ;
end

// Register the control signals
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin   
      rxdp_purge_reg  <= 1'b0 ;
      rxdp_purge_reg1 <= 1'b0 ;
      rxdp_purge_reg2 <= 1'b0 ;
      rxdp_purge_reg3 <= 1'b0 ;
      rxdp_ack_reg    <= 1'b0 ;
      atbl_empty_reg  <= 1'b0 ;
      atbl_empty_reg1 <= 1'b0 ;
      atbl_rden       <= 1'b0 ;
      atbl_rden_reg   <= 1'b0 ;
   end
   else begin
      rxdp_purge_reg  <= rxdp_purge_split ;
      rxdp_purge_reg1 <= rxdp_purge_reg_split ;
      rxdp_purge_reg2 <= rxdp_purge_reg1_split ;
      rxdp_purge_reg3 <= rxdp_purge_reg2_split ;
      rxdp_ack_reg    <= rxdp_ack_split ;
      atbl_empty_reg  <= atbl_empty_split ;
      atbl_empty_reg1 <= atbl_empty_reg_split ;
      atbl_rden       <= atbl_rden_c_split  ;
      atbl_rden_reg   <= atbl_rden_split ;
   end
end
assign atbl_empty_pr = atbl_empty_split & ~atbl_empty_reg_split ;
assign tx_rbuf_empty = atbl_empty_reg1_split ;

// Instantiate dual port memory for address table.
pmi_ram_dp #( 
   .pmi_wr_addr_depth    ( ATBL_MEM_DEPTH ),
   .pmi_wr_addr_width    ( ATBL_MEM_AWIDTH ),
   .pmi_wr_data_width    ( ATBL_MEM_DWIDTH ),
   .pmi_rd_addr_depth    ( ATBL_MEM_DEPTH ),
   .pmi_rd_addr_width    ( ATBL_MEM_AWIDTH ),
   .pmi_rd_data_width    ( ATBL_MEM_DWIDTH ),
   .pmi_regmode          ( "noreg" ),
   .pmi_gsr              ( "enable" ),
   .pmi_init_file        ("none"),
   .pmi_init_file_format ("binary"),
 

`ifdef ECP5UM


   .pmi_resetmode        ("sync"),   
   .pmi_family           ("ECP5U"),
 

`else


    

`ifdef ECP3


      .pmi_resetmode     ("sync"),   //Connect LOW
      .pmi_family        ("ECP3"),
    

`else


      .pmi_resetmode     ("async"),
      .pmi_family        ("EC2"),
    

`endif


 

`endif


   .module_type          ("pmi_ram_dp")
   ) 
   u1_atbl_mem (
   .Data         ( atbl_data_in ),
   .WrAddress    ( atblwr_ptr ),
   .RdAddress    ( atblrd_ptr ),
   .WrClock      ( sys_clk ),
   .RdClock      ( sys_clk ),
   .WrClockEn    ( 1'b1 ),
   .RdClockEn    ( 1'b1 ), 
   .WE           ( atbl_wren ),
 

`ifdef ECP5UM


   .Reset        (1'b0),
 

`else


    

`ifdef ECP3


      .Reset     (1'b0),
    

`else


      .Reset     (~rst_n), 
    

`endif


 

`endif


   .Q            ( atbl_data_out )
   );

// =============================================================================
// Register sequence number from RXDP b_reglock whenever
// ack or purge indications are there.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      rtry_seq_num <= 12'h000 ;
   else if (rxdp_ack_split || rxdp_purge_split) 
      rtry_seq_num <= rxdp_seqnum_split ;
   else
      rtry_seq_num <= rtry_seq_num_split ;
end

// generate purge active indication for the duration
// taken to compute and load new read address pointer.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      purge_active <= 1'b0 ;
   else if (rxdp_purge_split) 
      purge_active <= 1'b1 ;
   else if (atbl_rden_reg_split || tlp_size_end_split || tlp_trns_end_reg_split ) 
      purge_active <= 1'b0 ;
   else
      purge_active <= purge_active_split ;
end

// subtract the sequence number given by RXDP from
// the sequence number of the most resently transmitted.
//assign calc1 = tlp_seq_num - rtry_seq_num ;
assign calc1 = tlp_seq_num_split + ~rtry_seq_num_split + 1 ;

// Subtract the difference in sequence numbers calculated above
// from write pointer address of the address-table
// and this will form the new read address pointer of the address-table.
//assign atblrd_ptr_c = atblwr_ptr - calc1 ;
assign atblrd_ptr_c = atblwr_ptr_split + ~calc1 + 1 ;

// get TLP address from address-table.
assign tlprd_ptr_c =  atbl_data_out_split[10:0] ;

// Register retry indication frpm RXDP and
// ready indication from TXDT_MUX
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin  
      rxdp_rtry_reg    <= 1'b0 ;
      rtry_rdy_reg     <= 1'b0 ;
      rtry_rdy_pr_reg  <= 1'b0 ;
      tlp_size_end_reg <= 1'b0 ;
      rtry_done_reg1   <= 1'b0 ;
      phy_l0_reg       <= 1'b0 ;
   end
   else  begin  
      rxdp_rtry_reg    <= rxdp_rtry_split ;
      rtry_rdy_reg     <= tdmux_rtry_rdy_split  ;
      rtry_rdy_pr_reg  <= (rtry_rdy_pr_split & txtp_rtry_req1_split) | 
                          (tdmux_rtry_rdy_split & rply_tout_pend_split & rtry_done_reg1_split) ;
      tlp_size_end_reg <= tlp_size_end_split ;
      rtry_done_reg1   <= txtp_rtry_done ;
      phy_l0_reg       <= phy_l0_split ;
   end
end

// Generate raising edge detection pulse for retry indication from RXDP. 
assign rxdp_rtry_pr = rxdp_rtry_split & ~rxdp_rtry_reg_split ;

// Generate raising edge detection pulse for ready indication from TXDT_MUX. 
assign rtry_rdy_pr  = tdmux_rtry_rdy_split & ~rtry_rdy_reg_split ;

// Store TLP buffer and addres-table read pointer address
// at the begining of replaying TLPs.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin  
      rtry_tlp_staddr <= {(TLP_MEM_AWIDTH){1'b0}} ;
      rtry_atbl_staddr <= {(ATBL_MEM_AWIDTH){1'b0}} ;
   end
   else if (purge_active_split & (tlp_size_end_split || tlp_trns_end_reg_split)) begin  
      rtry_tlp_staddr  <= tlprd_ptr_c_split ;
      rtry_atbl_staddr <= atblrd_ptr_c_split ;
   end
   else if (rtry_req_pr_split) begin  
      rtry_tlp_staddr  <= tlprd_ptr_split ;
      rtry_atbl_staddr <= atblrd_ptr_split ;
   end
   else begin  
      rtry_tlp_staddr  <= rtry_tlp_staddr_split ;
      rtry_atbl_staddr <= rtry_atbl_staddr_split ;
   end
end


// At the end of last TLP transmission while replaying
// generate signal to load initial values. 
assign ld_rtry_staddr= (tlp_size_end_reg_split & last_rtry_pkt_split & tdmux_rtry_rdy_split) ;

// =============================================================================
// Replaying of retry buffer is counted with signal "txtp_rtry_done"
// and replay number roll over indication is generated when this count
// rolls from 2'b11 to 2'b00.
// =============================================================================

// Count the number of replays,
// increment at the end of every replay.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      rply_num <= 3'b000 ;
   //else  if (dl_inact || txtp_rnum_rlor || (rxdp_purge && !rxdp_rtry))
   else  if (dl_inact_split || ((rply_num_split == 3'b100) && txtp_rtry_done ) || (rxdp_purge_split && !rxdp_rtry_split)) 
      rply_num <= 3'b000 ;
   else  if ((rxdp_rtry_pr_split  || txtp_rply_tout) && !atbl_empty_split)
      rply_num <= rply_num_split + 3'b001 ;
end

// Generate replay number roll over pulse when
// replay number changers fromm 3'b011 to 3'b100
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin   
      rply_num_reg <= 3'b000 ;
      txtp_rnum_rlor <= 1'b0 ;
   end
   else begin  
      rply_num_reg <= rply_num_split ;
      txtp_rnum_rlor <= ((rply_num_split == 3'b100) & (rply_num_reg_split == 3'b011)) ;
   end
end


// =============================================================================
// replay time is the time between transmission of a TLP and reception of a
// DLLP, it is restarted when a dllp is received and retry buffer hold some
// of the un-acknowledged TLPs or at the begining of a TLP transmission if timer 
// is not running or by expiration of the timer value.
// =============================================================================

// Replay timer, reset with start_timer indication and
// hold the timer movement when there is no data in TLP buffer,
// otherwise keep running.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      rply_timer  <= 'h0000 ;
   else  if (rst_timer_1_split || rst_timer_2_split || atbl_empty_pr_split)  
      rply_timer <= 'h0000 ;
   else  if (nak_hold_timer_split || tout_hold_timer_split || 
             retrain_hold_timer_split || atbl_empty_split )  
      rply_timer <= rply_timer ;
   else if (ttlp_tval)   
      rply_timer <= rply_timer + 1 ;
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      tmr_running <= 1'b0 ;
   else  if (rst_timer_2_split)  
      tmr_running <= 1'b1 ;
   else  if (rst_timer_1_split || nak_hold_timer_split || 
             tout_hold_timer_split || retrain_hold_timer_split || tlp_empty_reg_split)  
      tmr_running <= 1'b0 ;
   else   
      tmr_running <= tmr_running_split ;
end

// Detect the end of first TLP's end while replaying
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      fst_rtlp_end <= 1'b0 ;
   else  if (rxdp_rtry_reg_split && rtlp_end_int_split )  
      fst_rtlp_end <= 1'b1 ;
   else  if (!rxdp_rtry_reg_split)  
      fst_rtlp_end <= 1'b0 ;
   else   
      fst_rtlp_end <= fst_rtlp_end_split ;
end

// Generate signal to hold replay timer whenever receive a NAK
// untill the end of first tlp
assign nak_hold_timer = ~fst_rtlp_end_split & rxdp_rtry_reg_split & (|calc1) ;

// Generate signal to hold replay timer whenever replay timer expires
// untill restart condition happens.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      tout_hold_timer <= 1'b0 ;
   else  if (rply_tout_c_split )  
      tout_hold_timer <= 1'b1 ;
   else  if (rst_timer_2_split | ack_rst_timer_split | nak_rst_timer_split | txtp_rnum_rlor)  
      tout_hold_timer <= 1'b0 ;
   else   
      tout_hold_timer <= tout_hold_timer_split ;
end

// Generate signal to hold replay timer whenever retrain happens
// untill restart condition happens.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      retrain_hold_timer <= 1'b0 ;
   else  if (txtp_rnum_rlor )  
      retrain_hold_timer <= 1'b1 ;
   else  if (phy_l0_split & ~phy_l0_reg_split)  
      retrain_hold_timer <= 1'b0 ;
   else   
      retrain_hold_timer <= retrain_hold_timer_split ;
end

// Generate reset timmer condition upon receiving NAK DLLPs,
// and retry buffer still holds TLPs for which ACK not 
// received(when calc1 holds a valuse other than 0)  
assign nak_rst_timer = (~atbl_empty_split & rxdp_rtry_pr_split) ;

// Generate start timmer condition upon receiving ACK DLLPs,
// and retry buffer still holds TLPs for which ACK not 
// received(when calc1 holds a valuse other than 0)  
assign ack_rst_timer = (~atbl_empty_split & rxdp_ack_reg_split) ;

// replay timeout pulse generation when timer reaches
// parameter value.
assign rply_tout_c = (rply_timer == RPLY_TMR_VAL)  ;

assign rst_timer_1 = ack_rst_timer_split | nak_rst_timer_split | rply_tout_c_split ;

// Generate start timmer at the end of a TLP from transaction layer or
// from retry buffer or DLLP condition aoccurs. 
assign rst_timer_2 =  (!tmr_running_split & (ttlp_end_split | rtlp_end_int_split)) ;



// Register the combinatorial signals.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)    
      txtp_rply_tout   <= 1'b0 ;
   else   
      txtp_rply_tout   <= rply_tout_c_split ;
end
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)    
      rply_tout_pend <= 1'b0 ;
   else if  (txtp_rply_tout && rtry_rdy_reg_split)  
      rply_tout_pend <= 1'b1 ;
   else if (!rtry_rdy_reg_split) 
      rply_tout_pend <= 1'b0 ;
end

// =============================================================================
// Generate request for replaying retry buffer whenever
// retry indication from RXDP is seen.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      txtp_rtry_req1 <= 1'b0 ;
   else if (dl_inact_split) 
      txtp_rtry_req1 <= 1'b0 ;
  else if ((rxdp_rtry_pr_split  || txtp_rply_tout) && !atbl_empty_split && (rply_num_split != 3'b011)) 
      txtp_rtry_req1 <= 1'b1 ;
  else  if ((phy_l0_split & ~phy_l0_reg_split) && !atbl_empty_split && (rply_num_split == 3'b100)) 
      txtp_rtry_req1 <= 1'b1 ;
   else if (txtp_rtry_done || (rxdp_ack_split && ~|calc1))
      txtp_rtry_req1 <= 1'b0 ;
   else if (rply_tout_pend_split ) 
      txtp_rtry_req1 <= 1'b1 ;
   else  
      txtp_rtry_req1 <= txtp_rtry_req1_split ;
end

assign txtp_rtry_req = txtp_rtry_req1_split | rply_tout_pend_split ;

assign rtry_req_pr = txtp_rtry_req1_split & ~rtry_req_reg_split ;

// Generate the indication of the end of replay.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      txtp_rtry_done <= 1'b0 ;
   //else if (ld_rtry_staddr || txtp_rnum_rlor)
   else if (ld_rtry_staddr_split)
      txtp_rtry_done <= 1'b1 ;
   else if (rxdp_rtry_split && ~|calc1 && atbl_empty_split)
      txtp_rtry_done <= rxdp_rtry_pr_split ;
   else  
      txtp_rtry_done <= 1'b0 ;
end

// Clock out data and packet boundary signals to TXDT_MUX.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin   
      rtry_req_reg  <= 1'b0 ;
      tlp_rden_reg  <= 1'b0 ;
      rtlp_data     <= {D_WIDTH{1'b0}} ;
      

`ifdef X4


         rtlp_tval  <= 1'b0 ;
         rtlp_dwen  <= 1'b0 ;
      

`endif



      rtlp_st_int   <= 1'b0 ;
      rtlp_st       <= 1'b0 ;

      rtlp_end_int <= 1'b0 ;
      rtlp_end     <= 1'b0 ;

      rtlp_end_reg <= 1'b0 ;
   end
   else if (ttlp_tval) begin
      rtry_req_reg  <= txtp_rtry_req1_split ;
      tlp_rden_reg  <= tlp_rden_int_split ;
      

`ifdef X1


         rtlp_data     <= tlp_rden_reg_split ? tlp_bdata_out[15:0] : 16'h0000 ;
      

`endif


      

`ifdef X4


         rtlp_data     <= tlp_rden_reg_split ? tlp_bdata_out[63:0] : 64'h0000_0000_0000_0000 ;
         rtlp_tval  <= tlp_rden_reg_split ;
         rtlp_dwen  <= (tlp_bdata_out[64] & rtlp_end_int_split) ;
      

`endif



      rtlp_st_int   <= (tlp_rden_int_split & ~tlp_rden_reg_split) ;
      rtlp_st       <= rtlp_st_int_split ;

      rtlp_end_int <= tlp_size_end_split ;
      rtlp_end     <= rtlp_end_int_split ;

      rtlp_end_reg <= rtlp_end ;
   end
end

assign txtp_ertlp_end =  tlp_size_end_split ;

always@* begin ttlp_data_split<={ttlp_data>>1,descram_out[0]};ttlp_st_split<=descram_out[1];ttlp_end_split<=descram_out[2];ttlp_nlfy_split<=descram_out[3];rxdp_seqnum_split<={rxdp_seqnum>>1,descram_out[4]};rxdp_ack_split<=descram_out[5];rxdp_rtry_split<=descram_out[6];rxdp_purge_split<=descram_out[7];tdmux_rtry_rdy_split<=descram_out[8];phy_l0_split<=descram_out[9];dl_inact_split<=descram_out[10];max_pl_size_split<={max_pl_size>>1,descram_out[11]};tlp_data_reg_split<={tlp_data_reg>>1,descram_out[12]};tlp_st_reg_split<=descram_out[13];tlp_end_reg_split<=descram_out[14];ttlp_nlfy_reg_split<=descram_out[15];tlp_trns_end_split<=descram_out[16];tlp_wren_int_split<=descram_out[17];tlp_rden_int_split<=descram_out[18];tlp_empty_reg_split<=descram_out[19];tlpwr_ptr_split<={tlpwr_ptr>>1,descram_out[20]};tlprd_ptr_split<={tlprd_ptr>>1,descram_out[21]};tlp_dcnt_split<={tlp_dcnt>>1,descram_out[22]};tlp_st_addr_split<={tlp_st_addr>>1,descram_out[23]};tlp_size_split<={tlp_size>>1,descram_out[24]};tlp_size_cnt_split<={tlp_size_cnt>>1,descram_out[25]};atblwr_ptr_split<={atblwr_ptr>>1,descram_out[26]};atblrd_ptr_split<={atblrd_ptr>>1,descram_out[27]};atbl_empty_reg_split<=descram_out[28];atbl_empty_reg1_split<=descram_out[29];atbl_rden_split<=descram_out[30];atbl_rden_reg_split<=descram_out[31];atbl_wren_split<=descram_out[32];tlp_rden_reg_split<=descram_out[33];rtlp_st_int_split<=descram_out[34];rtlp_end_int_split<=descram_out[35];rtlp_end_reg_split<=descram_out[36];rtry_tlp_staddr_split<={rtry_tlp_staddr>>1,descram_out[37]};rtry_atbl_staddr_split<={rtry_atbl_staddr>>1,descram_out[38]};rtry_rdy_pr_reg_split<=descram_out[39];rtry_req_reg_split<=descram_out[40];rxdp_rtry_reg_split<=descram_out[41];rxdp_purge_reg_split<=descram_out[42];rxdp_purge_reg1_split<=descram_out[43];rxdp_purge_reg2_split<=descram_out[44];rxdp_purge_reg3_split<=descram_out[45];rxdp_ack_reg_split<=descram_out[46];rtry_rdy_reg_split<=descram_out[47];tlp_seq_num_int_split<={tlp_seq_num_int>>1,descram_out[48]};tlp_seq_num_split<={tlp_seq_num>>1,descram_out[49]};rtry_seq_num_split<={rtry_seq_num>>1,descram_out[50]};txtp_rtry_req1_split<=descram_out[51];purge_active_split<=descram_out[52];rply_num_split<={rply_num>>1,descram_out[53]};rply_num_reg_split<={rply_num_reg>>1,descram_out[54]};tmr_running_split<=descram_out[55];fst_rtlp_end_split<=descram_out[56];last_rtry_pkt_split<=descram_out[57];tlp_size_end_reg_split<=descram_out[58];tlp_trns_end_reg_split<=descram_out[59];rply_tout_pend_split<=descram_out[60];rtry_done_reg1_split<=descram_out[61];tout_hold_timer_split<=descram_out[62];retrain_hold_timer_split<=descram_out[63];phy_l0_reg_split<=descram_out[64];max_pl_size_reg_split<={max_pl_size_reg>>1,descram_out[65]};dcnt_blk_split<=descram_out[66];rtry_blk_split<=descram_out[67];atblwr_ptr_m_split<={atblwr_ptr_m>>1,descram_out[68]};tlprd_ptr_c_split<={tlprd_ptr_c>>1,descram_out[69]};temp_split<={temp>>1,descram_out[70]};atbl_data_in_split<={atbl_data_in>>1,descram_out[71]};atbl_data_out_split<={atbl_data_out>>1,descram_out[72]};atblrd_ptr_c_split<={atblrd_ptr_c>>1,descram_out[73]};tlp_wren_split<=descram_out[74];tlp_rden_split<=descram_out[75];atbl_empty_split<=descram_out[76];atbl_pempty_split<=descram_out[77];atbl_rden_c_split<=descram_out[78];atbl_empty_pr_split<=descram_out[79];tlp_empty_split<=descram_out[80];ld_rtry_staddr_split<=descram_out[81];tlp_size_end_split<=descram_out[82];rxdp_rtry_pr_split<=descram_out[83];rtry_rdy_pr_split<=descram_out[84];rtry_req_pr_split<=descram_out[85];nak_hold_timer_split<=descram_out[86];rply_tout_c_split<=descram_out[87];nak_rst_timer_split<=descram_out[88];ack_rst_timer_split<=descram_out[89];rst_timer_1_split<=descram_out[90];rst_timer_2_split<=descram_out[91];end
always@* begin descram_in[2047]<=ttlp_st;descram_in[2046]<=ttlp_end;descram_in[2045]<=temp[0];descram_in[2044]<=ttlp_nlfy;descram_in[2043]<=atbl_data_in[0];descram_in[2041]<=rxdp_seqnum[0];descram_in[2038]<=atbl_data_out[0];descram_in[2035]<=rxdp_ack;descram_in[2029]<=last_rtry_pkt;descram_in[2028]<=atblrd_ptr_c[0];descram_in[2022]<=rxdp_rtry;descram_in[2011]<=tlp_size_end_reg;descram_in[2009]<=tlp_wren;descram_in[1996]<=rxdp_purge;descram_in[1974]<=tlp_trns_end_reg;descram_in[1971]<=tlp_rden;descram_in[1945]<=tdmux_rtry_rdy;descram_in[1943]<=tlp_seq_num[0];descram_in[1922]<=tlp_size_cnt[0];descram_in[1901]<=rply_tout_pend;descram_in[1895]<=atbl_empty;descram_in[1857]<=rtry_rdy_pr;descram_in[1842]<=phy_l0;descram_in[1839]<=rtry_seq_num[0];descram_in[1797]<=atblwr_ptr[0];descram_in[1791]<=rtry_blk;descram_in[1778]<=rxdp_ack_reg;descram_in[1776]<=tlp_dcnt[0];descram_in[1759]<=phy_l0_reg;descram_in[1755]<=rtry_done_reg1;descram_in[1742]<=atbl_pempty;descram_in[1667]<=rtry_req_pr;descram_in[1652]<=tlp_empty;descram_in[1637]<=dl_inact;descram_in[1631]<=txtp_rtry_req1;descram_in[1622]<=tlp_end_reg;descram_in[1546]<=atblrd_ptr[0];descram_in[1535]<=atblwr_ptr_m[0];descram_in[1531]<=tmr_running;descram_in[1509]<=rtry_rdy_reg;descram_in[1504]<=tlp_st_addr[0];descram_in[1471]<=max_pl_size_reg[0];descram_in[1468]<=tlpwr_ptr[0];descram_in[1463]<=tout_hold_timer;descram_in[1437]<=atbl_rden_c;descram_in[1391]<=tlp_rden_int;descram_in[1312]<=rtlp_st_int;descram_in[1286]<=nak_hold_timer;descram_in[1256]<=ld_rtry_staddr;descram_in[1226]<=max_pl_size[0];descram_in[1215]<=purge_active;descram_in[1197]<=ttlp_nlfy_reg;descram_in[1153]<=rtlp_end_reg;descram_in[1050]<=nak_rst_timer;descram_in[1044]<=atbl_empty_reg;descram_in[1037]<=rtry_rdy_pr_reg;descram_in[1023]<=ttlp_data[0];descram_in[1022]<=tlprd_ptr_c[0];descram_in[1014]<=fst_rtlp_end;descram_in[971]<=tlp_seq_num_int[0];descram_in[961]<=tlp_size[0];descram_in[928]<=rxdp_rtry_pr;descram_in[895]<=dcnt_blk;descram_in[889]<=rxdp_purge_reg3;descram_in[888]<=tlprd_ptr[0];descram_in[879]<=retrain_hold_timer;descram_in[826]<=atbl_empty_pr;descram_in[811]<=tlp_st_reg;descram_in[765]<=rply_num_reg[0];descram_in[734]<=tlp_empty_reg;descram_in[695]<=tlp_wren_int;descram_in[656]<=tlp_rden_reg;descram_in[576]<=rtlp_end_int;descram_in[525]<=rply_tout_c;descram_in[518]<=rtry_atbl_staddr[0];descram_in[464]<=tlp_size_end;descram_in[444]<=rxdp_purge_reg2;descram_in[405]<=tlp_data_reg[0];descram_in[382]<=rply_num[0];descram_in[347]<=tlp_trns_end;descram_in[328]<=atbl_wren;descram_in[259]<=rtry_tlp_staddr[0];descram_in[222]<=rxdp_purge_reg1;descram_in[209]<=rst_timer_2;descram_in[164]<=atbl_rden_reg;descram_in[111]<=rxdp_purge_reg;descram_in[104]<=rst_timer_1;descram_in[82]<=atbl_rden;descram_in[55]<=rxdp_rtry_reg;descram_in[52]<=ack_rst_timer;descram_in[41]<=atbl_empty_reg1;descram_in[27]<=rtry_req_reg;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_XX_11


// File             : txtp_seq.v


// Title            :


// Dependencies     : 


// Description      : This module generates and inserts seuence number


//                    for each TLP received from transaction layer


//                    re-allign the data stream. 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Jan 24, 2004


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module txtp_seq #(
   parameter D_WIDTH  = 64,
   parameter ST_SEQ_NUM  = 12'd0, 
   parameter CAL_SEQ_NUM  = 12'd2048 )
   (
   input wire        sys_clk ,     
   input wire        rst_n ,       

   input wire [D_WIDTH-1:0] tlpgen_data , 
   input wire        tlpgen_st ,   
   input wire        tlpgen_end ,  
   input wire        tlpgen_nlfy , 

   input wire [11:0] ackd_seq ,    
   input wire        dl_inact ,    
   `ifdef X4
      input wire     tlpgen_tval , 
      input wire     tlpgen_dwen , 
      output reg     ttlp_dwen ,   
   `endif

   output wire       seq_pause ,   

   output reg [D_WIDTH-1:0] ttlp_data ,   
   output reg        ttlp_st ,     
   output reg        ttlp_end ,    
   output reg        ttlp_nlfy ,   
   output reg [11:0] txtp_nxtseq   // current sequence num.


  ) ;
reg [D_WIDTH-1:0]     tlpgen_data_reg ;
reg                   tlpgen_end_reg ;
reg                   tlpgen_nlfy_reg ;
reg                   tlp_val ;

`ifdef X4
reg                tlpgen_dwen_reg ;
reg                tlpgen_st_reg ;
reg [15:0]         data_reg ;
reg                tlpgen_end_reg2 ;
reg                tlpgen_nlfy_reg2 ;
reg                tlpgen_dwen_reg2 ;

`endif
wire [11:0]           cmp_ackd_seq ;
wire                  calc ;

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif
reg [D_WIDTH - 1 : 0] tlpgen_data_split;
reg tlpgen_st_split;
reg tlpgen_end_split;
reg tlpgen_nlfy_split;
reg [11 : 0] ackd_seq_split;
reg dl_inact_split;
reg tlpgen_end_reg_split;
reg tlpgen_nlfy_reg_split;
reg tlp_val_split;
reg [11 : 0] cmp_ackd_seq_split;
reg calc_split;
reg [2047:0] descram_in;
wire [10:0] descram_out;

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

localparam descram_inst_SIZE = 11,descram_inst_SCRAMSTRING = 32'hfdffe0cb;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X4


`endif


`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif

// =============================================================================


`ifdef X4


   

`endif



//parameter ST_SEQ_NUM   = 12'd0 ;
//parameter CAL_SEQ_NUM  = 12'd2048 ;

// =============================================================================
// The data stream is capyured based on start of TLP, end of packet and 
// nullified packet indications from the transaction layer. 
// The 12 bits of sequence number and 4 bits of reserved field are added 
// to the begining of the TLP data and 32 bit data stream is re-alligned.
// =============================================================================

// Pipeline packet data and boundary indication signals 


`ifdef X1


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) begin 
         tlpgen_end_reg  <= 1'b0 ;
         tlpgen_nlfy_reg <= 1'b0 ;
         tlpgen_data_reg <= {D_WIDTH{1'b0}} ;
      end  
      else begin  
         tlpgen_end_reg  <= tlpgen_end_split ;
         tlpgen_nlfy_reg <= tlpgen_nlfy_split ;
         tlpgen_data_reg <= tlpgen_data_split ;
      end  
   end


`endif




`ifdef X4


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) begin 
         tlpgen_end_reg  <= 1'b0 ;
         tlpgen_nlfy_reg <= 1'b0 ;
         tlpgen_data_reg <= {D_WIDTH{1'b0}} ;
         tlpgen_dwen_reg <= 1'b0 ;
         tlpgen_st_reg   <= 1'b0 ;

         tlpgen_end_reg2  <= 1'b0 ;
         tlpgen_nlfy_reg2 <= 1'b0 ;
         tlpgen_dwen_reg2 <= 1'b0 ;
      end  
      else if (tlpgen_tval) begin  
         tlpgen_end_reg  <= tlpgen_end_split ;
         tlpgen_nlfy_reg <= tlpgen_nlfy_split ;
         tlpgen_data_reg <= tlpgen_data_split ;
         tlpgen_dwen_reg <= tlpgen_dwen ;
         tlpgen_st_reg   <= tlpgen_st_split ;

         tlpgen_end_reg2  <= tlpgen_end_reg_split ;
         tlpgen_nlfy_reg2 <= tlpgen_nlfy_reg_split ;
         tlpgen_dwen_reg2 <= tlpgen_dwen_reg ;

      end  
   end


`endif





`ifdef X1


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) begin 
         ttlp_st         <= 1'b0 ;
         ttlp_end        <= 1'b0 ;
         ttlp_nlfy       <= 1'b0 ;
      end  
      else begin  
         ttlp_st         <= tlpgen_st_split ;
         ttlp_end        <= tlpgen_end_reg_split ;
         ttlp_nlfy       <= tlpgen_nlfy_reg_split ;
      end  
   end


`endif




`ifdef X4


   // Generate end of TLP signals based on Dword enable,
   // after adding 16 bits of reserved field and sequence number
   // the end of TLP can move based on transaction layer TLP is
   // ending on odd/even 32 bit boundary.
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) begin  
         ttlp_st   <= 1'b0 ;
         ttlp_end  <= 1'b0 ;
         ttlp_nlfy <= 1'b0 ;
         ttlp_dwen <= 1'b0 ;
      end
      else begin
	 if (tlpgen_tval)
            ttlp_st <= tlpgen_st_reg ;

	 if (tlpgen_dwen_reg & tlpgen_tval) begin  
            ttlp_end  <= tlpgen_end_reg_split ;
            ttlp_nlfy <= tlpgen_nlfy_reg_split ;
            ttlp_dwen <= ~tlpgen_dwen_reg & (tlpgen_end_reg_split | tlpgen_nlfy_reg_split)  ;
         end
         else if (tlpgen_tval) begin
            if (!tlpgen_dwen_reg2) begin  
               ttlp_end  <= tlpgen_end_reg2 ;
               ttlp_nlfy <= tlpgen_nlfy_reg2 ;
               ttlp_dwen <= ~tlpgen_dwen_reg2 & (tlpgen_end_reg2 | tlpgen_nlfy_reg2)  ;
            end
            else begin  
               ttlp_end  <= 1'b0 ;
               ttlp_nlfy <= 1'b0 ;
               ttlp_dwen <= 1'b0 ;
            end
         end
      end
   end


`endif





`ifdef X1


   // Generate TLP valid boundary
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) 
         tlp_val  <= 1'b0 ;
      else if (tlpgen_st_split) 
         tlp_val  <= 1'b1 ;
      else if (tlpgen_end_reg_split) 
         tlp_val  <= 1'd0 ;
   end

   // Insert sequence number and reserved field in the begining of the TLP
   // data and re-allign the data stream
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) 
         ttlp_data  <= 16'd0 ;
      else if (tlpgen_st_split) 
         ttlp_data  <= txtp_nxtseq ;
      else if (tlp_val_split)
         ttlp_data  <= tlpgen_data_reg ;
      else 
         ttlp_data  <= 16'd0 ;
   end


`endif




`ifdef X4


   // Generate TLP valid boundary
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) 
         tlp_val  <= 1'b0 ;
      else if (tlpgen_st_reg && tlpgen_tval) 
         tlp_val  <= 1'b1 ;
      else if (ttlp_end && tlpgen_tval) 
         tlp_val  <= 1'd0 ;
   end

   // Insert sequence number and reserved field in the begining of the TLP
   // data and re-allign the data stream
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) begin 
         data_reg <= 16'd0 ;
         ttlp_data  <= 64'd0 ;
      end
      else begin
         // Latch input data stream when data is valid only lower
         // 16 bits are enough, which are used for re-alignment.
         if (tlpgen_st_reg || tlpgen_tval) 
            data_reg <= tlpgen_data_reg[15:0] ;
         else  
            data_reg <= data_reg ;

         case (1'b1)
            tlpgen_st_reg & tlpgen_tval  :  
               ttlp_data  <= {4'b0000, txtp_nxtseq, tlpgen_data_reg[63:16]} ;
            tlpgen_tval & tlp_val_split : 
               ttlp_data  <= {data_reg, tlpgen_data_reg[63:16]} ;
            tlpgen_end_reg_split & tlpgen_tval :  
               ttlp_data  <= {data_reg, 48'h0000_0000_0000} ;
            tlpgen_nlfy_reg_split & tlpgen_tval : 
               ttlp_data  <= {data_reg, 48'h0000_0000_0000} ;
            tlpgen_tval : 
               ttlp_data  <= 64'd0 ;
            default : 
               ttlp_data  <= ttlp_data ;
         endcase
      end
   end


`endif



// Generation of NXT_TX_SEQ sequence number,
// incremented with end of every TLP got from 
// transaction layer not with nullified packets.
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      txtp_nxtseq <= ST_SEQ_NUM ;
   else if (dl_inact_split)
      txtp_nxtseq <= ST_SEQ_NUM ;
   

`ifdef X1


      else if (tlpgen_end_split)
         txtp_nxtseq <= txtp_nxtseq + 12'h001 ;
   

`endif


   

`ifdef X4


      else if (tlpgen_end_split && tlpgen_tval)
         txtp_nxtseq <= txtp_nxtseq + 12'h001 ;
   

`endif


   else 
      txtp_nxtseq <= txtp_nxtseq ;
end

// =============================================================================
// Block the request from transaction layer to arbiter 
// if "(txtp_nxtseq - ackd_seq)mod 4096 >= 2048"
// =============================================================================
// 2's complement of ackd_seq number.
assign cmp_ackd_seq = ((~ackd_seq_split) + 12'h001) ;

// Compute the equation "(txtp_nxtseq - ackd_seq)mod 4096 >= 2048".
// This is same as "(txtp_nxtseq + 2's complement ackd_seq) >= 2048".
// Number 2048 is taken through parameter CAL_SEQ_NUM as it is
// easy to force in different test cases.
assign calc = ((txtp_nxtseq + cmp_ackd_seq_split) >= CAL_SEQ_NUM ) ; 

assign seq_pause = calc_split  ;

always@* begin tlpgen_data_split<={tlpgen_data>>1,descram_out[0]};tlpgen_st_split<=descram_out[1];tlpgen_end_split<=descram_out[2];tlpgen_nlfy_split<=descram_out[3];ackd_seq_split<={ackd_seq>>1,descram_out[4]};dl_inact_split<=descram_out[5];tlpgen_end_reg_split<=descram_out[6];tlpgen_nlfy_reg_split<=descram_out[7];tlp_val_split<=descram_out[8];cmp_ackd_seq_split<={cmp_ackd_seq>>1,descram_out[9]};calc_split<=descram_out[10];end
always@* begin descram_in[2047]<=tlpgen_st;descram_in[2046]<=tlpgen_end;descram_in[2044]<=tlpgen_nlfy;descram_in[2040]<=ackd_seq[0];descram_in[2033]<=dl_inact;descram_in[2018]<=tlpgen_end_reg;descram_in[1988]<=tlpgen_nlfy_reg;descram_in[1929]<=tlp_val;descram_in[1811]<=cmp_ackd_seq[0];descram_in[1574]<=calc;descram_in[1023]<=tlpgen_data[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_XX_11


// File             : txtp.v


// Title            :


// Dependencies     : txtp_seq.v


//                    txtp_cins.v


//                    txtp_rtry.v 


// Description      : This module is top level for "txtp block.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Jan 24, 2004


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module txtp #(
   parameter FADDR = 3,
   parameter D_WIDTH  = 64 )
   (
   input wire            sys_clk ,         
   input wire            rst_n ,           

   input wire            tlpgen_req ,      
   input wire [D_WIDTH-1:0]     tlpgen_data ,     
   input wire            tlpgen_st ,       
   input wire            tlpgen_end ,      
   input wire            tlpgen_nlfy ,     
   input wire            tlpgen_rdy_ack ,  

   input wire [11:0]     rxdp_seqnum ,     
   input wire            rxdp_ack ,        
   input wire            rxdp_rtry ,       
   input wire            rxdp_purge ,      

   input wire            dl_inact ,        
   input wire [FADDR:0]  dll_pause_cnt ,   
   input wire            phy_l0 ,          
   input wire [2:0]      max_pl_size ,     
   `ifdef X4
      input wire         tlpgen_tval ,     
      input wire         tlpgen_dwen ,     
      output wire        txtp_tval ,       
      output wire        txtp_dwen ,       
   `endif

   output wire           txtp_rdy ,        
   output wire           txtp_pause_ack ,
   output wire [D_WIDTH-1:0]    txtp_tdata ,      
   output wire           txtp_erly_val ,   
   output wire           txtp_st ,         
   output wire           txtp_end ,        
   output wire           txtp_edb ,        

   output wire           tx_rbuf_empty ,  
   output wire           txtp_rtry_done ,  
   output wire [11:0]    txtp_nxtseq ,     
   output wire           txtp_rply_tout ,  
   output wire           txtp_rnum_rlor    // Replay number roll over indication


   ) ;
wire[D_WIDTH-1:0]    ttlp_data ;
wire[D_WIDTH-1:0]    rtlp_data ;
wire[D_WIDTH-1:0]    comb_data ;

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif
reg rst_n_split;
reg tlpgen_req_split;
reg [D_WIDTH - 1 : 0] tlpgen_data_split;
reg tlpgen_st_split;
reg tlpgen_end_split;
reg tlpgen_nlfy_split;
reg tlpgen_rdy_ack_split;
reg [11 : 0] rxdp_seqnum_split;
reg rxdp_ack_split;
reg rxdp_rtry_split;
reg rxdp_purge_split;
reg dl_inact_split;
reg [FADDR : 0] dll_pause_cnt_split;
reg phy_l0_split;
reg [2 : 0] max_pl_size_split;
reg [D_WIDTH - 1 : 0] rtlp_data_split;
reg [D_WIDTH - 1 : 0] comb_data_split;
reg [2047:0] descram_in;
wire [16:0] descram_out;


`ifdef X4

`endif


`ifdef X4

`endif


`ifdef X4

`endif


`ifdef X4

`endif

localparam descram_inst_SIZE = 17,descram_inst_SCRAMSTRING = 32'hfdffe06b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X4



`endif

// =============================================================================

txtp_seq #(
   .D_WIDTH              ( D_WIDTH ) )
   u1_txtp_seq (
   // Clock and Reset
   .sys_clk       ( sys_clk ) ,
   .rst_n         ( rst_n_split ),

   // Inputs
   .tlpgen_data   ( tlpgen_data_split ) ,
   .tlpgen_st     ( tlpgen_st_split ) ,
   .tlpgen_end    ( tlpgen_end_split ) ,
   .tlpgen_nlfy   ( tlpgen_nlfy_split ) ,

   .ackd_seq      ( rxdp_seqnum_split ) ,
   .dl_inact      ( dl_inact_split  ) ,

   

`ifdef X4


      .tlpgen_tval( tlpgen_tval ) ,
      .tlpgen_dwen( tlpgen_dwen ) ,
      .ttlp_dwen  ( ttlp_dwen ) ,
   

`endif


   // Outputs
   .seq_pause     ( seq_num_pause ) ,
   .ttlp_data     ( ttlp_data ) ,
   .ttlp_st       ( ttlp_st ) ,
   .ttlp_end      ( ttlp_end ) ,
   .ttlp_nlfy     ( ttlp_nlfy ) ,
   .txtp_nxtseq   ( txtp_nxtseq )
  ) ;

  txtp_rtry #(
   .D_WIDTH              ( D_WIDTH ) )
   u1_txtp_rtry (
   // Clock and Reset
   .sys_clk        ( sys_clk ) ,
   .rst_n          ( rst_n_split ),

   // Inputs
   .ttlp_data      ( ttlp_data ) ,
   .ttlp_st        ( ttlp_st ) ,
   .ttlp_end       ( ttlp_end ) ,
   .ttlp_nlfy      ( ttlp_nlfy ) ,


   .rxdp_seqnum    ( rxdp_seqnum_split ) ,
   .rxdp_ack       ( rxdp_ack_split ) ,
   .rxdp_rtry      ( rxdp_rtry_split ) ,
   .rxdp_purge     ( rxdp_purge_split ) ,

   .tdmux_rtry_rdy ( rtry_rdy ) ,
   .dl_inact       ( dl_inact_split  ) ,
   .phy_l0         ( phy_l0_split ) ,
   .max_pl_size    ( max_pl_size_split ),
   

`ifdef X4


      .ttlp_tval   ( tlpgen_tval ) ,
      .ttlp_dwen   ( ttlp_dwen ) ,
      .rtlp_tval   ( ) ,
      .rtlp_dwen   ( rtlp_dwen ) ,
   

`endif



   // Outputs
   .txtp_rtry_req  ( rtry_req ) ,
   .rtlp_data      ( rtlp_data ) ,
   .rtlp_st        ( rtlp_st ) ,
   .rtlp_end       ( rtlp_end ) ,
   .txtp_ertlp_end ( ertlp_end ) ,
   .txtp_block     ( rb_size_pause ) ,

   .tx_rbuf_empty  ( tx_rbuf_empty ) ,
   .txtp_rtry_done ( txtp_rtry_done ) ,
   .txtp_rply_tout ( txtp_rply_tout ) ,  
   .txtp_rnum_rlor ( rnum_rlor )  
   ) ;

txtp_mux #(
   .FADDR         ( FADDR ),
   .D_WIDTH       ( D_WIDTH ) )
   u1_txtp_mux (
   // Clock and Reset
   .sys_clk       ( sys_clk ) ,
   .rst_n         ( rst_n_split ),

   // Inputs
   .tlpgen_req     ( tlpgen_req_split ) ,
   .tlpgen_rdy_ack ( tlpgen_rdy_ack_split ) ,
   .rtry_req       ( rtry_req ) ,
   .seq_num_pause  ( seq_num_pause ) ,
   .rb_size_pause  ( rb_size_pause ) ,
   .dll_pause_cnt  ( dll_pause_cnt_split ) ,
   .phy_l0         ( phy_l0_split ) ,
   .rnum_rlor      ( rnum_rlor ) ,

   .ttlp_data      ( ttlp_data ) ,
   .ttlp_st        ( ttlp_st ) ,
   .ttlp_end       ( ttlp_end ) ,
   .ttlp_nlfy      ( ttlp_nlfy ) ,

   .rtlp_data      ( rtlp_data_split ) ,
   .rtlp_st        ( rtlp_st ) ,
   .rtlp_end       ( rtlp_end ) ,
   .ertry_end      ( ertlp_end ) ,
   

`ifdef X4


      .ttlp_tval   ( tlpgen_tval ) ,
      .ttlp_dwen   ( ttlp_dwen ) ,
      .rtlp_dwen   ( rtlp_dwen ) ,
      .comb_tval   ( comb_tval ) ,
      .comb_dwen   ( comb_dwen ) , 
   

`endif



   // Outputs
   .txtp_rdy       ( txtp_rdy ) ,
   .rtry_rdy       ( rtry_rdy ) ,
   .txtp_pause_ack ( txtp_pause_ack ) ,
   .txtp_rnum_rlor ( txtp_rnum_rlor ) ,

   .comb_data      ( comb_data ) ,
   .comb_st        ( comb_st ) ,
   .comb_end       ( comb_end ) ,
   .comb_edb       ( comb_edb ) 
  ) ;

txtp_cins #(
   .D_WIDTH              ( D_WIDTH ) )
   u1_txtp_cins (
   // Clock and Reset
   .sys_clk       ( sys_clk ) ,
   .rst_n         ( rst_n_split ),

   // Inputs
   .comb_data     ( comb_data_split ) ,
   .comb_st       ( comb_st ) ,
   .comb_end      ( comb_end ) ,
   .comb_edb      ( comb_edb ) , 
   

`ifdef X4


      .comb_tval ( comb_tval ) ,
      .comb_dwen ( comb_dwen ) ,
      .txtp_tval ( txtp_tval ) ,
      .txtp_dwen ( txtp_dwen ) ,
   

`endif



   // Outputs
   .txtp_tdata    ( txtp_tdata ) ,
   .txtp_erly_val ( txtp_erly_val ) ,
   .txtp_st       ( txtp_st ) ,
   .txtp_end      ( txtp_end ) ,
   .txtp_edb      ( txtp_edb ) 
  ) ;


always@* begin rst_n_split<=descram_out[0];tlpgen_req_split<=descram_out[1];tlpgen_data_split<={tlpgen_data>>1,descram_out[2]};tlpgen_st_split<=descram_out[3];tlpgen_end_split<=descram_out[4];tlpgen_nlfy_split<=descram_out[5];tlpgen_rdy_ack_split<=descram_out[6];rxdp_seqnum_split<={rxdp_seqnum>>1,descram_out[7]};rxdp_ack_split<=descram_out[8];rxdp_rtry_split<=descram_out[9];rxdp_purge_split<=descram_out[10];dl_inact_split<=descram_out[11];dll_pause_cnt_split<={dll_pause_cnt>>1,descram_out[12]};phy_l0_split<=descram_out[13];max_pl_size_split<={max_pl_size>>1,descram_out[14]};rtlp_data_split<={rtlp_data>>1,descram_out[15]};comb_data_split<={comb_data>>1,descram_out[16]};end
always@* begin descram_in[2047]<=tlpgen_req;descram_in[2046]<=tlpgen_data[0];descram_in[2044]<=tlpgen_st;descram_in[2041]<=tlpgen_end;descram_in[2034]<=tlpgen_nlfy;descram_in[2021]<=tlpgen_rdy_ack;descram_in[1995]<=rxdp_seqnum[0];descram_in[1943]<=rxdp_ack;descram_in[1855]<=comb_data[0];descram_in[1838]<=rxdp_rtry;descram_in[1628]<=rxdp_purge;descram_in[1487]<=max_pl_size[0];descram_in[1209]<=dl_inact;descram_in[1023]<=rst_n;descram_in[927]<=rtlp_data[0];descram_in[743]<=phy_l0;descram_in[371]<=dll_pause_cnt[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          :  PCI_EXP_X4_11


// File             : cfg_dec.v


// Title            :


// Dependencies     : 


// Description      : 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Feb 21, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module cfg_dec1 (
   input wire          sys_clk ,      
   input wire          rst_n ,        

   input wire [63:0]   tlp_data ,     
   input wire          tlp_st ,       
   input wire          tlp_end ,      
   input wire          tlp_erly_st ,  
   input wire          phy_link_up ,  
   input wire          term_all_cfg , 

   `ifdef ECRC
      input wire       tlp_ecrc_ok ,  
      input wire       ecrc_chk_enb , 
   `endif

   
   input wire [9:0]    ADR_I ,        
   input wire [31:0]   DAT_I ,        
   input wire          WE_I ,         
   input wire          STB_I ,        

   
   input wire          s2e_cnt_err ,   

   output reg [7:0]    bus_num ,
   output reg [4:0]    dev_num ,
   output reg [2:0]    func_num ,
   output reg [15:0]   req_id ,
   output reg [7:0]    tag ,
   output reg [2:0]    tc ,

   output reg          reg_sel_t0 ,   
   output reg          reg_sel_pmsi , 
   output reg          reg_sel_cs ,   
   output reg          reg_sel_ec ,   
   `ifdef AER
      output reg       reg_sel_aer ,  
   `endif
   output reg          reg_sel_usp ,  
   output reg          reg_id_hit ,   
   output reg          type1_cfg ,    
   output reg          pois_cfg ,     
   output reg          cfg_hit ,
   output reg          nph_processed , 
   output reg          npd_processed , 

   output wire [5:0]   reg_addr ,     
   output wire [31:0]  reg_wdata ,    
   output wire [3:0]   reg_wdata_be , 
   output wire         reg_wr_t1 ,    
   output wire         reg_wr_pois ,  
   output wire         reg_wr ,       
   output wire         reg_rd ,       
   output reg          reg_rd_cpm ,   
   output reg          reg_wr_cpm ,   
   output reg          ecrc_ok        // ECRC is OK  


   ) ;
reg         cfgwr_tlp ;
reg         cfgrd_tlp ;
reg [3:0]   ereg_addr_tlp ;
reg [5:0]   reg_addr_tlp ;
reg [31:0]  reg_wdata_tlp ;
reg [3:0]   reg_be_tlp ;
reg         reg_wr_tlp ;
reg         reg_rd_tlp ;
reg         reg_wr_tlp1 ;
reg         reg_rd_tlp1 ;
reg         reg_rd_tlp2 ;
reg         reg_wrd_cpm1 ;
reg         reg_wrd_cpm2 ;
reg         tlp_addr_sel ;
reg         tlp_st_reg1 ;
reg         tlp_end_reg1 ;
reg         tlp_end_reg2 ;
reg         tlp_end_reg3 ;
reg [2:0]   func_num_rw ;
reg [15:0]  req_id1 ;
reg [15:0]  req_id2 ;
reg [7:0]   tag1 ;
reg [7:0]   tag2 ;
reg [2:0]   tc1 ;
reg [2:0]   tc2 ;
reg         type1_cfg_int ;
reg         type1_cfg_int1 ;
reg         pois_cfg_int ;
reg         pois_cfg_int1 ;

`ifdef ECRC
reg      td_d0 ;
wire     td ;

`endif
reg         cfg_chk;
reg         ecrc_ok_d0;
reg         ecrc_ok_d1;
reg         s2e_cnt_err_d0;
wire [9:0]  tlp_addr ;
wire [9:0]  reg_addr_comb ;
wire        ecrc_ok_c ;

`ifdef ECRC

`endif

`ifdef GEN2

`else

`endif

`ifdef AER

`endif

`ifdef AER

`endif

`ifdef GEN2

`else

`endif

`ifdef VC1

`endif

`ifdef VC2

`endif

`ifdef VC3

`endif

`ifdef VC4

`endif

`ifdef VC5

`endif

`ifdef VC6

`endif

`ifdef VC7

`endif

`ifdef VC8

`endif

`ifdef AER

`else

`endif

`ifdef ECRC

`else

`endif
reg [63 : 0] tlp_data_split;
reg tlp_st_split;
reg tlp_end_split;
reg tlp_erly_st_split;
reg phy_link_up_split;
reg term_all_cfg_split;
reg [9 : 0] ADR_I_split;
reg [31 : 0] DAT_I_split;
reg WE_I_split;
reg STB_I_split;
reg s2e_cnt_err_split;
reg cfgrd_tlp_split;
reg [3 : 0] ereg_addr_tlp_split;
reg [5 : 0] reg_addr_tlp_split;
reg [31 : 0] reg_wdata_tlp_split;
reg [3 : 0] reg_be_tlp_split;
reg reg_wr_tlp_split;
reg reg_rd_tlp_split;
reg reg_wr_tlp1_split;
reg reg_rd_tlp1_split;
reg reg_rd_tlp2_split;
reg reg_wrd_cpm1_split;
reg reg_wrd_cpm2_split;
reg tlp_addr_sel_split;
reg tlp_st_reg1_split;
reg tlp_end_reg1_split;
reg tlp_end_reg2_split;
reg tlp_end_reg3_split;
reg [2 : 0] func_num_rw_split;
reg [15 : 0] req_id1_split;
reg [15 : 0] req_id2_split;
reg [7 : 0] tag1_split;
reg [7 : 0] tag2_split;
reg [2 : 0] tc1_split;
reg [2 : 0] tc2_split;
reg type1_cfg_int_split;
reg type1_cfg_int1_split;
reg pois_cfg_int_split;
reg pois_cfg_int1_split;
reg cfg_chk_split;
reg ecrc_ok_d0_split;
reg ecrc_ok_d1_split;
reg s2e_cnt_err_d0_split;
reg [9 : 0] tlp_addr_split;
reg [9 : 0] reg_addr_comb_split;
reg ecrc_ok_c_split;
reg [2047:0] descram_in;
wire [45:0] descram_out;

`ifdef ECRC

`endif

`ifdef ECRC

`endif

`ifdef GEN2

`else

`endif

`ifdef AER

`endif

`ifdef AER

`endif

`ifdef GEN2

`else

`endif

`ifdef VC1

`endif

`ifdef VC2

`endif

`ifdef VC3

`endif

`ifdef VC4

`endif

`ifdef VC5

`endif

`ifdef VC6

`endif

`ifdef VC7

`endif

`ifdef VC8

`endif

`ifdef AER

`else

`endif

`ifdef ECRC

`else

`endif

localparam descram_inst_SIZE = 46,descram_inst_SCRAMSTRING = 32'hfdfff10b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef ECRC


`endif


`ifdef ECRC



`endif



`ifdef GEN2



`else



`endif



`ifdef AER



`endif



`ifdef AER



`endif



`ifdef GEN2



`else



`endif



`ifdef VC1



`endif



`ifdef VC2



`endif



`ifdef VC3



`endif



`ifdef VC4



`endif



`ifdef VC5



`endif



`ifdef VC6



`endif



`ifdef VC7



`endif



`ifdef VC8



`endif



`ifdef AER



`else



`endif



`ifdef ECRC



`else



`endif

// =============================================================================


`ifdef ECRC


   

`endif


// Decode config read and write type
assign cfg_dec = (tlp_data_split[61:57] == 5'b0_0010); // decode both tye0 and type1

assign cfgwr_dec = tlp_data_split[62] & cfg_dec  ;
assign cfgrd_dec = ~tlp_data_split[62] & cfg_dec ;

// Generate config read and write TLP indications for the length of TLP
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      cfgwr_tlp <= 1'b0;
   else if (tlp_st_split && cfgwr_dec) 
      cfgwr_tlp <= 1'b1;
   else if (tlp_end_reg1_split && !tlp_st_split) 
      cfgwr_tlp <= 1'b0;
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      cfgrd_tlp <= 1'b0;
   else if (tlp_st_split && cfgrd_dec) 
      cfgrd_tlp <= 1'b1;
   else if (tlp_end_reg1_split & !tlp_st_split) 
      cfgrd_tlp <= 1'b0;
end


// =============================================================================
// Extract different componebts of config read/write TLP
// =============================================================================
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin
      tc1     <= 2'b00;
      req_id1 <= 16'd0;
      tag1    <= 8'd0;
   end
   else if (tlp_st_split && cfg_dec) begin
      tc1     <= tlp_data_split[54:52];
      req_id1 <= tlp_data_split[31:16];
      tag1    <= tlp_data_split[15: 8];
   end
end
// pipeline extracted fieds to align with reg_rd_wr signals
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin
      tc2     <= 2'b00;
      tc      <= 2'b00;
      req_id2 <= 16'd0;
      req_id  <= 16'd0;
      tag2    <= 8'd0;
      tag     <= 8'd0;
   end
   else begin
      tc2     <= tc1_split;
      tc      <= tc2_split;
      req_id2 <= req_id1_split;
      req_id  <= req_id2_split;
      tag2    <= tag1_split;
      tag     <= tag2_split;
   end
end



`ifdef ECRC


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) 
         td_d0 <= 1'b0;
      else 
         td_d0 <= td;
   end
assign td = (tlp_st_split && cfg_dec) ? tlp_data_split[47] : td_d0; 


`endif



always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin
      cfg_chk    <= 1'b0;
   end
   else if (tlp_st_split) begin
   

`ifdef GEN2


      //TC =000, ATRR=00, AT=00, Len=1, Last DW BE = 4'b0000
      cfg_chk <= (tlp_data_split[54:52] == 3'b000) && (tlp_data_split[45:44] == 2'b00) &&
                 (tlp_data_split[43:42] == 2'b00) && (tlp_data_split[41:32] == 10'd1) && (tlp_data_split[7:4] == 4'b0000);
   

`else


      //TC =000, ATRR=00, Len=1, Last DW BE = 4'b0000
      cfg_chk <= (tlp_data_split[54:52] == 3'b000) && (tlp_data_split[45:44] == 2'b00) &&
                 (tlp_data_split[41:32] == 10'd1) && (tlp_data_split[7:4] == 4'b0000);
   

`endif


   end
   else if (tlp_end_reg1_split & !tlp_end_split) begin
      cfg_chk    <= 1'b0;
   end
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin
      bus_num       <= 8'd0;
      dev_num       <= 5'd0;
      func_num      <= 3'd0;
   end
   else if (!phy_link_up_split) begin
      bus_num       <= 8'd0 ;
      dev_num       <= 5'd0 ;
      func_num      <= 3'd0 ;
   end
   //else if (tlp_st_reg1 && cfgwr_tlp && cfg_chk && ecrc_ok_c) begin
   // Don't do this optional check for these field for config packets.
   // malformed_tlp needs to be generated if fields are not correct.
   else if (tlp_st_reg1_split && cfgwr_tlp && ecrc_ok_c_split) begin
      bus_num       <= tlp_data_split[63:56];
      dev_num       <= tlp_data_split[55:51];
      func_num      <= 3'd0;
   end
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      reg_wdata_tlp <= 32'd0;
   else if (tlp_st_reg1_split && cfgwr_tlp) 
      reg_wdata_tlp <= {tlp_data_split[7:0],tlp_data_split[15:8],
                        tlp_data_split[23:16],tlp_data_split[31:24]} ;
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      reg_be_tlp <= 4'h0;
   else if (tlp_st_split && cfgwr_dec) 
      reg_be_tlp <= tlp_data_split[3:0];
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin
      ereg_addr_tlp <= 4'hF ;
      reg_addr_tlp  <= 6'h3F ;
   end
   else if (tlp_st_reg1_split && (cfgwr_tlp || cfgrd_tlp_split) ) begin
      ereg_addr_tlp <= tlp_data_split[43:40] ;
      reg_addr_tlp  <= tlp_data_split[39:34] ;
   end
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      reg_rd_tlp    <= 1'b0 ;
      reg_wr_tlp    <= 1'b0 ;
   end
   else begin
      //reg_rd_tlp <= (tlp_end_reg1 & cfgrd_tlp & cfg_chk & ecrc_ok_d1) ;
      //reg_wr_tlp <= (tlp_end_reg1 & cfgwr_tlp & cfg_chk & ecrc_ok_d1) ;
      // Don't do this optional check for these field for config packets.
      // malformed_tlp needs to be generated if fields are not correct.
      reg_rd_tlp <= (tlp_end_reg1_split & cfgrd_tlp_split & ecrc_ok_d1_split) ;
      reg_wr_tlp <= (tlp_end_reg1_split & cfgwr_tlp & ecrc_ok_d1_split) ;
   end
end

// Extract function number from config read/write
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      func_num_rw <= 3'd0;
   else if (tlp_st_reg1_split && (cfgrd_tlp_split || cfgwr_tlp) ) 
      func_num_rw <= tlp_data_split[50:48];
end


always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      reg_id_hit <= 1'b0 ;  
   else 
      reg_id_hit <= (func_num_rw_split == func_num) ;
end

// Decode for type1 cfgs
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      type1_cfg_int  <= 1'd0 ;
   else if (tlp_st_split & (tlp_data_split[61:56] == 6'b0_00101)) 
      type1_cfg_int <= 1'b1 ;
   else if (tlp_end_reg1_split) 
      type1_cfg_int  <= 1'd0 ;
end
// Decode for Poisoned(EP) cfgWr TLP
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      pois_cfg_int  <= 1'd0 ;
   else if (tlp_st_split && cfgwr_dec && (tlp_data_split[46] == 1'b1)) 
      pois_cfg_int <= 1'b1 ;
   else if (tlp_end_reg1_split) 
      pois_cfg_int  <= 1'd0 ;
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      type1_cfg_int1 <= 1'd0 ;
      type1_cfg      <= 1'd0 ;
      pois_cfg_int1  <= 1'd0 ;
      pois_cfg       <= 1'd0 ;
   end
   else begin  
      type1_cfg_int1 <= type1_cfg_int_split ;
      type1_cfg      <= type1_cfg_int1_split ;
      pois_cfg_int1  <= pois_cfg_int_split ;
      pois_cfg       <= pois_cfg_int1_split ;
   end
end

// =============================================================================
// Decode selects for different register sets.
// Type 0 Registers            : 000h - 03Ch
// PM Capability structure     : 050h - 054h
// MSI Capability structure    : 070h - 07Ch
// PCIE Capability structure   : 090h - 0A0h
// PCIE Capability structure-2 : 0B4h - 0C0h : Only for Gen 2
// Device serial no. structure : 100h - 108h 
// VC Capability structure     : 10Ch - 178h
// =============================================================================
assign tlp_addr = {ereg_addr_tlp_split[3:0],reg_addr_tlp_split[5:4], reg_addr_tlp_split[3:0]} ;

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      tlp_st_reg1  <= 1'b0 ;  
      tlp_end_reg1 <= 1'b0 ;  
      tlp_end_reg2 <= 1'b0 ;  
      tlp_end_reg3 <= 1'b0 ;  
      reg_rd_tlp1  <= 1'b0 ;  
      reg_rd_tlp2  <= 1'b0 ;  
      reg_wr_tlp1  <= 1'b0 ;  
   end
   else begin 
      tlp_st_reg1  <= tlp_st_split ;  
      tlp_end_reg1 <= tlp_end_split ;  
      tlp_end_reg2 <= tlp_end_reg1_split ;  
      tlp_end_reg3 <= tlp_end_reg2_split ;  
      reg_rd_tlp1  <= reg_rd_tlp_split  ;  
      reg_rd_tlp2  <= reg_rd_tlp1_split  ;  
      reg_wr_tlp1  <= reg_wr_tlp_split ;  
   end
end


always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      tlp_addr_sel <= 1'b0 ;   
   else if (tlp_st_split && tlp_data_split[60:57] == 5'b0010)
      tlp_addr_sel <= 1'b1 ;  
   else if (tlp_end_reg3_split &&  !tlp_st_split && !tlp_st_reg1_split && !cfgwr_tlp && !cfgrd_tlp_split)
      tlp_addr_sel <= 1'b0 ;  
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      reg_rd_cpm <= 1'b0 ;  
   else if (!tlp_addr_sel_split && ~WE_I_split && STB_I_split && !reg_rd_cpm && !reg_wrd_cpm1_split && !reg_wrd_cpm2_split && !(tlp_st_split & cfg_dec) )
      reg_rd_cpm <= 1'b1 ;  
   else 
      reg_rd_cpm <= 1'b0 ;  
end
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      reg_wr_cpm <= 1'b0 ;  
   else if (!tlp_addr_sel_split && WE_I_split && STB_I_split && !reg_wr_cpm && !reg_wrd_cpm1_split && !reg_wrd_cpm2_split && !(tlp_st_split & cfg_dec) )
      reg_wr_cpm <= 1'b1 ;  
   else 
      reg_wr_cpm <= 1'b0 ;  
end
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin  
      reg_wrd_cpm1 <= 1'b0 ;  
      reg_wrd_cpm2 <= 1'b0 ;  
   end  
   else begin  
      reg_wrd_cpm1 <= reg_rd_cpm | reg_wr_cpm ;  
      reg_wrd_cpm2 <= reg_wrd_cpm1_split ;  
   end  
end

assign reg_addr_comb = tlp_addr_sel_split ? tlp_addr_split : ADR_I_split[9:0] ;
assign reg_wdata     = tlp_addr_sel_split ? reg_wdata_tlp_split : DAT_I_split ;
assign reg_wdata_be  = tlp_addr_sel_split ? reg_be_tlp_split : 4'b1111 ;
assign reg_rd        = reg_rd_tlp_split | reg_rd_cpm ;
assign reg_wr        = ((reg_wr_tlp_split & ~type1_cfg_int1_split & ~pois_cfg_int1_split) | reg_wr_cpm) ;
assign reg_wr_t1     = reg_wr_tlp_split & type1_cfg_int1_split ;
assign reg_wr_pois   = reg_wr_tlp_split & pois_cfg_int1_split ;

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      reg_sel_t0   <= 1'd0 ;
      reg_sel_pmsi <= 1'd0 ;
      reg_sel_cs   <= 1'd0 ;
      reg_sel_ec   <= 1'd0 ;
      

`ifdef AER


         reg_sel_aer <= 1'd0 ;
      

`endif


      reg_sel_usp <= 1'd0 ;
   end 
   else begin 
      reg_sel_t0   <= 1'd0 ;
      reg_sel_pmsi <= 1'd0 ;
      reg_sel_cs   <= 1'd0 ;
      reg_sel_ec   <= 1'd0 ;
      

`ifdef AER


         reg_sel_aer <= 1'd0 ;
      

`endif


      reg_sel_usp <= 1'd0 ;
      casex (reg_addr_comb_split[9:0])
         // 000h - 03Ch (00-0F) : type0
         10'b0000_00_xxxx : reg_sel_t0   <= 1'b1 ;

         // 050h - 054h (14-15) : PM capability
         10'b0000_01_010x : reg_sel_pmsi <= 1'b1 ;
         // 058h - 06Ch (16-1B) : Unimplemented
         10'b0000_01_011x , 
         10'b0000_01_10xx : reg_sel_usp <= 1'b1 ;

         // 070h - 07Ch (1C-1F) : MSI capability
         10'b0000_01_11xx : reg_sel_pmsi <= 1'b1 ;
         // 080h - 08Fh (20-23) : Unimplemented
         10'b0000_10_00xx : reg_sel_usp <= 1'b1 ;

         // 090h - 0A0h (24-28) : PCIE capability
         10'b0000_10_01xx , 
         10'b0000_10_1000 : reg_sel_cs <= 1'b1 ;
      

`ifdef GEN2


         // 0A4h - 0B0h (29-2C) : Unimplemented
         10'b0000_10_1001 ,
         10'b0000_10_101x ,
         10'b0000_10_1100 : reg_sel_usp <= 1'b1 ;
         // 0B4h - 0C0h (2D-30) : PCIE-2 capability
         10'b0000_10_1101 ,
         10'b0000_10_111x , 
         10'b0000_11_0000 : reg_sel_cs <= 1'b1 ;
         // 0C4h - 0FCh (31-3F) : Unimplemented
         10'b0000_11_0001 , 
         10'b0000_11_001x , 
         10'b0000_11_01xx , 
         10'b0000_11_1xxx : reg_sel_usp <= 1'b1 ;
      

`else


         // 0A4h - 0FCh (29-3F) : Unimplemented
         10'b0000_10_1001 , 
         10'b0000_10_101x , 
         10'b0000_10_11xx , 
         10'b0000_11_xxxx : reg_sel_usp <= 1'b1 ;
      

`endif


         // 100h - 108h (40-42) : Serial no
         10'b0001_00_000x ,
         10'b0001_00_0010 : reg_sel_ec <= 1'b1 ;

         

`ifdef VC1


            // 10Ch - 17Ch (43-5F) : Unimplemented
            10'b0001_00_0011 ,
            10'b0001_00_01xx ,
            10'b0001_00_xxxx ,
            10'b0001_01_xxxx : reg_sel_usp <= 1'b1 ;
         

`endif



         

`ifdef VC2


            // 10Ch - 130h (43-4C) : VC structure for VC0-1
            10'b0001_00_0011 ,
            10'b0001_00_01xx ,
            10'b0001_00_10xx ,
            10'b0001_00_1100 : reg_sel_ec <= 1'b1 ;

            // 134h - 17Ch (4D-5F) : Unimplemented
            10'b0001_00_1101 ,
            10'b0001_00_111x ,
            10'b0001_01_xxxx : reg_sel_usp <= 1'b1 ;
         

`endif



         

`ifdef VC3


            // 10Ch - 13Ch (43-4F) : VC structure for VC0-2
            10'b0001_00_0011 ,
            10'b0001_00_01xx ,
            10'b0001_00_1xxx : reg_sel_ec <= 1'b1 ;

            // 140h - 17Ch (50-5F) : Unimplemented
            10'b0001_01_xxxx : reg_sel_usp <= 1'b1 ;
         

`endif



         

`ifdef VC4


            // 10Ch - 148h (43-52) : VC structure for VC0-3
            10'b0001_00_0011 ,
            10'b0001_00_01xx ,
            10'b0001_00_1xxx ,
            10'b0001_01_000x ,
            10'b0001_01_0010 : reg_sel_ec <= 1'b1 ;

            // 14Ch - 17Ch (53-5F) : Unimplemented
            10'b0001_01_0011 ,
            10'b0001_01_01xx ,
            10'b0001_01_1xxx : reg_sel_usp <= 1'b1 ;
         

`endif



         

`ifdef VC5


            // 10Ch - 154h (43-55) : VC structure for VC0-4
            10'b0001_00_0011 ,
            10'b0001_00_01xx ,
            10'b0001_00_1xxx ,
            10'b0001_01_00xx ,
            10'b0001_01_010x : reg_sel_ec <= 1'b1 ;

            // 158h - 17Ch (56-5F) : Unimplemented
            10'b0001_01_011x ,
            10'b0001_01_1xxx : reg_sel_usp <= 1'b1 ;
         

`endif


         

`ifdef VC6


            // 10Ch - 160h (43-58) : VC structure for VC0-5
            10'b0001_00_0011 ,
            10'b0001_00_01xx ,
            10'b0001_00_1xxx ,
            10'b0001_01_0xxx ,
            10'b0001_01_1000 : reg_sel_ec <= 1'b1 ;

            // 164h - 17Ch (59-5F) : Unimplemented
            10'b0001_01_1001 ,
            10'b0001_01_101x ,
            10'b0001_01_11xx : reg_sel_usp <= 1'b1 ;
         

`endif


         

`ifdef VC7


            // 10Ch - 16Ch (43-5B) : VC structure for VC0-6
            10'b0001_00_0011 ,
            10'b0001_00_01xx ,
            10'b0001_00_1xxx ,
            10'b0001_01_0xxx ,
            10'b0001_01_10xx : reg_sel_ec <= 1'b1 ;

            // 170h - 17Ch (5C-5F) : Unimplemented
            10'b0001_01_11xx : reg_sel_usp <= 1'b1 ;
         

`endif


         

`ifdef VC8


            // 10Ch - 178h (43-5E) : VC structure for VC0-7
            10'b0001_00_0011 ,
            10'b0001_00_01xx ,
            10'b0001_00_1xxx ,
            10'b0001_01_0xxx ,
            10'b0001_01_10xx ,
            10'b0001_01_110x ,
            10'b0001_01_1110 : reg_sel_ec <= 1'b1 ;

            // 17Ch (5F) : Unimplemented
            10'b0001_01_1111 : reg_sel_usp <= 1'b1 ;
         

`endif


         // 180h - 19Ch (60-67) : Unimplemented
         10'b0001_10_0xxx : reg_sel_usp <= 1'b1 ;

         

`ifdef AER


            // 1A0h - 1C8h (68-72) : AER capability
            10'b0001_10_1xxx ,
            10'b0001_11_000x ,
            10'b0001_11_0010 : reg_sel_aer <= 1'b1 ;
         

`else


            // 1A0h - 1C8h (68-72) : Unimplemented
            10'b0001_10_1xxx ,
            10'b0001_11_000x ,
            10'b0001_11_0010 : reg_sel_usp <= 1'b1 ;
         

`endif



         // 1CCh - FFCh (73-3FF) : Unimplemented
         10'b0001_11_0011 ,
         10'b0001_11_01xx ,
         10'b0001_11_1xxx ,
         10'bxx1x_xx_xxxx ,
         10'bx1xx_xx_xxxx ,
         10'b1xxx_xx_xxxx : reg_sel_usp <= 1'b1 ;

                  default : reg_sel_usp <= 1'b1 ;
      endcase
   end 
end

assign reg_addr = reg_addr_comb_split[5:0] ;



`ifdef ECRC


   assign ecrc_ok_c = (ecrc_chk_enb & td) ? tlp_ecrc_ok : 1'b1 ;


`else


   assign ecrc_ok_c = 1'b1 ;


`endif



always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      ecrc_ok_d0 <= 1'd0 ;
      ecrc_ok_d1 <= 1'd0 ;
      ecrc_ok    <= 1'd0 ;
   end
   else begin  
      ecrc_ok_d0 <= ecrc_ok_c_split ;
      ecrc_ok_d1 <= ecrc_ok_d0_split ;
      ecrc_ok    <= ecrc_ok_d1_split ;
   end
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      s2e_cnt_err_d0 <= 1'b0;
   end
   else begin
      s2e_cnt_err_d0 <= s2e_cnt_err_split ;
   end
end

// Generate Credit Processed Signals for Credit Update
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      nph_processed <= 1'd0 ;
      npd_processed <= 1'd0 ;
   end  
   else if (!term_all_cfg_split) begin 
      if (reg_rd_tlp1_split & ~reg_sel_usp & ~s2e_cnt_err_d0_split) begin
         nph_processed <= 1'd1 ;
         npd_processed <= 1'd0 ;
      end  
      else if (reg_wr_tlp_split & ~reg_sel_usp & ~s2e_cnt_err_split) begin
         nph_processed <= 1'd1 ;
         npd_processed <= 1'd1 ;
      end  
      else begin 
         nph_processed <= 1'd0 ;
         npd_processed <= 1'd0 ;
      end  
   end  
   else begin  
      if (reg_rd_tlp1_split & ~s2e_cnt_err_d0_split) begin 
         nph_processed <= 1'd1 ;
         npd_processed <= 1'd0 ;
      end  
      else if (reg_wr_tlp_split & ~s2e_cnt_err_split) begin
         nph_processed <= 1'd1 ;
         npd_processed <= 1'd1 ;
      end  
      else begin 
         nph_processed <= 1'd0 ;
         npd_processed <= 1'd0 ;
      end  
   end  
end

// Generate Config hit signal
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      cfg_hit <= 1'd0 ;
   else if (!term_all_cfg_split) begin 
      if (reg_rd_tlp1_split & ~reg_sel_usp & ~s2e_cnt_err_d0_split) 
         cfg_hit <= 1'd1 ;
      else if (reg_wr_tlp_split & ~reg_sel_usp & ~s2e_cnt_err_split) 
         cfg_hit <= 1'd1 ;
      else  
         cfg_hit <= 1'd0 ;
   end
   else begin  
      if (reg_rd_tlp1_split & ~s2e_cnt_err_d0_split) 
         cfg_hit <= 1'd1 ;
      else if (reg_wr_tlp_split & ~s2e_cnt_err_split) 
         cfg_hit <= 1'd1 ;
      else
         cfg_hit <= 1'd0 ;
   end
end
always@* begin tlp_data_split<={tlp_data>>1,descram_out[0]};tlp_st_split<=descram_out[1];tlp_end_split<=descram_out[2];tlp_erly_st_split<=descram_out[3];phy_link_up_split<=descram_out[4];term_all_cfg_split<=descram_out[5];ADR_I_split<={ADR_I>>1,descram_out[6]};DAT_I_split<={DAT_I>>1,descram_out[7]};WE_I_split<=descram_out[8];STB_I_split<=descram_out[9];s2e_cnt_err_split<=descram_out[10];cfgrd_tlp_split<=descram_out[11];ereg_addr_tlp_split<={ereg_addr_tlp>>1,descram_out[12]};reg_addr_tlp_split<={reg_addr_tlp>>1,descram_out[13]};reg_wdata_tlp_split<={reg_wdata_tlp>>1,descram_out[14]};reg_be_tlp_split<={reg_be_tlp>>1,descram_out[15]};reg_wr_tlp_split<=descram_out[16];reg_rd_tlp_split<=descram_out[17];reg_wr_tlp1_split<=descram_out[18];reg_rd_tlp1_split<=descram_out[19];reg_rd_tlp2_split<=descram_out[20];reg_wrd_cpm1_split<=descram_out[21];reg_wrd_cpm2_split<=descram_out[22];tlp_addr_sel_split<=descram_out[23];tlp_st_reg1_split<=descram_out[24];tlp_end_reg1_split<=descram_out[25];tlp_end_reg2_split<=descram_out[26];tlp_end_reg3_split<=descram_out[27];func_num_rw_split<={func_num_rw>>1,descram_out[28]};req_id1_split<={req_id1>>1,descram_out[29]};req_id2_split<={req_id2>>1,descram_out[30]};tag1_split<={tag1>>1,descram_out[31]};tag2_split<={tag2>>1,descram_out[32]};tc1_split<={tc1>>1,descram_out[33]};tc2_split<={tc2>>1,descram_out[34]};type1_cfg_int_split<=descram_out[35];type1_cfg_int1_split<=descram_out[36];pois_cfg_int_split<=descram_out[37];pois_cfg_int1_split<=descram_out[38];cfg_chk_split<=descram_out[39];ecrc_ok_d0_split<=descram_out[40];ecrc_ok_d1_split<=descram_out[41];s2e_cnt_err_d0_split<=descram_out[42];tlp_addr_split<={tlp_addr>>1,descram_out[43]};reg_addr_comb_split<={reg_addr_comb>>1,descram_out[44]};ecrc_ok_c_split<=descram_out[45];end
always@* begin descram_in[2047]<=tlp_st;descram_in[2046]<=tlp_end;descram_in[2044]<=tlp_erly_st;descram_in[2040]<=phy_link_up;descram_in[2032]<=term_all_cfg;descram_in[2016]<=ADR_I[0];descram_in[1985]<=DAT_I[0];descram_in[1950]<=reg_rd_tlp;descram_in[1930]<=tlp_addr_sel;descram_in[1923]<=WE_I;descram_in[1852]<=reg_wr_tlp1;descram_in[1813]<=tlp_st_reg1;descram_in[1799]<=STB_I;descram_in[1656]<=reg_rd_tlp1;descram_in[1578]<=tlp_end_reg1;descram_in[1551]<=s2e_cnt_err;descram_in[1353]<=ecrc_ok_d0;descram_in[1345]<=req_id2[0];descram_in[1316]<=s2e_cnt_err_d0;descram_in[1285]<=tag2[0];descram_in[1265]<=reg_rd_tlp2;descram_in[1169]<=reg_addr_comb[0];descram_in[1108]<=tlp_end_reg2;descram_in[1054]<=cfgrd_tlp;descram_in[1045]<=tc2[0];descram_in[1023]<=tlp_data[0];descram_in[975]<=reg_wr_tlp;descram_in[965]<=reg_wrd_cpm2;descram_in[676]<=cfg_chk;descram_in[672]<=req_id1[0];descram_in[658]<=ecrc_ok_d1;descram_in[642]<=tag1[0];descram_in[584]<=tlp_addr[0];descram_in[522]<=tc1[0];descram_in[487]<=reg_be_tlp[0];descram_in[482]<=reg_wrd_cpm1;descram_in[338]<=pois_cfg_int1;descram_in[336]<=func_num_rw[0];descram_in[290]<=ecrc_ok_c;descram_in[243]<=reg_wdata_tlp[0];descram_in[169]<=pois_cfg_int;descram_in[168]<=tlp_end_reg3;descram_in[121]<=reg_addr_tlp[0];descram_in[84]<=type1_cfg_int1;descram_in[60]<=ereg_addr_tlp[0];descram_in[42]<=type1_cfg_int;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule

// =============================================================================



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X1_11


// File             : cfg_dsn_ec.v


// Title            :


// Dependencies     : 


// Description      : 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Feb 21, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module cfg_dsn_ec (
   
   input wire [31:0]   INIT_REG_104 , 
   input wire [31:0]   INIT_REG_108 , 

   input wire          sys_clk ,        
   input wire          rst_n ,          

   input wire          reg_sel_ec ,     
   input wire [4:0]    reg_addr ,       
   input wire [31:0]   reg_wdata ,      
   input wire          reg_wr ,         
   input wire          reg_rd ,         
   input wire          ecrc_ok ,        

   input wire          load_cfg ,       

   output reg [31:0]   reg_rd_data   
   ) ;
reg  [2:0]         dsnreg_sel ;
reg  [2:0]         dsnreg_sel_reg ;
wire [31:0]        dsnreg00_r ;
wire [31:0]        dsnreg04_r ;
wire [31:0]        dsnreg08_r ;

`ifdef CFG_VCC

`else

`ifdef AER

`ifdef NO_DSN

`else

`endif

`else

`ifdef NO_DSN

`else

`endif

`endif

`endif

`ifdef NO_DSN

`else

`endif

`ifdef NO_DSN

`else

`endif
reg [31 : 0] INIT_REG_104_split;
reg [31 : 0] INIT_REG_108_split;
reg reg_sel_ec_split;
reg [4 : 0] reg_addr_split;
reg [31 : 0] reg_wdata_split;
reg reg_wr_split;
reg reg_rd_split;
reg ecrc_ok_split;
reg load_cfg_split;
reg [2 : 0] dsnreg_sel_reg_split;
reg [31 : 0] dsnreg00_r_split;
reg [31 : 0] dsnreg04_r_split;
reg [31 : 0] dsnreg08_r_split;
reg [2047:0] descram_in;
wire [12:0] descram_out;

`ifdef CFG_VCC

`else

`ifdef AER

`ifdef NO_DSN

`else

`endif

`else

`ifdef NO_DSN

`else

`endif

`endif

`endif

`ifdef NO_DSN

`else

`endif

`ifdef NO_DSN

`else

`endif

localparam descram_inst_SIZE = 13,descram_inst_SCRAMSTRING = 32'hfdfff02b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef CFG_VCC



`else



`ifdef AER



`ifdef NO_DSN



`else



`endif



`else



`ifdef NO_DSN



`else



`endif



`endif



`endif



`ifdef NO_DSN



`else



`endif



`ifdef NO_DSN



`else



`endif

// =============================================================================

// VC Registers structure select
always @(reg_addr_split, reg_sel_ec_split) begin
   case ({reg_sel_ec_split, reg_addr_split[4:0]}) /* synthesis parallel_case */
      6'b1_000_00 : dsnreg_sel = 3'b001 ;  // Register 100
      6'b1_000_01 : dsnreg_sel = 3'b010 ;  // Register 104
      6'b1_000_10 : dsnreg_sel = 3'b100 ;  // Register 108
      default : dsnreg_sel = 3'b000 ; 
   endcase
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      dsnreg_sel_reg <= 3'h0;
   else 
      dsnreg_sel_reg <= dsnreg_sel ;
end

// Enhanced capability header Register at 100


`ifdef CFG_VCC


   assign dsnreg00_r = {12'h10C, `DSN_CAP_VER, 16'h0003} ;   


`else


   

`ifdef AER


      

`ifdef NO_DSN


         //Vendor specific capability structure, reserved for lattice
         assign dsnreg00_r = {12'h1A0, 4'h1, 16'h000B} ; // 4.2 
      

`else


         assign dsnreg00_r = {12'h1A0, `DSN_CAP_VER, 16'h0003} ;  
      

`endif


   

`else


      

`ifdef NO_DSN


         //Vendor specific capability structure, reserved for lattice
         assign dsnreg00_r = {`USR_EXT_CAP_ADDR, 4'h1, 16'h000B} ; // 4.2 
      

`else


         assign dsnreg00_r = {`USR_EXT_CAP_ADDR, `DSN_CAP_VER, 16'h0003} ;  
      

`endif


   

`endif




`endif



// Serial number register lower DW at 104


`ifdef NO_DSN


   //Vendor specific capability structure, reserved for lattice
   assign dsnreg04_r = {12'h00C, 4'h0, 16'h0000} ; // 4.2


`else


   assign dsnreg04_r = INIT_REG_104_split ; 


`endif



// Serial number register lower DW at 104


`ifdef NO_DSN


   //Vendor specific capability structure, reserved for lattice
   assign dsnreg08_r = 32'h0000_0000 ; // 4.2


`else


   assign dsnreg08_r = INIT_REG_108_split ; 


`endif



always @(*) begin 
   case (1'b1) /* synthesis parallel_case */
      dsnreg_sel_reg_split[0]  : reg_rd_data = dsnreg00_r_split ;
      dsnreg_sel_reg_split[1]  : reg_rd_data = dsnreg04_r_split ;
      dsnreg_sel_reg_split[2]  : reg_rd_data = dsnreg08_r_split ;
      default            : reg_rd_data = 32'd0 ;
   endcase
end


always@* begin INIT_REG_104_split<={INIT_REG_104>>1,descram_out[0]};INIT_REG_108_split<={INIT_REG_108>>1,descram_out[1]};reg_sel_ec_split<=descram_out[2];reg_addr_split<={reg_addr>>1,descram_out[3]};reg_wdata_split<={reg_wdata>>1,descram_out[4]};reg_wr_split<=descram_out[5];reg_rd_split<=descram_out[6];ecrc_ok_split<=descram_out[7];load_cfg_split<=descram_out[8];dsnreg_sel_reg_split<={dsnreg_sel_reg>>1,descram_out[9]};dsnreg00_r_split<={dsnreg00_r>>1,descram_out[10]};dsnreg04_r_split<={dsnreg04_r>>1,descram_out[11]};dsnreg08_r_split<={dsnreg08_r>>1,descram_out[12]};end
always@* begin descram_in[2047]<=INIT_REG_108[0];descram_in[2046]<=reg_sel_ec;descram_in[2044]<=reg_addr[0];descram_in[2041]<=reg_wdata[0];descram_in[2035]<=reg_wr;descram_in[2022]<=reg_rd;descram_in[1996]<=ecrc_ok;descram_in[1945]<=load_cfg;descram_in[1843]<=dsnreg_sel_reg[0];descram_in[1638]<=dsnreg00_r[0];descram_in[1229]<=dsnreg04_r[0];descram_in[1023]<=INIT_REG_104[0];descram_in[411]<=dsnreg08_r[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X1_11


// File             : cfg_pcie_cs.v


// Title            :


// Dependencies     :


// Description      :


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Feb 23, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module cfg_pcie_cs (
   
   input wire [31:0]   INIT_REG_090 ,
   input wire [31:0]   INIT_REG_094 ,
   input wire [31:0]   INIT_REG_09C ,
   input wire [31:0]   INIT_REG_0A0 ,
   `ifdef GEN2
      input wire [31:0]   INIT_REG_0B4 ,
   `endif

   input wire          sys_clk ,        
   input wire          rst_n ,          
   input wire          rst_n_main ,     

   input wire          reg_sel_cs ,     
   input wire [3:0]    reg_addr ,       
   input wire [31:0]   reg_wdata ,      
   input wire [3:0]    reg_wdata_be ,   
   input wire          reg_wr ,         
   input wire          reg_rd ,         
   input wire          ecrc_ok ,        

   input wire          phy_link_up ,    
   input wire [1:0]    phy_lnk_spd  ,   
   input wire          phy_lnk_demp ,   
   input wire          load_cfg ,       
   `ifdef GEN2
      input wire       flr ,            
   `endif
   `ifdef AER
      input wire [31:0]   uner_sevr ,   
   `endif

   
   input wire          lnk_train_err ,   
   input wire          lnk_train_status ,
   input wire [2:0]    lnk_width ,       
   input wire          dfrm_perr ,       
   input wire          dl_active ,       

   
   input wire          rxtp_bad_tlp,    
   input wire          rxdp_bad_dllp,   
   input wire          rxdp_dlerr,      
   input wire          txtp_rnum_rlor,  
   input wire          txtp_rply_tout , 
   input wire          lcmfci_fcp_err , 
   input wire          surp_down_err ,  
   input wire          rcvr_oflow ,     


   
   input wire          cmpln_tout ,     
   input wire          cmpltr_abort_np ,
   input wire          cmpltr_abort_p , 
   input wire          unexp_cmpln ,    
   input wire          ur_np_ext ,      
   input wire          ur_p_ext ,       
   input wire          np_req_pend ,    
   input wire  [7:0]   slot_sts ,       
   input wire          ptc_err_enable,  
   input wire          force_x2_cfg,    
   input wire          force_x1_cfg,    

   
   input wire          tlpdec_ecrc_err , 
   input wire          tlpdec_pois_tlp , 
   input wire          tlpdec_us_req ,   
   input wire          tlpdec_malf_tlp , 
   input wire          serr_enb ,        

   output wire [10:0]  slot_cntl_out ,   
   output wire [14:0]  dev_cntl_out ,
   output wire [7:0]   lnk_cntl_out ,
   output reg          ftl_err_out ,
   output reg          nftl_err_out ,
   output reg          cor_err_out ,
   `ifdef GEN2
      output wire [4:0] dev_cntl_2_out ,
      output wire       initiate_flr ,
      output wire [3:0] cs_target_lnk_spd ,
      output wire       cs_enter_compliance ,
      output wire       cs_hasd ,
      output wire       cs_tx_demphasis ,
      output wire [2:0] cs_tx_margin ,
      output wire       cs_enter_mod_comp ,
      output wire       cs_comp_sos ,
      output wire       cs_comp_demp ,

   `endif

   output wire [2:0]   max_pld_size ,    
   output wire         extd_synch ,      
   output wire         link_disable ,    
   output wire         retrain_lnk ,     
   output wire [2:0]   cfgcs_losel ,     

   output reg [31:0]   reg_rd_data
   ) ;
reg [12:0]           creg_sel ;
reg [12:0]           creg_sel_reg ;
reg [7:0]           link_cntl ;
reg [15:0]          link_cntl_2 ;
reg [15:0]          link_sts ;
reg [15:0]          dev_cntl ;
reg [15:0]          dev_cntl_2 ;
reg [5:0]           dev_sts ;
wire [31:0]         dev_cap_reg ;
reg  [31:0]         lnk_cap_reg ;
wire [31:0]         creg00_r ;
wire [31:0]         creg04_r ;
wire [31:0]         creg08_r ;
wire [31:0]         creg0c_r ;
wire [31:0]         creg10_r ;
wire [31:0]         creg24_r ;
wire [31:0]         creg28_r ;
wire [31:0]         creg2c_r ;
wire [31:0]         creg30_r ;
wire                ftl_err ;
wire                nftl_err1 ;
wire                nftl_err ;
wire                nftl_err_o ;
wire                cor_err ;
wire                ad_nftl_err ;
wire                dll_active ;

`ifdef AER

`else

`endif

`ifdef GEN2

`endif

`ifdef LEGACY_EP

`else

`endif

`ifdef GEN2

`else

`endif

`ifdef ERO_HW
localparam ERO_BIT = 1'b0 ;

`else
localparam ERO_BIT = 1'b1 ;

`endif

`ifdef GEN2

`endif

`ifdef ERO_HW

`else

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef ENDPOINT_COMP

`else

`endif

`ifdef ENDPOINT_COMP

`else

`ifdef SWITCH_COMP

`ifdef DWN_STRM_PORT

`else

`endif

`else

`endif

`endif

`ifdef ENDPOINT_COMP

`else

`ifdef SWITCH_COMP

`ifdef DWN_STRM_PORT

`else

`endif

`else

`endif

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif
reg [31 : 0] INIT_REG_090_split;
reg [31 : 0] INIT_REG_094_split;
reg [31 : 0] INIT_REG_09C_split;
reg [31 : 0] INIT_REG_0A0_split;
reg reg_sel_cs_split;
reg [3 : 0] reg_addr_split;
reg [31 : 0] reg_wdata_split;
reg [3 : 0] reg_wdata_be_split;
reg reg_wr_split;
reg reg_rd_split;
reg ecrc_ok_split;
reg phy_link_up_split;
reg [1 : 0] phy_lnk_spd_split;
reg phy_lnk_demp_split;
reg load_cfg_split;
reg lnk_train_err_split;
reg lnk_train_status_split;
reg [2 : 0] lnk_width_split;
reg dfrm_perr_split;
reg dl_active_split;
reg rxtp_bad_tlp_split;
reg rxdp_bad_dllp_split;
reg rxdp_dlerr_split;
reg txtp_rnum_rlor_split;
reg txtp_rply_tout_split;
reg lcmfci_fcp_err_split;
reg surp_down_err_split;
reg rcvr_oflow_split;
reg cmpln_tout_split;
reg cmpltr_abort_np_split;
reg cmpltr_abort_p_split;
reg unexp_cmpln_split;
reg ur_np_ext_split;
reg ur_p_ext_split;
reg np_req_pend_split;
reg [7 : 0] slot_sts_split;
reg ptc_err_enable_split;
reg force_x2_cfg_split;
reg force_x1_cfg_split;
reg tlpdec_ecrc_err_split;
reg tlpdec_pois_tlp_split;
reg tlpdec_us_req_split;
reg tlpdec_malf_tlp_split;
reg serr_enb_split;
reg [12 : 0] creg_sel_reg_split;
reg [7 : 0] link_cntl_split;
reg [15 : 0] link_cntl_2_split;
reg [15 : 0] link_sts_split;
reg [15 : 0] dev_cntl_split;
reg [15 : 0] dev_cntl_2_split;
reg [5 : 0] dev_sts_split;
reg [31 : 0] dev_cap_reg_split;
reg [31 : 0] lnk_cap_reg_split;
reg [31 : 0] creg00_r_split;
reg [31 : 0] creg04_r_split;
reg [31 : 0] creg08_r_split;
reg [31 : 0] creg0c_r_split;
reg [31 : 0] creg10_r_split;
reg [31 : 0] creg24_r_split;
reg [31 : 0] creg28_r_split;
reg [31 : 0] creg2c_r_split;
reg [31 : 0] creg30_r_split;
reg ftl_err_split;
reg nftl_err1_split;
reg nftl_err_split;
reg nftl_err_o_split;
reg cor_err_split;
reg ad_nftl_err_split;
reg dll_active_split;
reg [2047:0] descram_in;
wire [68:0] descram_out;

`ifdef AER

`else

`endif

`ifdef GEN2

`endif

`ifdef LEGACY_EP

`else

`endif

`ifdef GEN2

`else

`endif

`ifdef ERO_HW

`else

`endif

`ifdef GEN2

`endif

`ifdef ERO_HW

`else

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef ENDPOINT_COMP

`else

`endif

`ifdef ENDPOINT_COMP

`else

`ifdef SWITCH_COMP

`ifdef DWN_STRM_PORT

`else

`endif

`else

`endif

`endif

`ifdef ENDPOINT_COMP

`else

`ifdef SWITCH_COMP

`ifdef DWN_STRM_PORT

`else

`endif

`else

`endif

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

localparam descram_inst_SIZE = 69,descram_inst_SCRAMSTRING = 32'hfdffd88b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef AER



`else



`endif



`ifdef GEN2



`endif



`ifdef LEGACY_EP



`else



`endif



`ifdef GEN2



`else



`endif



`ifdef ERO_HW


`else


`endif



`ifdef GEN2



`endif



`ifdef ERO_HW



`else



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef ENDPOINT_COMP



`else



`endif



`ifdef ENDPOINT_COMP



`else



`ifdef SWITCH_COMP



`ifdef DWN_STRM_PORT



`else



`endif



`else



`endif



`endif



`ifdef ENDPOINT_COMP



`else



`ifdef SWITCH_COMP



`ifdef DWN_STRM_PORT



`else



`endif



`else



`endif



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif

// =============================================================================

//reg [3:0]           root_cntl ;
//reg [17:0]          root_sts ;
//reg [7:0]           slot_sts_reg ;
//reg [10:0]          slot_cntl ;
//wire [31:0]         slot_cap_reg ;
//wire [31:0]         creg14_r ;
//wire [31:0]         creg18_r ;
//wire [31:0]         creg1c_r ;
//wire [31:0]         creg20_r ;


`ifdef AER


   // Fatal errors
   assign ftl_err =
                    ((rxdp_dlerr_split      & uner_sevr[4])  |
                     (surp_down_err_split   & uner_sevr[5])  |
                     (tlpdec_pois_tlp_split & uner_sevr[12]) |
                     (lcmfci_fcp_err_split  & uner_sevr[13]) |
                     (cmpln_tout_split      & uner_sevr[14]) |
                     (cmpltr_abort_np_split & uner_sevr[15]) |
                     (cmpltr_abort_p_split  & uner_sevr[15]) |
                     (unexp_cmpln_split     & uner_sevr[16]) |
                     (rcvr_oflow_split      & uner_sevr[17]) |
                     (tlpdec_malf_tlp_split & uner_sevr[18]) |
                     (tlpdec_ecrc_err_split & uner_sevr[19]) |
                     (tlpdec_us_req_split   & uner_sevr[20]) |
                     (ur_p_ext_split        & uner_sevr[20]) |
                     (ur_np_ext_split       & uner_sevr[20])
                    ) ;

   // Non-Fatal errors
   assign nftl_err =
                     ((rxdp_dlerr_split      & ~uner_sevr[4])  |
                      (surp_down_err_split   & ~uner_sevr[5])  |
                      (lcmfci_fcp_err_split  & ~uner_sevr[13]) |
                      (cmpltr_abort_p_split  & ~uner_sevr[15]) |
                      (rcvr_oflow_split      & ~uner_sevr[17]) |
                      (tlpdec_malf_tlp_split & ~uner_sevr[18]) |
                      (tlpdec_ecrc_err_split & ~uner_sevr[19]) |
                      (ur_p_ext_split        & ~uner_sevr[20])
                     ) ;

   // Generate "Advisory Non-fatal Error" as Correctable error
   // if severity is non fatal for following Uncorrectable errors.
   assign ad_nftl_err = (tlpdec_us_req_split   & ~uner_sevr[20]) |
                        (ur_np_ext_split       & ~uner_sevr[20]) |
                        (cmpltr_abort_np_split & ~uner_sevr[15]) |
                        (tlpdec_pois_tlp_split & ~uner_sevr[12]) |
                        (cmpln_tout_split      & ~uner_sevr[14]) |
                        (unexp_cmpln_split     & ~uner_sevr[16]) ;

   // Correctable errors
   assign cor_err =
                    rxtp_bad_tlp_split |
                    rxdp_bad_dllp_split |
                    txtp_rply_tout_split |
                    txtp_rnum_rlor_split |
                    dfrm_perr_split |
                    ad_nftl_err_split ;


`else


   // Fatal errors
   assign ftl_err =
                    rxdp_dlerr_split |
                    lcmfci_fcp_err_split |
                    tlpdec_malf_tlp_split ;

   // Non-Fatal errors
   assign nftl_err =
                     tlpdec_pois_tlp_split |
                     cmpln_tout_split |
                     cmpltr_abort_p_split |
                     unexp_cmpln_split |
                     tlpdec_us_req_split |
                     tlpdec_ecrc_err_split |
                     ur_p_ext_split ;

   // "Advisory Non-fatal Error" to send message
   assign nftl_err_o = tlpdec_ecrc_err_split | ur_p_ext_split ;

   // Correctable errors
   assign cor_err =
                    rxtp_bad_tlp_split |
                    rxdp_bad_dllp_split |
                    txtp_rply_tout_split |
                    txtp_rnum_rlor_split |
                    dfrm_perr_split ;


`endif





// Register error signals to give out
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin
      ftl_err_out  <= 1'b0 ;
      nftl_err_out <= 1'b0 ;
      cor_err_out  <= 1'b0 ;
   end
   else begin
      // Required to pass PTC tests ver 1.1.0.12 S/W
      // For normal operation this signal is tied LOW
      if (ptc_err_enable_split) begin
         ftl_err_out  <= ftl_err_split ;
         nftl_err_out <= nftl_err_o_split ;
         cor_err_out  <= cor_err_split;
      end
      else begin
         ftl_err_out  <= ftl_err_split & (dev_cntl_split[2] | serr_enb_split) ;
         nftl_err_out <= nftl_err_o_split & (dev_cntl_split[1] | serr_enb_split) ;
         cor_err_out  <= cor_err_split & dev_cntl_split[0] ;
      end
   end
end

// =============================================================================
// Capability structure select
always @(reg_addr_split, reg_sel_cs_split) begin
   case ({reg_sel_cs_split, reg_addr_split[3:0]}) /* synthesis parallel_case */
      5'h1_4 : creg_sel = 13'b00000_00000001 ;  // Register 90, PCIE cs
      5'h1_5 : creg_sel = 13'b00000_00000010 ;  // Register 94
      5'h1_6 : creg_sel = 13'b00000_00000100 ;  // Register 98
      5'h1_7 : creg_sel = 13'b00000_00001000 ;  // Register 9C
      5'h1_8 : creg_sel = 13'b00000_00010000 ;  // Register A0
//    5'h1_9 : creg_sel = 13'b00000_00100000 ;  // Register A4
//    5'h1_A : creg_sel = 13'b00000_01000000 ;  // Register A8
//    5'h1_B : creg_sel = 13'b00000_10000000 ;  // Register AC
//    5'h1_C : creg_sel = 13'b00001_00000000 ;  // Register B0
   

`ifdef GEN2


      5'h1_D : creg_sel = 13'b00010_00000000 ;  // Register B4, PCIE-2 cs
      5'h1_E : creg_sel = 13'b00100_00000000 ;  // Register B8
      5'h1_F : creg_sel = 13'b01000_00000000 ;  // Register BC
      5'h1_0 : creg_sel = 13'b10000_00000000 ;  // Register C0
   

`endif


      default: creg_sel = 13'b00000_00000000 ;
   endcase
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      creg_sel_reg <= 9'd0 ;
   else
      creg_sel_reg <= creg_sel ;
end


// Capability structure Register at offset 00


`ifdef LEGACY_EP


   assign  creg00_r = {2'b00, INIT_REG_090_split[29:25], 1'b0, 4'h1, INIT_REG_090_split[19:16], INIT_REG_090_split[15:8], 8'h10} ; // 4.2


`else


   assign  creg00_r = {2'b00, INIT_REG_090_split[29:25], 1'b0, 4'h0, INIT_REG_090_split[19:16], INIT_REG_090_split[15:8], 8'h10} ;


`endif



// Device Capability Register at offset 04
assign  dev_cap_reg = {INIT_REG_094_split[31:3], INIT_REG_094_split[2:0]}  ;


`ifdef GEN2


   assign  creg04_r = {3'd0, INIT_REG_094_split[28:18],2'b00, 1'b1, 3'b000, INIT_REG_094_split[11:9], INIT_REG_094_split[8:6], INIT_REG_094_split[5:3], INIT_REG_094_split[2:0]} ;


`else


   assign  creg04_r = {4'd0, INIT_REG_094_split[27:18],2'b00, 1'b1, 3'b000, 3'b000, 3'b000, INIT_REG_094_split[5:3], INIT_REG_094_split[2:0]} ;


`endif



// Device Control Register at offset 08


`ifdef ERO_HW


   

`else


   

`endif


always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      dev_cntl <= {8'h20, 3'b000, ERO_BIT, 4'h0} ;
   

`ifdef GEN2


      else if (flr) begin
         dev_cntl[4:0] <= {ERO_BIT, 4'h0} ;
         dev_cntl[15:8] <= 8'h20 ;
      end
   

`endif


   else if (!phy_link_up_split)
      dev_cntl <= {8'h20, 3'b000, ERO_BIT, 4'h0} ;
   else if (reg_wr_split && ecrc_ok_split && creg_sel[2]) begin
      if (reg_wdata_be_split[0]) begin
         dev_cntl[3:0] <= reg_wdata_split[3:0] ;
         

`ifdef ERO_HW


            dev_cntl[4] <= 1'b0 ;
         

`else


            dev_cntl[4] <= reg_wdata_split[4] ;
         

`endif


         dev_cntl[7:5]   <= (reg_wdata_split [7:6]   != 2'b11) ? reg_wdata_split[7:5]   : dev_cntl_split[7:5] ;
      end
      if (reg_wdata_be_split[1]) begin
         dev_cntl[14:12] <= (reg_wdata_split [14:13] != 2'b11) ? reg_wdata_split[14:12] : dev_cntl_split[14:12] ;
	 

`ifdef GEN2


            dev_cntl[15] <= (creg04_r_split[28] == 1'b1) ? reg_wdata_split[15] : dev_cntl_split[15] ;
	 

`endif


      end
   end
end
//assign dev_cntl_out = dev_cntl ;
assign dev_cntl_out = {dev_cntl_split[14:12],4'b0000,dev_cntl_split[7:0]} ;
assign max_pld_size = dev_cntl_split[7:5] ;


`ifdef GEN2


   assign initiate_flr = dev_cntl_split[15] ;


`endif




// Device Status Register at offset 08
always @(posedge sys_clk, negedge rst_n) begin
   if ( !rst_n )
      dev_sts <= 6'd0 ;
   

`ifdef GEN2


      else if (flr)
         dev_sts <= 6'd0 ;
   

`endif


   else if (!phy_link_up_split)
      dev_sts <= 6'd0 ;
   else begin
      case (1'b1)
         (reg_wr_split && ecrc_ok_split && creg_sel[2] && reg_wdata_be_split[2]) : begin
            if (reg_wdata_split[16]) dev_sts[0] <= 1'b0 ;
            if (reg_wdata_split[17]) dev_sts[1] <= 1'b0 ;
            if (reg_wdata_split[18]) dev_sts[2] <= 1'b0 ;
         end
         (cor_err_split)  : dev_sts[0] <= 1'b1 ;
         (nftl_err_split) : dev_sts[1] <= 1'b1 ;
         (ftl_err_split)  : dev_sts[2] <= 1'b1 ;
      endcase

      if (reg_wr_split && ecrc_ok_split && creg_sel[2] && reg_wdata_split[19] && reg_wdata_be_split[2])
         dev_sts[3] <= 1'b0 ;
      else if (tlpdec_us_req_split || ur_p_ext_split || ur_np_ext_split)
         dev_sts[3] <= 1'b1 ;

       dev_sts[4] <= 1'b0 ;

      dev_sts[5] <= np_req_pend_split ;
   end
end
assign  creg08_r = {10'd0, dev_sts_split[5:0], 1'b0, dev_cntl_split[14:9], 1'b0, dev_cntl_split[7:0]} ;

// Link Capability Register at offset 0c
// Force X1/X2 when high
always @(*) begin
   if (force_x1_cfg_split)
      lnk_cap_reg = {INIT_REG_09C_split[31:24],1'b0,1'b1,4'b0000,3'b111,3'b111,2'b10,6'h01,4'h2} ;
   else
      lnk_cap_reg = {INIT_REG_09C_split[31:24],1'b0,1'b1,4'b0000,3'b111,3'b111,2'b10,6'h02,4'h2} ;
end

assign  creg0c_r = lnk_cap_reg_split ;
assign  cfgcs_losel = lnk_cap_reg_split[14:12] ;

// Link Control Register at offset 10
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      link_cntl[1:0] <= 2'd0 ;
   else if (!phy_link_up_split)
      link_cntl[1:0] <= 2'd0 ;
   else if (reg_wr_split && ecrc_ok_split && creg_sel[4] && reg_wdata_be_split[0])
      link_cntl[1:0] <= reg_wdata_split[1:0] ;
   else
      link_cntl[1:0] <= link_cntl_split[1:0] ;
end



`ifdef ENDPOINT_COMP


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n)
         link_cntl[3] <= 1'b0 ;
      else if (!phy_link_up_split)
         link_cntl[3] <= 1'b0 ;
      else if (reg_wr_split && ecrc_ok_split && creg_sel[4] && reg_wdata_be_split[0])
         link_cntl[3] <= reg_wdata_split[3] ;
      else
         link_cntl[3] <= link_cntl_split[3] ;
   end


`else


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n)
         link_cntl[3] <= 1'b0 ;
      else
         link_cntl[3] <= link_cntl_split[3] ;
   end


`endif





`ifdef ENDPOINT_COMP


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n)
         link_cntl[5:4] <= 2'b00 ;
      else
         link_cntl[5:4] <= link_cntl_split[5:4] ;
   end


`else


   

`ifdef SWITCH_COMP


      

`ifdef DWN_STRM_PORT


         always @(posedge sys_clk, negedge rst_n) begin
            if (!rst_n)
               link_cntl[5:4] <= 2'd0 ;
            else if (!phy_link_up_split)
               link_cntl[5:4] <= 2'd0 ;
            else if (reg_wr_split && ecrc_ok_split && creg_sel[4] && reg_wdata_be_split[0])
               link_cntl[5:4] <= reg_wdata_split[5:4] ;
            else
               link_cntl[5:4] <= link_cntl_split[5:4] ;
         end
      

`else


         always @(posedge sys_clk, negedge rst_n) begin
            if (!rst_n)
               link_cntl[5:4] <= 2'b00 ;
            else
               link_cntl[5:4] <= link_cntl_split[5:4] ;
         end
      

`endif


   

`else


      always @(posedge sys_clk, negedge rst_n) begin
         if (!rst_n)
            link_cntl[5:4] <= 2'd0 ;
         else if (!phy_link_up_split)
            link_cntl[5:4] <= 2'd0 ;
         else if (reg_wr_split && ecrc_ok_split && creg_sel[4] && reg_wdata_be_split[0])
            link_cntl[5:4] <= reg_wdata_split[5:4] ;
         else
            link_cntl[5:4] <= link_cntl_split[5:4] ;
      end
   

`endif




`endif



always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      link_cntl[7:6] <= 2'd0 ;
   else if (!phy_link_up_split)
      link_cntl[7:6] <= 2'd0 ;
   else if (reg_wr_split && ecrc_ok_split && creg_sel[4] && reg_wdata_be_split[0])
      link_cntl[7:6] <= reg_wdata_split[7:6] ;
   else
      link_cntl[7:6] <= link_cntl_split[7:6] ;
end

assign lnk_cntl_out = link_cntl_split ;
assign extd_synch = link_cntl_split[7] ;
assign retrain_lnk = link_cntl_split[5] ;
assign link_disable = link_cntl_split[4] ;

// Link Status Register at offset 10
always @(posedge sys_clk, negedge rst_n) begin
   if ( !rst_n ) begin
      link_sts[3:0] <= 4'd1 ;
      link_sts[9:4] <= 6'd1 ;
   end
   else begin
      link_sts[3:0] <= {2'b00, phy_lnk_spd_split} ;
      link_sts[9:4] <= {3'b000, lnk_width_split} ;
   end
end


`ifdef ENDPOINT_COMP


   always @(posedge sys_clk, negedge rst_n) begin
      if ( !rst_n )
         link_sts[11] <= 1'b0 ;
      else
         link_sts[11] <= link_sts_split[11] ;
   end


`else


   

`ifdef SWITCH_COMP


      

`ifdef DWN_STRM_PORT


         always @(posedge sys_clk, negedge rst_n) begin
            if ( !rst_n )
               link_sts[11] <= 1'd0 ;
            else
               link_sts[11] <= lnk_train_status_split ;
         end
      

`else


         always @(posedge sys_clk, negedge rst_n) begin
            if ( !rst_n )
               link_sts[11] <= 1'b0 ;
            else
               link_sts[11] <= link_sts_split[11] ;
         end
      

`endif


   

`else


      always @(posedge sys_clk, negedge rst_n) begin
         if ( !rst_n )
            link_sts[11] <= 1'd0 ;
         else
            link_sts[11] <= lnk_train_status_split ;
      end
   

`endif




`endif



always @(posedge sys_clk, negedge rst_n) begin
   if ( !rst_n )
      link_sts[13] <= 1'b0 ;
//   else if (lnk_cap_reg[20])
//      link_sts[13] <= dl_active ;
   else
      link_sts[13] <= 1'b0 ;
end

assign  creg10_r = {2'b00, link_sts_split[13], INIT_REG_0A0_split[28], link_sts_split[11], 1'b0, link_sts_split[9:0],
                    7'd0, 1'b0, link_cntl_split[7:6], 1'b0, link_cntl_split[4:3], 1'b0, link_cntl_split[1:0]} ;

/*
// Slot Capability Register at offset 14
assign  slot_cap_reg = INIT_REG_0A4 ;
assign  creg14_r = INIT_REG_0A4 ;

// Slot Control Register at offset 18
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      slot_cntl <= 11'd0 ;
   else if (load_cfg)
      slot_cntl <= INIT_REG_0A8[10:0] ;
   else if (reg_wr && ecrc_ok && creg_sel[6] && reg_wdata_be[0] && reg_wdata_be[1])
      slot_cntl <= reg_wdata[10:0] ;
   else
      slot_cntl <= slot_cntl ;
end
assign  slot_cntl_out = slot_cntl ;

// Slot Status Register at offset 18
always @(posedge sys_clk, negedge rst_n) begin
   if ( !rst_n )
      slot_sts_reg <= 8'd0 ;
   else if (load_cfg)
      slot_sts_reg <= INIT_REG_0A8[23:16] ;
   else if (reg_wr && ecrc_ok && creg_sel[6] && reg_wdata_be[2] ) begin
      if (reg_wdata[16]) slot_sts_reg[0] <= 1'b0 ;
      if (reg_wdata[17]) slot_sts_reg[1] <= 1'b0 ;
      if (reg_wdata[18]) slot_sts_reg[2] <= 1'b0 ;
      if (reg_wdata[19]) slot_sts_reg[3] <= 1'b0 ;
      if (reg_wdata[20]) slot_sts_reg[4] <= 1'b0 ;
   end
   else begin
      if (slot_sts[0]) slot_sts_reg[0] <= 1'b1 ;
      if (slot_sts[1]) slot_sts_reg[1] <= 1'b1 ;
      if (slot_sts[2]) slot_sts_reg[2] <= 1'b1 ;
      if (slot_sts[3]) slot_sts_reg[3] <= 1'b1 ;
      if (slot_sts[4]) slot_sts_reg[4] <= 1'b1 ;
   end
end

assign creg18_r = {8'd0, slot_sts_reg[7:0], 5'd0, slot_cntl[10:0]} ;

// Root Control Register at offset 1C
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      root_cntl <= 4'd0 ;
   else if (load_cfg)
      root_cntl <= INIT_REG_0AC[3:0] ;
   else if (reg_wr && ecrc_ok && creg_sel[7] && reg_wdata_be[0])
      root_cntl <= reg_wdata[3:0] ;
   else
      root_cntl <= root_cntl ;
end
assign creg1c_r = {16'd0, 12'd0, root_cntl[3:0]} ;

// Root Status Register at offset 20
always @(posedge sys_clk, negedge rst_n) begin
   if ( !rst_n )
      root_sts <= 18'd0 ;
   else if (load_cfg)
      root_sts <= INIT_REG_0B0[17:0] ;
   else if (reg_wr && ecrc_ok && creg_sel[8] && reg_wdata_be[1]) begin
         if (reg_wdata[16]) root_sts[16] <= 1'b0 ;
   end
   else
      root_sts[16] <= root_sts[16] ;
end
assign creg20_r = {14'd0, root_sts[17:16], root_sts[15:0]} ;
*/


`ifdef GEN2


   // Device Capability 2 Register at offset 24
   assign  creg24_r = {27'd0, INIT_REG_0B4[4:0]} ;

   // Device Control/Status 2 Register at offset 28
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n)
         dev_cntl_2 <= {27'd0, 1'b0, 4'h0} ;
      else if (flr)
         dev_cntl_2[4:0] <= {1'b0, 4'h0} ;
      else if (!phy_link_up_split)
         dev_cntl_2[4:0] <= {1'b0, 4'h0} ;
      else if (reg_wr_split && ecrc_ok_split && creg_sel[10]) begin
         if (reg_wdata_be_split[0]) begin
            dev_cntl_2[4:0] <= reg_wdata_split[4:0] ;
         end
      end
   end
   assign dev_cntl_2_out = dev_cntl_2_split[4:0] ;
   assign creg28_r = {15'd0, 11'd0, dev_cntl_2_split[4:0]} ;

   // Link Capability 2 Register at offset 2C
   assign creg2c_r = 32'd0 ;

   // Link Control/Status 2 Register at offset 30
   assign creg30_r = {15'h0,phy_lnk_demp_split,link_cntl_2_split} ;

// do not include sticky registers in core reset
always @(posedge sys_clk, negedge rst_n_main) begin
   if (!rst_n_main) begin
      link_cntl_2[3:0]   <= 4'b0010 ;
      link_cntl_2[4]     <= 1'b0 ;
      link_cntl_2[5]     <= 1'b1 ;
      link_cntl_2[6]     <= 1'b0 ;
      link_cntl_2[9:7]   <= 3'b000 ;
      link_cntl_2[10]    <= 1'b0 ;
      link_cntl_2[11]    <= 1'b0 ;
      link_cntl_2[12]    <= 1'b0 ;
      link_cntl_2[15:13] <= 3'b000 ;
   end
   else begin
      if (reg_wr_split && ecrc_ok_split && creg_sel[12] && reg_wdata_be_split[0]) begin
         link_cntl_2[5:0] <= reg_wdata_split[5:0] ;
         link_cntl_2[7]   <= reg_wdata_split[7] ;
      end
      if (reg_wr_split && ecrc_ok_split && creg_sel[12] && reg_wdata_be_split[1]) begin
         link_cntl_2[12:8]  <= reg_wdata_split[12:8] ;
      end
   end
end

assign cs_target_lnk_spd   = link_cntl_2_split[3:0] ;
assign cs_enter_compliance = link_cntl_2_split[4] ;
assign cs_hasd             = link_cntl_2_split[5] ;
assign cs_tx_demphasis     = link_cntl_2_split[6] ;
assign cs_tx_margin        = link_cntl_2_split[9:7] ;
assign cs_enter_mod_comp   = link_cntl_2_split[10] ;
assign cs_comp_sos         = link_cntl_2_split[11] ;
assign cs_comp_demp        = link_cntl_2_split[12] ;



`endif



always @(*) begin
   case (1'b1) /* synthesis parallel_case */
      creg_sel_reg_split[0] : reg_rd_data = creg00_r_split ;
      creg_sel_reg_split[1] : reg_rd_data = creg04_r_split ;
      creg_sel_reg_split[2] : reg_rd_data = creg08_r_split ;
      creg_sel_reg_split[3] : reg_rd_data = creg0c_r_split ;
      creg_sel_reg_split[4] : reg_rd_data = creg10_r_split ;
//      creg_sel_reg[5] : reg_rd_data = creg14_r ;
//      creg_sel_reg[6] : reg_rd_data = creg18_r ;
//      creg_sel_reg[7] : reg_rd_data = creg1c_r ;
//      creg_sel_reg[8] : reg_rd_data = creg20_r ;
   

`ifdef GEN2


      creg_sel_reg_split[9]  : reg_rd_data = creg24_r_split ;
      creg_sel_reg_split[10] : reg_rd_data = creg28_r_split ;
      creg_sel_reg_split[11] : reg_rd_data = creg2c_r_split ;
      creg_sel_reg_split[12] : reg_rd_data = creg30_r_split ;
   

`endif


      default          : reg_rd_data = 32'd0 ;
   endcase
end
always@* begin INIT_REG_090_split<={INIT_REG_090>>1,descram_out[0]};INIT_REG_094_split<={INIT_REG_094>>1,descram_out[1]};INIT_REG_09C_split<={INIT_REG_09C>>1,descram_out[2]};INIT_REG_0A0_split<={INIT_REG_0A0>>1,descram_out[3]};reg_sel_cs_split<=descram_out[4];reg_addr_split<={reg_addr>>1,descram_out[5]};reg_wdata_split<={reg_wdata>>1,descram_out[6]};reg_wdata_be_split<={reg_wdata_be>>1,descram_out[7]};reg_wr_split<=descram_out[8];reg_rd_split<=descram_out[9];ecrc_ok_split<=descram_out[10];phy_link_up_split<=descram_out[11];phy_lnk_spd_split<={phy_lnk_spd>>1,descram_out[12]};phy_lnk_demp_split<=descram_out[13];load_cfg_split<=descram_out[14];lnk_train_err_split<=descram_out[15];lnk_train_status_split<=descram_out[16];lnk_width_split<={lnk_width>>1,descram_out[17]};dfrm_perr_split<=descram_out[18];dl_active_split<=descram_out[19];rxtp_bad_tlp_split<=descram_out[20];rxdp_bad_dllp_split<=descram_out[21];rxdp_dlerr_split<=descram_out[22];txtp_rnum_rlor_split<=descram_out[23];txtp_rply_tout_split<=descram_out[24];lcmfci_fcp_err_split<=descram_out[25];surp_down_err_split<=descram_out[26];rcvr_oflow_split<=descram_out[27];cmpln_tout_split<=descram_out[28];cmpltr_abort_np_split<=descram_out[29];cmpltr_abort_p_split<=descram_out[30];unexp_cmpln_split<=descram_out[31];ur_np_ext_split<=descram_out[32];ur_p_ext_split<=descram_out[33];np_req_pend_split<=descram_out[34];slot_sts_split<={slot_sts>>1,descram_out[35]};ptc_err_enable_split<=descram_out[36];force_x2_cfg_split<=descram_out[37];force_x1_cfg_split<=descram_out[38];tlpdec_ecrc_err_split<=descram_out[39];tlpdec_pois_tlp_split<=descram_out[40];tlpdec_us_req_split<=descram_out[41];tlpdec_malf_tlp_split<=descram_out[42];serr_enb_split<=descram_out[43];creg_sel_reg_split<={creg_sel_reg>>1,descram_out[44]};link_cntl_split<={link_cntl>>1,descram_out[45]};link_cntl_2_split<={link_cntl_2>>1,descram_out[46]};link_sts_split<={link_sts>>1,descram_out[47]};dev_cntl_split<={dev_cntl>>1,descram_out[48]};dev_cntl_2_split<={dev_cntl_2>>1,descram_out[49]};dev_sts_split<={dev_sts>>1,descram_out[50]};dev_cap_reg_split<={dev_cap_reg>>1,descram_out[51]};lnk_cap_reg_split<={lnk_cap_reg>>1,descram_out[52]};creg00_r_split<={creg00_r>>1,descram_out[53]};creg04_r_split<={creg04_r>>1,descram_out[54]};creg08_r_split<={creg08_r>>1,descram_out[55]};creg0c_r_split<={creg0c_r>>1,descram_out[56]};creg10_r_split<={creg10_r>>1,descram_out[57]};creg24_r_split<={creg24_r>>1,descram_out[58]};creg28_r_split<={creg28_r>>1,descram_out[59]};creg2c_r_split<={creg2c_r>>1,descram_out[60]};creg30_r_split<={creg30_r>>1,descram_out[61]};ftl_err_split<=descram_out[62];nftl_err1_split<=descram_out[63];nftl_err_split<=descram_out[64];nftl_err_o_split<=descram_out[65];cor_err_split<=descram_out[66];ad_nftl_err_split<=descram_out[67];dll_active_split<=descram_out[68];end
always@* begin descram_in[2047]<=INIT_REG_094[0];descram_in[2046]<=INIT_REG_09C[0];descram_in[2044]<=INIT_REG_0A0[0];descram_in[2040]<=reg_sel_cs;descram_in[2032]<=reg_addr[0];descram_in[2017]<=reg_wdata[0];descram_in[1992]<=lnk_train_status;descram_in[1987]<=reg_wdata_be[0];descram_in[1936]<=lnk_width[0];descram_in[1927]<=reg_wr;descram_in[1873]<=ptc_err_enable;descram_in[1851]<=cor_err;descram_in[1849]<=creg30_r[0];descram_in[1847]<=creg00_r[0];descram_in[1825]<=dfrm_perr;descram_in[1807]<=reg_rd;descram_in[1767]<=creg24_r[0];descram_in[1698]<=force_x2_cfg;descram_in[1655]<=ad_nftl_err;descram_in[1651]<=ftl_err;descram_in[1646]<=creg04_r[0];descram_in[1602]<=dl_active;descram_in[1567]<=ecrc_ok;descram_in[1486]<=creg28_r[0];descram_in[1348]<=force_x1_cfg;descram_in[1296]<=tlpdec_pois_tlp;descram_in[1287]<=cmpln_tout;descram_in[1263]<=dll_active;descram_in[1255]<=nftl_err1;descram_in[1244]<=creg08_r[0];descram_in[1157]<=rxtp_bad_tlp;descram_in[1088]<=tlpdec_malf_tlp;descram_in[1086]<=phy_link_up;descram_in[1064]<=txtp_rnum_rlor;descram_in[1053]<=cmpltr_abort_p;descram_in[1038]<=link_cntl_2[0];descram_in[1023]<=INIT_REG_090[0];descram_in[996]<=lnk_train_err;descram_in[936]<=slot_sts[0];descram_in[925]<=nftl_err_o;descram_in[924]<=creg2c_r[0];descram_in[923]<=lnk_cap_reg[0];descram_in[883]<=creg10_r[0];descram_in[648]<=tlpdec_ecrc_err;descram_in[643]<=rcvr_oflow;descram_in[544]<=tlpdec_us_req;descram_in[532]<=rxdp_dlerr;descram_in[526]<=cmpltr_abort_np;descram_in[519]<=link_cntl[0];descram_in[498]<=load_cfg;descram_in[468]<=np_req_pend;descram_in[462]<=nftl_err;descram_in[461]<=dev_cap_reg[0];descram_in[441]<=creg0c_r[0];descram_in[321]<=surp_down_err;descram_in[266]<=rxdp_bad_dllp;descram_in[259]<=creg_sel_reg[0];descram_in[249]<=phy_lnk_demp;descram_in[234]<=ur_p_ext;descram_in[230]<=dev_sts[0];descram_in[160]<=lcmfci_fcp_err;descram_in[129]<=serr_enb;descram_in[124]<=phy_lnk_spd[0];descram_in[117]<=ur_np_ext;descram_in[115]<=dev_cntl_2[0];descram_in[80]<=txtp_rply_tout;descram_in[58]<=unexp_cmpln;descram_in[57]<=dev_cntl[0];descram_in[28]<=link_sts[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X1_11


// File             : cfg_pmsi_cs.v


// Title            :


// Dependencies     : 


// Description      : Implements Power management and MSI registers.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Feb 21, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module cfg_pmsi_cs (
   
   input wire [31:0]   INIT_REG_050 , 
   input wire [31:0]   INIT_REG_054 , 
   input wire [9:0]    INIT_PM_DS_DATA_0 , 
   input wire [9:0]    INIT_PM_DS_DATA_1 , 
   input wire [9:0]    INIT_PM_DS_DATA_2 , 
   input wire [9:0]    INIT_PM_DS_DATA_3 , 
   input wire [9:0]    INIT_PM_DS_DATA_4 , 
   input wire [9:0]    INIT_PM_DS_DATA_5 , 
   input wire [9:0]    INIT_PM_DS_DATA_6 , 
   input wire [9:0]    INIT_PM_DS_DATA_7 , 

   input wire [31:0]   INIT_REG_070 , 

   input wire          sys_clk ,        
   input wire          rst_n ,          

   input wire          reg_sel_cs ,     
   input wire [3:0]    reg_addr ,       
   input wire [31:0]   reg_wdata ,      
   input wire [3:0]    reg_wdata_be ,   
   input wire          reg_wr ,         
   input wire          reg_rd ,         
   input wire          ecrc_ok ,        

   input wire          phy_link_up ,    
   input wire          load_cfg ,       
   `ifdef GEN2
      input wire       flr ,            
   `endif
   input wire          pme_status ,     

   output reg [1:0]    pm_power_state , 
   output reg          pme_en ,         
   output reg [2:0]    mm_enable ,      
   output reg          msi_enable ,     
   output reg [31:0]   mes_laddr ,      
   output reg [31:0]   mes_uaddr ,      
   output reg [15:0]   mes_data ,       

   output reg [31:0]   reg_rd_data  
   ) ;
reg  [5:0]         pmsireg_sel ;
reg  [5:0]         pmsireg_sel_reg ;
reg  [1:0]         data_scale ;
reg  [7:0]         data ;
reg  [3:0]         data_select ;
reg                pme_status_reg ;
reg                pme_status_d ;
wire [31:0]        pmreg00_r ;
wire [31:0]        pmreg04_r ;
wire [31:0]        msireg00_r ;
wire [31:0]        msireg04_r ;
wire [31:0]        msireg08_r ;
wire [31:0]        msireg0c_r ;
wire [9:0]         data_0 ;
wire [9:0]         data_1 ;
wire [9:0]         data_2 ;
wire [9:0]         data_3 ;
wire [9:0]         data_4 ;
wire [9:0]         data_5 ;
wire [9:0]         data_6 ;
wire [9:0]         data_7 ;
wire               pme_status_pr ;

`ifdef GEN2

`endif
reg [31 : 0] INIT_REG_050_split;
reg [31 : 0] INIT_REG_054_split;
reg [9 : 0] INIT_PM_DS_DATA_0_split;
reg [9 : 0] INIT_PM_DS_DATA_1_split;
reg [9 : 0] INIT_PM_DS_DATA_2_split;
reg [9 : 0] INIT_PM_DS_DATA_3_split;
reg [9 : 0] INIT_PM_DS_DATA_4_split;
reg [9 : 0] INIT_PM_DS_DATA_5_split;
reg [9 : 0] INIT_PM_DS_DATA_6_split;
reg [9 : 0] INIT_PM_DS_DATA_7_split;
reg [31 : 0] INIT_REG_070_split;
reg reg_sel_cs_split;
reg [3 : 0] reg_addr_split;
reg [31 : 0] reg_wdata_split;
reg [3 : 0] reg_wdata_be_split;
reg reg_wr_split;
reg reg_rd_split;
reg ecrc_ok_split;
reg phy_link_up_split;
reg load_cfg_split;
reg pme_status_split;
reg [5 : 0] pmsireg_sel_reg_split;
reg [1 : 0] data_scale_split;
reg [7 : 0] data_split;
reg [3 : 0] data_select_split;
reg pme_status_reg_split;
reg pme_status_d_split;
reg [31 : 0] pmreg00_r_split;
reg [31 : 0] pmreg04_r_split;
reg [31 : 0] msireg00_r_split;
reg [31 : 0] msireg04_r_split;
reg [31 : 0] msireg08_r_split;
reg [31 : 0] msireg0c_r_split;
reg [9 : 0] data_0_split;
reg [9 : 0] data_1_split;
reg [9 : 0] data_2_split;
reg [9 : 0] data_3_split;
reg [9 : 0] data_4_split;
reg [9 : 0] data_5_split;
reg [9 : 0] data_6_split;
reg [9 : 0] data_7_split;
reg pme_status_pr_split;
reg [2047:0] descram_in;
wire [41:0] descram_out;

`ifdef GEN2

`endif

localparam descram_inst_SIZE = 42,descram_inst_SCRAMSTRING = 32'hfdfff40b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef GEN2



`endif

// =============================================================================
// VC Registers structure select
always @(reg_addr_split, reg_sel_cs_split) begin
   case ({reg_sel_cs_split, reg_addr_split[3:0]}) /* synthesis parallel_case */
      5'h1_4  : pmsireg_sel = 6'b000001 ;  // Register 050
      5'h1_5  : pmsireg_sel = 6'b000010 ;  // Register 054
      5'h1_C  : pmsireg_sel = 6'b000100 ;  // Register 070
      5'h1_D  : pmsireg_sel = 6'b001000 ;  // Register 074
      5'h1_E  : pmsireg_sel = 6'b010000 ;  // Register 078
      5'h1_F  : pmsireg_sel = 6'b100000 ;  // Register 07C
      default : pmsireg_sel = 6'b000000 ; 
   endcase
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      pmsireg_sel_reg <= 6'h0;
   else 
      pmsireg_sel_reg <= pmsireg_sel ;
end

// PM capability structure header Register at 050h
//assign pmreg00_r =  {INIT_REG_050[31:21], 1'b0, 1'b0, 3'b010, 8'h70, 8'h01} ; // 1.0a
//assign pmreg00_r =  {INIT_REG_050[31:21], 1'b0, 1'b0, 3'b011, 8'h70, 8'h01} ; // 1.1
assign pmreg00_r =  {INIT_REG_050_split[31:21], 1'b0, 1'b0, INIT_REG_050_split[18:16], 8'h70, 8'h01} ; // 3.4

// PM status-control register 054h
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      pm_power_state[1:0] <= 2'd0 ; 
   else if (reg_wr_split && ecrc_ok_split && pmsireg_sel[1] && reg_wdata_be_split[0])   
      pm_power_state[1:0] <= reg_wdata_split[1:0] ; 
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      pme_en <= 1'b0 ; 
   else if (INIT_REG_050_split[31] == 1'b0)   
      pme_en <= 1'b0 ; 
   else if (reg_wr_split && ecrc_ok_split && pmsireg_sel[1] && reg_wdata_be_split[1])   
      pme_en <=  reg_wdata_split[8] ; 
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      data_select <= 4'd0 ; 
   else if (INIT_REG_050_split[31:27] == 5'h00)   
      data_select <= 4'd0 ; 
   else if (reg_wr_split && ecrc_ok_split && pmsireg_sel[1] && reg_wdata_be_split[1])   
      data_select <=  reg_wdata_split[12:9] ; 
end

// Get PME_status transition
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      pme_status_d <= 1'b0 ; 
   else    
      pme_status_d <= pme_status_split ; 
end
assign pme_status_pr = pme_status_split & ~pme_status_d_split ; 


always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)   
      pme_status_reg <= 1'b0 ; 
   else if (INIT_REG_050_split[31] == 1'b0)   
      pme_status_reg <= 1'b0 ; 
   else if (pme_status_pr_split)   
      pme_status_reg <= 1'b1 ; 
   else if (reg_wr_split && ecrc_ok_split && pmsireg_sel[1] && (reg_wdata_split[15] == 1'b1) && reg_wdata_be_split[1])   
      pme_status_reg <= 1'b0 ; 
end

always @* begin
   case (data_select_split)
      4'd0    : {data_scale, data} = INIT_PM_DS_DATA_0_split ;
      4'd1    : {data_scale, data} = INIT_PM_DS_DATA_1_split ;
      4'd2    : {data_scale, data} = INIT_PM_DS_DATA_2_split ;
      4'd3    : {data_scale, data} = INIT_PM_DS_DATA_3_split ;
      4'd4    : {data_scale, data} = INIT_PM_DS_DATA_4_split ;
      4'd5    : {data_scale, data} = INIT_PM_DS_DATA_5_split ;
      4'd6    : {data_scale, data} = INIT_PM_DS_DATA_6_split ;
      4'd7    : {data_scale, data} = INIT_PM_DS_DATA_7_split ;
      default : {data_scale, data} = 10'd0 ;
   endcase
end

assign pmreg04_r = {data_split[7:0], 2'b00, 6'd0, 
                    pme_status_reg_split, data_scale_split[1:0], data_select_split[3:0], pme_en, 
                    4'd0, INIT_REG_054_split[3], 1'b0, pm_power_state[1:0]} ;


// MSI capability structure header Register at 070h
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      mm_enable[2:0] <= 3'd0 ; 
      msi_enable     <= 1'd0 ; 
   end
   

`ifdef GEN2


      else if (flr) begin 
         mm_enable[2:0] <= 3'd0 ; 
         msi_enable     <= 1'd0 ; 
      end
   

`endif


   else if (reg_wr_split && ecrc_ok_split && pmsireg_sel[2] && reg_wdata_be_split[2]) begin 
      mm_enable[2:0] <= reg_wdata_split[22:20] ; 
      msi_enable     <= reg_wdata_split[16] ; 
   end
end

assign msireg00_r = {7'd0, INIT_REG_070_split[24:23], mm_enable[2:0], 
                     INIT_REG_070_split[19:17],msi_enable, 8'h90, 8'h05} ; 

// MSI capability structure lower address Register at 074h
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin  
      mes_laddr[31:0] <= 32'd0 ; 
   end
   else if (reg_wr_split && ecrc_ok_split && pmsireg_sel[3]) begin   
      if (reg_wdata_be_split[0]) mes_laddr[7:2]   <= reg_wdata_split[7:2] ; 
      if (reg_wdata_be_split[1]) mes_laddr[15:8]  <= reg_wdata_split[15:8] ; 
      if (reg_wdata_be_split[2]) mes_laddr[23:16] <= reg_wdata_split[23:16] ; 
      if (reg_wdata_be_split[3]) mes_laddr[31:24] <= reg_wdata_split[31:24] ; 
   end
end

assign msireg04_r = {mes_laddr[31:2], 2'b00} ; 

// MSI capability structure higher address Register at 078
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      mes_uaddr[31:0] <= 32'd0 ; 
   else if (reg_wr_split && ecrc_ok_split && pmsireg_sel[4] && INIT_REG_070_split[23]) begin  
      if (reg_wdata_be_split[0]) mes_uaddr[7:0]   <= reg_wdata_split[7:0] ; 
      if (reg_wdata_be_split[1]) mes_uaddr[15:8]  <= reg_wdata_split[15:8] ; 
      if (reg_wdata_be_split[2]) mes_uaddr[23:16] <= reg_wdata_split[23:16] ; 
      if (reg_wdata_be_split[3]) mes_uaddr[31:24] <= reg_wdata_split[31:24] ; 
   end
end

assign msireg08_r = mes_uaddr ; 


// MSI capability structure Data Register at 07Ch
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      mes_data <= 16'd0 ; 
   else if (reg_wr_split && ecrc_ok_split && pmsireg_sel[5]) begin  
      if (reg_wdata_be_split[0]) mes_data[7:0]   <= reg_wdata_split[7:0] ; 
      if (reg_wdata_be_split[1]) mes_data[15:8]  <= reg_wdata_split[15:8] ; 
   end
end

assign msireg0c_r = {16'd0, mes_data} ; 


always @(*) begin 
   case (1'b1) /* synthesis parallel_case */
      pmsireg_sel_reg_split[0]  : reg_rd_data = pmreg00_r_split ;
      pmsireg_sel_reg_split[1]  : reg_rd_data = pmreg04_r_split ;
      pmsireg_sel_reg_split[2]  : reg_rd_data = msireg00_r_split ;
      pmsireg_sel_reg_split[3]  : reg_rd_data = msireg04_r_split ;
      pmsireg_sel_reg_split[4]  : reg_rd_data = msireg08_r_split ;
      pmsireg_sel_reg_split[5]  : reg_rd_data = msireg0c_r_split ;
      default             : reg_rd_data = 32'd0 ;
   endcase
end

always@* begin INIT_REG_050_split<={INIT_REG_050>>1,descram_out[0]};INIT_REG_054_split<={INIT_REG_054>>1,descram_out[1]};INIT_PM_DS_DATA_0_split<={INIT_PM_DS_DATA_0>>1,descram_out[2]};INIT_PM_DS_DATA_1_split<={INIT_PM_DS_DATA_1>>1,descram_out[3]};INIT_PM_DS_DATA_2_split<={INIT_PM_DS_DATA_2>>1,descram_out[4]};INIT_PM_DS_DATA_3_split<={INIT_PM_DS_DATA_3>>1,descram_out[5]};INIT_PM_DS_DATA_4_split<={INIT_PM_DS_DATA_4>>1,descram_out[6]};INIT_PM_DS_DATA_5_split<={INIT_PM_DS_DATA_5>>1,descram_out[7]};INIT_PM_DS_DATA_6_split<={INIT_PM_DS_DATA_6>>1,descram_out[8]};INIT_PM_DS_DATA_7_split<={INIT_PM_DS_DATA_7>>1,descram_out[9]};INIT_REG_070_split<={INIT_REG_070>>1,descram_out[10]};reg_sel_cs_split<=descram_out[11];reg_addr_split<={reg_addr>>1,descram_out[12]};reg_wdata_split<={reg_wdata>>1,descram_out[13]};reg_wdata_be_split<={reg_wdata_be>>1,descram_out[14]};reg_wr_split<=descram_out[15];reg_rd_split<=descram_out[16];ecrc_ok_split<=descram_out[17];phy_link_up_split<=descram_out[18];load_cfg_split<=descram_out[19];pme_status_split<=descram_out[20];pmsireg_sel_reg_split<={pmsireg_sel_reg>>1,descram_out[21]};data_scale_split<={data_scale>>1,descram_out[22]};data_split<={data>>1,descram_out[23]};data_select_split<={data_select>>1,descram_out[24]};pme_status_reg_split<=descram_out[25];pme_status_d_split<=descram_out[26];pmreg00_r_split<={pmreg00_r>>1,descram_out[27]};pmreg04_r_split<={pmreg04_r>>1,descram_out[28]};msireg00_r_split<={msireg00_r>>1,descram_out[29]};msireg04_r_split<={msireg04_r>>1,descram_out[30]};msireg08_r_split<={msireg08_r>>1,descram_out[31]};msireg0c_r_split<={msireg0c_r>>1,descram_out[32]};data_0_split<={data_0>>1,descram_out[33]};data_1_split<={data_1>>1,descram_out[34]};data_2_split<={data_2>>1,descram_out[35]};data_3_split<={data_3>>1,descram_out[36]};data_4_split<={data_4>>1,descram_out[37]};data_5_split<={data_5>>1,descram_out[38]};data_6_split<={data_6>>1,descram_out[39]};data_7_split<={data_7>>1,descram_out[40]};pme_status_pr_split<=descram_out[41];end
always@* begin descram_in[2047]<=INIT_REG_054[0];descram_in[2046]<=INIT_PM_DS_DATA_0[0];descram_in[2044]<=INIT_PM_DS_DATA_1[0];descram_in[2040]<=INIT_PM_DS_DATA_2[0];descram_in[2032]<=INIT_PM_DS_DATA_3[0];descram_in[2016]<=INIT_PM_DS_DATA_4[0];descram_in[2011]<=data_3[0];descram_in[1984]<=INIT_PM_DS_DATA_5[0];descram_in[1974]<=data_4[0];descram_in[1941]<=pme_status_d;descram_in[1920]<=INIT_PM_DS_DATA_6[0];descram_in[1901]<=data_5[0];descram_in[1835]<=pmreg00_r[0];descram_in[1793]<=INIT_PM_DS_DATA_7[0];descram_in[1754]<=data_6[0];descram_in[1679]<=load_cfg;descram_in[1623]<=pmreg04_r[0];descram_in[1539]<=INIT_REG_070[0];descram_in[1526]<=data_1[0];descram_in[1461]<=data_7[0];descram_in[1405]<=msireg0c_r[0];descram_in[1310]<=pme_status;descram_in[1199]<=msireg00_r[0];descram_in[1145]<=data_scale[0];descram_in[1030]<=reg_sel_cs;descram_in[1023]<=INIT_REG_050[0];descram_in[1005]<=data_2[0];descram_in[970]<=pme_status_reg;descram_in[874]<=pme_status_pr;descram_in[839]<=phy_link_up;descram_in[763]<=data_0[0];descram_in[702]<=msireg08_r[0];descram_in[572]<=pmsireg_sel_reg[0];descram_in[485]<=data_select[0];descram_in[419]<=ecrc_ok;descram_in[351]<=msireg04_r[0];descram_in[242]<=data[0];descram_in[209]<=reg_rd;descram_in[104]<=reg_wr;descram_in[52]<=reg_wdata_be[0];descram_in[26]<=reg_wdata[0];descram_in[13]<=reg_addr[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          :  PCI_EXP_X4_11


// File             : cfg_resp.v


// Title            :


// Dependencies     : 


// Description      : 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Feb 21, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module cfg_resp (
   input wire          sys_clk ,      
   input wire          rst_n ,        

   input wire [7:0]    bus_num ,
   input wire [4:0]    dev_num ,
   input wire [2:0]    func_num ,
   input wire [15:0]   req_id ,
   input wire [7:0]    tag ,
   input wire [2:0]    tc ,
   input wire          term_all_cfg , 
   input wire          load_id ,      
   `ifdef GEN2
      input wire       drop_resp ,    
   `endif

   input wire [31:0]   reg_rdata0 ,   
   input wire [31:0]   reg_rdata1 ,   
   input wire [31:0]   reg_rdata2 ,   
   input wire [31:0]   reg_rdata3 ,   
   input wire [31:0]   reg_rdata4 ,   
   input wire [31:0]   reg_rdata5 ,   
   input wire          reg_wr ,       
   input wire          reg_rd ,       
   input wire          reg_rd_cpm ,   
   input wire          reg_wr_cpm ,   
   input wire          reg_sel_usp ,  
   input wire          reg_id_hit ,   
   input wire          type1_cfg ,    
   input wire          pois_cfg ,     
   input wire          ecrc_ok ,      
   `ifdef ECRC
      input wire       ecrc_chk_enb , 
      input wire       ecrc_gen_enb , 
   `endif

   input wire          cfg_rmux_rd ,   
   input wire [7:0]    tx_ca_cplh ,     
   input wire          tx_ca_cplh_infi ,     

   
   output wire [31:0]  RDAT_O ,       
   output reg          ACK_O ,        

   output wire         us_req_int ,        
   output wire         cfg_rmux_req ,        
   output wire [63:0]  cfg_rmux_data ,     
   output wire         cfg_rmux_dwen ,        
   output wire         cfg_rmux_ae         
   ) ;
reg [6:0]   wr_ptr ;
reg [6:0]   rd_ptr ;
reg [7:0]   dcnt ;
wire        cfg_resp_wr ;
reg [63:0]  resp_din ;
reg         credit_gate ;
reg         resp_wr1 ;
reg         resp_wr2 ;
reg         reg_rd1 ;
reg         reg_wr1 ;
reg [15:0]  resp_d6 ;
reg [15:0]  resp_d7 ;
reg         resp_dwen ;
reg         reg_rw_cpm1 ;
reg [15:0]  req_id_reg ;
reg [7:0]   tag_reg ;
reg         load_id_reg ;
wire        mem_af ;
wire [1:0]  cfg_fmt ;
wire [9:0]  cfg_length ;
wire [2:0]  comp_sts ;
wire [15:0] resp_d0 ;
wire [15:0] resp_d1 ;
wire [15:0] resp_d2 ;
wire [15:0] resp_d3 ;
wire [15:0] resp_d4 ;
wire [15:0] resp_d5 ;
wire [63:0] resp_data0 ;
wire [63:0] resp_data1 ;
wire        send_ur ;

`ifdef GEN2

`endif

`ifdef ECRC

`else

`endif

`ifdef ECP3

`else

`endif

`ifdef ECP3

`else

`endif

`ifdef ECP3

`else

`endif
reg [7 : 0] bus_num_split;
reg [4 : 0] dev_num_split;
reg [2 : 0] func_num_split;
reg [15 : 0] req_id_split;
reg [7 : 0] tag_split;
reg [2 : 0] tc_split;
reg term_all_cfg_split;
reg load_id_split;
reg [31 : 0] reg_rdata0_split;
reg [31 : 0] reg_rdata1_split;
reg [31 : 0] reg_rdata2_split;
reg [31 : 0] reg_rdata3_split;
reg [31 : 0] reg_rdata4_split;
reg [31 : 0] reg_rdata5_split;
reg reg_wr_split;
reg reg_rd_split;
reg reg_rd_cpm_split;
reg reg_wr_cpm_split;
reg reg_sel_usp_split;
reg reg_id_hit_split;
reg type1_cfg_split;
reg pois_cfg_split;
reg ecrc_ok_split;
reg cfg_rmux_rd_split;
reg [7 : 0] tx_ca_cplh_split;
reg tx_ca_cplh_infi_split;
reg [6 : 0] rd_ptr_split;
reg [7 : 0] dcnt_split;
reg cfg_resp_wr_split;
reg [63 : 0] resp_din_split;
reg credit_gate_split;
reg resp_wr1_split;
reg resp_wr2_split;
reg reg_rd1_split;
reg reg_wr1_split;
reg [15 : 0] resp_d6_split;
reg [15 : 0] resp_d7_split;
reg resp_dwen_split;
reg reg_rw_cpm1_split;
reg [15 : 0] req_id_reg_split;
reg [7 : 0] tag_reg_split;
reg load_id_reg_split;
reg mem_af_split;
reg [1 : 0] cfg_fmt_split;
reg [9 : 0] cfg_length_split;
reg [2 : 0] comp_sts_split;
reg [15 : 0] resp_d0_split;
reg [15 : 0] resp_d1_split;
reg [15 : 0] resp_d2_split;
reg [15 : 0] resp_d3_split;
reg [15 : 0] resp_d4_split;
reg [15 : 0] resp_d5_split;
reg [63 : 0] resp_data0_split;
reg [63 : 0] resp_data1_split;
reg send_ur_split;
reg [2047:0] descram_in;
wire [54:0] descram_out;

`ifdef GEN2

`endif

`ifdef ECRC

`else

`endif


`ifdef ECP3

`else

`endif

`ifdef ECP3

`else

`endif

`ifdef ECP3

`else

`endif

localparam descram_inst_SIZE = 55,descram_inst_SCRAMSTRING = 32'hfdffd30b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef GEN2



`endif



`ifdef ECRC



`else



`endif



`ifdef ECP3



`else



`endif



`ifdef ECP3



`else



`endif



`ifdef ECP3



`else



`endif

// =============================================================================

// First data of response TLP write
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      resp_wr1 <= 1'b0;
   

`ifdef GEN2


      else if (drop_resp) 
         resp_wr1 <= 1'b0;
   

`endif


   else if (!term_all_cfg_split) begin
      if (((reg_wr_split && !reg_wr_cpm_split) || (reg_rd_split && !reg_rd_cpm_split)) && ecrc_ok_split && !reg_sel_usp_split && !mem_af_split) 
         resp_wr1 <= 1'b1;
      else 
         resp_wr1 <= 1'b0;
   end
   else  begin
      if (((reg_wr_split && !reg_wr_cpm_split) || (reg_rd_split && !reg_rd_cpm_split)) && ecrc_ok_split && !mem_af_split) 
         resp_wr1 <= 1'b1;
      else 
         resp_wr1 <= 1'b0;
   end
end

// Second data of response TLP write
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      resp_wr2 <= 1'b0;
   else 
      resp_wr2 <= resp_wr1_split;
end

// Register req_id and tag one more time to align response data
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      req_id_reg <= 16'd0 ;
      tag_reg    <= 8'd0 ;
   end
   else begin
      req_id_reg <= req_id_split ;
      tag_reg    <= tag_split ;
   end
end

// Form different components of response TLP
assign send_ur =  (type1_cfg_split | 
                   (~reg_id_hit_split & (reg_rd_split | reg_rd1_split)) |
                   (~reg_id_hit_split & (reg_wr_split | reg_wr1_split)) |
                   (pois_cfg_split & (reg_wr_split | reg_wr1_split))
	          ) ;
assign comp_sts   = (~load_id_reg_split) ? 3'b010 : (send_ur_split ? 3'b001 : 3'b000) ;
assign cfg_fmt    = ((reg_rd_split | reg_rd1_split) && reg_id_hit_split && ~type1_cfg_split) ? 2'b10 : 2'b00 ;
assign cfg_length = (cfg_fmt_split[1]) ? 10'h1 : 10'h0 ;

assign resp_d0 = {1'b0, cfg_fmt_split, 5'b01010, 1'b0, tc_split, 4'b0000} ;


`ifdef ECRC


   assign resp_d1 = {ecrc_gen_enb, 1'b0, 2'b00, 2'b0, cfg_length_split} ;


`else


   assign resp_d1 = {1'b0, 1'b0, 2'b00, 2'b0, cfg_length_split} ;


`endif


assign resp_d2 = {bus_num_split, dev_num_split, func_num_split} ;
assign resp_d3 = {comp_sts_split, 1'b0, 12'h004} ;
assign resp_d4 = req_id_reg_split ;
assign resp_d5 = {tag_reg_split, 1'b0, 7'h00} ;


always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      load_id_reg <= 1'b0 ;
      reg_rd1 <= 1'b0 ;
      reg_wr1 <= 1'b0 ;
   end
   else begin
      load_id_reg <= load_id_split ;
      reg_rd1 <= reg_rd_split ;
      reg_wr1 <= reg_wr_split ;
   end
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      resp_d6 <= 16'd0;
      resp_d7 <= 16'd0;
   end
   else if (reg_rd1_split) begin
      resp_d6[15:8] <= (reg_rdata0_split[7:0]  | reg_rdata1_split[7:0] | reg_rdata2_split[7:0]  | 
                        reg_rdata3_split[7:0] | reg_rdata4_split[7:0] | reg_rdata5_split[7:0]) ;
      resp_d6[7:0]  <= (reg_rdata0_split[15:8] | reg_rdata1_split[15:8] | reg_rdata2_split[15:8] | 
                        reg_rdata3_split[15:8] | reg_rdata4_split[15:8] | reg_rdata5_split[15:8]) ;

      resp_d7[15:8] <= (reg_rdata0_split[23:16] | reg_rdata1_split[23:16] | reg_rdata2_split[23:16] | 
                        reg_rdata3_split[23:16] | reg_rdata4_split[23:16] | reg_rdata5_split[23:16]) ;
      resp_d7[7:0]  <= (reg_rdata0_split[31:24] | reg_rdata1_split[31:24] | reg_rdata2_split[31:24] | 
                        reg_rdata3_split[31:24] | reg_rdata4_split[31:24] | reg_rdata5_split[31:24]) ;
   end
   else begin
      resp_d6 <= 16'd0;
      resp_d7 <= 16'd0;
   end
end

// Data out for CPM side reads
assign  RDAT_O = {resp_d6_split, resp_d7_split} ;
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      reg_rw_cpm1 <= 1'b0 ;
      ACK_O       <= 1'b0 ;
   end
   else begin
      reg_rw_cpm1 <= reg_wr_cpm_split | reg_rd_cpm_split ;
      ACK_O       <= reg_rw_cpm1_split ;
   end
end

assign resp_data0 = {resp_d0_split, resp_d1_split, resp_d2_split, resp_d3_split} ;
assign resp_data1 = {resp_d4_split, resp_d5_split, resp_d6_split, resp_d7_split} ;

assign us_req_int = (resp_wr1_split & comp_sts_split[0] ) ;

// Mux response TLP data to write into memory
always @* begin
   case (1'b1)
      resp_wr1_split : resp_din = resp_data0_split ;
      resp_wr2_split : resp_din = resp_data1_split ;
      default  : resp_din = 64'd0 ;
   endcase
end

// dwen is set for write response and reset for read response
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      resp_dwen <= 1'b0 ;
   else if (reg_wr1_split || (reg_rd1_split && (!reg_id_hit_split || type1_cfg_split)))
      resp_dwen <= 1'b1 ;
   else  
      resp_dwen <= 1'b0 ;
end

// Memory write enable 
assign cfg_resp_wr =  resp_wr1_split | resp_wr2_split ;

// Memory write pointer
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      wr_ptr <= 7'd0 ;
   else if (cfg_resp_wr_split)
      wr_ptr <= wr_ptr + 7'd1 ;
end

// Memory read pointer
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      rd_ptr <= 7'd0 ;
   else if (cfg_rmux_rd_split) 
      rd_ptr <= rd_ptr_split + 7'd1 ;
end

// Instantiate dual port memory TLP buffer.
pmi_ram_dp #( 
   .pmi_wr_addr_depth    ( 128 ),
   .pmi_wr_addr_width    ( 7 ),
   .pmi_wr_data_width    ( 65 ),
   .pmi_rd_addr_depth    ( 128 ),
   .pmi_rd_addr_width    ( 7 ),
   .pmi_rd_data_width    ( 65 ),
   .pmi_regmode          ( "noreg" ),
   .pmi_gsr              ( "enable" ),
   

`ifdef ECP3


      .pmi_resetmode     ( "sync" ),   //Connect LOW
   

`else


      .pmi_resetmode     ( "async" ),
   

`endif


   .pmi_init_file        ( "none" ),
   .pmi_init_file_format ( "binary" ),
   

`ifdef ECP3


      .pmi_family        ( "ECP3" ),
   

`else


      .pmi_family        ( "EC2" ),
   

`endif


   .module_type          ( "pmi_ram_dp" )
   ) 
   u1_resp_mem (
   .Data         ( {resp_dwen, resp_din} ),
   .WrAddress    ( wr_ptr ),
   .RdAddress    ( rd_ptr ),
   .WrClock      ( sys_clk ),
   .RdClock      ( sys_clk ),
   .WrClockEn    ( 1'b1 ),
   .RdClockEn    ( cfg_rmux_rd ), 
   .WE           ( cfg_resp_wr ),
   

`ifdef ECP3


      .Reset     (1'b0),
   

`else


      .Reset     ( ~rst_n ), 
   

`endif


   .Q            ( {cfg_rmux_dwen, cfg_rmux_data} )
   );

// =============================================================================

// Memory data counter
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)  
      dcnt <= 7'd0 ;
   else if (cfg_resp_wr_split && !cfg_rmux_rd_split) 
      dcnt <= dcnt_split + 7'd1 ;
   else if (cfg_rmux_rd_split && !cfg_resp_wr_split) 
      dcnt <= dcnt_split - 7'd1 ;
end

// When data count in memory is more than 248
assign mem_af = (&dcnt_split[7:3]) ;  

// Check for the credit available to send respose TLP.
always @(posedge sys_clk , negedge rst_n) begin
   if (!rst_n)  
      credit_gate <= 1'b0 ;
   else if (tx_ca_cplh_infi_split)
      credit_gate <= 1'b1 ;
   else if (tx_ca_cplh_split != 8'h00)
      credit_gate <= 1'b1 ;
   else 
      credit_gate <= 1'b0 ;
end

// When data count in memory is more than or equal to 2
assign cfg_rmux_req = ((dcnt_split >= 8'h02) && credit_gate_split) ;  

// When data count in memory is less than or equal to 1
assign cfg_rmux_ae = (|dcnt_split[7:1] == 1'b0) ;  

always@* begin bus_num_split<={bus_num>>1,descram_out[0]};dev_num_split<={dev_num>>1,descram_out[1]};func_num_split<={func_num>>1,descram_out[2]};req_id_split<={req_id>>1,descram_out[3]};tag_split<={tag>>1,descram_out[4]};tc_split<={tc>>1,descram_out[5]};term_all_cfg_split<=descram_out[6];load_id_split<=descram_out[7];reg_rdata0_split<={reg_rdata0>>1,descram_out[8]};reg_rdata1_split<={reg_rdata1>>1,descram_out[9]};reg_rdata2_split<={reg_rdata2>>1,descram_out[10]};reg_rdata3_split<={reg_rdata3>>1,descram_out[11]};reg_rdata4_split<={reg_rdata4>>1,descram_out[12]};reg_rdata5_split<={reg_rdata5>>1,descram_out[13]};reg_wr_split<=descram_out[14];reg_rd_split<=descram_out[15];reg_rd_cpm_split<=descram_out[16];reg_wr_cpm_split<=descram_out[17];reg_sel_usp_split<=descram_out[18];reg_id_hit_split<=descram_out[19];type1_cfg_split<=descram_out[20];pois_cfg_split<=descram_out[21];ecrc_ok_split<=descram_out[22];cfg_rmux_rd_split<=descram_out[23];tx_ca_cplh_split<={tx_ca_cplh>>1,descram_out[24]};tx_ca_cplh_infi_split<=descram_out[25];rd_ptr_split<={rd_ptr>>1,descram_out[26]};dcnt_split<={dcnt>>1,descram_out[27]};cfg_resp_wr_split<=descram_out[28];resp_din_split<={resp_din>>1,descram_out[29]};credit_gate_split<=descram_out[30];resp_wr1_split<=descram_out[31];resp_wr2_split<=descram_out[32];reg_rd1_split<=descram_out[33];reg_wr1_split<=descram_out[34];resp_d6_split<={resp_d6>>1,descram_out[35]};resp_d7_split<={resp_d7>>1,descram_out[36]};resp_dwen_split<=descram_out[37];reg_rw_cpm1_split<=descram_out[38];req_id_reg_split<={req_id_reg>>1,descram_out[39]};tag_reg_split<={tag_reg>>1,descram_out[40]};load_id_reg_split<=descram_out[41];mem_af_split<=descram_out[42];cfg_fmt_split<={cfg_fmt>>1,descram_out[43]};cfg_length_split<={cfg_length>>1,descram_out[44]};comp_sts_split<={comp_sts>>1,descram_out[45]};resp_d0_split<={resp_d0>>1,descram_out[46]};resp_d1_split<={resp_d1>>1,descram_out[47]};resp_d2_split<={resp_d2>>1,descram_out[48]};resp_d3_split<={resp_d3>>1,descram_out[49]};resp_d4_split<={resp_d4>>1,descram_out[50]};resp_d5_split<={resp_d5>>1,descram_out[51]};resp_data0_split<={resp_data0>>1,descram_out[52]};resp_data1_split<={resp_data1>>1,descram_out[53]};send_ur_split<=descram_out[54];end
always@* begin descram_in[2047]<=dev_num[0];descram_in[2046]<=func_num[0];descram_in[2044]<=req_id[0];descram_in[2040]<=tag[0];descram_in[2032]<=tc[0];descram_in[2016]<=term_all_cfg;descram_in[1985]<=load_id;descram_in[1922]<=reg_rdata0[0];descram_in[1796]<=reg_rdata1[0];descram_in[1732]<=resp_din[0];descram_in[1600]<=cfg_length[0];descram_in[1572]<=resp_wr2;descram_in[1544]<=reg_rdata2[0];descram_in[1457]<=dcnt[0];descram_in[1417]<=credit_gate;descram_in[1302]<=pois_cfg;descram_in[1164]<=resp_dwen;descram_in[1153]<=comp_sts[0];descram_in[1124]<=tag_reg[0];descram_in[1115]<=cfg_rmux_rd;descram_in[1105]<=reg_wr_cpm;descram_in[1096]<=reg_rd1;descram_in[1041]<=reg_rdata3[0];descram_in[1038]<=resp_d2[0];descram_in[1023]<=bus_num[0];descram_in[946]<=send_ur;descram_in[866]<=cfg_resp_wr;descram_in[800]<=cfg_fmt[0];descram_in[786]<=resp_wr1;descram_in[728]<=rd_ptr[0];descram_in[651]<=type1_cfg;descram_in[582]<=resp_d7[0];descram_in[562]<=req_id_reg[0];descram_in[557]<=ecrc_ok;descram_in[552]<=reg_rd_cpm;descram_in[519]<=resp_d1[0];descram_in[473]<=resp_data1[0];descram_in[400]<=mem_af;descram_in[364]<=tx_ca_cplh_infi;descram_in[325]<=reg_id_hit;descram_in[291]<=resp_d6[0];descram_in[281]<=reg_rw_cpm1;descram_in[276]<=reg_rd;descram_in[259]<=resp_d0[0];descram_in[236]<=resp_data0[0];descram_in[200]<=load_id_reg;descram_in[182]<=tx_ca_cplh[0];descram_in[162]<=reg_sel_usp;descram_in[145]<=reg_wr1;descram_in[138]<=reg_wr;descram_in[118]<=resp_d5[0];descram_in[69]<=reg_rdata5[0];descram_in[59]<=resp_d4[0];descram_in[34]<=reg_rdata4[0];descram_in[29]<=resp_d3[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule

// =============================================================================



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X1_11


// File             : cfg_vcc_ec.v


// Title            :


// Dependencies     : 


// Description      : 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Feb 24, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module cfg_vcc_ec (
   
   input wire [31:0]          INIT_REG_10C , 

   input wire                 sys_clk ,        
   input wire                 rst_n ,          

   input wire                 reg_sel_ec ,     
   input wire [4:0]           reg_addr ,       
   input wire [31:0]          reg_wdata ,      
   input wire [3:0]           reg_wdata_be ,   
   input wire                 reg_wr ,         
   input wire                 reg_rd ,         
   input wire                 ecrc_ok ,        

   input wire [`NUM_VC -1:0]  lcmfci_vcn_pnd ,

   output wire [2:0]          cfgec_evcc ,     
   output wire [2:0]          cfgec_lpevcc ,   
   output wire                cfgec_lvcat ,    
   output wire [2:0]          cfgec_vcasel ,   

   `ifdef EN_VC0
      output wire [7:0]       cfgec_tvmap_0 ,    
      output wire [2:0]       cfgec_vcid_0 ,    
      output wire             cfgec_vcenb_0 ,   
   `endif
   `ifdef EN_VC1
      output wire [7:0]       cfgec_tvmap_1 ,    
      output wire [2:0]       cfgec_vcid_1 ,    
      output wire             cfgec_vcenb_1 ,   
   `endif
   `ifdef EN_VC2
      output wire [7:0]       cfgec_tvmap_2 ,    
      output wire [2:0]       cfgec_vcid_2 ,    
      output wire             cfgec_vcenb_2 ,   
   `endif
   `ifdef EN_VC3
      output wire [7:0]       cfgec_tvmap_3 ,    
      output wire [2:0]       cfgec_vcid_3 ,    
      output wire             cfgec_vcenb_3 ,   
   `endif
   `ifdef EN_VC4
      output wire [7:0]       cfgec_tvmap_4 ,    
      output wire [2:0]       cfgec_vcid_4 ,    
      output wire             cfgec_vcenb_4 ,   
   `endif
   `ifdef EN_VC5
      output wire [7:0]       cfgec_tvmap_5 ,    
      output wire [2:0]       cfgec_vcid_5 ,    
      output wire             cfgec_vcenb_5 ,   
   `endif
   `ifdef EN_VC6
      output wire [7:0]       cfgec_tvmap_6 ,    
      output wire [2:0]       cfgec_vcid_6 ,    
      output wire             cfgec_vcenb_6 ,   
   `endif
   `ifdef EN_VC7
      output wire [7:0]       cfgec_tvmap_7 ,    
      output wire [2:0]       cfgec_vcid_7 ,    
      output wire             cfgec_vcenb_7 ,   
   `endif

   output reg [31:0]          reg_rd_data  
   ) ;
reg [27:0]          vcreg_sel ;
reg [27:0]          vcreg_sel_reg ;
reg [3:0]           vc_cntl ;
reg                 vc_sts ;
wire                ld_vcarb_tbl ;
wire [2:0]          vc_arb_select ;
wire [31:0]         vcreg00_r ;
wire [31:0]         vc_cap_reg1 ;
wire [31:0]         vcreg04_r ;
wire [31:0]         vc_cap_reg2 ;
wire [31:0]         vcreg08_r ;
wire [31:0]         vcreg0c_r ;
wire [2:0]          evcc ;
wire [2:0]          lpevcc ;
wire                vcat_sel = 1'b0 ;
wire [31:0] VCC_REG00 = INIT_REG_10C ;

`ifdef AER

`else 

`endif 

`ifdef EN_VC0
wire [31:0] vcreg10_r ;
wire [31:0] vcreg14_r ;
wire [31:0] vcreg18_r ;
wire [31:0] vc_rcap0 ;
reg  [31:0] vc_rcntl0 ;
reg         vc_rsts0 ;

`endif

`ifdef EN_VC1
wire [31:0] vcreg1c_r ;
wire [31:0] vcreg20_r ;
wire [31:0] vcreg24_r ;
wire [31:0] vc_rcap1 ;
reg  [31:0] vc_rcntl1 ;
reg         vc_rsts1 ;

`endif

`ifdef EN_VC2
wire [31:0] vcreg28_r ;
wire [31:0] vcreg2c_r ;
wire [31:0] vcreg30_r ;
wire [31:0] vc_rcap2 ;
reg  [31:0] vc_rcntl2 ;
reg         vc_rsts2 ;

`endif

`ifdef EN_VC3
wire [31:0] vcreg34_r ;
wire [31:0] vcreg38_r ;
wire [31:0] vcreg3c_r ;
wire [31:0] vc_rcap3 ;
reg  [31:0] vc_rcntl3 ;
reg         vc_rsts3 ;

`endif

`ifdef EN_VC4
wire [31:0] vcreg40_r ;
wire [31:0] vcreg44_r ;
wire [31:0] vcreg48_r ;
wire [31:0] vc_rcap4 ;
reg  [31:0] vc_rcntl4 ;
reg         vc_rsts4 ;

`endif

`ifdef EN_VC5
wire [31:0] vcreg4c_r ;
wire [31:0] vcreg50_r ;
wire [31:0] vcreg54_r ;
wire [31:0] vc_rcap5 ;
reg  [31:0] vc_rcntl5 ;
reg         vc_rsts5 ;

`endif

`ifdef EN_VC6
wire [31:0] vcreg58_r ;
wire [31:0] vcreg5c_r ;
wire [31:0] vcreg60_r ;
wire [31:0] vc_rcap6 ;
reg  [31:0] vc_rcntl6 ;
reg         vc_rsts6 ;

`endif

`ifdef EN_VC7
wire [31:0] vcreg64_r ;
wire [31:0] vcreg68_r ;
wire [31:0] vcreg6c_r ;
wire [31:0] vc_rcap7 ;
reg  [31:0] vc_rcntl7 ;
reg         vc_rsts7 ;

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif
reg [31 : 0] INIT_REG_10C_split;
reg reg_sel_ec_split;
reg [4 : 0] reg_addr_split;
reg [31 : 0] reg_wdata_split;
reg [3 : 0] reg_wdata_be_split;
reg reg_wr_split;
reg reg_rd_split;
reg ecrc_ok_split;
reg [`NUM_VC - 1 : 0] lcmfci_vcn_pnd_split;
reg [27 : 0] vcreg_sel_reg_split;
reg [3 : 0] vc_cntl_split;
reg vc_sts_split;
reg ld_vcarb_tbl_split;
reg [2 : 0] vc_arb_select_split;
reg [31 : 0] vcreg00_r_split;
reg [31 : 0] vc_cap_reg1_split;
reg [31 : 0] vcreg04_r_split;
reg [31 : 0] vc_cap_reg2_split;
reg [31 : 0] vcreg08_r_split;
reg [31 : 0] vcreg0c_r_split;
reg [2 : 0] evcc_split;
reg [2 : 0] lpevcc_split;
reg vcat_sel_split;
reg [31 : 0] VCC_REG00_split;
reg [2047:0] descram_in;
wire [23:0] descram_out;

`ifdef AER

`else 

`endif 

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

localparam descram_inst_SIZE = 24,descram_inst_SCRAMSTRING = 32'hfdfff02b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef AER



`else 



`endif 



`ifdef EN_VC0


`endif



`ifdef EN_VC1


`endif



`ifdef EN_VC2


`endif



`ifdef EN_VC3


`endif



`ifdef EN_VC4


`endif



`ifdef EN_VC5


`endif



`ifdef EN_VC6


`endif



`ifdef EN_VC7


`endif



`ifdef EN_VC0



`endif



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif



`ifdef EN_VC0



`endif



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif

// =============================================================================
// =============================================================================
// VC Registers structure select
// VC capabilities register structure starts at 'h10C
always @(reg_addr_split, reg_sel_ec_split) begin
   case ({reg_sel_ec_split, reg_addr_split[4:0]}) /* synthesis parallel_case */
      6'b1_00011 : vcreg_sel = 28'h000_0001 ;  // Register offset 00
      6'b1_00100 : vcreg_sel = 28'h000_0002 ;  // Register offset 04
      6'b1_00101 : vcreg_sel = 28'h000_0004 ;  // Register offset 08
      6'b1_00110 : vcreg_sel = 28'h000_0008 ;  // Register offset 0c
      6'b1_00111 : vcreg_sel = 28'h000_0010 ;  // Register offset 10 - VC0
      6'b1_01000 : vcreg_sel = 28'h000_0020 ;  // Register offset 14 
      6'b1_01001 : vcreg_sel = 28'h000_0040 ;  // Register offset 18
      6'b1_01010 : vcreg_sel = 28'h000_0080 ;  // Register offset 1c - VC1
      6'b1_01011 : vcreg_sel = 28'h000_0100 ;  // Register offset 20
      6'b1_01100 : vcreg_sel = 28'h000_0200 ;  // Register offset 24
      6'b1_01101 : vcreg_sel = 28'h000_0400 ;  // Register offset 28 - VC2
      6'b1_01110 : vcreg_sel = 28'h000_0800 ;  // Register offset 2C
      6'b1_01111 : vcreg_sel = 28'h000_1000 ;  // Register offset 30
      6'b1_10000 : vcreg_sel = 28'h000_2000 ;  // Register offset 34 - VC3
      6'b1_10001 : vcreg_sel = 28'h000_4000 ;  // Register offset 38
      6'b1_10010 : vcreg_sel = 28'h000_8000 ;  // Register offset 3C
      6'b1_10011 : vcreg_sel = 28'h001_0000 ;  // Register offset 40 - VC4
      6'b1_10100 : vcreg_sel = 28'h002_0000 ;  // Register offset 44
      6'b1_10101 : vcreg_sel = 28'h004_0000 ;  // Register offset 48
      6'b1_10110 : vcreg_sel = 28'h008_0000 ;  // Register offset 4C - VC5
      6'b1_10111 : vcreg_sel = 28'h010_0000 ;  // Register offset 50
      6'b1_11000 : vcreg_sel = 28'h020_0000 ;  // Register offset 54
      6'b1_11001 : vcreg_sel = 28'h040_0000 ;  // Register offset 58 - VC6
      6'b1_11010 : vcreg_sel = 28'h080_0000 ;  // Register offset 5c
      6'b1_11011 : vcreg_sel = 28'h100_0000 ;  // Register offset 60
      6'b1_11100 : vcreg_sel = 28'h200_0000 ;  // Register offset 64 - VC7
      6'b1_11101 : vcreg_sel = 28'h400_0000 ;  // Register offset 68
      6'b1_11110 : vcreg_sel = 28'h800_0000 ;  // Register offset 6C
      default    : vcreg_sel = 28'h000_0000 ; 
   endcase
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      vcreg_sel_reg <= 28'h000_0000;
   else 
      vcreg_sel_reg <= vcreg_sel ;
end

// Enhanced capability header Register at offset 00


`ifdef AER


   assign vcreg00_r = {12'h1A0, 4'h1, 16'h0002} ; 


`else 


   assign vcreg00_r = {VCC_REG00_split[31:20],4'h1, 16'h0002} ; 


`endif 



// Port VC capability Register1 at offset 04
assign evcc = (`NUM_VC - 1) ; 
assign lpevcc = `LPEVCC ; 

assign  vc_cap_reg1 = {16'd0, 4'd0, 2'b00, 2'b00, 1'b0, lpevcc_split, 1'b0, evcc_split}  ; 
assign  vcreg04_r =  vc_cap_reg1_split ; 

assign  cfgec_evcc = vc_cap_reg1_split[2:0] ; 
assign  cfgec_lpevcc = vc_cap_reg1_split[6:4] ; 

// Port VC capability Register2 at offset 08
assign  vc_cap_reg2 = {8'h00, 16'h0000, 8'h01} ; 
assign  vcreg08_r = vc_cap_reg2_split ; 

// Port VC Control Register at offset 0C
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      vc_cntl <= 4'd0 ; 
   else if (reg_wr_split && ecrc_ok_split && vcreg_sel[3] && reg_wdata_be_split[0]) 
      vc_cntl <= reg_wdata_split[3:0] ; 
   else 
      vc_cntl <= vc_cntl_split ; 
end
assign cfgec_lvcat = vc_cntl_split[0] ;
assign cfgec_vcasel = vc_cntl_split[3:1] ;

// Port VC Status Register at offset 0E 
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      vc_sts <= 1'b0 ; 
   else if (vcat_sel_split && reg_wr_split && ecrc_ok_split) 
      vc_sts <= 1'b1 ; 
   else if (vc_cntl_split[0]) 
      vc_sts <= 1'b0 ; 
   else 
      vc_sts <= vc_sts_split ; 
end
assign  vcreg0c_r = {15'h0000, 1'b0, 12'h000, vc_cntl_split[3:1], 1'b0}  ; 

// =============================================================================
// VC Resource Registr(0) at offsets 10, 14, 18
// =============================================================================


`ifdef EN_VC0


   // VC Resource Capability Register(0) at offset 10
   assign  vc_rcap0  = 32'd0  ; 
   assign  vcreg10_r = 32'd0 ; 

   // VC Resource Control Register(0) at offset 14
   assign  vcreg14_r =  {1'b1, 4'b0000, 3'b000, 4'b0000, 
                                        4'h0, 8'h00, 8'hFF} ; 
   assign  cfgec_tvmap_0 =  8'h01 ; 
   assign  cfgec_vcid_0  =  3'b000 ; 
   assign  cfgec_vcenb_0 =  1'b1 ; 

   // VC Resource Status Register(0) at offset 18
   always @(posedge sys_clk, negedge rst_n) begin
      if ( !rst_n ) 
         vc_rsts0 <= 1'b0 ; 
      else begin
         vc_rsts0 <= lcmfci_vcn_pnd_split[0] ;
      end
   end
   assign  vcreg18_r =  {14'h0000, vc_rsts0, 1'b0, 16'h0000} ; 


`endif


// =============================================================================
// VC Resource Registr(1) at offsets 1C, 20, 24
// =============================================================================


`ifdef EN_VC1


   // VC Resource Capability Register(1) at offset 1C
   assign  vc_rcap1  = 32'd0  ; 
   assign  vcreg1c_r = 32'd0 ; 

   // VC Resource Control Register(1) at offset 20
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) 
         vc_rcntl1 <= 32'd0 ; 
      else if (reg_wr_split && ecrc_ok_split && vcreg_sel[8]) begin 
         if (reg_wdata_be_split[0]) vc_rcntl1[7:0]   <= reg_wdata_split[7:0] ; 
         if (reg_wdata_be_split[3]) vc_rcntl1[31:24] <= reg_wdata_split[31:24] ; 
      end
   end
   assign  vcreg20_r =  {vc_rcntl1[31], 4'h0, vc_rcntl1[26:24], 4'h0, 
                         4'h0, 8'h00, vc_rcntl1[7:0]};
   assign  cfgec_tvmap_1 =  vc_rcntl1[7:0] ; 
   assign  cfgec_vcid_1  =  vc_rcntl1[26:24] ; 
   assign  cfgec_vcenb_1 =  vc_rcntl1[31] ; 

   // VC Resource Status Register(1) at offset 24
   always @(posedge sys_clk, negedge rst_n) begin
      if ( !rst_n ) 
         vc_rsts1 <= 2'd0 ; 
      else 
         vc_rsts1 <= lcmfci_vcn_pnd_split[1] ;
   end
   assign  vcreg24_r =  {14'h0000, vc_rsts1, 1'b0, 16'h0000} ; 


`endif



// =============================================================================
// VC Resource Registr(2) at offsets 28, 2C, 30
// =============================================================================


`ifdef EN_VC2


   // VC Resource Capability Register(2) at offset 28
   assign  vc_rcap2  = 32'd0  ; 
   assign  vcreg28_r = 32'd0 ; 

   // VC Resource Control Register(2) at offset 2C
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) 
         vc_rcntl2 <= 32'd0 ; 
      else if (reg_wr_split && ecrc_ok_split && vcreg_sel[11]) begin 
         if (reg_wdata_be_split[0]) vc_rcntl2[7:0]   <= reg_wdata_split[7:0] ; 
         if (reg_wdata_be_split[3]) vc_rcntl2[31:24] <= reg_wdata_split[31:24] ; 
      end
   end
   assign  vcreg2c_r =  {vc_rcntl2[31], 4'h0, vc_rcntl2[26:24], 4'h0, 
                         4'h0, 8'h00, vc_rcntl2[7:0]};
   assign  cfgec_tvmap_2 =  vc_rcntl2[7:0] ; 
   assign  cfgec_vcid_2  =  vc_rcntl2[26:24] ; 
   assign  cfgec_vcenb_2 =  vc_rcntl2[31] ; 

   // VC Resource Status Register(2) at offset 30
   always @(posedge sys_clk, negedge rst_n) begin
      if ( !rst_n ) 
         vc_rsts2 <= 2'd0 ; 
      else 
         vc_rsts2 <= lcmfci_vcn_pnd_split[2] ;
   end
   assign  vcreg30_r =  {14'h0000, vc_rsts2, 1'b0, 16'h0000} ; 


`endif



// =============================================================================
// VC Resource Registr(3) at offsets 34, 38, 3C
// =============================================================================


`ifdef EN_VC3


   // VC Resource Capability Register(3) at offset 34
   assign  vc_rcap3  = 32'd0  ; 
   assign  vcreg34_r = 32'd0 ; 

   // VC Resource Control Register(3) at offset 38
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) 
         vc_rcntl3 <= 32'd0 ; 
      else if (reg_wr_split && ecrc_ok_split && vcreg_sel[14]) begin 
         if (reg_wdata_be_split[0]) vc_rcntl3[7:0]   <= reg_wdata_split[7:0] ; 
         if (reg_wdata_be_split[3]) vc_rcntl3[31:24] <= reg_wdata_split[31:24] ; 
      end
   end
   assign  vcreg38_r =  {vc_rcntl3[31], 4'h0, vc_rcntl3[26:24], 4'h0, 
                         4'h0, 8'h00, vc_rcntl3[7:0]};
   assign  cfgec_tvmap_3 =  vc_rcntl3[7:0] ; 
   assign  cfgec_vcid_3  =  vc_rcntl3[26:24] ; 
   assign  cfgec_vcenb_3 =  vc_rcntl3[31] ; 

   // VC Resource Status Register(3) at offset 3C
   always @(posedge sys_clk, negedge rst_n) begin
      if ( !rst_n ) 
         vc_rsts3 <= 1'b0 ; 
      else 
         vc_rsts3 <= lcmfci_vcn_pnd_split[3] ;
   end
   assign  vcreg3c_r =  {14'h0000, vc_rsts3, 1'b0, 16'h0000} ; 


`endif



// =============================================================================
// VC Resource Registr(4) at offsets 40, 44, 48
// =============================================================================


`ifdef EN_VC4


   // VC Resource Capability Register(4) at offset 40
   assign  vc_rcap4  = 32'd0  ; 
   assign  vcreg40_r = 32'd0 ; 

   // VC Resource Control Register(4) at offset 44
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) 
         vc_rcntl4 <= 32'd0 ; 
      else if (reg_wr_split && ecrc_ok_split && vcreg_sel[17]) begin 
         if (reg_wdata_be_split[0]) vc_rcntl4[7:0]   <= reg_wdata_split[7:0] ; 
         if (reg_wdata_be_split[3]) vc_rcntl4[31:24] <= reg_wdata_split[31:24] ; 
      end
   end
   assign  vcreg44_r =  {vc_rcntl4[31], 4'h0, vc_rcntl4[26:24], 4'h0, 
                         4'h0, 8'h00, vc_rcntl4[7:0]};
   assign  cfgec_tvmap_4 =  vc_rcntl4[7:0] ; 
   assign  cfgec_vcid_4  =  vc_rcntl4[26:24] ; 
   assign  cfgec_vcenb_4 =  vc_rcntl4[31] ; 

   // VC Resource Status Register(4) at offset 48
   always @(posedge sys_clk, negedge rst_n) begin
      if ( !rst_n ) 
         vc_rsts4 <= 1'b0 ; 
      else 
         vc_rsts4 <= lcmfci_vcn_pnd_split[4] ;
   end
   assign  vcreg48_r =  {14'h0000, vc_rsts4, 1'b0, 16'h0000} ; 


`endif



// =============================================================================
// VC Resource Registr(5) at offsets 4C, 50, 54
// =============================================================================


`ifdef EN_VC5


   // VC Resource Capability Register(5) at offset 4C
   assign  vc_rcap5  = 32'd0  ; 
   assign  vcreg4c_r = 32'd0 ; 

   // VC Resource Control Register(5) at offset 50
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) 
         vc_rcntl5 <= 32'd0 ; 
      else if (reg_wr_split && ecrc_ok_split && vcreg_sel[20]) begin 
         if (reg_wdata_be_split[0]) vc_rcntl5[7:0]   <= reg_wdata_split[7:0] ; 
         if (reg_wdata_be_split[3]) vc_rcntl5[31:24] <= reg_wdata_split[31:24] ; 
      end
   end
   assign  vcreg50_r =  {vc_rcntl5[31], 4'h0, vc_rcntl5[26:24], 4'h0, 
                         4'h0, 8'h00, vc_rcntl5[7:0]};
   assign  cfgec_tvmap_5 =  vc_rcntl5[7:0] ; 
   assign  cfgec_vcid_5  =  vc_rcntl5[26:24] ; 
   assign  cfgec_vcenb_5 =  vc_rcntl5[31] ; 

   // VC Resource Status Register(5) at offset 54
   always @(posedge sys_clk, negedge rst_n) begin
      if ( !rst_n ) 
         vc_rsts5 <= 1'b0 ; 
      else 
         vc_rsts5 <= lcmfci_vcn_pnd_split[5] ;
   end
   assign  vcreg54_r =  {14'h0000, vc_rsts5, 1'b0, 16'h0000} ; 




`endif


// =============================================================================
// VC Resource Registr(6) at offsets 58, 5C, 60
// =============================================================================


`ifdef EN_VC6


   // VC Resource Capability Register(6) at offset 58
   assign  vc_rcap6  = 32'd0  ; 
   assign  vcreg58_r = 32'd0 ; 

   // VC Resource Control Register(6) at offset 5C
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) 
         vc_rcntl6 <= 32'd0 ; 
      else if (reg_wr_split && ecrc_ok_split && vcreg_sel[23]) begin 
         if (reg_wdata_be_split[0]) vc_rcntl6[7:0]   <= reg_wdata_split[7:0] ; 
         if (reg_wdata_be_split[3]) vc_rcntl6[31:24] <= reg_wdata_split[31:24] ; 
      end
   end
   assign  vcreg5c_r =  {vc_rcntl6[31], 4'h0, vc_rcntl6[26:24], 4'h0, 
                         4'h0, 8'h00, vc_rcntl6[7:0]};
   assign  cfgec_tvmap_6 =  vc_rcntl6[7:0] ; 
   assign  cfgec_vcid_6  =  vc_rcntl6[26:24] ; 
   assign  cfgec_vcenb_6 =  vc_rcntl6[31] ; 

   // VC Resource Status Register(6) at offset 60
   always @(posedge sys_clk, negedge rst_n) begin
      if ( !rst_n ) 
         vc_rsts6 <= 1'b0 ; 
      else 
         vc_rsts6 <= lcmfci_vcn_pnd_split[6] ;
   end
   assign  vcreg60_r =  {14'h0000, vc_rsts6, 1'b0, 16'h0000} ; 



`endif


// =============================================================================
// VC Resource Registr(7) at offsets 64, 68, 6C
// =============================================================================


`ifdef EN_VC7


   // VC Resource Capability Register(7) at offset 64
   assign  vc_rcap7  = 32'd0  ; 
   assign  vcreg64_r = 32'd0 ; 

   // VC Resource Control Register(7) at offset 68
   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) 
         vc_rcntl7 <= 32'd0 ; 
      else if (reg_wr_split && ecrc_ok_split && vcreg_sel[26]) begin 
         if (reg_wdata_be_split[0]) vc_rcntl7[7:0]   <= reg_wdata_split[7:0] ; 
         if (reg_wdata_be_split[3]) vc_rcntl7[31:24] <= reg_wdata_split[31:24] ; 
      end
   end
   assign  vcreg68_r =  {vc_rcntl7[31], 4'h0, vc_rcntl7[26:24], 4'h0, 
                         4'h0, 8'h00, vc_rcntl7[7:0]};
   assign  cfgec_tvmap_7 =  vc_rcntl7[7:0] ; 
   assign  cfgec_vcid_7  =  vc_rcntl7[26:24] ; 
   assign  cfgec_vcenb_7 =  vc_rcntl7[31] ; 

   // VC Resource Status Register(4) at offset 48
   always @(posedge sys_clk, negedge rst_n) begin
      if ( !rst_n ) 
         vc_rsts7 <= 1'b0 ; 
      else 
         vc_rsts7 <= lcmfci_vcn_pnd_split[7] ;
   end
   assign  vcreg6c_r =  {14'h0000, vc_rsts7, 1'b0, 16'h0000} ; 




`endif


// =============================================================================

always @(vcreg_sel_reg_split,  
         vcreg00_r_split, vcreg04_r_split, vcreg08_r_split, vcreg0c_r_split  
        

`ifdef EN_VC0


           , vcreg10_r, vcreg14_r, vcreg18_r  
        

`endif


        

`ifdef EN_VC1


           , vcreg1c_r, vcreg20_r, vcreg24_r  
        

`endif


        

`ifdef EN_VC2


           , vcreg28_r, vcreg2c_r, vcreg30_r  
        

`endif


        

`ifdef EN_VC3


           , vcreg34_r, vcreg38_r, vcreg3c_r  
        

`endif


        

`ifdef EN_VC4


           , vcreg40_r, vcreg44_r, vcreg48_r  
        

`endif


        

`ifdef EN_VC5


           , vcreg4c_r, vcreg50_r, vcreg54_r  
        

`endif


        

`ifdef EN_VC6


           , vcreg58_r, vcreg5c_r, vcreg60_r  
        

`endif


        

`ifdef EN_VC7


           , vcreg64_r, vcreg68_r, vcreg6c_r 
        

`endif


        ) begin
   case (1'b1) /* synthesis parallel_case */
         vcreg_sel_reg_split[0]  : reg_rd_data = vcreg00_r_split ;
         vcreg_sel_reg_split[1]  : reg_rd_data = vcreg04_r_split ;
         vcreg_sel_reg_split[2]  : reg_rd_data = vcreg08_r_split ;
         vcreg_sel_reg_split[3]  : reg_rd_data = vcreg0c_r_split ;
      

`ifdef EN_VC0


         vcreg_sel_reg_split[4]  : reg_rd_data = vcreg10_r ;
         vcreg_sel_reg_split[5]  : reg_rd_data = vcreg14_r ;
         vcreg_sel_reg_split[6]  : reg_rd_data = vcreg18_r ;
      

`endif


      

`ifdef EN_VC1


         vcreg_sel_reg_split[7]  : reg_rd_data = vcreg1c_r ;
         vcreg_sel_reg_split[8]  : reg_rd_data = vcreg20_r ;
         vcreg_sel_reg_split[9]  : reg_rd_data = vcreg24_r ;
      

`endif


      

`ifdef EN_VC2


         vcreg_sel_reg_split[10] : reg_rd_data = vcreg28_r ;
         vcreg_sel_reg_split[11] : reg_rd_data = vcreg2c_r ;
         vcreg_sel_reg_split[12] : reg_rd_data = vcreg30_r ;
      

`endif


      

`ifdef EN_VC3


         vcreg_sel_reg_split[13] : reg_rd_data = vcreg34_r ;
         vcreg_sel_reg_split[14] : reg_rd_data = vcreg38_r ;
         vcreg_sel_reg_split[15] : reg_rd_data = vcreg3c_r ;
      

`endif


      

`ifdef EN_VC4


         vcreg_sel_reg_split[16] : reg_rd_data = vcreg40_r ;
         vcreg_sel_reg_split[17] : reg_rd_data = vcreg44_r ;
         vcreg_sel_reg_split[18] : reg_rd_data = vcreg48_r ;
      

`endif


      

`ifdef EN_VC5


         vcreg_sel_reg_split[19] : reg_rd_data = vcreg4c_r ;
         vcreg_sel_reg_split[20] : reg_rd_data = vcreg50_r ;
         vcreg_sel_reg_split[21] : reg_rd_data = vcreg54_r ;
      

`endif


      

`ifdef EN_VC6


         vcreg_sel_reg_split[22] : reg_rd_data = vcreg58_r ;
         vcreg_sel_reg_split[23] : reg_rd_data = vcreg5c_r ;
         vcreg_sel_reg_split[24] : reg_rd_data = vcreg60_r ;
      

`endif


      

`ifdef EN_VC7


         vcreg_sel_reg_split[25] : reg_rd_data = vcreg64_r ;
         vcreg_sel_reg_split[26] : reg_rd_data = vcreg68_r ;
         vcreg_sel_reg_split[27] : reg_rd_data = vcreg6c_r ;
      

`endif


      default              : reg_rd_data = 32'd0 ;
   endcase
end

always@* begin INIT_REG_10C_split<={INIT_REG_10C>>1,descram_out[0]};reg_sel_ec_split<=descram_out[1];reg_addr_split<={reg_addr>>1,descram_out[2]};reg_wdata_split<={reg_wdata>>1,descram_out[3]};reg_wdata_be_split<={reg_wdata_be>>1,descram_out[4]};reg_wr_split<=descram_out[5];reg_rd_split<=descram_out[6];ecrc_ok_split<=descram_out[7];lcmfci_vcn_pnd_split<={lcmfci_vcn_pnd>>1,descram_out[8]};vcreg_sel_reg_split<={vcreg_sel_reg>>1,descram_out[9]};vc_cntl_split<={vc_cntl>>1,descram_out[10]};vc_sts_split<=descram_out[11];ld_vcarb_tbl_split<=descram_out[12];vc_arb_select_split<={vc_arb_select>>1,descram_out[13]};vcreg00_r_split<={vcreg00_r>>1,descram_out[14]};vc_cap_reg1_split<={vc_cap_reg1>>1,descram_out[15]};vcreg04_r_split<={vcreg04_r>>1,descram_out[16]};vc_cap_reg2_split<={vc_cap_reg2>>1,descram_out[17]};vcreg08_r_split<={vcreg08_r>>1,descram_out[18]};vcreg0c_r_split<={vcreg0c_r>>1,descram_out[19]};evcc_split<={evcc>>1,descram_out[20]};lpevcc_split<={lpevcc>>1,descram_out[21]};vcat_sel_split<=descram_out[22];VCC_REG00_split<={VCC_REG00>>1,descram_out[23]};end
always@* begin descram_in[2047]<=reg_sel_ec;descram_in[2046]<=reg_addr[0];descram_in[2044]<=reg_wdata[0];descram_in[2041]<=reg_wdata_be[0];descram_in[2035]<=reg_wr;descram_in[2022]<=reg_rd;descram_in[1996]<=ecrc_ok;descram_in[1945]<=lcmfci_vcn_pnd[0];descram_in[1843]<=vcreg_sel_reg[0];descram_in[1746]<=vcreg08_r[0];descram_in[1685]<=lpevcc[0];descram_in[1645]<=vcreg00_r[0];descram_in[1638]<=vc_cntl[0];descram_in[1445]<=vcreg0c_r[0];descram_in[1322]<=vcat_sel;descram_in[1242]<=vc_cap_reg1[0];descram_in[1229]<=vc_sts;descram_in[1023]<=INIT_REG_10C[0];descram_in[873]<=vc_cap_reg2[0];descram_in[842]<=evcc[0];descram_in[822]<=vc_arb_select[0];descram_in[597]<=VCC_REG00[0];descram_in[436]<=vcreg04_r[0];descram_in[411]<=ld_vcarb_tbl;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================




// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X1_11


// File             : cfg_type0.v


// Title            :


// Dependencies     : 


// Description      : 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Feb 21, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module cfg_type0 (
   
   input wire [31:0]   INIT_REG_000 , 
   input wire [31:0]   INIT_REG_008 , 
   input wire [31:0]   INIT_REG_00C ,
   input wire [31:0]   INIT_REG_010 , 
   input wire [31:0]   INIT_REG_014 , 
   input wire [31:0]   INIT_REG_018 , 
   input wire [31:0]   INIT_REG_01C , 
   input wire [31:0]   INIT_REG_020 , 
   input wire [31:0]   INIT_REG_024 , 
   input wire [31:0]   INIT_REG_028 , 
   input wire [31:0]   INIT_REG_02C , 
   input wire [31:0]   INIT_REG_030 , 
   input wire [31:0]   INIT_REG_03C , 
   input wire          load_id ,        

   input wire          sys_clk ,        
   input wire          rst_n ,          

   input wire          reg_sel_t0 ,     
   input wire [3:0]    reg_addr ,       
   input wire [31:0]   reg_wdata ,      
   input wire [3:0]    reg_wdata_be ,   
   input wire          reg_wr ,         
   input wire          reg_rd ,         
   input wire          ecrc_ok ,        

   input wire          phy_link_up ,    
   input wire          load_cfg ,       
   `ifdef GEN2
      input wire       flr ,            
   `endif
   input wire [15:0]   sts_reg_in ,      

   
   output reg [31:0]   bar_10 ,         
   output reg [31:0]   bar_14 ,         
   output reg [31:0]   bar_18 ,         
   output reg [31:0]   bar_1c ,         
   output reg [31:0]   bar_20 ,         
   output reg [31:0]   bar_24 ,         
   output reg [31:0]   bar_30 ,         
   output wire [5:0]   cmd_reg_out ,    

   output reg [31:0]   reg_rd_data   
   ) ;
reg [15:0]          breg_sel ;
reg [15:0]          breg_sel_reg ;
reg                 load_id_reg ;
reg [15:0]          cmd_reg ;
reg [15:0]          sts_reg ;
reg [7:0]           cls_reg ;
reg [7:0]           intr_line ;
reg [31:0]          breg_00 ;
reg [31:0]          breg_08 ;
reg [31:0]          breg_2c ;
wire [31:0]         breg_0c ;
wire [31:0]         breg_1c ;
wire [31:0]         breg_28 ;
wire [15:0]         cmd_reg_r ;
wire [15:0]         sts_reg_r ;
wire [31:0]         breg00_r ;
wire [31:0]         breg04_r ;
wire [31:0]         breg08_r ;
wire [31:0]         breg0c_r ;
wire [31:0]         breg10_r ;
wire [31:0]         breg14_r ;
wire [31:0]         breg18_r ;
wire [31:0]         breg1c_r ;
wire [31:0]         breg20_r ;
wire [31:0]         breg24_r ;
wire [31:0]         breg28_r ;
wire [31:0]         breg2c_r ;
wire [31:0]         breg30_r ;
wire [31:0]         breg34_r ;
wire [31:0]         breg38_r ;
wire [31:0]         breg3c_r ;
wire [7:0]          intr_pin ;
wire [7:0]          cap_ptr ;

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif
reg [31 : 0] INIT_REG_000_split;
reg [31 : 0] INIT_REG_008_split;
reg [31 : 0] INIT_REG_00C_split;
reg [31 : 0] INIT_REG_010_split;
reg [31 : 0] INIT_REG_014_split;
reg [31 : 0] INIT_REG_018_split;
reg [31 : 0] INIT_REG_01C_split;
reg [31 : 0] INIT_REG_020_split;
reg [31 : 0] INIT_REG_024_split;
reg [31 : 0] INIT_REG_028_split;
reg [31 : 0] INIT_REG_02C_split;
reg [31 : 0] INIT_REG_030_split;
reg [31 : 0] INIT_REG_03C_split;
reg load_id_split;
reg reg_sel_t0_split;
reg [3 : 0] reg_addr_split;
reg [31 : 0] reg_wdata_split;
reg [3 : 0] reg_wdata_be_split;
reg reg_wr_split;
reg reg_rd_split;
reg ecrc_ok_split;
reg phy_link_up_split;
reg load_cfg_split;
reg [15 : 0] sts_reg_in_split;
reg [15 : 0] breg_sel_reg_split;
reg load_id_reg_split;
reg [15 : 0] cmd_reg_split;
reg [15 : 0] sts_reg_split;
reg [7 : 0] cls_reg_split;
reg [7 : 0] intr_line_split;
reg [31 : 0] breg_00_split;
reg [31 : 0] breg_08_split;
reg [31 : 0] breg_2c_split;
reg [31 : 0] breg_0c_split;
reg [31 : 0] breg_1c_split;
reg [31 : 0] breg_28_split;
reg [15 : 0] cmd_reg_r_split;
reg [15 : 0] sts_reg_r_split;
reg [31 : 0] breg00_r_split;
reg [31 : 0] breg04_r_split;
reg [31 : 0] breg08_r_split;
reg [31 : 0] breg0c_r_split;
reg [31 : 0] breg10_r_split;
reg [31 : 0] breg14_r_split;
reg [31 : 0] breg18_r_split;
reg [31 : 0] breg1c_r_split;
reg [31 : 0] breg20_r_split;
reg [31 : 0] breg24_r_split;
reg [31 : 0] breg28_r_split;
reg [31 : 0] breg2c_r_split;
reg [31 : 0] breg30_r_split;
reg [31 : 0] breg34_r_split;
reg [31 : 0] breg38_r_split;
reg [31 : 0] breg3c_r_split;
reg [7 : 0] intr_pin_split;
reg [7 : 0] cap_ptr_split;
reg [2047:0] descram_in;
wire [55:0] descram_out;

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

localparam descram_inst_SIZE = 56,descram_inst_SCRAMSTRING = 32'hfdffda0b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif

// =============================================================================

always @(reg_addr_split, reg_sel_t0_split) begin
   case ({reg_sel_t0_split, reg_addr_split[3:0]}) /* synthesis parallel_case */
      5'h1_0 : breg_sel = 16'b0000_0000_0000_0001 ;  // Register 00
      5'h1_1 : breg_sel = 16'b0000_0000_0000_0010 ;  // Register 04
      5'h1_2 : breg_sel = 16'b0000_0000_0000_0100 ;  // Register 08
      5'h1_3 : breg_sel = 16'b0000_0000_0000_1000 ;  // Register 0c
      5'h1_4 : breg_sel = 16'b0000_0000_0001_0000 ;  // Register 10
      5'h1_5 : breg_sel = 16'b0000_0000_0010_0000 ;  // Register 14
      5'h1_6 : breg_sel = 16'b0000_0000_0100_0000 ;  // Register 18
      5'h1_7 : breg_sel = 16'b0000_0000_1000_0000 ;  // Register 1c
      5'h1_8 : breg_sel = 16'b0000_0001_0000_0000 ;  // Register 20
      5'h1_9 : breg_sel = 16'b0000_0010_0000_0000 ;  // Register 24
      5'h1_A : breg_sel = 16'b0000_0100_0000_0000 ;  // Register 28
      5'h1_B : breg_sel = 16'b0000_1000_0000_0000 ;  // Register 2c
      5'h1_C : breg_sel = 16'b0001_0000_0000_0000 ;  // Register 30
      5'h1_D : breg_sel = 16'b0010_0000_0000_0000 ;  // Register 34
      5'h1_E : breg_sel = 16'b0100_0000_0000_0000 ;  // Register 38 
      5'h1_F : breg_sel = 16'b1000_0000_0000_0000 ;  // Register 3c
      default: breg_sel = 16'b0000_0000_0000_0000 ;  
   endcase
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      breg_sel_reg <= 16'h0000 ;
      load_id_reg  <= 1'b0 ;
   end 
   else begin 
      breg_sel_reg <= breg_sel ;
      load_id_reg  <= load_id_split ;
   end 
end

// register at offset 00
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      breg_00 <= 32'd0 ;
   else if (load_id_reg_split) 
      breg_00 <= INIT_REG_000_split ;
end
assign  breg00_r = breg_00_split ; 

// Command register at offset 04
always @(posedge sys_clk, negedge rst_n) begin
   if ( !rst_n ) 
      cmd_reg <= 16'd0 ; 
   

`ifdef GEN2


      else if (flr) begin
         cmd_reg[0]  <= 1'b0 ;
         cmd_reg[1]  <= 1'b0 ;
         cmd_reg[2]  <= 1'b0 ;
         cmd_reg[6]  <= 1'b0 ;
         cmd_reg[8]  <= 1'b0 ;
         cmd_reg[10] <= 1'b0 ;
      end
   

`endif


   else if (!phy_link_up_split) begin
      cmd_reg[0]  <= 1'b0 ;
      cmd_reg[1]  <= 1'b0 ;
      cmd_reg[2]  <= 1'b0 ;
      cmd_reg[6]  <= 1'b0 ;
      cmd_reg[8]  <= 1'b0 ;
      cmd_reg[10] <= 1'b0 ;
   end
   else if (reg_wr_split && ecrc_ok_split && breg_sel[1] ) begin
      if (reg_wdata_be_split[0]) begin
         cmd_reg[0]  <= reg_wdata_split[0] ;
         cmd_reg[1]  <= reg_wdata_split[1] ;
         cmd_reg[2]  <= reg_wdata_split[2] ;
         cmd_reg[6]  <= reg_wdata_split[6] ;
      end
      if (reg_wdata_be_split[1]) begin
         cmd_reg[8]  <= reg_wdata_split[8] ;
         cmd_reg[10] <= reg_wdata_split[10] ;
      end
   end
end
assign  cmd_reg_out = {cmd_reg_split[10], cmd_reg_split[8], cmd_reg_split[6], cmd_reg_split[2], cmd_reg_split[1:0]}  ; 

assign  cmd_reg_r = {5'd0, cmd_reg_split[10], 1'b0, cmd_reg_split[8], 
                     1'b0, cmd_reg_split[6], 3'b000, cmd_reg_split[2], cmd_reg_split[1:0]}  ; 

// Status register at offset 04
always @(posedge sys_clk, negedge rst_n) begin
   if ( !rst_n ) 
      sts_reg <= 16'd0 ; 
   

`ifdef GEN2


      else if (flr) 
         sts_reg <= 16'd0 ; 
   

`endif


   else if (reg_wr_split && ecrc_ok_split && breg_sel[1] && reg_wdata_be_split[3]) begin
      if (reg_wdata_split[24]) sts_reg[8]  <= 1'b0 ;
      if (reg_wdata_split[27]) sts_reg[11] <= 1'b0 ;
      if (reg_wdata_split[28]) sts_reg[12] <= 1'b0 ;
      if (reg_wdata_split[29]) sts_reg[13] <= 1'b0 ;
      if (reg_wdata_split[30]) sts_reg[14] <= 1'b0 ;
      if (reg_wdata_split[31]) sts_reg[15] <= 1'b0 ;
   end
   else begin
      if (sts_reg_in_split[3] )  
         sts_reg[3]  <= 1'b1 ;
      else 
         sts_reg[3]  <= 1'b0 ;

      if (sts_reg_in_split[8] )  sts_reg[8]  <= 1'b1 ;
      if (sts_reg_in_split[11] ) sts_reg[11] <= 1'b1 ;
      if (sts_reg_in_split[12] ) sts_reg[12] <= 1'b1 ;
      if (sts_reg_in_split[13] ) sts_reg[13] <= 1'b1 ;
      if (sts_reg_in_split[14] ) sts_reg[14] <= 1'b1 ;
      if (sts_reg_in_split[15] ) sts_reg[15] <= 1'b1 ;
   end
end
assign  sts_reg_r = {sts_reg_split[15:11], 2'b00, sts_reg_split[8], 3'b000, 1'b1, sts_reg_split[3], 3'b000} ; 
assign  breg04_r = {sts_reg_r_split, cmd_reg_r_split} ; 

// Register at offset 08
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      breg_08 <= 32'd0 ;
   else if (load_id_reg_split) 
      breg_08 <= INIT_REG_008_split ;
end
assign  breg08_r = breg_08_split ; 

// Register at offset 0C
assign  breg_0c = INIT_REG_00C_split ; 
always @(posedge sys_clk or negedge rst_n) begin
   if ( !rst_n ) 
      cls_reg <= 8'd0 ; 
   else if (load_cfg_split)
      cls_reg <= INIT_REG_00C_split[7:0] ; 
   

`ifdef GEN2


      else if (flr) 
         cls_reg <= INIT_REG_00C_split[7:0] ; 
   

`endif


   else if (reg_wr_split && ecrc_ok_split && breg_sel[3] && reg_wdata_be_split[0])
      cls_reg[7:0]  <= reg_wdata_split[7:0] ;
end

assign  breg0c_r = {INIT_REG_00C_split[31:8], cls_reg_split[7:0]} ; 

// following convensions used for BAR egisters
// (INIT_REG_0[2:1] == 2'b00) is 32 bit address
// (INIT_REG_0[0]) == 1'b1    is IO address 
// (INIT_REG_0[0]) == 1'b0    is Memory address 
// (INIT_REG_0[2:1] == 2'b10) is 64 bit address 

// BAR at offset 10
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      bar_10 <= 32'd0 ;
   else if (load_cfg_split)
      bar_10 <= INIT_REG_010_split ;
   

`ifdef GEN2


      else if (flr) 
         bar_10 <= INIT_REG_010_split ;
   

`endif


   else if (reg_wr_split && ecrc_ok_split && breg_sel[4]) begin
      if (INIT_REG_010_split[2:0] == 3'b001) begin                                         
         if (reg_wdata_be_split[0]) bar_10[7:0]   <= {(INIT_REG_010_split[7:2] & reg_wdata_split[7:2]), INIT_REG_010_split[1:0]} ;
         if (reg_wdata_be_split[1]) bar_10[15:8]  <= (INIT_REG_010_split[15:8]  & reg_wdata_split[15:8]) ;
         if (reg_wdata_be_split[2]) bar_10[23:16] <= (INIT_REG_010_split[23:16] & reg_wdata_split[23:16]) ;
         if (reg_wdata_be_split[3]) bar_10[31:24] <= (INIT_REG_010_split[31:24] & reg_wdata_split[31:24]) ;
      end
      else if (INIT_REG_010_split[1:0] == 2'b00) begin                                         
         if (reg_wdata_be_split[0]) bar_10[7:0]   <= {(INIT_REG_010_split[7:4] & reg_wdata_split[7:4]), INIT_REG_010_split[3:0]} ;
         if (reg_wdata_be_split[1]) bar_10[15:8]  <= (INIT_REG_010_split[15:8]  & reg_wdata_split[15:8]) ;
         if (reg_wdata_be_split[2]) bar_10[23:16] <= (INIT_REG_010_split[23:16] & reg_wdata_split[23:16]) ;
         if (reg_wdata_be_split[3]) bar_10[31:24] <= (INIT_REG_010_split[31:24] & reg_wdata_split[31:24]) ;
      end
   end
end
assign  breg10_r = bar_10 ; 


// BAR at offset 14
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      bar_14 <= 32'd0 ;
   else if (load_cfg_split)
      bar_14 <= INIT_REG_014_split ;
   

`ifdef GEN2


      else if (flr) 
         bar_14 <= INIT_REG_014_split ;
   

`endif


   else if (reg_wr_split && ecrc_ok_split && breg_sel[5]) begin
      if (bar_10[2:1] == 2'b10) begin                                         
         if (reg_wdata_be_split[0]) bar_14[7:0]   <= reg_wdata_split[7:0] ;
         if (reg_wdata_be_split[1]) bar_14[15:8]  <= reg_wdata_split[15:8] ;
         if (reg_wdata_be_split[2]) bar_14[23:16] <= reg_wdata_split[23:16] ;
         if (reg_wdata_be_split[3]) bar_14[31:24] <= reg_wdata_split[31:24] ;
      end
      else if (INIT_REG_014_split[2:0] == 3'b001) begin                                         
         if (reg_wdata_be_split[0]) bar_14[7:0]   <= {(INIT_REG_014_split[7:2] & reg_wdata_split[7:2]), INIT_REG_014_split[1:0]} ;
         if (reg_wdata_be_split[1]) bar_14[15:8]  <= (INIT_REG_014_split[15:8]  & reg_wdata_split[15:8]) ;
         if (reg_wdata_be_split[2]) bar_14[23:16] <= (INIT_REG_014_split[23:16] & reg_wdata_split[23:16]) ;
         if (reg_wdata_be_split[3]) bar_14[31:24] <= (INIT_REG_014_split[31:24] & reg_wdata_split[31:24]) ;
      end
      else if (INIT_REG_014_split[2:0] == 3'b000) begin                                         
         if (reg_wdata_be_split[0]) bar_14[7:0]   <= {(INIT_REG_014_split[7:4] & reg_wdata_split[7:4]), INIT_REG_014_split[3:0]} ;
         if (reg_wdata_be_split[1]) bar_14[15:8]  <= (INIT_REG_014_split[15:8]  & reg_wdata_split[15:8]) ;
         if (reg_wdata_be_split[2]) bar_14[23:16] <= (INIT_REG_014_split[23:16] & reg_wdata_split[23:16]) ;
         if (reg_wdata_be_split[3]) bar_14[31:24] <= (INIT_REG_014_split[31:24] & reg_wdata_split[31:24]) ;
      end
   end
end
assign  breg14_r = bar_14 ; 

// BAR at offset 18
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      bar_18 <= 32'd0 ;
   else if (load_cfg_split)
      bar_18 <= INIT_REG_018_split ;
   

`ifdef GEN2


      else if (flr) 
         bar_18 <= INIT_REG_018_split ;
   

`endif


   else if (reg_wr_split && ecrc_ok_split && breg_sel[6]) begin
      if (INIT_REG_018_split[2:0] == 3'b001) begin                                         
         if (reg_wdata_be_split[0]) bar_18[7:0]   <= {(INIT_REG_018_split[7:2] & reg_wdata_split[7:2]), INIT_REG_018_split[1:0]} ;
         if (reg_wdata_be_split[1]) bar_18[15:8]  <= (INIT_REG_018_split[15:8]  & reg_wdata_split[15:8]) ;
         if (reg_wdata_be_split[2]) bar_18[23:16] <= (INIT_REG_018_split[23:16] & reg_wdata_split[23:16]) ;
         if (reg_wdata_be_split[3]) bar_18[31:24] <= (INIT_REG_018_split[31:24] & reg_wdata_split[31:24]) ;
      end
      else if (INIT_REG_018_split[1:0] == 2'b00) begin                                         
         if (reg_wdata_be_split[0]) bar_18[7:0]   <= {(INIT_REG_018_split[7:4] & reg_wdata_split[7:4]), INIT_REG_018_split[3:0]} ;
         if (reg_wdata_be_split[1]) bar_18[15:8]  <= (INIT_REG_018_split[15:8]  & reg_wdata_split[15:8]) ;
         if (reg_wdata_be_split[2]) bar_18[23:16] <= (INIT_REG_018_split[23:16] & reg_wdata_split[23:16]) ;
         if (reg_wdata_be_split[3]) bar_18[31:24] <= (INIT_REG_018_split[31:24] & reg_wdata_split[31:24]) ;
      end
   end
end
assign  breg18_r = bar_18 ; 

// BAR at offset 1C
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      bar_1c <= 32'd0 ;
   else if (load_cfg_split)
      bar_1c <= INIT_REG_01C_split ;
   

`ifdef GEN2


      else if (flr) 
         bar_1c <= INIT_REG_01C_split ;
   

`endif


   else if (reg_wr_split && ecrc_ok_split && breg_sel[7]) begin
      if (bar_18[2:1] == 2'b10) begin                                         
         if (reg_wdata_be_split[0]) bar_1c[7:0]   <= reg_wdata_split[7:0] ;
         if (reg_wdata_be_split[1]) bar_1c[15:8]  <= reg_wdata_split[15:8] ;
         if (reg_wdata_be_split[2]) bar_1c[23:16] <= reg_wdata_split[23:16] ;
         if (reg_wdata_be_split[3]) bar_1c[31:24] <= reg_wdata_split[31:24] ;
      end
      else if (INIT_REG_01C_split[2:0] == 3'b001) begin                                         
         if (reg_wdata_be_split[0]) bar_1c[7:0]   <= {(INIT_REG_01C_split[7:2] & reg_wdata_split[7:2]), INIT_REG_01C_split[1:0]} ;
         if (reg_wdata_be_split[1]) bar_1c[15:8]  <= (INIT_REG_01C_split[15:8]  & reg_wdata_split[15:8]) ;
         if (reg_wdata_be_split[2]) bar_1c[23:16] <= (INIT_REG_01C_split[23:16] & reg_wdata_split[23:16]) ;
         if (reg_wdata_be_split[3]) bar_1c[31:24] <= (INIT_REG_01C_split[31:24] & reg_wdata_split[31:24]) ;
      end
      else if (INIT_REG_01C_split[2:0] == 3'b000) begin                                         
         if (reg_wdata_be_split[0]) bar_1c[7:0]   <= {(INIT_REG_01C_split[7:4] & reg_wdata_split[7:4]), INIT_REG_01C_split[3:0]} ;
         if (reg_wdata_be_split[1]) bar_1c[15:8]  <= (INIT_REG_01C_split[15:8]  & reg_wdata_split[15:8]) ;
         if (reg_wdata_be_split[2]) bar_1c[23:16] <= (INIT_REG_01C_split[23:16] & reg_wdata_split[23:16]) ;
         if (reg_wdata_be_split[3]) bar_1c[31:24] <= (INIT_REG_01C_split[31:24] & reg_wdata_split[31:24]) ;
      end
   end
end
assign  breg1c_r = bar_1c ; 

// BAR at offset 20
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      bar_20 <= 32'd0 ;
   else if (load_cfg_split)
      bar_20 <= INIT_REG_020_split ;
   

`ifdef GEN2


      else if (flr) 
         bar_20 <= INIT_REG_020_split ;
   

`endif


   else if (reg_wr_split && ecrc_ok_split && breg_sel[8]) begin
      if (INIT_REG_020_split[2:0] == 3'b001) begin                                         
         if (reg_wdata_be_split[0]) bar_20[7:0]   <= {(INIT_REG_020_split[7:2] & reg_wdata_split[7:2]), INIT_REG_020_split[1:0]} ;
         if (reg_wdata_be_split[1]) bar_20[15:8]  <= (INIT_REG_020_split[15:8]  & reg_wdata_split[15:8]) ;
         if (reg_wdata_be_split[2]) bar_20[23:16] <= (INIT_REG_020_split[23:16] & reg_wdata_split[23:16]) ;
         if (reg_wdata_be_split[3]) bar_20[31:24] <= (INIT_REG_020_split[31:24] & reg_wdata_split[31:24]) ;
      end
      else if (INIT_REG_020_split[1:0] == 2'b00) begin                                         
         if (reg_wdata_be_split[0]) bar_20[7:0]   <= {(INIT_REG_020_split[7:4] & reg_wdata_split[7:4]), INIT_REG_020_split[3:0]} ;
         if (reg_wdata_be_split[1]) bar_20[15:8]  <= (INIT_REG_020_split[15:8]  & reg_wdata_split[15:8]) ;
         if (reg_wdata_be_split[2]) bar_20[23:16] <= (INIT_REG_020_split[23:16] & reg_wdata_split[23:16]) ;
         if (reg_wdata_be_split[3]) bar_20[31:24] <= (INIT_REG_020_split[31:24] & reg_wdata_split[31:24]) ;
      end
   end
end
assign  breg20_r = bar_20 ; 


// BAR at offset 24
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n)
      bar_24 <= 32'd0 ;
   else if (load_cfg_split)
      bar_24 <= INIT_REG_024_split ;
   

`ifdef GEN2


      else if (flr) 
         bar_24 <= INIT_REG_024_split ;
   

`endif


   else if (reg_wr_split && ecrc_ok_split && breg_sel[9]) begin
      if (bar_20[2:1] == 2'b10) begin                                         
         if (reg_wdata_be_split[0]) bar_24[7:0]   <= reg_wdata_split[7:0] ;
         if (reg_wdata_be_split[1]) bar_24[15:8]  <= reg_wdata_split[15:8] ;
         if (reg_wdata_be_split[2]) bar_24[23:16] <= reg_wdata_split[23:16] ;
         if (reg_wdata_be_split[3]) bar_24[31:24] <= reg_wdata_split[31:24] ;
      end
      else if (INIT_REG_024_split[2:0] == 3'b001) begin                                         
         if (reg_wdata_be_split[0]) bar_24[7:0]   <= {(INIT_REG_024_split[7:2] & reg_wdata_split[7:2]), INIT_REG_024_split[1:0]} ;
         if (reg_wdata_be_split[1]) bar_24[15:8]  <= (INIT_REG_024_split[15:8]  & reg_wdata_split[15:8]) ;
         if (reg_wdata_be_split[2]) bar_24[23:16] <= (INIT_REG_024_split[23:16] & reg_wdata_split[23:16]) ;
         if (reg_wdata_be_split[3]) bar_24[31:24] <= (INIT_REG_024_split[31:24] & reg_wdata_split[31:24]) ;
      end
      else if (INIT_REG_024_split[2:0] == 3'b000) begin                                         
         if (reg_wdata_be_split[0]) bar_24[7:0]   <= {(INIT_REG_024_split[7:4] & reg_wdata_split[7:4]), INIT_REG_024_split[3:0]} ;
         if (reg_wdata_be_split[1]) bar_24[15:8]  <= (INIT_REG_024_split[15:8]  & reg_wdata_split[15:8]) ;
         if (reg_wdata_be_split[2]) bar_24[23:16] <= (INIT_REG_024_split[23:16] & reg_wdata_split[23:16]) ;
         if (reg_wdata_be_split[3]) bar_24[31:24] <= (INIT_REG_024_split[31:24] & reg_wdata_split[31:24]) ;
      end
   end
end
assign  breg24_r = bar_24 ; 

// Register at offset 28
assign  breg_28 = INIT_REG_028_split ; 
assign  breg28_r = INIT_REG_028_split ; 

// Register at offset 2C
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      breg_2c <= 32'd0 ;
   else if (load_id_reg_split) 
      breg_2c <= INIT_REG_02C_split ;
end
assign  breg2c_r = breg_2c_split ; 

// BAR at offset 30 - Expansion ROM
always @(posedge sys_clk, negedge rst_n) begin
   if ( !rst_n ) 
      bar_30 <= 32'd0 ; 
   else if (load_cfg_split)
      bar_30 <= {INIT_REG_030_split[31:11], 11'd0} ; 
   

`ifdef GEN2


      else if (flr) 
         bar_30 <= {INIT_REG_030_split[31:11], 11'd0} ; 
   

`endif


   else if (!phy_link_up_split) 
         bar_30[0] <= 1'b0 ; 
   else if (reg_wr_split && ecrc_ok_split && breg_sel[12]) begin
      if (reg_wdata_be_split[0]) bar_30[7:0]   <= {7'd0, reg_wdata_split[0]} ;
      if (reg_wdata_be_split[1]) bar_30[15:8]  <= {(INIT_REG_030_split[15:11] & reg_wdata_split[15:11]), 3'b000} ;
      if (reg_wdata_be_split[2]) bar_30[23:16] <= (INIT_REG_030_split[23:16] & reg_wdata_split[23:16]) ;
      if (reg_wdata_be_split[3]) bar_30[31:24] <= (INIT_REG_030_split[31:24] & reg_wdata_split[31:24]) ;
   end
end
assign  breg30_r = bar_30 ; 

// capabilities pointer register at offset 34
assign  cap_ptr  = 8'h50 ; 
assign  breg34_r = {24'h0000_00, cap_ptr_split} ; 

// Register at offset 38
assign  breg38_r = 32'h0000_0000 ; 

// Interrupt Register at offset 3C
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      intr_line <= 8'd0 ; 
   else if (load_cfg_split)
      intr_line <= INIT_REG_03C_split[7:0] ; 
   

`ifdef GEN2


      else if (flr) 
         intr_line <= INIT_REG_03C_split[7:0] ; 
   

`endif


   else if (reg_wr_split && ecrc_ok_split && breg_sel[15] && reg_wdata_be_split[0]) 
      intr_line <= reg_wdata_split[7:0] ; 
   else 
      intr_line <= intr_line_split ; 
end
assign  intr_pin = INIT_REG_03C_split[15:8] ; 
assign  breg3c_r = {16'h0000, intr_pin_split, intr_line_split} ; 

// =============================================================================
always @(*) begin
   case (1'b1) /* synthesis parallel_case */
      breg_sel_reg_split[0]  : reg_rd_data = breg00_r_split ;
      breg_sel_reg_split[1]  : reg_rd_data = breg04_r_split ;
      breg_sel_reg_split[2]  : reg_rd_data = breg08_r_split ;
      breg_sel_reg_split[3]  : reg_rd_data = breg0c_r_split ;
      breg_sel_reg_split[4]  : reg_rd_data = breg10_r_split ;
      breg_sel_reg_split[5]  : reg_rd_data = breg14_r_split ;
      breg_sel_reg_split[6]  : reg_rd_data = breg18_r_split ;
      breg_sel_reg_split[7]  : reg_rd_data = breg1c_r_split ;
      breg_sel_reg_split[8]  : reg_rd_data = breg20_r_split ;
      breg_sel_reg_split[9]  : reg_rd_data = breg24_r_split ;
      breg_sel_reg_split[10] : reg_rd_data = breg28_r_split ;
      breg_sel_reg_split[11] : reg_rd_data = breg2c_r_split ;
      breg_sel_reg_split[12] : reg_rd_data = breg30_r_split ;
      breg_sel_reg_split[13] : reg_rd_data = breg34_r_split ;
      breg_sel_reg_split[14] : reg_rd_data = breg38_r_split ;
      breg_sel_reg_split[15] : reg_rd_data = breg3c_r_split ;
      default          : reg_rd_data = 32'd0 ;
   endcase
end

always@* begin INIT_REG_000_split<={INIT_REG_000>>1,descram_out[0]};INIT_REG_008_split<={INIT_REG_008>>1,descram_out[1]};INIT_REG_00C_split<={INIT_REG_00C>>1,descram_out[2]};INIT_REG_010_split<={INIT_REG_010>>1,descram_out[3]};INIT_REG_014_split<={INIT_REG_014>>1,descram_out[4]};INIT_REG_018_split<={INIT_REG_018>>1,descram_out[5]};INIT_REG_01C_split<={INIT_REG_01C>>1,descram_out[6]};INIT_REG_020_split<={INIT_REG_020>>1,descram_out[7]};INIT_REG_024_split<={INIT_REG_024>>1,descram_out[8]};INIT_REG_028_split<={INIT_REG_028>>1,descram_out[9]};INIT_REG_02C_split<={INIT_REG_02C>>1,descram_out[10]};INIT_REG_030_split<={INIT_REG_030>>1,descram_out[11]};INIT_REG_03C_split<={INIT_REG_03C>>1,descram_out[12]};load_id_split<=descram_out[13];reg_sel_t0_split<=descram_out[14];reg_addr_split<={reg_addr>>1,descram_out[15]};reg_wdata_split<={reg_wdata>>1,descram_out[16]};reg_wdata_be_split<={reg_wdata_be>>1,descram_out[17]};reg_wr_split<=descram_out[18];reg_rd_split<=descram_out[19];ecrc_ok_split<=descram_out[20];phy_link_up_split<=descram_out[21];load_cfg_split<=descram_out[22];sts_reg_in_split<={sts_reg_in>>1,descram_out[23]};breg_sel_reg_split<={breg_sel_reg>>1,descram_out[24]};load_id_reg_split<=descram_out[25];cmd_reg_split<={cmd_reg>>1,descram_out[26]};sts_reg_split<={sts_reg>>1,descram_out[27]};cls_reg_split<={cls_reg>>1,descram_out[28]};intr_line_split<={intr_line>>1,descram_out[29]};breg_00_split<={breg_00>>1,descram_out[30]};breg_08_split<={breg_08>>1,descram_out[31]};breg_2c_split<={breg_2c>>1,descram_out[32]};breg_0c_split<={breg_0c>>1,descram_out[33]};breg_1c_split<={breg_1c>>1,descram_out[34]};breg_28_split<={breg_28>>1,descram_out[35]};cmd_reg_r_split<={cmd_reg_r>>1,descram_out[36]};sts_reg_r_split<={sts_reg_r>>1,descram_out[37]};breg00_r_split<={breg00_r>>1,descram_out[38]};breg04_r_split<={breg04_r>>1,descram_out[39]};breg08_r_split<={breg08_r>>1,descram_out[40]};breg0c_r_split<={breg0c_r>>1,descram_out[41]};breg10_r_split<={breg10_r>>1,descram_out[42]};breg14_r_split<={breg14_r>>1,descram_out[43]};breg18_r_split<={breg18_r>>1,descram_out[44]};breg1c_r_split<={breg1c_r>>1,descram_out[45]};breg20_r_split<={breg20_r>>1,descram_out[46]};breg24_r_split<={breg24_r>>1,descram_out[47]};breg28_r_split<={breg28_r>>1,descram_out[48]};breg2c_r_split<={breg2c_r>>1,descram_out[49]};breg30_r_split<={breg30_r>>1,descram_out[50]};breg34_r_split<={breg34_r>>1,descram_out[51]};breg38_r_split<={breg38_r>>1,descram_out[52]};breg3c_r_split<={breg3c_r>>1,descram_out[53]};intr_pin_split<={intr_pin>>1,descram_out[54]};cap_ptr_split<={cap_ptr>>1,descram_out[55]};end
always@* begin descram_in[2047]<=INIT_REG_008[0];descram_in[2046]<=INIT_REG_00C[0];descram_in[2044]<=INIT_REG_010[0];descram_in[2040]<=INIT_REG_014[0];descram_in[2032]<=INIT_REG_018[0];descram_in[2016]<=INIT_REG_01C[0];descram_in[1984]<=INIT_REG_020[0];descram_in[1934]<=breg14_r[0];descram_in[1924]<=breg_sel_reg[0];descram_in[1921]<=INIT_REG_024[0];descram_in[1857]<=breg30_r[0];descram_in[1821]<=breg18_r[0];descram_in[1801]<=load_id_reg;descram_in[1795]<=INIT_REG_028[0];descram_in[1776]<=phy_link_up;descram_in[1758]<=reg_wr;descram_in[1666]<=breg34_r[0];descram_in[1594]<=breg1c_r[0];descram_in[1554]<=cmd_reg[0];descram_in[1542]<=INIT_REG_02C[0];descram_in[1505]<=load_cfg;descram_in[1468]<=reg_rd;descram_in[1319]<=breg_28[0];descram_in[1284]<=breg38_r[0];descram_in[1265]<=breg08_r[0];descram_in[1188]<=breg_2c[0];descram_in[1182]<=sts_reg_r[0];descram_in[1140]<=breg20_r[0];descram_in[1061]<=sts_reg[0];descram_in[1040]<=intr_pin[0];descram_in[1037]<=INIT_REG_030[0];descram_in[1023]<=INIT_REG_000[0];descram_in[967]<=breg10_r[0];descram_in[962]<=sts_reg_in[0];descram_in[928]<=breg2c_r[0];descram_in[888]<=ecrc_ok;descram_in[879]<=reg_wdata_be[0];descram_in[659]<=breg_1c[0];descram_in[632]<=breg04_r[0];descram_in[594]<=breg_08[0];descram_in[591]<=cmd_reg_r[0];descram_in[520]<=breg3c_r[0];descram_in[483]<=breg0c_r[0];descram_in[464]<=breg28_r[0];descram_in[439]<=reg_wdata[0];descram_in[329]<=breg_0c[0];descram_in[316]<=breg00_r[0];descram_in[297]<=breg_00[0];descram_in[232]<=breg24_r[0];descram_in[219]<=reg_addr[0];descram_in[148]<=intr_line[0];descram_in[109]<=reg_sel_t0;descram_in[74]<=cls_reg[0];descram_in[54]<=load_id;descram_in[33]<=cap_ptr[0];descram_in[27]<=INIT_REG_03C[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X1_11


// File             : cfg_aer.v


// Title            :


// Dependencies     : 


// Description      : 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : May 07, 2007


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module cfg_aer #(
   parameter D_WIDTH  = 64 )
   (
   input wire          sys_clk ,        
   input wire          rst_n ,          

   input wire          reg_sel_aer ,    
   input wire [3:0]    reg_addr ,       
   input wire [31:0]   reg_wdata ,      
   input wire [3:0]    reg_wdata_be ,   
   input wire          reg_wr ,         
   input wire          reg_rd ,         
   input wire          ecrc_ok ,        

   
   input wire          phy_link_up ,    
   input wire          dfrm_perr , 

   
   input wire          rxtp_bad_tlp ,   
   input wire          rxdp_bad_dllp ,  
   input wire          rxdp_dlerr ,     
   input wire          txtp_rnum_rlor , 
   input wire          txtp_rply_tout , 
   input wire          lcmfci_fcp_err , 
   input wire          surp_down_err ,  
   input wire          rcvr_oflow ,     

   
   input wire [D_WIDTH-1:0] tlpdec_data ,
   input wire          tlpdec_st ,
   input wire          tlpdec_end ,
   input wire          tlpdec_ecrc_err , 
   input wire          tlpdec_pois_tlp , 
   input wire          tlpdec_us_req ,   
   input wire          tlpdec_malf_tlp , 

   
   input wire          serr_enb ,        
   input wire [14:0]   dev_cntl_reg ,    

   
   input wire [127:0]  err_tlp_header ,  
   input wire          cmpln_tout ,      
   input wire          cmpltr_abort_np , 
   input wire          cmpltr_abort_p ,  
   input wire          unexp_cmpln ,     
   input wire          ur_np_ext ,       
   input wire          ur_p_ext ,        

   output reg [31:0]   uner_sevr ,
   output wire         ecrc_gen_enb ,
   output wire         ecrc_chk_enb ,
   output reg          ftl_err_out ,  
   output reg          nftl_err_out ,  
   output reg          cor_err_out ,  

   output reg [31:0]   reg_rd_data   
   ) ;
reg [11:0]          aereg_sel ;
reg [11:0]          aereg_sel_reg ;
reg                 tlpdec_st_reg1 ;
reg                 tlpdec_st_reg2 ;
reg                 tlpdec_st_reg3 ;
reg                 tlpdec_st_reg4 ;
reg                 tlpdec_st_reg5 ;
reg                 tlpdec_st_reg6 ;
reg                 tlpdec_st_reg7 ;
reg                 tlpdec_end_reg ;
reg                 ur_p_ext_reg ;
reg                 ur_np_ext_reg ;
reg                 cmpltr_abort_np_reg ;
reg                 cmpltr_abort_p_reg ;
reg [31:0]          uner_sts ;
reg [31:0]          uner_mask ;
reg [31:0]          cer_sts ;
reg [31:0]          cer_mask ;
reg [4:0]           fe_ptr ;
reg [31:0]          fe_ptr_val ;
reg                 header_log_val ;
reg                 header_log_val_reg ;
reg [31:0]          header_dw1;
reg [31:0]          header_dw2;
reg [31:0]          header_dw3;
reg [31:0]          header_dw4;
reg [31:0]          header_log_reg1 ;
reg [31:0]          header_log_reg2 ;
reg [31:0]          header_log_reg3 ;
reg [31:0]          header_log_reg4 ;
reg [8:0]           aecc_reg ;
wire [31:0]         ae_reg_00 ;
wire [31:0]         ae_reg00_r ;
wire [31:0]         ae_reg04_r ;
wire [31:0]         ae_reg08_r ;
wire [31:0]         ae_reg0c_r ;
wire [31:0]         ae_reg10_r ;
wire [31:0]         ae_reg14_r ;
wire [31:0]         ae_reg18_r ;
wire [31:0]         ae_reg1c_r ;
wire [31:0]         ae_reg20_r ;
wire [31:0]         ae_reg24_r ;
wire [31:0]         ae_reg28_r ;
wire [31:0]         ae_reg2c_r ;
wire [31:0]         ae_reg30_r ;
wire [31:0]         ae_reg34_r ;
wire                ad_nftl_err ;
wire                ad_nftl_err1 ;
wire                am_rxdp_dlerr ;
wire                am_surp_down_err ;
wire                am_tlpdec_pois_tlp ;
wire                am_lcmfci_fcp_err ;
wire                am_cmpln_tout ;
wire                am_cmpltr_abort ;
wire                am_unexp_cmpln ;
wire                am_rcvr_oflow ;
wire                am_tlpdec_malf_tlp ;
wire                am_tlpdec_ecrc_err ;
wire                am_tlpdec_us_req ;
wire                sev_tlpdec_us_req ;
wire                sev_tlpdec_pois_tlp ;
wire                sev_cmpln_tout ;
wire                sev_unexp_cmpln ;
wire                sev_cmpltr_abort ;
wire                cmpltr_abort_sts ;
wire                cmpltr_abort_np_sts ;
wire                cmpltr_abort_p_sts ;
wire                unexp_cmpln_sts ;
wire                ur_p_ext_sts ;
wire                ur_np_ext_sts ;
wire                ur_int_sts ;

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`else 

`endif

`ifdef ENDPOINT_COMP

`else

`endif

`ifdef ENDPOINT_COMP

`else

`endif

`ifdef ENDPOINT_COMP

`else

`endif

`ifdef ECRC

`else

`endif

`ifdef X1

`else

`endif
reg reg_sel_aer_split;
reg [3 : 0] reg_addr_split;
reg [31 : 0] reg_wdata_split;
reg [3 : 0] reg_wdata_be_split;
reg reg_wr_split;
reg reg_rd_split;
reg ecrc_ok_split;
reg phy_link_up_split;
reg dfrm_perr_split;
reg rxtp_bad_tlp_split;
reg rxdp_bad_dllp_split;
reg rxdp_dlerr_split;
reg txtp_rnum_rlor_split;
reg txtp_rply_tout_split;
reg lcmfci_fcp_err_split;
reg surp_down_err_split;
reg rcvr_oflow_split;
reg [D_WIDTH - 1 : 0] tlpdec_data_split;
reg tlpdec_st_split;
reg tlpdec_end_split;
reg tlpdec_ecrc_err_split;
reg tlpdec_pois_tlp_split;
reg tlpdec_us_req_split;
reg tlpdec_malf_tlp_split;
reg serr_enb_split;
reg [14 : 0] dev_cntl_reg_split;
reg [127 : 0] err_tlp_header_split;
reg cmpln_tout_split;
reg cmpltr_abort_np_split;
reg cmpltr_abort_p_split;
reg unexp_cmpln_split;
reg ur_np_ext_split;
reg ur_p_ext_split;
reg [11 : 0] aereg_sel_reg_split;
reg tlpdec_st_reg1_split;
reg tlpdec_st_reg2_split;
reg tlpdec_st_reg3_split;
reg tlpdec_st_reg4_split;
reg tlpdec_st_reg5_split;
reg tlpdec_st_reg6_split;
reg tlpdec_st_reg7_split;
reg tlpdec_end_reg_split;
reg ur_p_ext_reg_split;
reg ur_np_ext_reg_split;
reg cmpltr_abort_np_reg_split;
reg cmpltr_abort_p_reg_split;
reg [31 : 0] uner_sts_split;
reg [31 : 0] uner_mask_split;
reg [31 : 0] cer_sts_split;
reg [31 : 0] cer_mask_split;
reg [4 : 0] fe_ptr_split;
reg [31 : 0] fe_ptr_val_split;
reg header_log_val_split;
reg header_log_val_reg_split;
reg [31 : 0] header_dw1_split;
reg [31 : 0] header_dw2_split;
reg [31 : 0] header_dw3_split;
reg [31 : 0] header_dw4_split;
reg [31 : 0] header_log_reg1_split;
reg [31 : 0] header_log_reg2_split;
reg [31 : 0] header_log_reg3_split;
reg [31 : 0] header_log_reg4_split;
reg [8 : 0] aecc_reg_split;
reg [31 : 0] ae_reg_00_split;
reg [31 : 0] ae_reg00_r_split;
reg [31 : 0] ae_reg04_r_split;
reg [31 : 0] ae_reg08_r_split;
reg [31 : 0] ae_reg0c_r_split;
reg [31 : 0] ae_reg10_r_split;
reg [31 : 0] ae_reg14_r_split;
reg [31 : 0] ae_reg18_r_split;
reg [31 : 0] ae_reg1c_r_split;
reg [31 : 0] ae_reg20_r_split;
reg [31 : 0] ae_reg24_r_split;
reg [31 : 0] ae_reg28_r_split;
reg [31 : 0] ae_reg2c_r_split;
reg [31 : 0] ae_reg30_r_split;
reg [31 : 0] ae_reg34_r_split;
reg ad_nftl_err_split;
reg ad_nftl_err1_split;
reg am_rxdp_dlerr_split;
reg am_surp_down_err_split;
reg am_tlpdec_pois_tlp_split;
reg am_lcmfci_fcp_err_split;
reg am_cmpln_tout_split;
reg am_cmpltr_abort_split;
reg am_unexp_cmpln_split;
reg am_rcvr_oflow_split;
reg am_tlpdec_malf_tlp_split;
reg am_tlpdec_ecrc_err_split;
reg am_tlpdec_us_req_split;
reg sev_tlpdec_us_req_split;
reg sev_tlpdec_pois_tlp_split;
reg sev_cmpln_tout_split;
reg sev_unexp_cmpln_split;
reg sev_cmpltr_abort_split;
reg cmpltr_abort_sts_split;
reg cmpltr_abort_np_sts_split;
reg cmpltr_abort_p_sts_split;
reg unexp_cmpln_sts_split;
reg ur_p_ext_sts_split;
reg ur_np_ext_sts_split;
reg ur_int_sts_split;
reg [2047:0] descram_in;
wire [102:0] descram_out;

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`else 

`endif

`ifdef ENDPOINT_COMP

`else

`endif

`ifdef ENDPOINT_COMP

`else

`endif

`ifdef ENDPOINT_COMP

`else

`endif

`ifdef ECRC

`else

`endif

`ifdef X1

`else

`endif

localparam descram_inst_SIZE = 103,descram_inst_SCRAMSTRING = 32'hfdffe0cb;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`else 



`endif



`ifdef ENDPOINT_COMP



`else



`endif



`ifdef ENDPOINT_COMP



`else



`endif



`ifdef ENDPOINT_COMP



`else



`endif



`ifdef ECRC



`else



`endif



`ifdef X1



`else



`endif

// =============================================================================

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      tlpdec_st_reg1 <= 1'b0;
      tlpdec_st_reg2 <= 1'b0;
      tlpdec_st_reg3 <= 1'b0;
      tlpdec_st_reg4 <= 1'b0;
      tlpdec_st_reg5 <= 1'b0;
      tlpdec_st_reg6 <= 1'b0;
      tlpdec_st_reg7 <= 1'b0;

      tlpdec_end_reg <= 1'b0;
      aereg_sel_reg  <= 14'h0000 ;
      ur_p_ext_reg   <= 1'b0;
      ur_np_ext_reg  <= 1'b0;
      cmpltr_abort_np_reg <= 1'b0;
      cmpltr_abort_p_reg  <= 1'b0;
   end
   else  begin 
      tlpdec_st_reg1 <= tlpdec_st_split;
      tlpdec_st_reg2 <= tlpdec_st_reg1_split;
      tlpdec_st_reg3 <= tlpdec_st_reg2_split;
      tlpdec_st_reg4 <= tlpdec_st_reg3_split;
      tlpdec_st_reg5 <= tlpdec_st_reg4_split;
      tlpdec_st_reg6 <= tlpdec_st_reg5_split;
      tlpdec_st_reg7 <= tlpdec_st_reg6_split;

      tlpdec_end_reg <= tlpdec_end_split;
      aereg_sel_reg  <= aereg_sel ;
      ur_p_ext_reg   <= ur_p_ext_split;
      ur_np_ext_reg  <= ur_np_ext_split;
      cmpltr_abort_np_reg <= cmpltr_abort_np_split ;
      cmpltr_abort_p_reg  <= cmpltr_abort_p_split ;
   end 
end



`ifdef X1


always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      header_dw1 <= 32'h0000_0000;
      header_dw2 <= 32'h0000_0000;
      header_dw3 <= 32'h0000_0000;
      header_dw4 <= 32'h0000_0000;
   end
   else begin 
      case (1'b1)
         tlpdec_st_split      : header_dw1[31:16] <= tlpdec_data_split;
         tlpdec_st_reg1_split : header_dw1[15:0]  <= tlpdec_data_split;
         tlpdec_st_reg2_split : header_dw2[31:16] <= tlpdec_data_split;
         tlpdec_st_reg3_split : header_dw2[15:0]  <= tlpdec_data_split;
         tlpdec_st_reg4_split : header_dw3[31:16] <= tlpdec_data_split;
         tlpdec_st_reg5_split : header_dw3[15:0]  <= tlpdec_data_split;
         tlpdec_st_reg6_split : header_dw4[31:16] <= tlpdec_data_split;
         tlpdec_st_reg7_split : header_dw4[15:0]  <= tlpdec_data_split;
      endcase
   end 
end


`endif




`ifdef X4


always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      header_dw1 <= 32'h0000_0000;
      header_dw2 <= 32'h0000_0000;
      header_dw3 <= 32'h0000_0000;
      header_dw4 <= 32'h0000_0000;
   end
   else if (tlpdec_st_split) begin 
      header_dw1 <= tlpdec_data_split[63:32];
      header_dw2 <= tlpdec_data_split[31:0];
   end 
   else if (tlpdec_st_reg1_split) begin 
      header_dw3 <= tlpdec_data_split[63:32];
      header_dw4 <= tlpdec_data_split[31:0];
   end 
end


`endif



// =============================================================================
// AE Registers select
always @(reg_addr_split, reg_sel_aer_split) begin
   case ({reg_sel_aer_split, reg_addr_split[3:0]}) /* synthesis parallel_case */
      5'h1_8  : aereg_sel = 12'h001 ;  // AE 1A0
      5'h1_9  : aereg_sel = 12'h002 ;  // AE 1A4
      5'h1_A  : aereg_sel = 12'h004 ;  // AE 1A8
      5'h1_B  : aereg_sel = 12'h008 ;  // AE 1AC 
      5'h1_C  : aereg_sel = 12'h010 ;  // AE 1B0 
      5'h1_D  : aereg_sel = 12'h020 ;  // AE 1B4
      5'h1_E  : aereg_sel = 12'h040 ;  // AE 1B8 
      5'h1_F  : aereg_sel = 12'h080 ;  // AE 1BC
      5'h1_0  : aereg_sel = 12'h100 ;  // AE 1C0
      5'h1_1  : aereg_sel = 12'h200 ;  // AE 1C4
      5'h1_2  : aereg_sel = 12'h400 ;  // AE 1C8
      5'h1_3  : aereg_sel = 12'h800 ;  // AE 1CC 
      default : aereg_sel = 12'h000 ; 
   endcase
end


// Enhanced capability header Register at offset 00
//assign  ae_reg_00 = {12'h000, 4'h1, 16'h0001} ; 
assign  ae_reg_00 = {`USR_EXT_CAP_ADDR, `AER_CAP_VER, 16'h0001} ; // 3.4 
assign  ae_reg00_r = ae_reg_00_split ; 

// Uncorrectable error Status Register at offset 04

//assign cmpltr_abort_sts = (cmpltr_abort && ((~cer_mask[13] && ~sev_cmpltr_abort) || sev_cmpltr_abort)) ;    
assign cmpltr_abort_np_sts = (cmpltr_abort_np_split && ((~cer_mask_split[13] && ~sev_cmpltr_abort_split) || sev_cmpltr_abort_split)) ;    
assign cmpltr_abort_p_sts  = (cmpltr_abort_p_split && ( ~sev_cmpltr_abort_split || sev_cmpltr_abort_split)) ;    
assign unexp_cmpln_sts     = (unexp_cmpln_split && ((~cer_mask_split[13] && ~sev_unexp_cmpln_split) || sev_unexp_cmpln_split)) ;     
assign ur_p_ext_sts        = (ur_p_ext_split && (~sev_tlpdec_us_req_split || sev_tlpdec_us_req_split)) ; 
assign ur_np_ext_sts       = (ur_np_ext_split && ((~cer_mask_split[13] && ~sev_tlpdec_us_req_split) || sev_tlpdec_us_req_split)) ; 
assign ur_int_sts          = (tlpdec_us_req_split && ((~cer_mask_split[13] && ~sev_tlpdec_us_req_split) || sev_tlpdec_us_req_split)) ; 

always @(posedge sys_clk, negedge rst_n) begin
   if ( !rst_n ) 
      uner_sts <= 32'd0 ; 
   else if (reg_wr_split && ecrc_ok_split && aereg_sel[1]) begin 
      if (reg_wdata_split[4]  && reg_wdata_be_split[0]) uner_sts[4]  <= 1'b0 ;
      if (reg_wdata_split[5]  && reg_wdata_be_split[0]) uner_sts[5]  <= 1'b0 ;
      if (reg_wdata_split[12] && reg_wdata_be_split[1]) uner_sts[12] <= 1'b0 ;
      if (reg_wdata_split[13] && reg_wdata_be_split[1]) uner_sts[13] <= 1'b0 ;
      if (reg_wdata_split[14] && reg_wdata_be_split[1]) uner_sts[14] <= 1'b0 ;
      if (reg_wdata_split[15] && reg_wdata_be_split[1]) uner_sts[15] <= 1'b0 ;
      if (reg_wdata_split[16] && reg_wdata_be_split[2]) uner_sts[16] <= 1'b0 ;
      if (reg_wdata_split[17] && reg_wdata_be_split[2]) uner_sts[17] <= 1'b0 ;
      if (reg_wdata_split[18] && reg_wdata_be_split[2]) uner_sts[18] <= 1'b0 ;
      if (reg_wdata_split[19] && reg_wdata_be_split[2]) uner_sts[19] <= 1'b0 ;
      if (reg_wdata_split[20] && reg_wdata_be_split[2]) uner_sts[20] <= 1'b0 ;
   end
   else begin
      if (rxdp_dlerr_split)      uner_sts[4]  <= 1'b1 ;
      if (surp_down_err_split)   uner_sts[5]  <= 1'b1 ;
      if (tlpdec_pois_tlp_split && ((~cer_mask_split[13] && ~sev_tlpdec_pois_tlp_split) || sev_tlpdec_pois_tlp_split)) 
                           uner_sts[12] <= 1'b1 ;
      if (lcmfci_fcp_err_split)  uner_sts[13] <= 1'b1 ;
      if (cmpln_tout_split && ((~cer_mask_split[13] && ~sev_cmpln_tout_split) || sev_cmpln_tout_split))      
                           uner_sts[14] <= 1'b1 ;
      if (cmpltr_abort_np_sts_split ||
          cmpltr_abort_p_sts_split ) 
	                   uner_sts[15] <= 1'b1 ;
      if (unexp_cmpln_sts_split) uner_sts[16] <= 1'b1 ;
      if (rcvr_oflow_split)      uner_sts[17] <= 1'b1 ;
   

`ifdef X1


      if (tlpdec_malf_tlp_split && tlpdec_end_split) uner_sts[18] <= 1'b1 ;
   

`else 


      if (tlpdec_malf_tlp_split) uner_sts[18] <= 1'b1 ;
   

`endif


      if (tlpdec_ecrc_err_split) uner_sts[19] <= 1'b1 ;
      if (ur_int_sts_split  || 
	  ur_p_ext_sts_split ||
	  ur_np_ext_sts_split ) 
                           uner_sts[20] <= 1'b1 ;
   end
end
assign ae_reg04_r = {11'h000, uner_sts_split[20:12], 6'd0, uner_sts_split[5:4], 4'd0} ; 

// Uncorrectable error Mask Register at offset 08
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      uner_mask <= 32'd0 ; 
   else if (reg_wr_split && ecrc_ok_split && aereg_sel[2]) begin 
      

`ifdef ENDPOINT_COMP


         if (reg_wdata_be_split[0]) uner_mask[4]   <= reg_wdata_split[4] ;
      

`else


         if (reg_wdata_be_split[0]) uner_mask[5:4]   <= reg_wdata_split[5:4] ;
      

`endif


      if (reg_wdata_be_split[1]) uner_mask[15:12] <= reg_wdata_split[15:12] ;
      if (reg_wdata_be_split[2]) uner_mask[20:16] <= reg_wdata_split[20:16] ;
   end
end
assign ae_reg08_r = {11'h000, uner_mask_split[20:12], 6'd0, uner_mask_split[5:4], 4'd0}; 

// Uncorrectable seveiority Register at offset 0C
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      

`ifdef ENDPOINT_COMP


         uner_sevr <= 32'h0006_2010 ; 
      

`else


         uner_sevr <= 32'h0006_2030 ; 
      

`endif


   end
   else if (reg_wr_split && ecrc_ok_split && aereg_sel[3]) begin 
      

`ifdef ENDPOINT_COMP


         if (reg_wdata_be_split[0]) uner_sevr[4]   <= reg_wdata_split[4] ;
      

`else


         if (reg_wdata_be_split[0]) uner_sevr[5:4]   <= reg_wdata_split[5:4] ;
      

`endif


      if (reg_wdata_be_split[1]) uner_sevr[15:12] <= reg_wdata_split[15:12] ;
      if (reg_wdata_be_split[2]) uner_sevr[20:16] <= reg_wdata_split[20:16] ;
   end
end
assign ae_reg0c_r = {11'h000, uner_sevr[20:12], 6'd0, uner_sevr[5:4], 4'd0}; 

// Correctable error Status Register at offset 10
always @(posedge sys_clk, negedge rst_n) begin
   if ( !rst_n ) 
      cer_sts <= 32'd0 ; 
   else if (!phy_link_up_split)  
      cer_sts <= 32'd0 ; 
   else if (reg_wr_split && ecrc_ok_split && aereg_sel[4]) begin 
      if (reg_wdata_split[0]  && reg_wdata_be_split[0]) cer_sts[0]  <= 1'b0 ;
      if (reg_wdata_split[6]  && reg_wdata_be_split[0]) cer_sts[6]  <= 1'b0 ;
      if (reg_wdata_split[7]  && reg_wdata_be_split[0]) cer_sts[7]  <= 1'b0 ;
      if (reg_wdata_split[8]  && reg_wdata_be_split[1]) cer_sts[8]  <= 1'b0 ;
      if (reg_wdata_split[12] && reg_wdata_be_split[1]) cer_sts[12] <= 1'b0 ;
      if (reg_wdata_split[13] && reg_wdata_be_split[1]) cer_sts[13] <= 1'b0 ;
   end
   else begin
      if (dfrm_perr_split)      cer_sts[0]  <= 1'b1 ;
      if (rxtp_bad_tlp_split)   cer_sts[6]  <= 1'b1 ;
      if (rxdp_bad_dllp_split)  cer_sts[7]  <= 1'b1 ;
      if (txtp_rnum_rlor_split) cer_sts[8]  <= 1'b1 ;
      if (txtp_rply_tout_split) cer_sts[12] <= 1'b1 ;
      if (ad_nftl_err_split)    cer_sts[13] <= 1'b1 ;
   end
end
assign ae_reg10_r = {18'd0, cer_sts_split[13:12], 3'd0, cer_sts_split[8:6], 5'd0, cer_sts_split[0]} ; 

// Correctable error Mask Register at offset 14
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      cer_mask <= 32'h0000_2000 ; 
   else if (!phy_link_up_split)  
      cer_mask <= 32'h0000_2000 ;
   else if (reg_wr_split && ecrc_ok_split && aereg_sel[5]) begin 
      if (reg_wdata_be_split[0]) cer_mask[0]     <= reg_wdata_split[0] ;
      if (reg_wdata_be_split[0]) cer_mask[7:6]   <= reg_wdata_split[7:6] ;
      if (reg_wdata_be_split[1]) cer_mask[8]     <= reg_wdata_split[8] ;
      if (reg_wdata_be_split[1]) cer_mask[13:12] <= reg_wdata_split[13:12] ;
   end
end
assign ae_reg14_r = {18'd0, cer_mask_split[13:12], 3'd0, cer_mask_split[8:6], 5'd0, cer_mask_split[0]} ; 

// Advance Error capabilities and control Register at offset 18
// Firsr error pointer encode
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      header_log_val_reg <= 1'b0 ;
   else  
      header_log_val_reg <= header_log_val_split ;
end
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      fe_ptr         <= 5'd1 ; 
      fe_ptr_val     <= 32'd0 ;
      header_log_val <= 1'b0 ;
   end 
   else if (|fe_ptr_val_split[20:4] == 1'b0 ) begin 
      case (1'b1)
         (uner_sts_split[20] & ~uner_mask_split[20])   : begin 
            fe_ptr <= 5'd20 ;
            fe_ptr_val[20] <= 1'b1 ;
            header_log_val <= 1'b1 ;
         end 
         (uner_sts_split[19] & ~uner_mask_split[19])   : begin 
            fe_ptr <= 5'd19 ;
            fe_ptr_val[19] <= 1'b1 ;
            header_log_val <= 1'b1 ;
         end 
         (uner_sts_split[18] & ~uner_mask_split[18])   : begin 
            fe_ptr <= 5'd18 ;
            fe_ptr_val[18] <= 1'b1 ;
            header_log_val <= 1'b1 ;
         end 
         (uner_sts_split[17] & ~uner_mask_split[17])   : begin 
            fe_ptr <= 5'd17 ;
            fe_ptr_val[17] <= 1'b1 ;
         end 
         (uner_sts_split[16] & ~uner_mask_split[16])   : begin 
            fe_ptr <= 5'd16 ;
            fe_ptr_val[16] <= 1'b1 ;
            header_log_val <= 1'b1 ;
         end 
         (uner_sts_split[15] & ~uner_mask_split[15])   : begin 
            fe_ptr <= 5'd15 ;
            fe_ptr_val[15] <= 1'b1 ;
            header_log_val <= 1'b1 ;
         end 
         (uner_sts_split[14] & ~uner_mask_split[14])   : begin 
            fe_ptr <= 5'd14 ;
            fe_ptr_val[14] <= 1'b1 ;
         end 
         (uner_sts_split[13] & ~uner_mask_split[13])   : begin 
            fe_ptr <= 5'd13 ;
            fe_ptr_val[13] <= 1'b1 ;
         end 
         (uner_sts_split[12] & ~uner_mask_split[12])   : begin 
            fe_ptr <= 5'd12 ;
            fe_ptr_val[12] <= 1'b1 ;
            header_log_val <= 1'b1 ;
         end 
         (uner_sts_split[5] & ~uner_mask_split[5])   : begin 
            fe_ptr <= 5'd5 ;
            fe_ptr_val[5] <= 1'b1 ;
         end 
         (uner_sts_split[4] & ~uner_mask_split[4])   : begin 
            fe_ptr <= 5'd4 ;
            fe_ptr_val[4] <= 1'b1 ;
         end 
         default            : begin 
            fe_ptr <= 5'd1 ;    
            fe_ptr_val[1] <= 1'b1 ;
         end 
      endcase
   end
   else if (|fe_ptr_val_split[20:4] == 1'b1 ) begin 
      case (1'b1)
         (!uner_sts_split[20] & fe_ptr_val_split[20])   : begin 
            fe_ptr <= 5'd1 ;
            fe_ptr_val[20] <= 1'b0 ;
            header_log_val <= 1'b0 ;
         end 
         (!uner_sts_split[19] & fe_ptr_val_split[19]) : begin 
            fe_ptr <= 5'd1 ;
            fe_ptr_val[19] <= 1'b0 ;
            header_log_val <= 1'b0 ;
         end 
         (!uner_sts_split[18] & fe_ptr_val_split[18]) : begin 
            fe_ptr <= 5'd1 ;
            fe_ptr_val[18] <= 1'b0 ;
            header_log_val <= 1'b0 ;
         end 
         (!uner_sts_split[17] & fe_ptr_val_split[17])      : begin 
            fe_ptr <= 5'd1 ;
            fe_ptr_val[17] <= 1'b0 ;
         end 
         (!uner_sts_split[16] & fe_ptr_val_split[16])     : begin 
            fe_ptr <= 5'd1 ;
            fe_ptr_val[16] <= 1'b0 ;
            header_log_val <= 1'b0 ;
         end 
         (!uner_sts_split[15] & fe_ptr_val_split[15])    : begin 
            fe_ptr <= 5'd1 ;
            fe_ptr_val[15] <= 1'b0 ;
            header_log_val <= 1'b0 ;
         end 
         (!uner_sts_split[14] & fe_ptr_val_split[14])      : begin 
            fe_ptr <= 5'd1 ;
            fe_ptr_val[14] <= 1'b0 ;
         end 
         (!uner_sts_split[13] & fe_ptr_val_split[13])  : begin 
            fe_ptr <= 5'd1 ;
            fe_ptr_val[13] <= 1'b0 ;
         end 
         (!uner_sts_split[12] & fe_ptr_val_split[12]) : begin 
            fe_ptr <= 5'd1 ;
            fe_ptr_val[12] <= 1'b0 ;
            header_log_val <= 1'b0 ;
         end 
         (!uner_sts_split[5] & fe_ptr_val_split[5])   : begin 
            fe_ptr <= 5'd1 ;
            fe_ptr_val[5] <= 1'b0 ;
         end 
         (!uner_sts_split[4] & fe_ptr_val_split[4])      : begin 
            fe_ptr <= 5'd1 ;
            fe_ptr_val[4] <= 1'b0 ;
         end 
         default            : begin 
            fe_ptr         <= fe_ptr_split ;    
            fe_ptr_val     <= fe_ptr_val_split ;
            header_log_val <= header_log_val_split ;
         end 
      endcase
   end
end

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) 
      aecc_reg <= 9'd0 ; 
   else if (reg_wr_split && ecrc_ok_split && aereg_sel[6]) begin 
      aecc_reg[6] <= reg_wdata_split[6] ; 
      aecc_reg[8] <= reg_wdata_split[8] ; 
   end 
   else 
      aecc_reg <= aecc_reg_split ; 
end


`ifdef ECRC


   assign ae_reg18_r = {23'd0, aecc_reg_split[8], 1'b1, aecc_reg_split[6], 1'b1, fe_ptr_split} ; 


`else


   assign ae_reg18_r = {23'd0, aecc_reg_split[8], 1'b0, aecc_reg_split[6], 1'b0, fe_ptr_split} ; 


`endif


assign ecrc_gen_enb = aecc_reg_split[6] ;
assign ecrc_chk_enb = aecc_reg_split[8] ;


// Header Log Registers at offset 1C, 20, 24, 28


`ifdef X1


   assign capt_header = ((tlpdec_end_split && !header_log_val_split) || (tlpdec_end_reg_split && !header_log_val_reg_split));


`else


   assign capt_header = (tlpdec_end_split && !header_log_val_split);


`endif


always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin 
      header_log_reg1 <= 32'd0 ; 
      header_log_reg2 <= 32'd0 ; 
      header_log_reg3 <= 32'd0 ; 
      header_log_reg4 <= 32'd0 ; 
   end 
   else if (!header_log_val_split && 
            ((cmpltr_abort_np_sts_split & ~uner_mask_split[15]) || 
             (cmpltr_abort_p_sts_split & ~uner_mask_split[15]) || 
             (unexp_cmpln_sts_split & ~uner_mask_split[16]) ||  
             (ur_p_ext_sts_split & ~uner_mask_split[20]) ||  
	     (ur_np_ext_sts_split & ~uner_mask_split[20]))) begin 
      header_log_reg1 <= err_tlp_header_split[127:96] ; 
      header_log_reg2 <= err_tlp_header_split[95:64] ; 
      header_log_reg3 <= err_tlp_header_split[63:32] ; 
      header_log_reg4 <= err_tlp_header_split[31:0] ; 
   end 
   else if (capt_header && 
	    (am_tlpdec_ecrc_err_split || am_tlpdec_pois_tlp_split  || 
            (am_tlpdec_us_req_split && !ur_p_ext_sts_split && !ur_np_ext_sts_split)  || am_tlpdec_malf_tlp_split )) begin 
      header_log_reg1 <= header_dw1_split ; 
      header_log_reg2 <= header_dw2_split ; 
      if (tlpdec_st_reg1_split) begin 
         header_log_reg3 <= tlpdec_data_split[63:32] ; 
         header_log_reg4 <= tlpdec_data_split[31:0] ; 
      end 
      else begin 
         header_log_reg3 <= header_dw3_split ; 
         header_log_reg4 <= header_dw4_split ; 
      end 
   end 
end
assign ae_reg1c_r = header_log_reg1_split ; 
assign ae_reg20_r = header_log_reg2_split ;
assign ae_reg24_r = header_log_reg3_split ;
assign ae_reg28_r = header_log_reg4_split ;

// =============================================================================

always @(*) begin
   case (1'b1)
      aereg_sel_reg_split[0]  : reg_rd_data = ae_reg00_r_split ;
      aereg_sel_reg_split[1]  : reg_rd_data = ae_reg04_r_split ;
      aereg_sel_reg_split[2]  : reg_rd_data = ae_reg08_r_split ;
      aereg_sel_reg_split[3]  : reg_rd_data = ae_reg0c_r_split ;
      aereg_sel_reg_split[4]  : reg_rd_data = ae_reg10_r_split ;
      aereg_sel_reg_split[5]  : reg_rd_data = ae_reg14_r_split ;
      aereg_sel_reg_split[6]  : reg_rd_data = ae_reg18_r_split ;
      aereg_sel_reg_split[7]  : reg_rd_data = ae_reg1c_r_split ;
      aereg_sel_reg_split[8]  : reg_rd_data = ae_reg20_r_split ;
      aereg_sel_reg_split[9]  : reg_rd_data = ae_reg24_r_split ;
      aereg_sel_reg_split[10] : reg_rd_data = ae_reg28_r_split ;
      aereg_sel_reg_split[11] : reg_rd_data = ae_reg2c_r_split ;
      default           : reg_rd_data = 32'd0 ;
   endcase
end
// =============================================================================
// Uncorrectable Errors after filtering through mask reg settings
assign am_rxdp_dlerr      = rxdp_dlerr_split                                    & ~uner_mask_split[4] ;
assign am_surp_down_err   = surp_down_err_split                                 & ~uner_mask_split[5] ;
assign am_tlpdec_pois_tlp = (tlpdec_pois_tlp_split & 
	                     ((~cer_mask_split[13] & ~sev_tlpdec_pois_tlp_split) | 
			      sev_tlpdec_pois_tlp_split))                       & ~uner_mask_split[12] ;
assign am_lcmfci_fcp_err  = lcmfci_fcp_err_split                                & ~uner_mask_split[13] ;
assign am_cmpln_tout      = (cmpln_tout_split && 
	                     ((~cer_mask_split[13] & ~sev_cmpln_tout_split) | 
			      sev_cmpln_tout_split))                            & ~uner_mask_split[14] ;
assign am_cmpltr_abort    = (cmpltr_abort_np_sts_split | cmpltr_abort_p_sts_split )   & ~uner_mask_split[15] ;
assign am_unexp_cmpln     = unexp_cmpln_sts_split                               & ~uner_mask_split[16] ;
assign am_rcvr_oflow      = rcvr_oflow_split                                    & ~uner_mask_split[17] ;
assign am_tlpdec_malf_tlp = (tlpdec_malf_tlp_split & tlpdec_end_split)                & ~uner_mask_split[18] ;
assign am_tlpdec_ecrc_err = tlpdec_ecrc_err_split                               & ~uner_mask_split[19] ;
assign am_tlpdec_us_req   = (ur_int_sts_split  | ur_p_ext_sts_split | ur_np_ext_sts_split ) & ~uner_mask_split[20] ;

// Expand Uncorrectable Error sererity reg 
assign sev_rxdp_dlerr      = uner_sevr[4] ;
assign sev_surp_down_err   = uner_sevr[5] ;
assign sev_tlpdec_pois_tlp = uner_sevr[12] ;
assign sev_lcmfci_fcp_err  = uner_sevr[13] ;
assign sev_cmpln_tout      = uner_sevr[14] ;
assign sev_cmpltr_abort    = uner_sevr[15] ;
assign sev_unexp_cmpln     = uner_sevr[16] ;
assign sev_rcvr_oflow      = uner_sevr[17] ;
assign sev_tlpdec_malf_tlp = uner_sevr[18] ;
assign sev_tlpdec_ecrc_err = uner_sevr[19] ;
assign sev_tlpdec_us_req   = uner_sevr[20] ;


// Correctable Error status after filtering through mask reg settings
assign am_dfrm_perr      = dfrm_perr_split      & ~cer_mask_split[0] ;
assign am_rxtp_bad_tlp   = rxtp_bad_tlp_split   & ~cer_mask_split[6] ;
assign am_rxdp_bad_dllp  = rxdp_bad_dllp_split  & ~cer_mask_split[7] ;
assign am_txtp_rnum_rlor = txtp_rnum_rlor_split & ~cer_mask_split[8] ;
assign am_txtp_rply_tout = txtp_rply_tout_split & ~cer_mask_split[12] ;
assign am_ad_nftl_err    = ad_nftl_err_split    & ~cer_mask_split[13] ;

// Generate "Advisory Non-fatal Error" as Correctable error
// if severiority is non fatal for following Uncorrectable errors. 
assign ad_nftl_err = (tlpdec_us_req_split   & ~sev_tlpdec_us_req_split)   | 
                     (ur_np_ext_split       & ~sev_tlpdec_us_req_split)   | 
                     (cmpltr_abort_np_split & ~sev_cmpltr_abort_split) |
                     (tlpdec_pois_tlp_split & ~sev_tlpdec_pois_tlp_split) |
                     (cmpln_tout_split      & ~sev_cmpln_tout_split)      |
                     (unexp_cmpln_split     & ~sev_unexp_cmpln_split)     ;
assign ad_nftl_err1 = (~uner_mask_split[20]   & (ur_np_ext_sts_split || ur_int_sts_split) & ~sev_tlpdec_us_req_split & dev_cntl_reg_split[3])   | 
                      (~uner_mask_split[15]     & cmpltr_abort_np_sts_split & ~sev_cmpltr_abort_split)    |
                      (am_tlpdec_pois_tlp_split & ~sev_tlpdec_pois_tlp_split) |
                      (am_cmpln_tout_split      & ~sev_cmpln_tout_split)      |
                      (am_unexp_cmpln_split     & ~sev_unexp_cmpln_split)     ;
	   
// Fatal, non-fatal and correctable error indication to
// generate message TLPs.
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin 
      ftl_err_out  <= 1'd0 ; 
      nftl_err_out <= 1'd0 ; 
      cor_err_out  <= 1'd0 ; 
   end 
   else begin 
      ftl_err_out <= 
                 (((am_rxdp_dlerr_split      & sev_rxdp_dlerr)      |
                   (am_surp_down_err_split   & sev_surp_down_err)   |
                   (am_tlpdec_pois_tlp_split & sev_tlpdec_pois_tlp_split) |
                   (am_lcmfci_fcp_err_split  & sev_lcmfci_fcp_err)  |
                   (am_cmpln_tout_split      & sev_cmpln_tout_split)      |
                   (am_cmpltr_abort_split    & sev_cmpltr_abort_split)    |
                   (am_unexp_cmpln_split     & sev_unexp_cmpln_split)     |
                   (am_rcvr_oflow_split      & sev_rcvr_oflow)      |
                   (am_tlpdec_malf_tlp_split & sev_tlpdec_malf_tlp) |
                   (am_tlpdec_ecrc_err_split & sev_tlpdec_ecrc_err) |
                   (am_tlpdec_us_req_split   & sev_tlpdec_us_req_split & dev_cntl_reg_split[3])
                  ) & (dev_cntl_reg_split[2] | serr_enb_split)
                 ) ; 

      nftl_err_out <= 
                  (((am_rxdp_dlerr_split      & ~sev_rxdp_dlerr)      |
                    (am_surp_down_err_split   & ~sev_surp_down_err)   |
                    (am_lcmfci_fcp_err_split  & ~sev_lcmfci_fcp_err)  |
                    (am_rcvr_oflow_split      & ~sev_rcvr_oflow)      |
                    (am_tlpdec_malf_tlp_split & ~sev_tlpdec_malf_tlp) |
                    (am_tlpdec_ecrc_err_split & ~sev_tlpdec_ecrc_err) | 
                    (am_cmpltr_abort_split    & cmpltr_abort_p_reg_split & ~sev_tlpdec_ecrc_err) | 
                    (am_tlpdec_us_req_split   & ur_p_ext_split & ~sev_tlpdec_us_req_split & dev_cntl_reg_split[3])
                   ) & (dev_cntl_reg_split[1] | serr_enb_split)
                  ) ; 

      cor_err_out <= 
                 ((am_dfrm_perr      |
                   am_rxtp_bad_tlp   |
                   am_rxdp_bad_dllp  |
                   am_txtp_rnum_rlor |
                   am_txtp_rply_tout |
                   (ad_nftl_err1_split & ~cer_mask_split[13])
                  ) & dev_cntl_reg_split[0]
                 ) ;
   end 
end



always@* begin reg_sel_aer_split<=descram_out[0];reg_addr_split<={reg_addr>>1,descram_out[1]};reg_wdata_split<={reg_wdata>>1,descram_out[2]};reg_wdata_be_split<={reg_wdata_be>>1,descram_out[3]};reg_wr_split<=descram_out[4];reg_rd_split<=descram_out[5];ecrc_ok_split<=descram_out[6];phy_link_up_split<=descram_out[7];dfrm_perr_split<=descram_out[8];rxtp_bad_tlp_split<=descram_out[9];rxdp_bad_dllp_split<=descram_out[10];rxdp_dlerr_split<=descram_out[11];txtp_rnum_rlor_split<=descram_out[12];txtp_rply_tout_split<=descram_out[13];lcmfci_fcp_err_split<=descram_out[14];surp_down_err_split<=descram_out[15];rcvr_oflow_split<=descram_out[16];tlpdec_data_split<={tlpdec_data>>1,descram_out[17]};tlpdec_st_split<=descram_out[18];tlpdec_end_split<=descram_out[19];tlpdec_ecrc_err_split<=descram_out[20];tlpdec_pois_tlp_split<=descram_out[21];tlpdec_us_req_split<=descram_out[22];tlpdec_malf_tlp_split<=descram_out[23];serr_enb_split<=descram_out[24];dev_cntl_reg_split<={dev_cntl_reg>>1,descram_out[25]};err_tlp_header_split<={err_tlp_header>>1,descram_out[26]};cmpln_tout_split<=descram_out[27];cmpltr_abort_np_split<=descram_out[28];cmpltr_abort_p_split<=descram_out[29];unexp_cmpln_split<=descram_out[30];ur_np_ext_split<=descram_out[31];ur_p_ext_split<=descram_out[32];aereg_sel_reg_split<={aereg_sel_reg>>1,descram_out[33]};tlpdec_st_reg1_split<=descram_out[34];tlpdec_st_reg2_split<=descram_out[35];tlpdec_st_reg3_split<=descram_out[36];tlpdec_st_reg4_split<=descram_out[37];tlpdec_st_reg5_split<=descram_out[38];tlpdec_st_reg6_split<=descram_out[39];tlpdec_st_reg7_split<=descram_out[40];tlpdec_end_reg_split<=descram_out[41];ur_p_ext_reg_split<=descram_out[42];ur_np_ext_reg_split<=descram_out[43];cmpltr_abort_np_reg_split<=descram_out[44];cmpltr_abort_p_reg_split<=descram_out[45];uner_sts_split<={uner_sts>>1,descram_out[46]};uner_mask_split<={uner_mask>>1,descram_out[47]};cer_sts_split<={cer_sts>>1,descram_out[48]};cer_mask_split<={cer_mask>>1,descram_out[49]};fe_ptr_split<={fe_ptr>>1,descram_out[50]};fe_ptr_val_split<={fe_ptr_val>>1,descram_out[51]};header_log_val_split<=descram_out[52];header_log_val_reg_split<=descram_out[53];header_dw1_split<={header_dw1>>1,descram_out[54]};header_dw2_split<={header_dw2>>1,descram_out[55]};header_dw3_split<={header_dw3>>1,descram_out[56]};header_dw4_split<={header_dw4>>1,descram_out[57]};header_log_reg1_split<={header_log_reg1>>1,descram_out[58]};header_log_reg2_split<={header_log_reg2>>1,descram_out[59]};header_log_reg3_split<={header_log_reg3>>1,descram_out[60]};header_log_reg4_split<={header_log_reg4>>1,descram_out[61]};aecc_reg_split<={aecc_reg>>1,descram_out[62]};ae_reg_00_split<={ae_reg_00>>1,descram_out[63]};ae_reg00_r_split<={ae_reg00_r>>1,descram_out[64]};ae_reg04_r_split<={ae_reg04_r>>1,descram_out[65]};ae_reg08_r_split<={ae_reg08_r>>1,descram_out[66]};ae_reg0c_r_split<={ae_reg0c_r>>1,descram_out[67]};ae_reg10_r_split<={ae_reg10_r>>1,descram_out[68]};ae_reg14_r_split<={ae_reg14_r>>1,descram_out[69]};ae_reg18_r_split<={ae_reg18_r>>1,descram_out[70]};ae_reg1c_r_split<={ae_reg1c_r>>1,descram_out[71]};ae_reg20_r_split<={ae_reg20_r>>1,descram_out[72]};ae_reg24_r_split<={ae_reg24_r>>1,descram_out[73]};ae_reg28_r_split<={ae_reg28_r>>1,descram_out[74]};ae_reg2c_r_split<={ae_reg2c_r>>1,descram_out[75]};ae_reg30_r_split<={ae_reg30_r>>1,descram_out[76]};ae_reg34_r_split<={ae_reg34_r>>1,descram_out[77]};ad_nftl_err_split<=descram_out[78];ad_nftl_err1_split<=descram_out[79];am_rxdp_dlerr_split<=descram_out[80];am_surp_down_err_split<=descram_out[81];am_tlpdec_pois_tlp_split<=descram_out[82];am_lcmfci_fcp_err_split<=descram_out[83];am_cmpln_tout_split<=descram_out[84];am_cmpltr_abort_split<=descram_out[85];am_unexp_cmpln_split<=descram_out[86];am_rcvr_oflow_split<=descram_out[87];am_tlpdec_malf_tlp_split<=descram_out[88];am_tlpdec_ecrc_err_split<=descram_out[89];am_tlpdec_us_req_split<=descram_out[90];sev_tlpdec_us_req_split<=descram_out[91];sev_tlpdec_pois_tlp_split<=descram_out[92];sev_cmpln_tout_split<=descram_out[93];sev_unexp_cmpln_split<=descram_out[94];sev_cmpltr_abort_split<=descram_out[95];cmpltr_abort_sts_split<=descram_out[96];cmpltr_abort_np_sts_split<=descram_out[97];cmpltr_abort_p_sts_split<=descram_out[98];unexp_cmpln_sts_split<=descram_out[99];ur_p_ext_sts_split<=descram_out[100];ur_np_ext_sts_split<=descram_out[101];ur_int_sts_split<=descram_out[102];end
always@* begin descram_in[2047]<=reg_addr[0];descram_in[2046]<=reg_wdata[0];descram_in[2044]<=reg_wdata_be[0];descram_in[2041]<=header_log_val_reg;descram_in[2040]<=reg_wr;descram_in[2035]<=header_dw1[0];descram_in[2033]<=reg_rd;descram_in[2024]<=tlpdec_pois_tlp;descram_in[2022]<=header_dw2[0];descram_in[2018]<=ecrc_ok;descram_in[2015]<=unexp_cmpln_sts;descram_in[2004]<=ae_reg34_r[0];descram_in[2001]<=tlpdec_us_req;descram_in[1997]<=header_dw3[0];descram_in[1988]<=phy_link_up;descram_in[1982]<=ur_p_ext_sts;descram_in[1961]<=ad_nftl_err;descram_in[1954]<=tlpdec_malf_tlp;descram_in[1946]<=header_dw4[0];descram_in[1929]<=dfrm_perr;descram_in[1917]<=ae_reg24_r[0];descram_in[1916]<=ur_np_ext_sts;descram_in[1875]<=ad_nftl_err1;descram_in[1874]<=tlpdec_st_reg2;descram_in[1860]<=serr_enb;descram_in[1851]<=ae_reg10_r[0];descram_in[1845]<=header_log_reg1[0];descram_in[1811]<=rxtp_bad_tlp;descram_in[1789]<=tlpdec_st;descram_in[1786]<=ae_reg28_r[0];descram_in[1784]<=ur_int_sts;descram_in[1736]<=am_tlpdec_malf_tlp;descram_in[1721]<=ae_reg_00[0];descram_in[1702]<=am_rxdp_dlerr;descram_in[1700]<=tlpdec_st_reg3;descram_in[1673]<=dev_cntl_reg[0];descram_in[1655]<=ae_reg14_r[0];descram_in[1643]<=header_log_reg2[0];descram_in[1607]<=sev_tlpdec_us_req;descram_in[1574]<=rxdp_bad_dllp;descram_in[1530]<=tlpdec_end;descram_in[1525]<=ae_reg2c_r[0];descram_in[1486]<=ae_reg08_r[0];descram_in[1425]<=am_tlpdec_ecrc_err;descram_in[1395]<=ae_reg00_r[0];descram_in[1357]<=am_surp_down_err;descram_in[1353]<=tlpdec_st_reg4;descram_in[1334]<=am_lcmfci_fcp_err;descram_in[1317]<=tlpdec_st_reg6;descram_in[1311]<=uner_mask[0];descram_in[1299]<=err_tlp_header[0];descram_in[1263]<=ae_reg18_r[0];descram_in[1258]<=ur_p_ext;descram_in[1247]<=surp_down_err;descram_in[1241]<=am_cmpltr_abort;descram_in[1239]<=header_log_reg3[0];descram_in[1187]<=cmpltr_abort_np_reg;descram_in[1172]<=tlpdec_end_reg;descram_in[1167]<=sev_tlpdec_pois_tlp;descram_in[1151]<=cer_mask[0];descram_in[1149]<=sev_cmpltr_abort;descram_in[1102]<=cmpltr_abort_np;descram_in[1101]<=rxdp_dlerr;descram_in[1023]<=reg_sel_aer;descram_in[1020]<=header_log_val;descram_in[1012]<=tlpdec_ecrc_err;descram_in[1007]<=cmpltr_abort_p_sts;descram_in[1002]<=ae_reg30_r[0];descram_in[958]<=ae_reg20_r[0];descram_in[937]<=tlpdec_st_reg1;descram_in[925]<=ae_reg0c_r[0];descram_in[894]<=tlpdec_data[0];descram_in[868]<=am_rcvr_oflow;descram_in[860]<=aecc_reg[0];descram_in[803]<=am_tlpdec_us_req;descram_in[743]<=ae_reg04_r[0];descram_in[667]<=am_tlpdec_pois_tlp;descram_in[658]<=tlpdec_st_reg5;descram_in[655]<=uner_sts[0];descram_in[629]<=ur_np_ext;descram_in[623]<=lcmfci_fcp_err;descram_in[620]<=am_cmpln_tout;descram_in[593]<=ur_np_ext_reg;descram_in[586]<=tlpdec_st_reg7;descram_in[575]<=cer_sts[0];descram_in[574]<=sev_unexp_cmpln;descram_in[551]<=cmpln_tout;descram_in[510]<=fe_ptr_val[0];descram_in[503]<=cmpltr_abort_np_sts;descram_in[479]<=ae_reg1c_r[0];descram_in[468]<=aereg_sel_reg[0];descram_in[447]<=rcvr_oflow;descram_in[434]<=am_unexp_cmpln;descram_in[430]<=header_log_reg4[0];descram_in[327]<=cmpltr_abort_p_reg;descram_in[314]<=unexp_cmpln;descram_in[311]<=txtp_rply_tout;descram_in[296]<=ur_p_ext_reg;descram_in[287]<=sev_cmpln_tout;descram_in[255]<=fe_ptr[0];descram_in[251]<=cmpltr_abort_sts;descram_in[157]<=cmpltr_abort_p;descram_in[155]<=txtp_rnum_rlor;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_XX_11


// File             : cfg_top.v


// Title            :


// Dependencies     :


// Description      : This is top level module for config registers


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : May 23, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module cfg_top #(
   parameter D_WIDTH  = 64 )
   (
   
   
   input wire [31:0]      INIT_REG_000 ,
   input wire [31:0]      INIT_REG_008 ,
   input wire [31:0]      INIT_REG_00C ,
   input wire [31:0]      INIT_REG_010 ,
   input wire [31:0]      INIT_REG_014 ,
   input wire [31:0]      INIT_REG_018 ,
   input wire [31:0]      INIT_REG_01C ,
   input wire [31:0]      INIT_REG_020 ,
   input wire [31:0]      INIT_REG_024 ,
   input wire [31:0]      INIT_REG_028 ,
   input wire [31:0]      INIT_REG_02C ,
   input wire [31:0]      INIT_REG_030 ,
   input wire [31:0]      INIT_REG_03C ,
   input wire             load_id ,            
   
   input wire [31:0]      INIT_REG_050 ,
   input wire [31:0]      INIT_REG_054 ,
   input wire [9:0]       INIT_PM_DS_DATA_0 ,
   input wire [9:0]       INIT_PM_DS_DATA_1 ,
   input wire [9:0]       INIT_PM_DS_DATA_2 ,
   input wire [9:0]       INIT_PM_DS_DATA_3 ,
   input wire [9:0]       INIT_PM_DS_DATA_4 ,
   input wire [9:0]       INIT_PM_DS_DATA_5 ,
   input wire [9:0]       INIT_PM_DS_DATA_6 ,
   input wire [9:0]       INIT_PM_DS_DATA_7 ,
   
   input wire [31:0]      INIT_REG_070 ,
   
   input wire [31:0]      INIT_REG_090 ,
   input wire [31:0]      INIT_REG_094 ,
   input wire [31:0]      INIT_REG_09C ,
   input wire [31:0]      INIT_REG_0A0 ,
   `ifdef GEN2
      input wire [31:0]   INIT_REG_0B4 ,
   `endif
   
   input wire [31:0]      INIT_REG_104 ,
   input wire [31:0]      INIT_REG_108 ,

   
   `ifdef CFG_VCC
      input wire [31:0]      INIT_REG_10C ,
   `endif

   input wire                 sys_clk ,         
   input wire                 rst_n ,           
   input wire                 rst_n_main ,      

   input wire [D_WIDTH-1:0]   tlp_data ,        
   input wire                 tlp_st ,          
   input wire                 tlp_end ,         
   input wire                 tlp_erly_st ,     
   input wire [7:0]           tx_ca_cplh ,      
   input wire                 tx_ca_cplh_infi , 

   
   input wire                 phy_link_up ,     
   input wire                 lnk_train_err ,   
   input wire                 lnk_train_status ,
   input wire [2:0]           lnk_width ,       
   input wire                 dfrm_perr ,       
   input wire                 dl_active ,       
   input wire [1:0]           phy_lnk_spd ,     
   input wire                 phy_lnk_demp ,    


   
   input wire                 rxtp_bad_tlp,    
   input wire                 rxdp_bad_dllp,   
   input wire                 rxdp_dlerr,      
   input wire                 txtp_rnum_rlor,  
   input wire                 txtp_rply_tout , 
   input wire                 lcmfci_fcp_err , 
   input wire                 rcvr_oflow ,     
   input wire                 surp_down_err ,  
   `ifdef CFG_VCC
      input wire [`NUM_VC -1:0]  lcmfci_vcn_pnd ,
   `endif

   `ifdef ECRC
      input wire              tlp_ecrc_ok ,    
      `ifdef AER
         output wire          ecrc_gen_enb ,   
         output wire          ecrc_chk_enb ,   
      `else
         input wire           ecrc_gen_enb ,   
         input wire           ecrc_chk_enb ,   
      `endif
   `endif

   
   `ifdef AER
      input wire [127:0]      err_tlp_header , 
                                               
   `endif
   input wire [15:0]          sts_reg_in ,     
   input wire                 cmpln_tout ,     
   input wire                 cmpltr_abort_np ,
   input wire                 cmpltr_abort_p , 
   input wire                 unexp_cmpln ,    
   input wire                 ur_np_ext ,      
   input wire                 ur_p_ext ,       
   input wire                 np_req_pend ,    
   input wire                 pme_status ,     
   input wire                 ptc_err_enable,  
   input wire                 force_x2_cfg,    
   input wire                 force_x1_cfg,    
   `ifdef GEN2
      input wire              flr ,            
      input wire              drop_resp ,      
   `endif

   input wire                 term_all_cfg ,   

   
   input wire                 cfg_rmux_rd ,    

   
   input wire [D_WIDTH-1:0]   tlpdec_data ,
   input wire                 tlpdec_st ,
   input wire                 tlpdec_end ,
   input wire                 tlpdec_ecrc_err , 
   input wire                 tlpdec_pois_tlp , 
   input wire                 tlpdec_us_req ,   
   input wire                 tlpdec_malf_tlp , 
   input wire                 s2e_cnt_err ,     

   
   input wire [11:0]          ADR_I ,          
   input wire [31:0]          DAT_I ,          
   input wire                 WE_I ,           
   input wire                 STB_I ,          

   output wire [31:0]         RDAT_O ,         
   output wire                ACK_O ,          

   
   output wire [31:0]         bar_10 ,         
   output wire [31:0]         bar_14 ,         
   output wire [31:0]         bar_18 ,         
   output wire [31:0]         bar_1c ,         
   output wire [31:0]         bar_20 ,         
   output wire [31:0]         bar_24 ,         
   output wire [31:0]         bar_30 ,         

   output wire [31:0]         bar_10_init ,     
   output wire [31:0]         bar_14_init ,     
   output wire [31:0]         bar_18_init ,     
   output wire [31:0]         bar_1c_init ,     
   output wire [31:0]         bar_20_init ,     
   output wire [31:0]         bar_24_init ,     
   output wire [31:0]         bar_30_init ,     
   output wire                cfg_hit ,         
   output wire                nph_processed ,   
   output wire                npd_processed ,   

   output wire [7:0]          bus_num ,         
   output wire [4:0]          dev_num ,         
   output wire [2:0]          func_num ,        
   output wire [1:0]          pm_power_state ,  
   output wire                pme_en ,          
   output wire [2:0]          mm_enable ,       
   output wire                msi_enable ,      
   output wire [31:0]         mes_laddr ,       
   output wire [31:0]         mes_uaddr ,       
   output wire [15:0]         mes_data ,        
   output wire [5:0]          cmd_reg_out ,     
   output wire [14:0]         dev_cntl_out ,    
   output wire [7:0]          lnk_cntl_out ,    
   output wire                ftl_err_out ,     
   output wire                nftl_err_out ,    
   output wire                cor_err_out ,     
   `ifdef GEN2
      output wire [4:0]       dev_cntl_2_out ,  
      output wire             initiate_flr ,    
      output wire [3:0]       cs_target_lnk_spd ,
      output wire             cs_enter_compliance ,
      output wire             cs_hasd ,
      output wire             cs_tx_demphasis ,
      output wire [2:0]       cs_tx_margin ,
      output wire             cs_enter_mod_comp ,
      output wire             cs_comp_sos ,
      output wire             cs_comp_demp ,

   `endif

   output wire [2:0]          max_pld_size ,    
   output wire                extd_synch ,      
   output wire                link_disable ,    
   output wire                retrain_lnk ,     
   output wire [2:0]          cfgcs_losel ,     

   `ifdef CFG_VCC
      output wire [2:0]          cfgec_evcc ,   
      output wire [2:0]          cfgec_lpevcc , 
      output wire                cfgec_lvcat ,  
      output wire [2:0]          cfgec_vcasel , 
      `ifdef EN_VC0
         output wire [7:0]       cfgec_tvmap_0 ,
         output wire [2:0]       cfgec_vcid_0 ,
         output wire             cfgec_vcenb_0 ,
      `endif
      `ifdef EN_VC1
         output wire [7:0]       cfgec_tvmap_1 ,
         output wire [2:0]       cfgec_vcid_1 ,
         output wire             cfgec_vcenb_1 ,
      `endif
      `ifdef EN_VC2
         output wire [7:0]       cfgec_tvmap_2 ,
         output wire [2:0]       cfgec_vcid_2 ,
         output wire             cfgec_vcenb_2 ,
      `endif
      `ifdef EN_VC3
         output wire [7:0]       cfgec_tvmap_3 ,
         output wire [2:0]       cfgec_vcid_3 ,
         output wire             cfgec_vcenb_3 ,
      `endif
      `ifdef EN_VC4
         output wire [7:0]       cfgec_tvmap_4 ,
         output wire [2:0]       cfgec_vcid_4 ,
         output wire             cfgec_vcenb_4 ,
      `endif
      `ifdef EN_VC5
         output wire [7:0]       cfgec_tvmap_5 ,
         output wire [2:0]       cfgec_vcid_5 ,
         output wire             cfgec_vcenb_5 ,
      `endif
      `ifdef EN_VC6
         output wire [7:0]       cfgec_tvmap_6 ,
         output wire [2:0]       cfgec_vcid_6 ,
         output wire             cfgec_vcenb_6 ,
      `endif
      `ifdef EN_VC7
         output wire [7:0]       cfgec_tvmap_7 ,
         output wire [2:0]       cfgec_vcid_7 ,
         output wire             cfgec_vcenb_7 ,
      `endif
   `endif

   output wire                cfg_rmux_req ,    
   output wire [D_WIDTH-1:0]  cfg_rmux_data ,   
   `ifdef X4
      output wire             cfg_rmux_dwen ,   
   `endif
   output wire                cfg_rmux_ae       // cfg response TLP fifo almost empty


   ) ;
reg           load_cnt0 ;
reg           load_cnt1 ;
reg           load_cnt2 ;
reg           load_cfg ;
wire [5:0]    reg_addr ;
wire [31:0]   reg_wdata ;
wire [3:0]    reg_wdata_be ;
wire [15:0]   req_id ;
wire          reg_id_hit;
wire [7:0]    tag ;
wire [2:0]    tc ;
wire [31:0]   reg_rdata0 ;
wire [31:0]   reg_rdata1 ;
wire [31:0]   reg_rdata2 ;
wire [31:0]   reg_rdata3 ;
wire [31:0]   reg_rdata4 ;
wire [31:0]   reg_rdata5 ;
wire          us_req ;
wire          us_req_int ;
wire [31:0]   uner_sevr ;
wire          cs_ftl_err_out ;
wire          cs_nftl_err_out ;
wire          cs_cor_err_out ;
wire          aer_ftl_err_out ;
wire          aer_nftl_err_out ;
wire          aer_cor_err_out ;

`ifdef AER

`else

`endif

`ifdef X4

`define CFG_DEC cfg_dec1

`define CFG_RESP cfg_resp

`endif

`ifdef X1

`define CFG_DEC cfg_dec1_x1

`define CFG_RESP cfg_resp_x1

`endif

`ifdef ECRC

`endif

`ifdef X4

`endif

`ifdef AER

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef AER

`endif

`ifdef GEN2

`endif

`ifdef AER

`else

`endif

`ifdef CFG_VCC

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`endif

`ifdef AER

`endif

`ifdef GEN2

`endif

`ifdef CFG_VCC

`else

`endif

`ifdef AER

`else

`endif

`ifdef ECRC

`endif

`ifdef X4

`endif
reg [31 : 0] INIT_REG_000_split;
reg [31 : 0] INIT_REG_008_split;
reg [31 : 0] INIT_REG_00C_split;
reg [31 : 0] INIT_REG_010_split;
reg [31 : 0] INIT_REG_014_split;
reg [31 : 0] INIT_REG_018_split;
reg [31 : 0] INIT_REG_01C_split;
reg [31 : 0] INIT_REG_020_split;
reg [31 : 0] INIT_REG_024_split;
reg [31 : 0] INIT_REG_028_split;
reg [31 : 0] INIT_REG_02C_split;
reg [31 : 0] INIT_REG_030_split;
reg [31 : 0] INIT_REG_03C_split;
reg load_id_split;
reg [31 : 0] INIT_REG_050_split;
reg [31 : 0] INIT_REG_054_split;
reg [9 : 0] INIT_PM_DS_DATA_0_split;
reg [9 : 0] INIT_PM_DS_DATA_1_split;
reg [9 : 0] INIT_PM_DS_DATA_2_split;
reg [9 : 0] INIT_PM_DS_DATA_3_split;
reg [9 : 0] INIT_PM_DS_DATA_4_split;
reg [9 : 0] INIT_PM_DS_DATA_5_split;
reg [9 : 0] INIT_PM_DS_DATA_6_split;
reg [9 : 0] INIT_PM_DS_DATA_7_split;
reg [31 : 0] INIT_REG_070_split;
reg [31 : 0] INIT_REG_090_split;
reg [31 : 0] INIT_REG_094_split;
reg [31 : 0] INIT_REG_09C_split;
reg [31 : 0] INIT_REG_0A0_split;
reg [31 : 0] INIT_REG_104_split;
reg [31 : 0] INIT_REG_108_split;
reg rst_n_main_split;
reg [D_WIDTH - 1 : 0] tlp_data_split;
reg tlp_st_split;
reg tlp_end_split;
reg tlp_erly_st_split;
reg [7 : 0] tx_ca_cplh_split;
reg tx_ca_cplh_infi_split;
reg phy_link_up_split;
reg lnk_train_err_split;
reg lnk_train_status_split;
reg [2 : 0] lnk_width_split;
reg dfrm_perr_split;
reg dl_active_split;
reg [1 : 0] phy_lnk_spd_split;
reg phy_lnk_demp_split;
reg rxtp_bad_tlp_split;
reg rxdp_bad_dllp_split;
reg rxdp_dlerr_split;
reg txtp_rnum_rlor_split;
reg txtp_rply_tout_split;
reg lcmfci_fcp_err_split;
reg rcvr_oflow_split;
reg surp_down_err_split;
reg [15 : 0] sts_reg_in_split;
reg cmpln_tout_split;
reg cmpltr_abort_np_split;
reg cmpltr_abort_p_split;
reg unexp_cmpln_split;
reg ur_np_ext_split;
reg ur_p_ext_split;
reg np_req_pend_split;
reg pme_status_split;
reg ptc_err_enable_split;
reg force_x2_cfg_split;
reg force_x1_cfg_split;
reg term_all_cfg_split;
reg cfg_rmux_rd_split;
reg [D_WIDTH - 1 : 0] tlpdec_data_split;
reg tlpdec_st_split;
reg tlpdec_end_split;
reg tlpdec_ecrc_err_split;
reg tlpdec_pois_tlp_split;
reg tlpdec_us_req_split;
reg tlpdec_malf_tlp_split;
reg s2e_cnt_err_split;
reg [11 : 0] ADR_I_split;
reg [31 : 0] DAT_I_split;
reg WE_I_split;
reg STB_I_split;
reg load_cnt1_split;
reg load_cnt2_split;
reg load_cfg_split;
reg [5 : 0] reg_addr_split;
reg [31 : 0] reg_wdata_split;
reg [3 : 0] reg_wdata_be_split;
reg [15 : 0] req_id_split;
reg reg_id_hit_split;
reg [7 : 0] tag_split;
reg [2 : 0] tc_split;
reg [31 : 0] reg_rdata0_split;
reg [31 : 0] reg_rdata1_split;
reg [31 : 0] reg_rdata2_split;
reg [31 : 0] reg_rdata3_split;
reg [31 : 0] reg_rdata4_split;
reg [31 : 0] reg_rdata5_split;
reg us_req_split;
reg us_req_int_split;
reg [31 : 0] uner_sevr_split;
reg cs_ftl_err_out_split;
reg cs_nftl_err_out_split;
reg cs_cor_err_out_split;
reg aer_ftl_err_out_split;
reg aer_nftl_err_out_split;
reg aer_cor_err_out_split;
reg [2047:0] descram_in;
wire [104:0] descram_out;

`ifdef AER

`else

`endif

`ifdef X4

`define CFG_DEC cfg_dec1

`define CFG_RESP cfg_resp

`endif

`ifdef X1

`define CFG_DEC cfg_dec1_x1

`define CFG_RESP cfg_resp_x1

`endif


`ifdef ECRC

`endif

`ifdef X4

`endif

`ifdef AER

`endif


`ifdef GEN2

`endif


`ifdef GEN2

`endif


`ifdef GEN2

`endif

`ifdef GEN2

`endif

`ifdef AER

`endif

`ifdef GEN2

`endif

`ifdef AER

`else

`endif


`ifdef CFG_VCC


`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`endif

`ifdef AER


`endif


`ifdef GEN2

`endif

`ifdef CFG_VCC

`else

`endif

`ifdef AER

`else

`endif

`ifdef ECRC

`endif

`ifdef X4

`endif

localparam descram_inst_SIZE = 105,descram_inst_SCRAMSTRING = 32'hfdfff10b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef AER



`else



`endif



`ifdef X4



`define CFG_DEC cfg_dec1



`define CFG_RESP cfg_resp



`endif



`ifdef X1



`define CFG_DEC cfg_dec1_x1



`define CFG_RESP cfg_resp_x1



`endif



`ifdef ECRC



`endif



`ifdef X4



`endif



`ifdef AER



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef GEN2



`endif



`ifdef AER



`endif



`ifdef GEN2



`endif



`ifdef AER



`else



`endif



`ifdef CFG_VCC



`ifdef EN_VC0



`endif



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif



`endif



`ifdef AER



`endif



`ifdef GEN2



`endif



`ifdef CFG_VCC



`else



`endif



`ifdef AER



`else



`endif



`ifdef ECRC



`endif



`ifdef X4



`endif

// =============================================================================


`ifdef AER


   assign ftl_err_out  =  aer_ftl_err_out_split ;
   assign nftl_err_out =  aer_nftl_err_out_split ;
   assign cor_err_out  =  aer_cor_err_out_split ;


`else


   assign ftl_err_out  =  cs_ftl_err_out_split ;
   assign nftl_err_out =  cs_nftl_err_out_split ;
   assign cor_err_out  =  cs_cor_err_out_split ;


`endif





`ifdef X4


   

`define CFG_DEC cfg_dec1


   

`define CFG_RESP cfg_resp




`endif




`ifdef X1


   

`define CFG_DEC cfg_dec1_x1


   

`define CFG_RESP cfg_resp_x1




`endif


// =============================================================================
// Configuration space address decoder
// =============================================================================
`CFG_DEC u1_cfg_dec1 (
   .sys_clk      ( sys_clk ) ,
   .rst_n        ( rst_n ) ,

   .tlp_data     ( tlp_data ) ,
   .tlp_st       ( tlp_st ) ,
   .tlp_end      ( tlp_end ) ,
   .tlp_erly_st  ( tlp_erly_st ) ,
   .phy_link_up  ( phy_link_up ) ,
   .term_all_cfg ( term_all_cfg ) ,

   

`ifdef ECRC


      .tlp_ecrc_ok  ( tlp_ecrc_ok ) ,
      .ecrc_chk_enb ( ecrc_chk_enb ) ,
   

`endif



   // CPM Interface
   .ADR_I        ( ADR_I[11:2] ) ,
   .DAT_I        ( DAT_I ),
   .WE_I         ( WE_I ),
   .STB_I        ( STB_I ),

   

`ifdef X4


      .s2e_cnt_err  ( s2e_cnt_err ),
   

`endif



   .bus_num      ( bus_num ) ,
   .dev_num      ( dev_num ) ,
   .func_num     ( func_num ) ,
   .req_id       ( req_id ) ,
   .tag          ( tag ) ,
   .tc           ( tc ) ,

   .reg_sel_t0    ( reg_sel_t0 ) ,
   .reg_sel_pmsi  ( reg_sel_pmsi ) ,
   .reg_sel_cs    ( reg_sel_cs ) ,
   .reg_sel_ec    ( reg_sel_ec ) ,
   

`ifdef AER


      .reg_sel_aer  ( reg_sel_aer ) ,
   

`endif


   .reg_sel_usp   ( reg_sel_usp ) ,
   .reg_id_hit    ( reg_id_hit ) ,
   .type1_cfg     ( type1_cfg ) ,
   .pois_cfg      ( pois_cfg ) ,
   .cfg_hit       ( cfg_hit ) ,
   .nph_processed ( nph_processed ) ,
   .npd_processed ( npd_processed ) ,

   .reg_addr      ( reg_addr ) ,
   .reg_wdata     ( reg_wdata ) ,
   .reg_wdata_be  ( reg_wdata_be ) ,
   .reg_wr_t1     ( reg_wr_t1 ) ,
   .reg_wr_pois   ( reg_wr_pois ) ,
   .reg_wr        ( reg_wr ) ,
   .reg_rd        ( reg_rd ) ,
   .reg_wr_cpm    ( reg_wr_cpm ) ,
   .reg_rd_cpm    ( reg_rd_cpm ) ,
   .ecrc_ok       ( ecrc_ok )
   ) ;

// =============================================================================
// Type 0 registers
// =============================================================================
assign bar_10_init = INIT_REG_010_split ;
assign bar_14_init = INIT_REG_014_split ;
assign bar_18_init = INIT_REG_018_split ;
assign bar_1c_init = INIT_REG_01C_split ;
assign bar_20_init = INIT_REG_020_split ;
assign bar_24_init = INIT_REG_024_split ;
assign bar_30_init = INIT_REG_030_split ;

cfg_type0 u1_cfg_type0 (
   // Register Initial Values
   .INIT_REG_000 ( INIT_REG_000_split )  ,
   .INIT_REG_008 ( INIT_REG_008_split )  ,
   .INIT_REG_00C ( INIT_REG_00C_split )  ,
   .INIT_REG_010 ( INIT_REG_010_split )  ,
   .INIT_REG_014 ( INIT_REG_014_split )  ,
   .INIT_REG_018 ( INIT_REG_018_split )  ,
   .INIT_REG_01C ( INIT_REG_01C_split )  ,
   .INIT_REG_020 ( INIT_REG_020_split )  ,
   .INIT_REG_024 ( INIT_REG_024_split )  ,
   .INIT_REG_028 ( INIT_REG_028_split )  ,
   .INIT_REG_02C ( INIT_REG_02C_split )  ,
   .INIT_REG_030 ( INIT_REG_030_split )  ,
   .INIT_REG_03C ( INIT_REG_03C_split )  ,
   .load_id      ( load_id_split ) ,

   .phy_link_up  ( phy_link_up_split ) ,
   .sys_clk      ( sys_clk ) ,
   .rst_n        ( rst_n ) ,

   .reg_sel_t0   ( reg_sel_t0 ) ,
   .reg_addr     ( reg_addr_split[3:0] ) ,
   .reg_wdata    ( reg_wdata_split ) ,
   .reg_wdata_be ( reg_wdata_be_split ) ,
   .reg_wr       ( (reg_wr & ~s2e_cnt_err_split) ) ,
   .reg_rd       ( reg_rd ) ,
   .ecrc_ok      ( ecrc_ok ) ,

   .load_cfg     ( load_cfg_split ) ,
   

`ifdef GEN2


      .flr       ( flr ) ,
   

`endif


   .sts_reg_in   ( sts_reg_in_split ) ,

   // From registers
   .bar_10       ( bar_10 ) ,
   .bar_14       ( bar_14 ) ,
   .bar_18       ( bar_18 ) ,
   .bar_1c       ( bar_1c ) ,
   .bar_20       ( bar_20 ) ,
   .bar_24       ( bar_24 ) ,
   .bar_30       ( bar_30 ) ,
   .cmd_reg_out  ( cmd_reg_out ),

   .reg_rd_data  ( reg_rdata0 )
   ) ;

// =============================================================================
// PM and MSI Capabolity Structure registers
// =============================================================================
cfg_pmsi_cs u1_cfg_pmsi_cs (
   .INIT_REG_050      ( INIT_REG_050_split )  ,
   .INIT_REG_054      ( INIT_REG_054_split )  ,
   .INIT_PM_DS_DATA_0 ( INIT_PM_DS_DATA_0_split )  ,
   .INIT_PM_DS_DATA_1 ( INIT_PM_DS_DATA_1_split )  ,
   .INIT_PM_DS_DATA_2 ( INIT_PM_DS_DATA_2_split )  ,
   .INIT_PM_DS_DATA_3 ( INIT_PM_DS_DATA_3_split )  ,
   .INIT_PM_DS_DATA_4 ( INIT_PM_DS_DATA_4_split )  ,
   .INIT_PM_DS_DATA_5 ( INIT_PM_DS_DATA_5_split )  ,
   .INIT_PM_DS_DATA_6 ( INIT_PM_DS_DATA_6_split )  ,
   .INIT_PM_DS_DATA_7 ( INIT_PM_DS_DATA_7_split )  ,

   .INIT_REG_070      ( INIT_REG_070_split )  ,

   .sys_clk        ( sys_clk ) ,
   .rst_n          ( rst_n ),

   .phy_link_up    ( phy_link_up_split ) ,
   .reg_sel_cs     ( reg_sel_pmsi ) ,
   .reg_addr       ( reg_addr_split[3:0] ) ,
   .reg_wdata      ( reg_wdata_split ) ,
   .reg_wdata_be   ( reg_wdata_be_split ) ,
   .reg_wr         ( (reg_wr & ~s2e_cnt_err_split) ) ,
   .reg_rd         ( reg_rd ) ,
   .ecrc_ok        ( ecrc_ok ) ,

   .load_cfg       ( load_cfg_split ) ,
   

`ifdef GEN2


      .flr       ( flr ) ,
   

`endif


   .pme_status     ( pme_status_split ) ,

   .pm_power_state ( pm_power_state ) ,
   .pme_en         ( pme_en ) ,

   .mm_enable      ( mm_enable ) ,
   .msi_enable     ( msi_enable ) ,
   .mes_laddr      ( mes_laddr ) ,
   .mes_uaddr      ( mes_uaddr ) ,
   .mes_data       ( mes_data ) ,

   .reg_rd_data    ( reg_rdata1 )
   ) ;


// =============================================================================
// PCIE Capabolity Structure registers
// =============================================================================
cfg_pcie_cs u1_pcie_cfg_cs (
   .INIT_REG_090 ( INIT_REG_090_split )  ,
   .INIT_REG_094 ( INIT_REG_094_split )  ,
   .INIT_REG_09C ( INIT_REG_09C_split )  ,
   .INIT_REG_0A0 ( INIT_REG_0A0_split )  ,
   

`ifdef GEN2


      .INIT_REG_0B4 ( INIT_REG_0B4 )  ,
   

`endif



   .sys_clk      ( sys_clk ) ,
   .rst_n        ( rst_n ),
   .rst_n_main   ( rst_n_main_split ),

   .reg_sel_cs   ( reg_sel_cs ) ,
   .reg_addr     ( reg_addr_split[3:0] ) ,
   .reg_wdata    ( reg_wdata_split ) ,
   .reg_wdata_be ( reg_wdata_be_split ) ,
   .reg_wr       ( (reg_wr & ~s2e_cnt_err_split) ) ,
   .reg_rd       ( reg_rd ) ,
   .ecrc_ok      ( ecrc_ok ) ,

   .phy_link_up  ( phy_link_up_split ) ,
   .load_cfg     ( load_cfg_split ) ,
   

`ifdef GEN2


      .flr       ( flr ) ,
   

`endif



   

`ifdef AER


      .uner_sevr ( uner_sevr_split ) ,
   

`endif



   // From PHY
   .lnk_train_err    ( lnk_train_err_split ) ,
   .lnk_train_status ( lnk_train_status_split ) ,
   .lnk_width        ( lnk_width_split ) ,
   .dfrm_perr        ( dfrm_perr_split ) ,
   .dl_active        ( dl_active_split ) ,
   .phy_lnk_spd      ( phy_lnk_spd_split ) ,
   .phy_lnk_demp     ( phy_lnk_demp_split ) ,

   // From dll
   .rxtp_bad_tlp     ( rxtp_bad_tlp_split ) ,
   .rxdp_bad_dllp    ( rxdp_bad_dllp_split ) ,
   .rxdp_dlerr       ( rxdp_dlerr_split ) ,
   .txtp_rnum_rlor   ( txtp_rnum_rlor_split ) ,
   .txtp_rply_tout   ( txtp_rply_tout_split ) ,
   .lcmfci_fcp_err   ( lcmfci_fcp_err_split ) ,
   .surp_down_err    ( surp_down_err_split ) ,
   .rcvr_oflow       ( rcvr_oflow_split ) ,

   // From User logic
   .cmpln_tout       ( cmpln_tout_split ) ,
   .cmpltr_abort_np  ( cmpltr_abort_np_split ) ,
   .cmpltr_abort_p   ( cmpltr_abort_p_split ) ,
   .unexp_cmpln      ( unexp_cmpln_split ) ,
   .ur_np_ext        ( ur_np_ext_split ) ,
   .ur_p_ext         ( ur_p_ext_split ) ,
   .np_req_pend      ( np_req_pend_split ) ,
   .slot_sts         ( 8'h00 ) ,
   .ptc_err_enable   ( ptc_err_enable_split ) ,
   .force_x2_cfg     ( force_x2_cfg_split ) ,
   .force_x1_cfg     ( force_x1_cfg_split ) ,


   // From tlpdec
   .tlpdec_ecrc_err  ( tlpdec_ecrc_err_split ),
   .tlpdec_pois_tlp  ( tlpdec_pois_tlp_split ),
   .tlpdec_us_req    ( us_req_split ),
   .tlpdec_malf_tlp  ( tlpdec_malf_tlp_split ),
   .serr_enb         ( cmd_reg_out[4] ),

   // Outputs
   // From registers
   .slot_cntl_out    ( ) ,
   .dev_cntl_out     ( dev_cntl_out ),
   .lnk_cntl_out     ( lnk_cntl_out ),
   .ftl_err_out      ( cs_ftl_err_out ),
   .nftl_err_out     ( cs_nftl_err_out ),
   .cor_err_out      ( cs_cor_err_out ),
   

`ifdef GEN2


      .dev_cntl_2_out      ( dev_cntl_2_out ),
      .initiate_flr        ( initiate_flr ),
      .cs_target_lnk_spd   (cs_target_lnk_spd),
      .cs_enter_compliance (cs_enter_compliance),
      .cs_hasd             (cs_hasd),
      .cs_tx_demphasis     (cs_tx_demphasis),
      .cs_tx_margin        (cs_tx_margin),
      .cs_enter_mod_comp   (cs_enter_mod_comp),
      .cs_comp_sos         (cs_comp_sos),
      .cs_comp_demp        (cs_comp_demp),
   

`endif



   .max_pld_size     ( max_pld_size ) ,
   .extd_synch       ( extd_synch ) ,
   .link_disable     ( link_disable ) ,
   .retrain_lnk      ( retrain_lnk ) ,
   .cfgcs_losel      ( cfgcs_losel ) ,

   .reg_rd_data      ( reg_rdata2 )
   ) ;

   // Add UR caused by access of unimplemented function
   

`ifdef AER


       assign us_req = (tlpdec_us_req_split | us_req_int_split) ;
   

`else


       assign us_req = tlpdec_us_req_split ;
   

`endif



// =============================================================================
// Device Serial number Capabolity Structure registers
// =============================================================================
cfg_dsn_ec u1_cfg_dsn_ec (
   .INIT_REG_104 ( INIT_REG_104_split )  ,
   .INIT_REG_108 ( INIT_REG_108_split )  ,

   .sys_clk      ( sys_clk ) ,
   .rst_n        ( rst_n ),

   .reg_sel_ec   ( reg_sel_ec ) ,
   .reg_addr     ( reg_addr_split[4:0] ) ,
   .reg_wdata    ( reg_wdata_split ) ,
   .reg_wr       ( (reg_wr & ~s2e_cnt_err_split) ) ,
   .reg_rd       ( reg_rd ) ,
   .ecrc_ok      ( ecrc_ok ) ,

   .load_cfg     ( load_cfg_split ) ,

   .reg_rd_data  ( reg_rdata3 )
   ) ;


// =============================================================================
// Virtual Channel Capabolity Structure registers
// =============================================================================


`ifdef CFG_VCC


cfg_vcc_ec u1_cfg_vcc_ec (
   // Register Initial Values
   .INIT_REG_10C ( INIT_REG_10C )  ,

   .sys_clk          ( sys_clk ) ,
   .rst_n            ( rst_n ) ,

   .reg_sel_ec       ( reg_sel_ec ) ,
   .reg_addr         ( reg_addr_split[4:0] ) ,
   .reg_wdata        ( reg_wdata_split ) ,
   .reg_wdata_be     ( reg_wdata_be_split ) ,
   .reg_wr           ( (reg_wr & ~s2e_cnt_err_split) ) ,
   .reg_rd           ( reg_rd ) ,
   .ecrc_ok          ( ecrc_ok ) ,

   .lcmfci_vcn_pnd   ( lcmfci_vcn_pnd ) ,

   // Outputs
   .cfgec_evcc       ( cfgec_evcc ) ,
   .cfgec_lpevcc     ( cfgec_lpevcc ) ,
   .cfgec_lvcat      ( cfgec_lvcat ) ,
   .cfgec_vcasel     ( cfgec_vcasel ) ,

   

`ifdef EN_VC0


      .cfgec_tvmap_0 ( cfgec_tvmap_0 ) ,
      .cfgec_vcid_0  ( cfgec_vcid_0 ) ,
      .cfgec_vcenb_0 ( cfgec_vcenb_0 ) ,
   

`endif


   

`ifdef EN_VC1


      .cfgec_tvmap_1 ( cfgec_tvmap_1 ) ,
      .cfgec_vcid_1  ( cfgec_vcid_1 ) ,
      .cfgec_vcenb_1 ( cfgec_vcenb_1 ) ,
   

`endif


   

`ifdef EN_VC2


      .cfgec_tvmap_2 ( cfgec_tvmap_2 ) ,
      .cfgec_vcid_2  ( cfgec_vcid_2 ) ,
      .cfgec_vcenb_2 ( cfgec_vcenb_2 ) ,
   

`endif


   

`ifdef EN_VC3


      .cfgec_tvmap_3 ( cfgec_tvmap_3 ) ,
      .cfgec_vcid_3  ( cfgec_vcid_3 ) ,
      .cfgec_vcenb_3 ( cfgec_vcenb_3 ) ,
   

`endif


   

`ifdef EN_VC4


      .cfgec_tvmap_4 ( cfgec_tvmap_4 ) ,
      .cfgec_vcid_4  ( cfgec_vcid_4 ) ,
      .cfgec_vcenb_4 ( cfgec_vcenb_4 ) ,
   

`endif


   

`ifdef EN_VC5


      .cfgec_tvmap_5 ( cfgec_tvmap_5 ) ,
      .cfgec_vcid_5  ( cfgec_vcid_5 ) ,
      .cfgec_vcenb_5 ( cfgec_vcenb_5 ) ,
   

`endif


   

`ifdef EN_VC6


      .cfgec_tvmap_6 ( cfgec_tvmap_6 ) ,
      .cfgec_vcid_6  ( cfgec_vcid_6 ) ,
      .cfgec_vcenb_6 ( cfgec_vcenb_6 ) ,
   

`endif


   

`ifdef EN_VC7


      .cfgec_tvmap_7 ( cfgec_tvmap_7 ) ,
      .cfgec_vcid_7  ( cfgec_vcid_7 ) ,
      .cfgec_vcenb_7 ( cfgec_vcenb_7 ) ,
   

`endif


   .reg_rd_data      ( reg_rdata4 )
   ) ;


`endif





`ifdef AER


   cfg_aer #(
      .D_WIDTH          ( D_WIDTH ) )
      u1_cfg_aer (
      .sys_clk          ( sys_clk ) ,
      .rst_n            ( rst_n ) ,

      .reg_sel_aer      ( reg_sel_aer ) ,
      .reg_addr         ( reg_addr_split[3:0] ) ,
      .reg_wdata        ( reg_wdata_split ) ,
      .reg_wdata_be     ( reg_wdata_be_split ) ,
      .reg_wr           ( (reg_wr & ~s2e_cnt_err_split) ) ,
      .reg_rd           ( reg_rd ) ,
      .ecrc_ok          ( ecrc_ok ) ,

      // From PHY
      .phy_link_up      ( phy_link_up_split ) ,
      .dfrm_perr        ( dfrm_perr_split ) ,

      // From DLL
      .rxtp_bad_tlp     ( rxtp_bad_tlp_split ) ,
      .rxdp_bad_dllp    ( rxdp_bad_dllp_split ) ,
      .rxdp_dlerr       ( rxdp_dlerr_split ) ,
      .txtp_rnum_rlor   ( txtp_rnum_rlor_split ) ,
      .txtp_rply_tout   ( txtp_rply_tout_split ) ,
      .lcmfci_fcp_err   ( lcmfci_fcp_err_split ) ,
      .surp_down_err    ( surp_down_err_split ) ,
      .rcvr_oflow       ( rcvr_oflow_split ) ,

      // From tlpdec
      .tlpdec_data      ( tlpdec_data_split ) ,
      .tlpdec_st        ( tlpdec_st_split ) ,
      .tlpdec_end       ( tlpdec_end_split ) ,
      .tlpdec_ecrc_err  ( tlpdec_ecrc_err_split ),
      .tlpdec_pois_tlp  ( tlpdec_pois_tlp_split ),
      .tlpdec_us_req    ( us_req_split ),
      .tlpdec_malf_tlp  ( tlpdec_malf_tlp_split ),

      .serr_enb         ( cmd_reg_out[4] ),
      .dev_cntl_reg     ( dev_cntl_out ),

      // From User logic
      .err_tlp_header   ( err_tlp_header ) ,
      .cmpln_tout       ( cmpln_tout_split ) ,
      .cmpltr_abort_np  ( cmpltr_abort_np_split ) ,
      .cmpltr_abort_p   ( cmpltr_abort_p_split ) ,
      .unexp_cmpln      ( unexp_cmpln_split ) ,
      .ur_np_ext        ( ur_np_ext_split ) ,
      .ur_p_ext         ( ur_p_ext_split ) ,

      .ecrc_gen_enb     ( ecrc_gen_enb ) ,
      .ecrc_chk_enb     ( ecrc_chk_enb ) ,

      .uner_sevr        ( uner_sevr ) ,
      .ftl_err_out      ( aer_ftl_err_out ) ,
      .nftl_err_out     ( aer_nftl_err_out ) ,
      .cor_err_out      ( aer_cor_err_out ) ,

      .reg_rd_data      ( reg_rdata5 )
      ) ;



`endif


// =============================================================================
// Response TLP generator
// =============================================================================
`CFG_RESP u1_cfg_resp (
   .sys_clk         ( sys_clk ) ,
   .rst_n           ( rst_n ) ,

   .bus_num         ( bus_num ) ,
   .dev_num         ( dev_num ) ,
   .func_num        ( func_num ) ,
   .req_id          ( req_id ) ,
   .tag             ( tag ) ,
   .tc              ( tc ) ,
   .term_all_cfg    ( term_all_cfg ) ,
   .load_id         ( load_id ) ,
   

`ifdef GEN2


      .drop_resp    ( drop_resp ),
   

`endif



   .reg_rdata0      ( reg_rdata0 ) ,
   .reg_rdata1      ( reg_rdata1 ) ,
   .reg_rdata2      ( reg_rdata2 ) ,
   .reg_rdata3      ( reg_rdata3 ) ,
   

`ifdef CFG_VCC


      .reg_rdata4   ( reg_rdata4 ) ,
   

`else


      .reg_rdata4   ( 32'd0 ) ,
   

`endif


   

`ifdef AER


      .reg_rdata5   ( reg_rdata5 ) ,
   

`else


      .reg_rdata5   ( 32'd0 ) ,
   

`endif


   .reg_wr          ( ((reg_wr | reg_wr_t1 | reg_wr_pois) & ~s2e_cnt_err) ) ,
   .reg_rd          ( (reg_rd & ~s2e_cnt_err) ) ,
   .reg_wr_cpm      ( reg_wr_cpm ) ,
   .reg_rd_cpm      ( reg_rd_cpm ) ,
   .reg_sel_usp     ( reg_sel_usp ) ,
   .reg_id_hit      ( reg_id_hit ) ,
   .type1_cfg       ( type1_cfg ) ,
   .pois_cfg        ( pois_cfg ) ,
   .ecrc_ok         ( ecrc_ok ) ,

   

`ifdef ECRC


      .ecrc_gen_enb ( ecrc_gen_enb ) ,
      .ecrc_chk_enb ( ecrc_chk_enb ) ,
   

`endif



   .cfg_rmux_rd     ( cfg_rmux_rd ) ,
   .tx_ca_cplh      ( tx_ca_cplh ) ,
   .tx_ca_cplh_infi ( tx_ca_cplh_infi ),

   // Outputs
   // CPM Interface
   .RDAT_O          ( RDAT_O ),
   .ACK_O           ( ACK_O ),

   .us_req_int      ( us_req_int ) ,
   .cfg_rmux_req    ( cfg_rmux_req ) ,
   .cfg_rmux_data   ( cfg_rmux_data ) ,
   

`ifdef X4


      .cfg_rmux_dwen   ( cfg_rmux_dwen ) ,
   

`endif


   .cfg_rmux_ae     ( cfg_rmux_ae )
   ) ;

// =============================================================================
// load_cfg is 2 clock pulse, when all config registers are
// loaded with their initializing values.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      load_cnt0 <= 1'b0;
      load_cnt1 <= 1'b0;
      load_cnt2 <= 1'b0;
      load_cfg  <= 1'b0;
   end
   else begin
      load_cnt0 <= 1'b1;
      load_cnt1 <= load_cnt0;
      load_cnt2 <= load_cnt1_split;
      load_cfg  <= load_cnt0 & ~load_cnt2_split;
   end
end


always@* begin INIT_REG_000_split<={INIT_REG_000>>1,descram_out[0]};INIT_REG_008_split<={INIT_REG_008>>1,descram_out[1]};INIT_REG_00C_split<={INIT_REG_00C>>1,descram_out[2]};INIT_REG_010_split<={INIT_REG_010>>1,descram_out[3]};INIT_REG_014_split<={INIT_REG_014>>1,descram_out[4]};INIT_REG_018_split<={INIT_REG_018>>1,descram_out[5]};INIT_REG_01C_split<={INIT_REG_01C>>1,descram_out[6]};INIT_REG_020_split<={INIT_REG_020>>1,descram_out[7]};INIT_REG_024_split<={INIT_REG_024>>1,descram_out[8]};INIT_REG_028_split<={INIT_REG_028>>1,descram_out[9]};INIT_REG_02C_split<={INIT_REG_02C>>1,descram_out[10]};INIT_REG_030_split<={INIT_REG_030>>1,descram_out[11]};INIT_REG_03C_split<={INIT_REG_03C>>1,descram_out[12]};load_id_split<=descram_out[13];INIT_REG_050_split<={INIT_REG_050>>1,descram_out[14]};INIT_REG_054_split<={INIT_REG_054>>1,descram_out[15]};INIT_PM_DS_DATA_0_split<={INIT_PM_DS_DATA_0>>1,descram_out[16]};INIT_PM_DS_DATA_1_split<={INIT_PM_DS_DATA_1>>1,descram_out[17]};INIT_PM_DS_DATA_2_split<={INIT_PM_DS_DATA_2>>1,descram_out[18]};INIT_PM_DS_DATA_3_split<={INIT_PM_DS_DATA_3>>1,descram_out[19]};INIT_PM_DS_DATA_4_split<={INIT_PM_DS_DATA_4>>1,descram_out[20]};INIT_PM_DS_DATA_5_split<={INIT_PM_DS_DATA_5>>1,descram_out[21]};INIT_PM_DS_DATA_6_split<={INIT_PM_DS_DATA_6>>1,descram_out[22]};INIT_PM_DS_DATA_7_split<={INIT_PM_DS_DATA_7>>1,descram_out[23]};INIT_REG_070_split<={INIT_REG_070>>1,descram_out[24]};INIT_REG_090_split<={INIT_REG_090>>1,descram_out[25]};INIT_REG_094_split<={INIT_REG_094>>1,descram_out[26]};INIT_REG_09C_split<={INIT_REG_09C>>1,descram_out[27]};INIT_REG_0A0_split<={INIT_REG_0A0>>1,descram_out[28]};INIT_REG_104_split<={INIT_REG_104>>1,descram_out[29]};INIT_REG_108_split<={INIT_REG_108>>1,descram_out[30]};rst_n_main_split<=descram_out[31];tlp_data_split<={tlp_data>>1,descram_out[32]};tlp_st_split<=descram_out[33];tlp_end_split<=descram_out[34];tlp_erly_st_split<=descram_out[35];tx_ca_cplh_split<={tx_ca_cplh>>1,descram_out[36]};tx_ca_cplh_infi_split<=descram_out[37];phy_link_up_split<=descram_out[38];lnk_train_err_split<=descram_out[39];lnk_train_status_split<=descram_out[40];lnk_width_split<={lnk_width>>1,descram_out[41]};dfrm_perr_split<=descram_out[42];dl_active_split<=descram_out[43];phy_lnk_spd_split<={phy_lnk_spd>>1,descram_out[44]};phy_lnk_demp_split<=descram_out[45];rxtp_bad_tlp_split<=descram_out[46];rxdp_bad_dllp_split<=descram_out[47];rxdp_dlerr_split<=descram_out[48];txtp_rnum_rlor_split<=descram_out[49];txtp_rply_tout_split<=descram_out[50];lcmfci_fcp_err_split<=descram_out[51];rcvr_oflow_split<=descram_out[52];surp_down_err_split<=descram_out[53];sts_reg_in_split<={sts_reg_in>>1,descram_out[54]};cmpln_tout_split<=descram_out[55];cmpltr_abort_np_split<=descram_out[56];cmpltr_abort_p_split<=descram_out[57];unexp_cmpln_split<=descram_out[58];ur_np_ext_split<=descram_out[59];ur_p_ext_split<=descram_out[60];np_req_pend_split<=descram_out[61];pme_status_split<=descram_out[62];ptc_err_enable_split<=descram_out[63];force_x2_cfg_split<=descram_out[64];force_x1_cfg_split<=descram_out[65];term_all_cfg_split<=descram_out[66];cfg_rmux_rd_split<=descram_out[67];tlpdec_data_split<={tlpdec_data>>1,descram_out[68]};tlpdec_st_split<=descram_out[69];tlpdec_end_split<=descram_out[70];tlpdec_ecrc_err_split<=descram_out[71];tlpdec_pois_tlp_split<=descram_out[72];tlpdec_us_req_split<=descram_out[73];tlpdec_malf_tlp_split<=descram_out[74];s2e_cnt_err_split<=descram_out[75];ADR_I_split<={ADR_I>>1,descram_out[76]};DAT_I_split<={DAT_I>>1,descram_out[77]};WE_I_split<=descram_out[78];STB_I_split<=descram_out[79];load_cnt1_split<=descram_out[80];load_cnt2_split<=descram_out[81];load_cfg_split<=descram_out[82];reg_addr_split<={reg_addr>>1,descram_out[83]};reg_wdata_split<={reg_wdata>>1,descram_out[84]};reg_wdata_be_split<={reg_wdata_be>>1,descram_out[85]};req_id_split<={req_id>>1,descram_out[86]};reg_id_hit_split<=descram_out[87];tag_split<={tag>>1,descram_out[88]};tc_split<={tc>>1,descram_out[89]};reg_rdata0_split<={reg_rdata0>>1,descram_out[90]};reg_rdata1_split<={reg_rdata1>>1,descram_out[91]};reg_rdata2_split<={reg_rdata2>>1,descram_out[92]};reg_rdata3_split<={reg_rdata3>>1,descram_out[93]};reg_rdata4_split<={reg_rdata4>>1,descram_out[94]};reg_rdata5_split<={reg_rdata5>>1,descram_out[95]};us_req_split<=descram_out[96];us_req_int_split<=descram_out[97];uner_sevr_split<={uner_sevr>>1,descram_out[98]};cs_ftl_err_out_split<=descram_out[99];cs_nftl_err_out_split<=descram_out[100];cs_cor_err_out_split<=descram_out[101];aer_ftl_err_out_split<=descram_out[102];aer_nftl_err_out_split<=descram_out[103];aer_cor_err_out_split<=descram_out[104];end
always@* begin descram_in[2047]<=INIT_REG_008[0];descram_in[2046]<=INIT_REG_00C[0];descram_in[2045]<=aer_nftl_err_out;descram_in[2044]<=INIT_REG_010[0];descram_in[2042]<=aer_cor_err_out;descram_in[2040]<=INIT_REG_014[0];descram_in[2032]<=INIT_REG_018[0];descram_in[2016]<=INIT_REG_01C[0];descram_in[1985]<=INIT_REG_020[0];descram_in[1950]<=INIT_PM_DS_DATA_1[0];descram_in[1930]<=INIT_PM_DS_DATA_7[0];descram_in[1923]<=INIT_REG_024[0];descram_in[1909]<=reg_addr[0];descram_in[1878]<=cmpltr_abort_np;descram_in[1874]<=reg_id_hit;descram_in[1870]<=ADR_I[0];descram_in[1852]<=INIT_PM_DS_DATA_2[0];descram_in[1813]<=INIT_REG_070[0];descram_in[1799]<=INIT_REG_028[0];descram_in[1770]<=reg_wdata[0];descram_in[1708]<=cmpltr_abort_p;descram_in[1700]<=tag[0];descram_in[1693]<=DAT_I[0];descram_in[1656]<=INIT_PM_DS_DATA_3[0];descram_in[1578]<=INIT_REG_090[0];descram_in[1573]<=force_x2_cfg;descram_in[1551]<=INIT_REG_02C[0];descram_in[1493]<=sts_reg_in[0];descram_in[1492]<=reg_wdata_be[0];descram_in[1491]<=tlpdec_malf_tlp;descram_in[1417]<=pme_status;descram_in[1396]<=tlpdec_pois_tlp;descram_in[1378]<=ur_p_ext;descram_in[1368]<=unexp_cmpln;descram_in[1353]<=lnk_train_status;descram_in[1352]<=tc[0];descram_in[1345]<=INIT_REG_108[0];descram_in[1339]<=WE_I;descram_in[1316]<=dfrm_perr;descram_in[1312]<=reg_rdata1[0];descram_in[1285]<=tlp_data[0];descram_in[1265]<=INIT_PM_DS_DATA_4[0];descram_in[1262]<=load_cnt1;descram_in[1198]<=tlpdec_st;descram_in[1169]<=phy_lnk_spd[0];descram_in[1163]<=rxdp_bad_dllp;descram_in[1153]<=reg_rdata3[0];descram_in[1117]<=txtp_rply_tout;descram_in[1108]<=INIT_REG_094[0];descram_in[1098]<=force_x1_cfg;descram_in[1054]<=INIT_REG_030[0];descram_in[1045]<=tlp_end;descram_in[1039]<=us_req;descram_in[1023]<=INIT_REG_000[0];descram_in[1022]<=aer_ftl_err_out;descram_in[975]<=INIT_PM_DS_DATA_0[0];descram_in[965]<=INIT_PM_DS_DATA_6[0];descram_in[954]<=load_cfg;descram_in[939]<=cmpln_tout;descram_in[937]<=req_id[0];descram_in[935]<=s2e_cnt_err;descram_in[786]<=ptc_err_enable;descram_in[746]<=surp_down_err;descram_in[745]<=tlpdec_us_req;descram_in[708]<=np_req_pend;descram_in[698]<=tlpdec_ecrc_err;descram_in[689]<=ur_np_ext;descram_in[676]<=lnk_train_err;descram_in[672]<=INIT_REG_104[0];descram_in[658]<=lnk_width[0];descram_in[656]<=reg_rdata0[0];descram_in[642]<=rst_n_main;descram_in[631]<=STB_I;descram_in[599]<=tlpdec_data[0];descram_in[584]<=dl_active;descram_in[581]<=rxtp_bad_tlp;descram_in[576]<=reg_rdata2[0];descram_in[558]<=txtp_rnum_rlor;descram_in[522]<=tlp_st;descram_in[519]<=reg_rdata5[0];descram_in[511]<=cs_cor_err_out;descram_in[487]<=INIT_REG_054[0];descram_in[482]<=INIT_PM_DS_DATA_5[0];descram_in[477]<=load_cnt2;descram_in[373]<=rcvr_oflow;descram_in[349]<=tlpdec_end;descram_in[338]<=phy_link_up;descram_in[336]<=INIT_REG_0A0[0];descram_in[299]<=cfg_rmux_rd;descram_in[290]<=phy_lnk_demp;descram_in[279]<=rxdp_dlerr;descram_in[259]<=reg_rdata4[0];descram_in[255]<=cs_nftl_err_out;descram_in[243]<=INIT_REG_050[0];descram_in[186]<=lcmfci_fcp_err;descram_in[169]<=tx_ca_cplh_infi;descram_in[168]<=INIT_REG_09C[0];descram_in[149]<=term_all_cfg;descram_in[127]<=cs_ftl_err_out;descram_in[121]<=load_id;descram_in[84]<=tx_ca_cplh[0];descram_in[63]<=uner_sevr[0];descram_in[60]<=INIT_REG_03C[0];descram_in[42]<=tlp_erly_st;descram_in[31]<=us_req_int;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_x4


// File             : rxfc_arb.v


// Title            : RX Flow Control Block Arbiter b/w diff VCs and types


// Dependencies     :


// Description      : Arbitration logic for sending HP req to TXDP from diff


//                    VCs anf diff Types


//                    Round-robin is implemented


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Rajakumar


// Mod. Date        : Mar 25, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module  rxfc_arb(
   
   input wire sys_clk,              
   input wire rst_n,                

   
   input wire txdp_hpreq,           
   input wire txdp_lpreq,           

   
   input wire [`NUM_VC-1:0] p_pend_1a,            
   input wire [`NUM_VC-1:0] np_pend_1a,           
   input wire [`NUM_VC-1:0] cpl_pend_1a,          

   input wire [`NUM_VC-1:0] p_pend_1bc,           
   input wire [`NUM_VC-1:0] np_pend_1bc,          
   input wire [`NUM_VC-1:0] cpl_pend_1bc,         

   input wire [`NUM_VC-1:0] p_pend_2,             
   input wire [`NUM_VC-1:0] np_pend_2,            
   input wire [`NUM_VC-1:0] cpl_pend_2,           

   
   
   output wire [`NUM_VC-1:0] arb_sent_p,           
   output wire [`NUM_VC-1:0] arb_sent_np,          
   output wire [`NUM_VC-1:0] arb_sent_cpl,         

   
   output reg                fc_update1,           
   output reg [2:0]          fc_vcid1,             
   output reg [1:0]          fc_type1,             

   output reg                fc_update2,           
   output reg [2:0]          fc_vcid2,             
   output reg [1:0]          fc_type2              // Type P/NP/CPL



   );
parameter NUM_REQ = 3*`NUM_VC;
localparam TYP_P   = 2'b00;
localparam TYP_NP  = 2'b01;
localparam TYP_CPL = 2'b10;
reg   [`NUM_VC-1:0]       pend1_p;
reg   [`NUM_VC-1:0]       pend1_np;
reg   [`NUM_VC-1:0]       pend1_cpl;
reg   [`NUM_VC-1:0]       pend2_p;
reg   [`NUM_VC-1:0]       pend2_np;
reg   [`NUM_VC-1:0]       pend2_cpl;
reg   [`NUM_VC-1:0]       sent1_p;
reg   [`NUM_VC-1:0]       sent1_np;
reg   [`NUM_VC-1:0]       sent1_cpl;
reg   [`NUM_VC-1:0]       sent2_p;
reg   [`NUM_VC-1:0]       sent2_np;
reg   [`NUM_VC-1:0]       sent2_cpl;
reg   [1:0]               lp_t_cnt;
reg   [1:0]               lp_t_cnt_q;
reg   [1:0]               hp_t_cnt;
reg   [1:0]               hp_t_cnt_q;

`ifdef VC1
reg                       lp_v_cnt;
reg                       lp_v_cnt_q;
reg                       hp_v_cnt;
reg                       hp_v_cnt_q;

`else

`ifdef VC2
reg                          lp_v_cnt;
reg                          lp_v_cnt_q;
reg                          hp_v_cnt;
reg                          hp_v_cnt_q;

`else

`ifdef VC3
reg  [1:0]                         lp_v_cnt;
reg  [1:0]                         lp_v_cnt_q;
reg  [1:0]                         hp_v_cnt;
reg  [1:0]                         hp_v_cnt_q;

`else

`ifdef VC4
reg  [1:0]                         lp_v_cnt;
reg  [1:0]                         lp_v_cnt_q;
reg  [1:0]                         hp_v_cnt;
reg  [1:0]                         hp_v_cnt_q;

`else   // 5 - 8
reg  [2:0]                         lp_v_cnt;
reg  [2:0]                         lp_v_cnt_q;
reg  [2:0]                         hp_v_cnt;
reg  [2:0]                         hp_v_cnt_q;

`endif

`endif

`endif

`endif
reg txdp_hpreq_split;
reg txdp_lpreq_split;
reg [`NUM_VC - 1 : 0] p_pend_1a_split;
reg [`NUM_VC - 1 : 0] np_pend_1a_split;
reg [`NUM_VC - 1 : 0] cpl_pend_1a_split;
reg [`NUM_VC - 1 : 0] p_pend_1bc_split;
reg [`NUM_VC - 1 : 0] np_pend_1bc_split;
reg [`NUM_VC - 1 : 0] cpl_pend_1bc_split;
reg [`NUM_VC - 1 : 0] p_pend_2_split;
reg [`NUM_VC - 1 : 0] np_pend_2_split;
reg [`NUM_VC - 1 : 0] cpl_pend_2_split;
reg [`NUM_VC - 1 : 0] pend1_p_split;
reg [`NUM_VC - 1 : 0] pend1_np_split;
reg [`NUM_VC - 1 : 0] pend1_cpl_split;
reg [`NUM_VC - 1 : 0] pend2_p_split;
reg [`NUM_VC - 1 : 0] pend2_np_split;
reg [`NUM_VC - 1 : 0] pend2_cpl_split;
reg [`NUM_VC - 1 : 0] sent1_p_split;
reg [`NUM_VC - 1 : 0] sent1_np_split;
reg [`NUM_VC - 1 : 0] sent1_cpl_split;
reg [`NUM_VC - 1 : 0] sent2_p_split;
reg [`NUM_VC - 1 : 0] sent2_np_split;
reg [`NUM_VC - 1 : 0] sent2_cpl_split;
reg [1 : 0] lp_t_cnt_split;
reg [1 : 0] lp_t_cnt_q_split;
reg [1 : 0] hp_t_cnt_split;
reg [1 : 0] hp_t_cnt_q_split;
reg [2047:0] descram_in;
wire [26:0] descram_out;

`ifdef VC1

`else

`ifdef VC2

`else

`ifdef VC3

`else

`ifdef VC4

`else   // 5 - 8

`endif

`endif

`endif

`endif

localparam descram_inst_SIZE = 27,descram_inst_SCRAMSTRING = 32'hfdffe0cb;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1


`else



`ifdef VC2


`else



`ifdef VC3


`else



`ifdef VC4


`else   // 5 - 8


`endif



`endif



`endif



`endif

// =============================================================================
// Parameters
// for VC=8 --> 24, VC=1 --> 3
//---- Registers


`ifdef VC1


   //Always zero
   //Always zero
   //Always zero
   //Always zero


`else


   

`ifdef VC2


      

`else


      

`ifdef VC3


         

`else


         

`ifdef VC4


            

`else   // 5 - 8


            

`endif


      

`endif


   

`endif




`endif





// =============================================================================
// Combining Both 1a & 1bc requests
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      {pend1_cpl,pend1_np,pend1_p} <= 'd0;
      {pend2_cpl,pend2_np,pend2_p} <= 'd0;
   end
   else begin
      {pend1_cpl,pend1_np,pend1_p} <= {(cpl_pend_1a_split | cpl_pend_1bc_split),
                                       (np_pend_1a_split | np_pend_1bc_split),
                                       (p_pend_1a_split | p_pend_1bc_split)} &
                                       ~{sent1_cpl_split,sent1_np_split,sent1_p_split};

      {pend2_cpl,pend2_np,pend2_p} <= {cpl_pend_2_split,
                                       np_pend_2_split,
                                       p_pend_2_split} &
                                       ~{sent2_cpl_split,sent2_np_split,sent2_p_split};
   end
end

// =============================================================================
// ORDER: All P requests for each VC , all NP then all CPL
// =============================================================================
// High Priority
// Request gen. to TXDP & Ack gen. to rxfc_vc module
// =============================================================================
assign {arb_sent_cpl, arb_sent_np, arb_sent_p} = {sent1_cpl_split,sent1_np_split,sent1_p_split} |
                                                 {sent2_cpl_split,sent2_np_split,sent2_p_split};

always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      fc_update1  <= 1'b0;
      fc_vcid1    <= 3'b000;
      fc_type1    <= 2'b00;
      sent1_p   <= 'd0;
      sent1_np  <= 'd0;
      sent1_cpl <= 'd0;
   end
   else begin
      //Initalize all the bits to zero as v_cnt width can be 1 or 2 bits
      fc_vcid1    <= 3'b000;
      fc_update1  <= 1'b0;

      if(!txdp_hpreq_split) begin
        case(hp_t_cnt_split)
          TYP_P   : begin
            fc_update1  <= pend1_p_split[hp_v_cnt];
            fc_vcid1    <= hp_v_cnt;
            fc_type1    <= TYP_P;
          end
          TYP_NP  : begin
            fc_update1  <= pend1_np_split[hp_v_cnt];
            fc_vcid1    <= hp_v_cnt;
            fc_type1    <= TYP_NP;
          end
          default : begin
            fc_update1  <= pend1_cpl_split[hp_v_cnt];
            fc_vcid1    <= hp_v_cnt;
            fc_type1    <= TYP_CPL;
          end
        endcase
      end

      sent1_p   <= 'd0;
      sent1_np  <= 'd0;
      sent1_cpl <= 'd0;
      case(hp_t_cnt_q_split)
        TYP_P   : sent1_p  [hp_v_cnt_q] <= fc_update1;
        TYP_NP  : sent1_np [hp_v_cnt_q] <= fc_update1;
        default : sent1_cpl[hp_v_cnt_q] <= fc_update1;
      endcase
   end
end

// =============================================================================
// Low Priority
// Request gen. to TXDP
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      sent2_p   <= 'd0;
      sent2_np  <= 'd0;
      sent2_cpl <= 'd0;
      fc_update2  <= 1'b0;
      fc_vcid2    <= 3'b000;
      fc_type2    <= 2'b00;
   end
   else begin
      //Initalize all the bits to zero as v_cnt width can be 1 or 2 bits
      fc_vcid2    <= 3'b000;
      fc_update2  <= 1'b0;

      if(!txdp_lpreq_split) begin
        case(lp_t_cnt_split)
          TYP_P   : begin
            fc_update2  <= pend2_p_split[lp_v_cnt];
            fc_vcid2    <= lp_v_cnt;
            fc_type2    <= TYP_P;
          end
          TYP_NP  : begin
            fc_update2  <= pend2_np_split[lp_v_cnt];
            fc_vcid2    <= lp_v_cnt;
            fc_type2    <= TYP_NP;
          end
          default : begin
            fc_update2  <= pend2_cpl_split[lp_v_cnt];
            fc_vcid2    <= lp_v_cnt;
            fc_type2    <= TYP_CPL;
          end
        endcase
      end

      sent2_p   <= 'd0;
      sent2_np  <= 'd0;
      sent2_cpl <= 'd0;
      case(lp_t_cnt_q_split)
        TYP_P   : sent2_p  [lp_v_cnt_q] <= fc_update2;
        TYP_NP  : sent2_np [lp_v_cnt_q] <= fc_update2;
        default : sent2_cpl[lp_v_cnt_q] <= fc_update2;
      endcase
   end
end

// =============================================================================
// Counters for selecting HP request
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      hp_v_cnt     <= 'd0;
      hp_v_cnt_q   <= 'd0;
      hp_t_cnt     <= 'd0;
      hp_t_cnt_q   <= 'd0;
   end
   else begin
      hp_t_cnt_q <= hp_t_cnt_split;
      hp_v_cnt_q <= hp_v_cnt;
      if(!txdp_hpreq_split) begin
         // VCID count : 0 to VCN/(NUM_VC-1)
         hp_v_cnt <= (hp_v_cnt == (`NUM_VC-1)) ? 0 : (hp_v_cnt + 1);

         // Type count : 0 to 2 counter for P, NP, CPL
         if(hp_v_cnt == (`NUM_VC-1)) begin
            hp_t_cnt <= (hp_t_cnt_split == 2'b10) ? 2'b00 : (hp_t_cnt_split + 2'b01);
         end
      end
   end
end

// =============================================================================
// Counters for selecting LP request
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      lp_v_cnt     <= 'd0;
      lp_t_cnt     <= 'd0;
      lp_v_cnt_q   <= 'd0;
      lp_t_cnt_q   <= 'd0;
   end
   else begin
      lp_v_cnt_q   <= lp_v_cnt;
      lp_t_cnt_q   <= lp_t_cnt_split;
      if(!txdp_lpreq_split) begin
         // VCID count : 0 to VCN/(NUM_VC-1)
         lp_v_cnt <= (lp_v_cnt == (`NUM_VC-1)) ? 0 : (lp_v_cnt + 1);

         // Type count : 0 to 2 counter for P, NP, CPL
         if(lp_v_cnt == (`NUM_VC-1)) begin
            lp_t_cnt <= (lp_t_cnt_split == 2'b10) ? 2'b00 : (lp_t_cnt_split + 2'b01);
         end
      end
   end
end

always@* begin txdp_hpreq_split<=descram_out[0];txdp_lpreq_split<=descram_out[1];p_pend_1a_split<={p_pend_1a>>1,descram_out[2]};np_pend_1a_split<={np_pend_1a>>1,descram_out[3]};cpl_pend_1a_split<={cpl_pend_1a>>1,descram_out[4]};p_pend_1bc_split<={p_pend_1bc>>1,descram_out[5]};np_pend_1bc_split<={np_pend_1bc>>1,descram_out[6]};cpl_pend_1bc_split<={cpl_pend_1bc>>1,descram_out[7]};p_pend_2_split<={p_pend_2>>1,descram_out[8]};np_pend_2_split<={np_pend_2>>1,descram_out[9]};cpl_pend_2_split<={cpl_pend_2>>1,descram_out[10]};pend1_p_split<={pend1_p>>1,descram_out[11]};pend1_np_split<={pend1_np>>1,descram_out[12]};pend1_cpl_split<={pend1_cpl>>1,descram_out[13]};pend2_p_split<={pend2_p>>1,descram_out[14]};pend2_np_split<={pend2_np>>1,descram_out[15]};pend2_cpl_split<={pend2_cpl>>1,descram_out[16]};sent1_p_split<={sent1_p>>1,descram_out[17]};sent1_np_split<={sent1_np>>1,descram_out[18]};sent1_cpl_split<={sent1_cpl>>1,descram_out[19]};sent2_p_split<={sent2_p>>1,descram_out[20]};sent2_np_split<={sent2_np>>1,descram_out[21]};sent2_cpl_split<={sent2_cpl>>1,descram_out[22]};lp_t_cnt_split<={lp_t_cnt>>1,descram_out[23]};lp_t_cnt_q_split<={lp_t_cnt_q>>1,descram_out[24]};hp_t_cnt_split<={hp_t_cnt>>1,descram_out[25]};hp_t_cnt_q_split<={hp_t_cnt_q>>1,descram_out[26]};end
always@* begin descram_in[2047]<=txdp_lpreq;descram_in[2046]<=p_pend_1a[0];descram_in[2044]<=np_pend_1a[0];descram_in[2040]<=cpl_pend_1a[0];descram_in[2033]<=p_pend_1bc[0];descram_in[2024]<=sent2_np[0];descram_in[2018]<=np_pend_1bc[0];descram_in[2001]<=sent2_cpl[0];descram_in[1988]<=cpl_pend_1bc[0];descram_in[1954]<=lp_t_cnt[0];descram_in[1929]<=p_pend_2[0];descram_in[1860]<=lp_t_cnt_q[0];descram_in[1811]<=np_pend_2[0];descram_in[1789]<=sent1_np[0];descram_in[1673]<=hp_t_cnt[0];descram_in[1574]<=cpl_pend_2[0];descram_in[1530]<=sent1_cpl[0];descram_in[1299]<=hp_t_cnt_q[0];descram_in[1247]<=pend2_np[0];descram_in[1101]<=pend1_p[0];descram_in[1023]<=txdp_hpreq;descram_in[1012]<=sent2_p[0];descram_in[894]<=sent1_p[0];descram_in[623]<=pend2_p[0];descram_in[447]<=pend2_cpl[0];descram_in[311]<=pend1_cpl[0];descram_in[155]<=pend1_np[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule

// =============================================================================


// Revision 1.2 2006/06/27 17:14:45PDT rperugu


// All X1 flies copied (old ones are from SC X4).


// Revision 1.2 2006/04/04 15:52:38PDT srajadur


// r_cnt_dly reg initialized


// Revision 1.1 2006/02/02 14:35:32PST srajadur


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.4 2005/02/14 17:41:55PST rperugu


// AS_X4 modifications: Added Inputs - txdp_hpreq & txdp_lpreq.


// Revision 1.3 2004/06/28 17:38:27PDT rperugu


// r_cnt, v_cnt & t_cnt are introduced to give proper ID & Type along with


// requests update1 & 2.


// Revision 1.2 2004/06/28 15:52:14PDT uananthi


//


// Revision 1.1 2004/04/21 10:31:54PDT gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// Revision 1.1 2004/04/08 14:45:41PDT rperugu


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_x4


// File             : rxfc_vc.v


// Title            : RX Flow Control Block for One VC


// Dependencies     :


// Description      : This Block stored the Credit Available Registers for One


//                    VC. Also it generates Update FC request


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Rajakumar


// Mod. Date        : Mar 25, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module  rxfc_vc(
   
   input wire sys_clk,              
   input wire rst_n,                


   
   input wire [7:0] INIT_PH_FC,           
   input wire [7:0] INIT_NPH_FC,          
   input wire [7:0] INIT_CPLH_FC,         
   input wire [11:0] INIT_PD_FC,           
   input wire [11:0] INIT_NPD_FC,          
   input wire [11:0] INIT_CPLD_FC,         

   input wire [6:0] UPDATE_FREQ_PH,       
   input wire [10:0] UPDATE_FREQ_PD,       
   input wire [6:0] UPDATE_FREQ_NPH,      
   input wire [10:0] UPDATE_FREQ_NPD,      
   input wire [6:0] UPDATE_FREQ_CPLH,     
   input wire [10:0] UPDATE_FREQ_CPLD,     

   
   input wire vc_init,              
   input wire send_update,          

   
   input wire phy_l0_l0s,           

   
   input wire txdp_p_sent,          
   input wire txdp_np_sent,         
   input wire txdp_cpl_sent,        

   
   input wire arb_sent_p,           
   input wire arb_sent_np,          
   input wire arb_sent_cpl,         

   
   input wire ph_buf_status,        
   input wire pd_buf_status,        
   input wire nph_buf_status,       
   input wire npd_buf_status,       
   input wire cplh_buf_status,      
   input wire cpld_buf_status,      
   input wire ph_processed,         
   input wire pd_processed,         
   input wire nph_processed,        
   input wire npd_processed,        
   input wire cplh_processed,       
   input wire cpld_processed,       

   input wire [7:0] pd_num,               
   input wire  [7:0]npd_num,              
   input wire  [7:0]cpld_num,             

   input wire nph_processed_cfg,    
   input wire npd_processed_cfg,    
   input wire ph_processed_msg,     

`ifdef AER
   
   input wire vc_rcvd,              
   input wire ph_rcvd,              
   input wire pd_rcvd,              
   input wire nph_rcvd,             
   input wire npd_rcvd ,            
   input wire [8:0] credits_rcvd,         

   input wire malf_pkt_ph,          
   input wire malf_pkt_pd,          
   input wire malf_pkt_nph,         
   input wire malf_pkt_npd,         
`endif

   
   
   output reg p_pend_1a,            
   output reg np_pend_1a,           
   output reg cpl_pend_1a,          

   output reg p_pend_1bc,           
   output reg np_pend_1bc,          
   output reg cpl_pend_1bc,         

   output reg p_pend_2,             
   output reg np_pend_2,            
   output reg cpl_pend_2,           

   output reg p_infi_credit,        
   output reg np_infi_credit,       
   output reg cpl_infi_credit,      

   `ifdef AER
      output reg overflow,          
   `endif
   output wire [23:0] fc_p,         
   output wire [23:0] fc_np,        
   output wire [23:0] fc_cpl        // CPL type


   );
parameter BUF_FULL_DATA_CNT = 3'b111;
parameter P_TYPE   = 2'b00;
parameter NP_TYPE  = 2'b01;
parameter CPL_TYPE = 2'b10;

`ifdef CUMULATIVE_CREDIT_CHECK
reg  [7:0]                x_ph, x_nph, x_cplh;
reg  [11:0]               x_pd,   y_pd,   z_pd,   pd_diff,   pd_diff_local;
reg  [11:0]               x_npd,  y_npd,  z_npd,  npd_diff,  npd_diff_local;
reg  [11:0]               x_cpld, y_cpld, z_cpld, cpld_diff, cpld_diff_local;

`endif
reg  [11:0]               ca_p_data;
reg  [7:0]                ca_p_hdr;
reg  [11:0]               ca_np_data;
reg  [7:0]                ca_np_hdr;
reg  [11:0]               ca_cpl_data;
reg  [7:0]                ca_cpl_hdr;
reg                       reset_pcnt;
reg                       reset_npcnt;
reg                       reset_cplcnt;
reg  [2:0]                pd_pro_cnt1a;
reg  [2:0]                cpld_pro_cnt1a;
reg  [13:0]               p_cnt;
reg  [13:0]               np_cnt;
reg  [13:0]               cpl_cnt;
reg  [6:0]                ph_pro_cnt1b;
reg  [11:0]               pd_pro_cnt1b;
reg  [6:0]                nph_pro_cnt1b;
reg  [11:0]               npd_pro_cnt1b;
reg  [6:0]                cplh_pro_cnt1b;
reg  [11:0]               cpld_pro_cnt1b;
reg  [7:0]                cr_p_hdr;
reg  [11:0]               cr_p_data;
reg  [7:0]                cr_np_hdr;
reg  [11:0]               cr_np_data;
reg  [7:0]                copy_cr_p_hdr;
reg  [11:0]               copy_cr_p_data;
reg  [7:0]                copy_cr_np_hdr;
reg  [11:0]               copy_cr_np_data;
wire [7:0]                cacr_phdiff;
wire [11:0]               cacr_pddiff;
wire [7:0]                cacr_nphdiff;
wire [11:0]               cacr_npddiff;
reg                       ph_overflow;
reg                       pd_overflow;
reg                       nph_overflow;
reg                       npd_overflow;
wire                      sent_p;
wire                      sent_np;
wire                      sent_cpl;
wire                      nph_processed_comb;
wire                      npd_processed_comb;
wire                      ph_processed_comb;
wire                      ph_infi;
wire                      pd_infi;
wire                      nph_infi;
wire                      npd_infi;
wire                      cplh_infi;
wire                      cpld_infi;
wire                      phcnt_1bexp_comb;
wire                      pdcnt_1bexp_comb;
wire                      nphcnt_1bexp_comb;
wire                      npdcnt_1bexp_comb;
wire                      cplhcnt_1bexp_comb;
wire                      cpldcnt_1bexp_comb;
wire [5:0]                npd_num_temp;

`ifdef CUMULATIVE_CREDIT_CHECK

`else

`endif

`ifdef AER

`endif
reg [7 : 0] INIT_PH_FC_split;
reg [7 : 0] INIT_NPH_FC_split;
reg [7 : 0] INIT_CPLH_FC_split;
reg [11 : 0] INIT_PD_FC_split;
reg [11 : 0] INIT_NPD_FC_split;
reg [11 : 0] INIT_CPLD_FC_split;
reg [6 : 0] UPDATE_FREQ_PH_split;
reg [10 : 0] UPDATE_FREQ_PD_split;
reg [6 : 0] UPDATE_FREQ_NPH_split;
reg [10 : 0] UPDATE_FREQ_NPD_split;
reg [6 : 0] UPDATE_FREQ_CPLH_split;
reg [10 : 0] UPDATE_FREQ_CPLD_split;
reg vc_init_split;
reg send_update_split;
reg phy_l0_l0s_split;
reg txdp_p_sent_split;
reg txdp_np_sent_split;
reg txdp_cpl_sent_split;
reg arb_sent_p_split;
reg arb_sent_np_split;
reg arb_sent_cpl_split;
reg ph_buf_status_split;
reg pd_buf_status_split;
reg nph_buf_status_split;
reg npd_buf_status_split;
reg cplh_buf_status_split;
reg cpld_buf_status_split;
reg ph_processed_split;
reg pd_processed_split;
reg nph_processed_split;
reg npd_processed_split;
reg cplh_processed_split;
reg cpld_processed_split;
reg [7 : 0] pd_num_split;
reg [7 : 0] npd_num_split;
reg [7 : 0] cpld_num_split;
reg nph_processed_cfg_split;
reg npd_processed_cfg_split;
reg ph_processed_msg_split;
reg [11 : 0] ca_p_data_split;
reg [7 : 0] ca_p_hdr_split;
reg [11 : 0] ca_np_data_split;
reg [7 : 0] ca_np_hdr_split;
reg [11 : 0] ca_cpl_data_split;
reg [7 : 0] ca_cpl_hdr_split;
reg reset_pcnt_split;
reg reset_npcnt_split;
reg reset_cplcnt_split;
reg [2 : 0] pd_pro_cnt1a_split;
reg [2 : 0] cpld_pro_cnt1a_split;
reg [13 : 0] p_cnt_split;
reg [13 : 0] np_cnt_split;
reg [13 : 0] cpl_cnt_split;
reg [6 : 0] ph_pro_cnt1b_split;
reg [11 : 0] pd_pro_cnt1b_split;
reg [6 : 0] nph_pro_cnt1b_split;
reg [11 : 0] npd_pro_cnt1b_split;
reg [6 : 0] cplh_pro_cnt1b_split;
reg [11 : 0] cpld_pro_cnt1b_split;
reg [7 : 0] cr_p_hdr_split;
reg [11 : 0] cr_p_data_split;
reg [7 : 0] cr_np_hdr_split;
reg [11 : 0] cr_np_data_split;
reg [7 : 0] copy_cr_p_hdr_split;
reg [11 : 0] copy_cr_p_data_split;
reg [7 : 0] copy_cr_np_hdr_split;
reg [11 : 0] copy_cr_np_data_split;
reg [7 : 0] cacr_phdiff_split;
reg [11 : 0] cacr_pddiff_split;
reg [7 : 0] cacr_nphdiff_split;
reg [11 : 0] cacr_npddiff_split;
reg ph_overflow_split;
reg pd_overflow_split;
reg nph_overflow_split;
reg npd_overflow_split;
reg sent_p_split;
reg sent_np_split;
reg sent_cpl_split;
reg nph_processed_comb_split;
reg npd_processed_comb_split;
reg ph_processed_comb_split;
reg ph_infi_split;
reg pd_infi_split;
reg nph_infi_split;
reg npd_infi_split;
reg cplh_infi_split;
reg cpld_infi_split;
reg phcnt_1bexp_comb_split;
reg pdcnt_1bexp_comb_split;
reg nphcnt_1bexp_comb_split;
reg npdcnt_1bexp_comb_split;
reg cplhcnt_1bexp_comb_split;
reg cpldcnt_1bexp_comb_split;
reg [5 : 0] npd_num_temp_split;
reg [2047:0] descram_in;
wire [93:0] descram_out;

`ifdef CUMULATIVE_CREDIT_CHECK

`endif

`ifdef CUMULATIVE_CREDIT_CHECK

`else

`endif

`ifdef AER

`endif

localparam descram_inst_SIZE = 94,descram_inst_SCRAMSTRING = 32'hfdffe81b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef CUMULATIVE_CREDIT_CHECK


`endif


`ifdef CUMULATIVE_CREDIT_CHECK



`else



`endif



`ifdef AER



`endif

// =============================================================================
// Parameters
//For VC 8

//---- Registers


`ifdef CUMULATIVE_CREDIT_CHECK




`endif



// ----- CREDIT AVAILABLE Registers
// HIGH PRIORITY Processing Registers & Counters
// ----- CREDIT RECEIVED Registers (for OverFlow check)
/****
reg  [7:0]                cacr_phdiff;
reg  [11:0]               cacr_pddiff;
reg  [7:0]                cacr_nphdiff;
reg  [11:0]               cacr_npddiff;
****/
//---- Wires
// =============================================================================
// 1 Credit = 4 DW = 16 bytes
// 4K bytes Pkt = 4K/16 Credits = 256 Credits
// =============================================================================
assign fc_p   = {2'b00, ca_p_hdr_split, 2'b00, ca_p_data_split};
assign fc_np  = {2'b00, ca_np_hdr_split, 2'b00, ca_np_data_split};
assign fc_cpl = {2'b00, ca_cpl_hdr_split, 2'b00, ca_cpl_data_split};

assign ph_infi   = (INIT_PH_FC_split == 0);
assign pd_infi   = (INIT_PD_FC_split == 0);
assign nph_infi  = (INIT_NPH_FC_split == 0);
assign npd_infi  = (INIT_NPD_FC_split == 0);
assign cplh_infi = (INIT_CPLH_FC_split == 0);
assign cpld_infi = (INIT_CPLD_FC_split == 0);

assign nph_processed_comb = nph_processed_split | nph_processed_cfg_split;
assign npd_processed_comb = npd_processed_split | npd_processed_cfg_split;

assign ph_processed_comb = ph_processed_split | ph_processed_msg_split;

// =============================================================================
// Generation of Header/Data Value for CA registers
// User can give upto 4K bytes (1K credits) of processed data at one shot.
// But consecutive UpdateFC values should differ by Max. 2047 credits
// For Header this value is 127.
// The following makes the y_reg in smaller parts (<=2047) & stores in x_reg.
// This x_reg is used to form the DLLP (added to INIT_FC val)
// =============================================================================
assign npd_num_temp = (npd_processed_cfg_split) ? (npd_num_split + 1'b1) : npd_num_split;



`ifdef CUMULATIVE_CREDIT_CHECK


always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      x_pd            <= 12'd0;
      y_pd            <= 12'd0;
      z_pd            <= 12'd0;
      pd_diff         <= 12'd0;
      pd_diff_local   <= 12'd0;
      x_npd           <= 12'd0;
      y_npd           <= 12'd0;
      z_npd           <= 12'd0;
      npd_diff        <= 12'd0;
      npd_diff_local  <= 12'd0;
      x_cpld          <= 12'd0;
      y_cpld          <= 12'd0;
      z_cpld          <= 12'd0;
      cpld_diff       <= 12'd0;
      cpld_diff_local <= 12'd0;
      x_ph            <= 8'd0;
      x_nph           <= 8'd0;
      x_cplh          <= 8'd0;
   end
   else begin
      //--- DATA
      //------------------ PD --------------------------
      if(vc_init_split) begin   //VC is not initalized
         y_pd  <= 12'd0;
         z_pd  <= 12'd0;
      end
      else begin
         //Total Outstanding
         y_pd <= (pd_processed_split) ? (y_pd + pd_num_split) : y_pd;

         //Sent
         z_pd  <= (txdp_p_sent_split) ? x_pd : z_pd; //?? check for the delay x_pd_del1/2/3
      end

      //Total Outstanding  - Sent
      //TOD = (x-z) + (y-x) = y-z
      pd_diff       <= y_pd - z_pd;

      //Local outstanding/Local to be sent - sent
      //LOD = (x-z)
      pd_diff_local <= x_pd - z_pd;

      //Local Outstanding
      //if(pd_diff[11] == 1'b0)
      if(pd_diff <= 12'd2047)             //TO is OK send
         x_pd <= y_pd;
      else if(pd_diff_local <= 12'd2047)  //TO is more & LOD is OK
         x_pd <= z_pd + 12'd2047;

      //------------------ NPD --------------------------
      if(vc_init_split) begin   //VC is not initalized
         y_npd  <= 12'd0;
         z_npd  <= 12'd0;
      end
      else begin
         case({npd_processed_split, npd_processed_cfg_split})
            2'b01   : y_npd  <= y_npd + 1'b1;
            2'b10,
            2'b11   : y_npd  <= y_npd + npd_num_temp_split;
            default : y_npd  <= y_npd;
         endcase

         z_npd  <= (txdp_np_sent_split) ? x_npd : z_npd;
      end

      npd_diff       <= y_npd - z_npd;
      npd_diff_local <= x_npd - z_npd;

      if(npd_diff <= 12'd2047)
         x_npd <= y_npd;
      else if(npd_diff_local <= 12'd2047)
         x_npd <= z_npd + 12'd2047;

      //------------------ CPLD -------------------------
      if(vc_init_split) begin   //VC is not initalized
         y_cpld  <= 12'd0;
         z_cpld  <= 12'd0;
      end
      else begin
         y_cpld  <= (cpld_processed_split) ? (y_cpld + cpld_num_split) : y_cpld;
         z_cpld  <= (txdp_cpl_sent_split) ? x_cpld : z_cpld;
      end

      cpld_diff       <= y_cpld - z_cpld;
      cpld_diff_local <= x_cpld - z_cpld;

      if(cpld_diff <= 12'd2047)
         x_cpld <= y_cpld;
      else if(cpld_diff_local <= 12'd2047)
         x_cpld <= z_cpld + 12'd2047;

      //--- HEADERS
      //------------------ PH/NPH/CPLH -------------------
      if(vc_init_split) begin   //VC is not initalized
         x_ph   <= 8'd0;
         x_nph  <= 8'd0;
         x_cplh <= 8'd0;
      end
      else begin
         x_ph   <= (ph_processed_split) ? (x_ph + 1'b1) : x_ph;
         x_nph  <= (nph_processed_split) ? (x_nph + 1'b1) : x_nph;
         x_cplh <= (cplh_processed_split) ? (x_cplh + 1'b1) : x_cplh;
      end
   end
end

// =============================================================================
// Updating the Credit Available Registers
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      ca_p_hdr    <= 8'd0;
      ca_np_hdr   <= 8'd0;
      ca_cpl_hdr  <= 8'd0;
      ca_p_data   <= 12'd0;
      ca_np_data  <= 12'd0;
      ca_cpl_data <= 12'd0;
   end
   else begin
      //P
      ca_p_hdr     <= (!ph_infi_split) ? (INIT_PH_FC_split + x_ph) : INIT_PH_FC_split;
      ca_p_data    <= (!pd_infi_split) ? (INIT_PD_FC_split + x_pd) : INIT_PD_FC_split;

      //NP
      ca_np_hdr    <= (!nph_infi_split) ? (INIT_NPH_FC_split + x_nph) : INIT_NPH_FC_split;
      ca_np_data   <= (!npd_infi_split) ? (INIT_NPD_FC_split + x_npd) : INIT_NPD_FC_split;

      //CPL
      ca_cpl_hdr   <= (!cplh_infi_split) ? (INIT_CPLH_FC_split + x_cplh) : INIT_CPLH_FC_split;
      ca_cpl_data  <= (!cpld_infi_split) ? (INIT_CPLD_FC_split + x_cpld) : INIT_CPLD_FC_split;
   end
end



`else


// =============================================================================
// Updating the Credit Available Registers
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
         ca_p_hdr    <= 8'd0;
         ca_np_hdr   <= 8'd0;
         ca_cpl_hdr  <= 8'd0;
         ca_p_data   <= 12'd0;
         ca_np_data  <= 12'd0;
         ca_cpl_data <= 12'd0;
   end
   else begin
      if(vc_init_split) begin   //VC is not initalized OR link has gone down
         ca_p_hdr    <= INIT_PH_FC_split;
         ca_np_hdr   <= INIT_NPH_FC_split;
         ca_cpl_hdr  <= INIT_CPLH_FC_split;
         ca_p_data   <= INIT_PD_FC_split;
         ca_np_data  <= INIT_NPD_FC_split;
         ca_cpl_data <= INIT_CPLD_FC_split;
      end
      else begin
         //P
         if (!ph_infi_split && ph_processed_split && ph_processed_msg_split)
            ca_p_hdr <= (ca_p_hdr_split + 2) ;
         else if (!ph_infi_split && ph_processed_comb_split)
            ca_p_hdr <= (ca_p_hdr_split + 1) ;

         ca_p_data   <= (!pd_infi_split && pd_processed_split) ? (ca_p_data_split + pd_num_split) : ca_p_data_split;

         //NP
         if (!nph_infi_split && nph_processed_split && nph_processed_cfg_split)
            ca_np_hdr <= (ca_np_hdr_split + 2) ;
         else if (!nph_infi_split && nph_processed_comb_split)
            ca_np_hdr <= (ca_np_hdr_split + 1) ;

         if (!npd_infi_split) begin
            case({npd_processed_split, npd_processed_cfg_split})
               2'b01   : ca_np_data  <= ca_np_data_split + 1'b1;
               2'b10,
               2'b11   : ca_np_data  <= ca_np_data_split + npd_num_temp_split;
               default : ca_np_data  <= ca_np_data_split;
            endcase
         end

         //CPL
         ca_cpl_hdr  <= (!cplh_infi_split && cplh_processed_split) ? (ca_cpl_hdr_split + 1) : ca_cpl_hdr_split;
         ca_cpl_data <= (!cpld_infi_split && cpld_processed_split) ? (ca_cpl_data_split + cpld_num_split) : ca_cpl_data_split;
      end
   end
end


`endif



// =============================================================================
// Credit Received Registers
// Updated when a PKT is received for this VC & cjeck for over-flow.
// When Over Flow occurs it keeps the old value
// The pkt has to be "NOT Malformed"
// CPL are infinite for EP
// =============================================================================


`ifdef AER


      //---- (CA - CR)
assign cacr_phdiff   = ca_p_hdr_split   - cr_p_hdr_split;
assign cacr_pddiff   = ca_p_data_split  - cr_p_data_split;
assign cacr_nphdiff  = ca_np_hdr_split  - cr_np_hdr_split;
assign cacr_npddiff  = ca_np_data_split - cr_np_data_split;
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      cr_p_hdr        <= 8'd0;
      cr_p_data       <= 12'd0;
      cr_np_hdr       <= 8'd0;
      cr_np_data      <= 12'd0;
      copy_cr_p_hdr   <= 8'd0;
      copy_cr_p_data  <= 12'd0;
      copy_cr_np_hdr  <= 8'd0;
      copy_cr_np_data <= 12'd0;
      /****
      cacr_phdiff     <= 8'd0;
      cacr_pddiff     <= 12'd0;
      cacr_nphdiff    <= 8'd0;
      cacr_npddiff    <= 12'd0;
      ****/
      ph_overflow     <= 1'b0;
      pd_overflow     <= 1'b0;
      nph_overflow    <= 1'b0;
      npd_overflow    <= 1'b0;
      overflow        <= 1'b0;
   end
   else begin
      //---- CR Register Copy
      if(vc_rcvd) begin   //Store before the Update
         copy_cr_p_hdr   <= (!ph_infi_split  && ph_rcvd)  ? cr_p_hdr_split   : copy_cr_p_hdr_split;
         copy_cr_p_data  <= (!pd_infi_split  && pd_rcvd)  ? cr_p_data_split  : copy_cr_p_data_split;
         copy_cr_np_hdr  <= (!nph_infi_split && nph_rcvd) ? cr_np_hdr_split  : copy_cr_np_hdr_split;
         copy_cr_np_data <= (!npd_infi_split && npd_rcvd) ? cr_np_data_split : copy_cr_np_data_split;
      end

      /****
      //---- (CA - CR)
      cacr_phdiff   <= ca_p_hdr   - cr_p_hdr;
      cacr_pddiff   <= ca_p_data  - cr_p_data;
      cacr_nphdiff  <= ca_np_hdr  - cr_np_hdr;
      cacr_npddiff  <= ca_np_data - cr_np_data;
      ****/

      //---- Over Flow check    (Check cacr_phdiff[7] set ---> OverFlow)
      ph_overflow  <= (cacr_phdiff_split  >= 'd128)  ? 1'b1 : 1'b0;
      pd_overflow  <= (cacr_pddiff_split  >= 'd2048) ? 1'b1 : 1'b0;
      nph_overflow <= (cacr_nphdiff_split >= 'd128)  ? 1'b1 : 1'b0;
      npd_overflow <= (cacr_npddiff_split >= 'd2048) ? 1'b1 : 1'b0;
      overflow     <= ph_overflow_split | pd_overflow_split | nph_overflow_split | npd_overflow_split;

      //---- CR Registers
      if(vc_init_split) //VC is not initalized OR link has gone down
         cr_p_hdr      <= 8'd0;
      else if(!ph_infi_split && vc_rcvd) begin   //--PH
         if(ph_rcvd)
            cr_p_hdr      <= cr_p_hdr_split + 1;
         else if(ph_overflow_split || pd_overflow_split || malf_pkt_ph)
            cr_p_hdr      <= copy_cr_p_hdr_split;
      end

      if(vc_init_split) //VC is not initalized
         cr_p_data     <= 12'd0;
      else if(!pd_infi_split && vc_rcvd) begin   //--PD
         if(pd_rcvd)
            cr_p_data     <= cr_p_data_split + credits_rcvd;
         else if(ph_overflow_split || pd_overflow_split || malf_pkt_pd)
            cr_p_data     <= copy_cr_p_data_split;
      end

      if(vc_init_split) //VC is not initalized
         cr_np_hdr     <= 8'd0;
      else if(!nph_infi_split && vc_rcvd) begin   //--NPH
         if(nph_rcvd)
            cr_np_hdr     <= cr_np_hdr_split + 1;
         else if(nph_overflow_split || npd_overflow_split || malf_pkt_nph)
            cr_np_hdr     <= copy_cr_np_hdr_split;
      end

      if(vc_init_split) //VC is not initalized
         cr_np_data     <= 12'd0;
      else if(!npd_infi_split && vc_rcvd) begin   //--NPD
         if(npd_rcvd)
            cr_np_data    <= cr_np_data_split + credits_rcvd;
         else if(nph_overflow_split || npd_overflow_split || malf_pkt_npd)
            cr_np_data    <= copy_cr_np_data_split;
      end

   end
end


`endif



// =============================================================================
// All the counters are reset when ..
//       1. Corresponding credit TYPE is advertised as INIFINTE during Init.
//       2. VC negotiation is pending OR VC is not initialized
//       3. PHY Layer is in NOT in LO or LOs states.
//       4. TXDP sent correcponding TYPE Update DLLP (From HPQ or LPQ)
//
//  *  Update FC has to be sent at least once in 30 Micrsec (timer is configurable
//     by user (30 Micr sec = 3750  clks, 45 Micro sec = 5625 clks).
//     30 Microsec -0%/+50%. It is 120 Microsec when Exteneded sync bit of
//     Control Link Register is set.
//     Choose a 12-bit countert (12'hFFF=4095 clks) & it will be 14-bit counter
//     if Ext. Sync bit is set.
// =============================================================================
// Update FC Timer selection, changed from reg to wire to eliminate false generation of
// updated FC after reset

always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      reset_pcnt      <= 1'b0;
      reset_npcnt     <= 1'b0;
      reset_cplcnt    <= 1'b0;
      p_infi_credit   <= 1'b0;
      np_infi_credit  <= 1'b0;
      cpl_infi_credit <= 1'b0;
   end
   else begin

      // 4) -- 1c
      //When VC is Enabled & PHY LAYER L0 or L0s state only counters are
      //incremented
      reset_pcnt    <= txdp_p_sent_split | p_infi_credit | vc_init_split | !phy_l0_l0s_split;
      reset_npcnt   <= txdp_np_sent_split | np_infi_credit | vc_init_split | !phy_l0_l0s_split;
      reset_cplcnt  <= txdp_cpl_sent_split | cpl_infi_credit | vc_init_split | !phy_l0_l0s_split;

      //Inifinite credit check
      p_infi_credit   <= ((INIT_PH_FC_split == 0)   && (INIT_PD_FC_split == 0))   ? 1'b1 : 1'b0;
      np_infi_credit  <= ((INIT_NPH_FC_split == 0)  && (INIT_NPD_FC_split == 0))  ? 1'b1 : 1'b0;
      cpl_infi_credit <= ((INIT_CPLH_FC_split == 0) && (INIT_CPLD_FC_split == 0)) ? 1'b1 : 1'b0;

   end
end
// =============================================================================
// FIRST TYPE Requests -- HP
// High Priority Request Generation to TXDP Block to  send Update DLLP
// High prority requests are guarenteed to go out within 4k(max) symbol times.
//  1) When any (non-infinite) NPH, NPD, PH, CPLH credits are consumed and TL has
//     processed them one or more of them, then Update FC has to be sent immediately.
//  2) When any (non-inifinite) PD or CPLD credits availabe is less than Max_pay
//     Load_Size and TL has processed one or more of them, Update FC has to be
//     sent immediately (frequency - No. of credits may be configurable).
//  3) NORMAL UPDATE on CNT EXPIRY: Update when say every 8 headers are processed.
//     The no. is programmable for each type.
//  4) Update FC has to be sent at least once in 30 Micrsec (timer is configurable
//     by user (30 Micr sec = 3750  clks, 45 Micro sec = 5625 clks).
//     30 Microsec -0%/+50%. It is 120 Microsec when Exteneded sync bit of
//     Control Link Register is set.
//     Choose a 12-bit countert (12'hFFF=4095 clks) & it will be 14-bit counter
//     if Ext. Sync bit is set.
//
// =============================================================================
assign sent_p   = arb_sent_p_split | reset_pcnt_split;
assign sent_np  = arb_sent_np_split | reset_npcnt_split;
assign sent_cpl = arb_sent_cpl_split | reset_cplcnt_split;

always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      pd_pro_cnt1a    <= 0;
      cpld_pro_cnt1a  <= 0;
      p_pend_1a       <= 1'b0;
      np_pend_1a      <= 1'b0;
      cpl_pend_1a     <= 1'b0;
   end
   else begin
      // 1) 2) -- 1a
      // During Buffer Full/Alm. Full conditions send Update FC every 32/64 bytes for
      // Data & for every H prcocessed
      // (Consider Appli. logic wait states during data transfer after H is taken)

      if(p_pend_1a) begin
         if(sent_p_split)
            p_pend_1a  <= 1'b0;
      end
      else
         p_pend_1a   <= (ph_buf_status_split & ph_processed_comb_split) | (pd_buf_status_split & pd_processed_split);

      if(np_pend_1a) begin
         if(sent_np_split)
            np_pend_1a  <= 1'b0;
      end
      else
         np_pend_1a  <= (nph_buf_status_split & nph_processed_comb_split) | (npd_buf_status_split & npd_processed_comb_split) ;

      if(cpl_pend_1a) begin
         if(sent_cpl_split)
            cpl_pend_1a  <= 1'b0;
      end
      else
         cpl_pend_1a <= (cplh_buf_status_split & cplh_processed_split) | (cpld_buf_status_split & cpld_processed_split);

   end
end

// =============================================================================
//  3) NORMAL UPDATE on CNT EXPIRY: Update when say every 8 headers are processed.
//     The no. is programmable for each type.
//  4) Update FC upon Timer Expiration
// =============================================================================

//Headers
assign phcnt_1bexp_comb   = (ph_pro_cnt1b_split == (UPDATE_FREQ_PH_split - 1)) ? 1'b1 : 1'b0;
assign nphcnt_1bexp_comb  = (nph_pro_cnt1b_split == (UPDATE_FREQ_NPH_split - 1)) ? 1'b1 : 1'b0;
assign cplhcnt_1bexp_comb = (cplh_pro_cnt1b_split == (UPDATE_FREQ_CPLH_split - 1)) ? 1'b1 : 1'b0;

//Data
assign pdcnt_1bexp_comb   = (pd_pro_cnt1b_split >= UPDATE_FREQ_PD_split) ? 1'b1 : 1'b0;
assign npdcnt_1bexp_comb  = (npd_pro_cnt1b_split >= UPDATE_FREQ_NPD_split) ? 1'b1 : 1'b0;
assign cpldcnt_1bexp_comb = (cpld_pro_cnt1b_split >= UPDATE_FREQ_CPLD_split) ? 1'b1 : 1'b0;

always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      ph_pro_cnt1b    <= 0;
      pd_pro_cnt1b    <= 0;
      nph_pro_cnt1b   <= 0;
      npd_pro_cnt1b   <= 0;
      cplh_pro_cnt1b  <= 0;
      cpld_pro_cnt1b  <= 0;
      p_cnt           <= 0;
      np_cnt          <= 0;
      cpl_cnt         <= 0;
      p_pend_1bc      <= 1'b0;
      np_pend_1bc     <= 1'b0;
      cpl_pend_1bc    <= 1'b0;
   end
   else begin
      // 3) 1b -- Normal Updates when TLPs are getting processed
      // Eg. for every 8 headers processed OR for every 4k bytes proeceed
      // FC DLLPs will be sent

      // PH & PD
      if(ph_buf_status_split || reset_pcnt_split || (phcnt_1bexp_comb_split && ph_processed_comb_split))
         ph_pro_cnt1b  <= 0;
      else
         ph_pro_cnt1b  <= (ph_processed_comb_split) ? (ph_pro_cnt1b_split + 1) : ph_pro_cnt1b_split;

      if(pd_buf_status_split || reset_pcnt_split || pdcnt_1bexp_comb_split)
         pd_pro_cnt1b  <= 0;
      else if (pd_processed_split)
         pd_pro_cnt1b  <= pd_pro_cnt1b_split + pd_num_split;

      // NPH & NPD
      if(nph_buf_status_split || reset_npcnt_split || (nphcnt_1bexp_comb_split && nph_processed_comb_split))
         nph_pro_cnt1b  <= 0;
      else
         nph_pro_cnt1b  <= (nph_processed_comb_split) ? (nph_pro_cnt1b_split + 1) : nph_pro_cnt1b_split;

      if(npd_buf_status_split || reset_npcnt_split || npdcnt_1bexp_comb_split)
         npd_pro_cnt1b  <= 0;
      else if (npd_processed_split)
         npd_pro_cnt1b  <= npd_pro_cnt1b_split + npd_num_split;


      // CPLH & CPLD
      if(cplh_buf_status_split || reset_cplcnt_split || (cplhcnt_1bexp_comb_split && cplh_processed_split))
         cplh_pro_cnt1b  <= 0;
      else
        cplh_pro_cnt1b  <= (cplh_processed_split) ? (cplh_pro_cnt1b_split + 1) : cplh_pro_cnt1b_split;

      if(cpld_buf_status_split || reset_cplcnt_split || cpldcnt_1bexp_comb_split)
         cpld_pro_cnt1b  <= 0;
      else if (cpld_processed_split)
         cpld_pro_cnt1b  <= cpld_pro_cnt1b_split + cpld_num_split;

      // ----- Combining both 1b & 1c to get PENDING bits -------
      if(p_pend_1bc) begin
         if(sent_p_split)
            p_pend_1bc  <= 1'b0;
      end
      else
         p_pend_1bc   <= (ph_processed_comb_split && phcnt_1bexp_comb_split) | (pdcnt_1bexp_comb_split) |
                         (!reset_pcnt_split && send_update_split);

      if(np_pend_1bc) begin
         if(sent_np_split)
            np_pend_1bc  <= 1'b0;
      end
      else
         np_pend_1bc  <= (nph_processed_comb_split && nphcnt_1bexp_comb_split) | (npdcnt_1bexp_comb_split) |
                         (!reset_npcnt_split && send_update_split);

      if(cpl_pend_1bc) begin
         if(sent_cpl_split)
            cpl_pend_1bc  <= 1'b0;
      end
      else
         cpl_pend_1bc <= (cplh_processed_split && cplhcnt_1bexp_comb_split) | (cpldcnt_1bexp_comb_split) |
                         (!reset_cplcnt_split && send_update_split);

   end
end

// =============================================================================
// SECOND TYPE Requests -- LP
// Normal Update when any credit is updated (go to LP requests Q)
// Data update is taken whenever 8 clks of data (8x8=64bytes) are processed for
// any type.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      p_pend_2       <= 1'b0;
      np_pend_2      <= 1'b0;
      cpl_pend_2     <= 1'b0;
   end
   else begin
      if(p_pend_2) begin
         if(sent_p_split)
            p_pend_2  <= 1'b0;
      end
      else
         p_pend_2   <=  !reset_pcnt_split && (ph_processed_comb_split | pd_processed_split);

      if(np_pend_2) begin
         if(sent_np_split)
            np_pend_2  <= 1'b0;
      end
      else
         np_pend_2   <=  !reset_npcnt_split && ((nph_processed_comb_split) | (npd_processed_comb_split));

      if(cpl_pend_2) begin
         if(sent_cpl_split)
            cpl_pend_2  <= 1'b0;
      end
      else
         cpl_pend_2 <=  !reset_cplcnt_split && (cplh_processed_split | cpld_processed_split);

      // use timer for updateFC
      p_pend_2       <= 1'b0;
      np_pend_2      <= 1'b0;
      cpl_pend_2     <= 1'b0;
   end
end


always@* begin INIT_PH_FC_split<={INIT_PH_FC>>1,descram_out[0]};INIT_NPH_FC_split<={INIT_NPH_FC>>1,descram_out[1]};INIT_CPLH_FC_split<={INIT_CPLH_FC>>1,descram_out[2]};INIT_PD_FC_split<={INIT_PD_FC>>1,descram_out[3]};INIT_NPD_FC_split<={INIT_NPD_FC>>1,descram_out[4]};INIT_CPLD_FC_split<={INIT_CPLD_FC>>1,descram_out[5]};UPDATE_FREQ_PH_split<={UPDATE_FREQ_PH>>1,descram_out[6]};UPDATE_FREQ_PD_split<={UPDATE_FREQ_PD>>1,descram_out[7]};UPDATE_FREQ_NPH_split<={UPDATE_FREQ_NPH>>1,descram_out[8]};UPDATE_FREQ_NPD_split<={UPDATE_FREQ_NPD>>1,descram_out[9]};UPDATE_FREQ_CPLH_split<={UPDATE_FREQ_CPLH>>1,descram_out[10]};UPDATE_FREQ_CPLD_split<={UPDATE_FREQ_CPLD>>1,descram_out[11]};vc_init_split<=descram_out[12];send_update_split<=descram_out[13];phy_l0_l0s_split<=descram_out[14];txdp_p_sent_split<=descram_out[15];txdp_np_sent_split<=descram_out[16];txdp_cpl_sent_split<=descram_out[17];arb_sent_p_split<=descram_out[18];arb_sent_np_split<=descram_out[19];arb_sent_cpl_split<=descram_out[20];ph_buf_status_split<=descram_out[21];pd_buf_status_split<=descram_out[22];nph_buf_status_split<=descram_out[23];npd_buf_status_split<=descram_out[24];cplh_buf_status_split<=descram_out[25];cpld_buf_status_split<=descram_out[26];ph_processed_split<=descram_out[27];pd_processed_split<=descram_out[28];nph_processed_split<=descram_out[29];npd_processed_split<=descram_out[30];cplh_processed_split<=descram_out[31];cpld_processed_split<=descram_out[32];pd_num_split<={pd_num>>1,descram_out[33]};npd_num_split<={npd_num>>1,descram_out[34]};cpld_num_split<={cpld_num>>1,descram_out[35]};nph_processed_cfg_split<=descram_out[36];npd_processed_cfg_split<=descram_out[37];ph_processed_msg_split<=descram_out[38];ca_p_data_split<={ca_p_data>>1,descram_out[39]};ca_p_hdr_split<={ca_p_hdr>>1,descram_out[40]};ca_np_data_split<={ca_np_data>>1,descram_out[41]};ca_np_hdr_split<={ca_np_hdr>>1,descram_out[42]};ca_cpl_data_split<={ca_cpl_data>>1,descram_out[43]};ca_cpl_hdr_split<={ca_cpl_hdr>>1,descram_out[44]};reset_pcnt_split<=descram_out[45];reset_npcnt_split<=descram_out[46];reset_cplcnt_split<=descram_out[47];pd_pro_cnt1a_split<={pd_pro_cnt1a>>1,descram_out[48]};cpld_pro_cnt1a_split<={cpld_pro_cnt1a>>1,descram_out[49]};p_cnt_split<={p_cnt>>1,descram_out[50]};np_cnt_split<={np_cnt>>1,descram_out[51]};cpl_cnt_split<={cpl_cnt>>1,descram_out[52]};ph_pro_cnt1b_split<={ph_pro_cnt1b>>1,descram_out[53]};pd_pro_cnt1b_split<={pd_pro_cnt1b>>1,descram_out[54]};nph_pro_cnt1b_split<={nph_pro_cnt1b>>1,descram_out[55]};npd_pro_cnt1b_split<={npd_pro_cnt1b>>1,descram_out[56]};cplh_pro_cnt1b_split<={cplh_pro_cnt1b>>1,descram_out[57]};cpld_pro_cnt1b_split<={cpld_pro_cnt1b>>1,descram_out[58]};cr_p_hdr_split<={cr_p_hdr>>1,descram_out[59]};cr_p_data_split<={cr_p_data>>1,descram_out[60]};cr_np_hdr_split<={cr_np_hdr>>1,descram_out[61]};cr_np_data_split<={cr_np_data>>1,descram_out[62]};copy_cr_p_hdr_split<={copy_cr_p_hdr>>1,descram_out[63]};copy_cr_p_data_split<={copy_cr_p_data>>1,descram_out[64]};copy_cr_np_hdr_split<={copy_cr_np_hdr>>1,descram_out[65]};copy_cr_np_data_split<={copy_cr_np_data>>1,descram_out[66]};cacr_phdiff_split<={cacr_phdiff>>1,descram_out[67]};cacr_pddiff_split<={cacr_pddiff>>1,descram_out[68]};cacr_nphdiff_split<={cacr_nphdiff>>1,descram_out[69]};cacr_npddiff_split<={cacr_npddiff>>1,descram_out[70]};ph_overflow_split<=descram_out[71];pd_overflow_split<=descram_out[72];nph_overflow_split<=descram_out[73];npd_overflow_split<=descram_out[74];sent_p_split<=descram_out[75];sent_np_split<=descram_out[76];sent_cpl_split<=descram_out[77];nph_processed_comb_split<=descram_out[78];npd_processed_comb_split<=descram_out[79];ph_processed_comb_split<=descram_out[80];ph_infi_split<=descram_out[81];pd_infi_split<=descram_out[82];nph_infi_split<=descram_out[83];npd_infi_split<=descram_out[84];cplh_infi_split<=descram_out[85];cpld_infi_split<=descram_out[86];phcnt_1bexp_comb_split<=descram_out[87];pdcnt_1bexp_comb_split<=descram_out[88];nphcnt_1bexp_comb_split<=descram_out[89];npdcnt_1bexp_comb_split<=descram_out[90];cplhcnt_1bexp_comb_split<=descram_out[91];cpldcnt_1bexp_comb_split<=descram_out[92];npd_num_temp_split<={npd_num_temp>>1,descram_out[93]};end
always@* begin descram_in[2047]<=INIT_NPH_FC[0];descram_in[2046]<=INIT_CPLH_FC[0];descram_in[2045]<=INIT_PD_FC[0];descram_in[2042]<=INIT_NPD_FC[0];descram_in[2037]<=INIT_CPLD_FC[0];descram_in[2032]<=copy_cr_np_data[0];descram_in[2026]<=UPDATE_FREQ_PH[0];descram_in[2017]<=cacr_phdiff[0];descram_in[2005]<=UPDATE_FREQ_PD[0];descram_in[1986]<=cacr_pddiff[0];descram_in[1962]<=UPDATE_FREQ_NPH[0];descram_in[1925]<=cacr_nphdiff[0];descram_in[1891]<=cpld_buf_status;descram_in[1877]<=UPDATE_FREQ_NPD[0];descram_in[1844]<=cpld_num[0];descram_in[1835]<=cplh_pro_cnt1b[0];descram_in[1802]<=cacr_npddiff[0];descram_in[1742]<=arb_sent_np;descram_in[1735]<=ph_processed;descram_in[1707]<=UPDATE_FREQ_CPLH[0];descram_in[1666]<=ca_p_hdr[0];descram_in[1654]<=pd_buf_status;descram_in[1640]<=nph_processed_cfg;descram_in[1623]<=cpld_pro_cnt1b[0];descram_in[1593]<=npd_processed;descram_in[1578]<=nph_infi;descram_in[1556]<=ph_overflow;descram_in[1532]<=copy_cr_p_data[0];descram_in[1459]<=txdp_cpl_sent;descram_in[1437]<=arb_sent_cpl;descram_in[1422]<=pd_processed;descram_in[1407]<=cr_np_data[0];descram_in[1388]<=txdp_p_sent;descram_in[1371]<=send_update;descram_in[1366]<=UPDATE_FREQ_CPLD[0];descram_in[1352]<=pdcnt_1bexp_comb;descram_in[1351]<=cpld_pro_cnt1a[0];descram_in[1315]<=npdcnt_1bexp_comb;descram_in[1308]<=np_cnt[0];descram_in[1304]<=sent_cpl;descram_in[1285]<=ca_np_data[0];descram_in[1260]<=nph_buf_status;descram_in[1232]<=npd_processed_cfg;descram_in[1199]<=cr_p_hdr[0];descram_in[1165]<=cpldcnt_1bexp_comb;descram_in[1139]<=cplh_processed;descram_in[1138]<=ph_pro_cnt1b[0];descram_in[1122]<=npd_processed_comb;descram_in[1108]<=npd_infi;descram_in[1064]<=pd_overflow;descram_in[1045]<=ca_cpl_data[0];descram_in[1023]<=INIT_PH_FC[0];descram_in[1016]<=copy_cr_np_hdr[0];descram_in[945]<=cplh_buf_status;descram_in[922]<=npd_num[0];descram_in[917]<=npd_pro_cnt1b[0];descram_in[871]<=arb_sent_p;descram_in[833]<=ca_p_data[0];descram_in[827]<=ph_buf_status;descram_in[796]<=nph_processed;descram_in[789]<=pd_infi;descram_in[766]<=copy_cr_p_hdr[0];descram_in[729]<=txdp_np_sent;descram_in[703]<=cr_np_hdr[0];descram_in[694]<=phy_l0_l0s;descram_in[685]<=vc_init;descram_in[676]<=phcnt_1bexp_comb;descram_in[675]<=pd_pro_cnt1a[0];descram_in[657]<=nphcnt_1bexp_comb;descram_in[654]<=p_cnt[0];descram_in[652]<=sent_np;descram_in[582]<=cplhcnt_1bexp_comb;descram_in[569]<=cpl_cnt[0];descram_in[561]<=nph_processed_comb;descram_in[522]<=ca_np_hdr[0];descram_in[472]<=npd_buf_status;descram_in[461]<=pd_num[0];descram_in[458]<=nph_pro_cnt1b[0];descram_in[416]<=ph_processed_msg;descram_in[394]<=ph_infi;descram_in[351]<=cr_p_data[0];descram_in[338]<=cpld_infi;descram_in[337]<=reset_cplcnt;descram_in[326]<=sent_p;descram_in[283]<=npd_num_temp[0];descram_in[230]<=cpld_processed;descram_in[229]<=pd_pro_cnt1b[0];descram_in[197]<=ph_processed_comb;descram_in[169]<=cplh_infi;descram_in[168]<=reset_npcnt;descram_in[163]<=npd_overflow;descram_in[84]<=reset_pcnt;descram_in[81]<=nph_overflow;descram_in[42]<=ca_cpl_hdr[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule

// =============================================================================


// Revision 1.11 2007/09/14 15:44:48PDT rperugu


// 1) Over Flow : cr registers are reset when link goes down


// 2) Over Flow : crdiff registers are made wires to same a clk delay &


//                properly get back the copy registers to cr reg.


// Revision 1.10 2007/07/19 14:19:42PDT rperugu


// Change the OverFlow comp. value from 127 to 128. 2**8 / 2 = 128.


// Revision 1.9 2007/06/15 16:46:46PDT rperugu


// AER OverFlow check logic added.


// Revision 1.8 2007/06/01 11:39:43PDT rperugu


//


// Revision 1.7 2007/04/10 17:55:32PDT rperugu


// Unused signals phcnt_1bexp registers are commented.


// Revision 1.6 2007/04/10 15:36:59PDT rperugu


// *_pro_cnt1b counters are getting reset immediately with (*cnt_1bexp).


//    This is changed to (*cnt_1bexp_comb && *_processed).


// Revision 1.5 2007/04/09 14:23:46PDT rperugu


// Infi. Credits : Gen. of LP req. is taken care (infi check is ANDed for *_pend_2 outputs)


// Revision 1.4 2006/08/01 17:39:34PDT rperugu


// ph_infi, pd_infi, etc.. are created - bug fix.


// Revision 1.3 2006/07/30 16:49:45PDT rperugu


// Added _cfg signals for NP type.


// Revision 1.2 2006/06/27 17:14:47PDT rperugu


// All X1 flies copied (old ones are from SC X4).


// Revision 1.5 2006/04/04 15:54:43PDT srajadur


// txdp_p_sent kind of signals added in ports and logics


// Revision 1.4 2006/04/03 18:35:29PDT srajadur


// common counter for updateFC


// Revision 1.3 2006/03/20 10:36:04PST rperugu


// Added Outputs p/np/cpl_infi_credit from TRNC to DLL(txdp_ctrl).


// Revision 1.2 2006/02/22 10:11:35PST gkrishna


// Update FC Timer selection, changed from reg to wire to eliminate false generation of


// // updated FC after reset


// Revision 1.1 2006/02/02 14:35:32PST srajadur


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.5 2005/04/13 12:08:41PDT uananthi


// updated UPDATE_TIMER width


// Revision 1.4 2005/04/07 11:53:03PDT uananthi


// updated RXFC parameters bus.


// Revision 1.3 2004/06/28 15:15:56PDT uananthi


// else is missing.


// Revision 1.2 2004/04/22 16:32:33PDT rperugu


// defines are removed.


// Revision 1.1 2004/04/21 10:31:54PDT gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// Revision 1.2 2004/04/14 18:28:51PDT rperugu


// update_timer reset value should be greater than 0, otherwise


// _bc pendings are asserted once as the both cnts are zeros.


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_x4


// File             : rxfc.v


// Title            : RX Flow Control Block


// Dependencies     :


// Description      : This Block stored the Credit Available Registers


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Rajakumar


// Mod. Date        : Mar 25, 2004


// Changes Made     : Initial Creation


//


// Version          : 2.0


// Author(s)        : SK Rajadurai


// Mod. Date        : Mar 25, 2004


// Changes Made     : Modified for PCIe x1


// =============================================================================




`timescale 1 ns / 100 ps
module  rxfc(
   input wire               sys_clk,              
   input wire               rst_n,                

   
   input wire [(8*`NUM_VC)-1:0]  INIT_PH_FC,      
   input wire [(8*`NUM_VC)-1:0]  INIT_NPH_FC,     
   input wire [(8*`NUM_VC)-1:0]  INIT_CPLH_FC,    
   input wire [(12*`NUM_VC)-1:0] INIT_PD_FC,      
   input wire [(12*`NUM_VC)-1:0] INIT_NPD_FC,     
   input wire [(12*`NUM_VC)-1:0] INIT_CPLD_FC,    

   input wire [6:0]         UPDATE_FREQ_PH,       
   input wire [10:0]        UPDATE_FREQ_PD,       
   input wire [6:0]         UPDATE_FREQ_NPH,      
   input wire [10:0]        UPDATE_FREQ_NPD,      
   input wire [6:0]         UPDATE_FREQ_CPLH,     
   input wire [10:0]        UPDATE_FREQ_CPLD,     
   input wire [11:0]        UPDATE_TIMER,
   
   input wire [`NUM_VC-1:0] vcneg_pend,           
   input wire               ext_sync_bit,         

   
   input wire               phy_l0_l0s,           

   
   input wire               txdp_hpreq,           
   input wire               txdp_lpreq,           
   input wire [`NUM_VC-1:0] txdp_p_sent,          
   input wire [`NUM_VC-1:0] txdp_np_sent,         
   input wire [`NUM_VC-1:0] txdp_cpl_sent,        

   
   input wire [`NUM_VC-1:0] ph_buf_status,        
   input wire [`NUM_VC-1:0] pd_buf_status,        
   input wire [`NUM_VC-1:0] nph_buf_status,       
   input wire [`NUM_VC-1:0] npd_buf_status,       
   input wire [`NUM_VC-1:0] cplh_buf_status,      
   input wire [`NUM_VC-1:0] cpld_buf_status,      
   input wire [`NUM_VC-1:0] ph_processed,         
   input wire [`NUM_VC-1:0] pd_processed,         
   input wire [`NUM_VC-1:0] nph_processed,        
   input wire [`NUM_VC-1:0] npd_processed,        
   input wire [`NUM_VC-1:0] cplh_processed,       
   input wire [`NUM_VC-1:0] cpld_processed,       
   input wire               nph_processed_cfg,    
   input wire               npd_processed_cfg,    
   input wire               ph_processed_msg,     

   input wire [7:0]         pd_num,               
   input wire [7:0]         npd_num,              
   input wire [7:0]         cpld_num,             

`ifdef AER
   
   input wire               vc_rcvd,              
   input wire               ph_rcvd,              
   input wire               pd_rcvd,              
   input wire               nph_rcvd,             
   input wire               npd_rcvd ,            
   input wire [8:0]         credits_rcvd,         

   input wire               malf_pkt_ph,          
   input wire               malf_pkt_pd,          
   input wire               malf_pkt_nph,         
   input wire               malf_pkt_npd,         
`endif

   
   output wire       fc_update1,              
   output wire [2:0] fc_vcid1,                
   output wire [1:0] fc_type1,                

   output wire       fc_update2,              
   output wire [2:0] fc_vcid2,                
   output wire [1:0] fc_type2,                

   output wire [`NUM_VC-1:0] p_infi_credit,   
   output wire [`NUM_VC-1:0] np_infi_credit,  
   output wire [`NUM_VC-1:0] cpl_infi_credit, 

   `ifdef AER
      output wire    fc_overflow,             
   `endif
   output wire [(24*`NUM_VC)-1:0] fc_p,       
   output wire [(24*`NUM_VC)-1:0] fc_np,      
   output wire [(24*`NUM_VC)-1:0] fc_cpl      
   );
parameter P_TYPE   = 2'b00;
parameter NP_TYPE  = 2'b01;
parameter CPL_TYPE = 2'b10;
integer                     i;
wire  [`NUM_VC-1:0]         p_pend_1a;
wire  [`NUM_VC-1:0]         np_pend_1a;
wire  [`NUM_VC-1:0]         cpl_pend_1a;
wire  [`NUM_VC-1:0]         p_pend_1bc;
wire  [`NUM_VC-1:0]         np_pend_1bc;
wire  [`NUM_VC-1:0]         cpl_pend_1bc;
wire  [`NUM_VC-1:0]         p_pend_2;
wire  [`NUM_VC-1:0]         np_pend_2;
wire  [`NUM_VC-1:0]         cpl_pend_2;
wire  [`NUM_VC-1:0]         arb_sent_p;
wire  [`NUM_VC-1:0]         arb_sent_np;
wire  [`NUM_VC-1:0]         arb_sent_cpl;
wire                        send_update;
wire  [13:0]                update_timer;
reg   [13:0]                fc_update_timer;
wire  [`NUM_VC -1:0]        nph_processed_cfg1;
wire  [`NUM_VC -1:0]        npd_processed_cfg1;
wire  [`NUM_VC -1:0]        ph_processed_msg1;
wire  [`NUM_VC -1:0]        overflow_allvc;

`ifdef VC1

`else

`endif

`ifdef AER

`endif

`ifdef AER

`endif
reg [(8 * `NUM_VC) - 1 : 0] INIT_PH_FC_split;
reg [(8 * `NUM_VC) - 1 : 0] INIT_NPH_FC_split;
reg [(8 * `NUM_VC) - 1 : 0] INIT_CPLH_FC_split;
reg [(12 * `NUM_VC) - 1 : 0] INIT_PD_FC_split;
reg [(12 * `NUM_VC) - 1 : 0] INIT_NPD_FC_split;
reg [(12 * `NUM_VC) - 1 : 0] INIT_CPLD_FC_split;
reg [6 : 0] UPDATE_FREQ_PH_split;
reg [10 : 0] UPDATE_FREQ_PD_split;
reg [6 : 0] UPDATE_FREQ_NPH_split;
reg [10 : 0] UPDATE_FREQ_NPD_split;
reg [6 : 0] UPDATE_FREQ_CPLH_split;
reg [10 : 0] UPDATE_FREQ_CPLD_split;
reg [11 : 0] UPDATE_TIMER_split;
reg [`NUM_VC - 1 : 0] vcneg_pend_split;
reg ext_sync_bit_split;
reg phy_l0_l0s_split;
reg txdp_hpreq_split;
reg txdp_lpreq_split;
reg [`NUM_VC - 1 : 0] txdp_p_sent_split;
reg [`NUM_VC - 1 : 0] txdp_np_sent_split;
reg [`NUM_VC - 1 : 0] txdp_cpl_sent_split;
reg [`NUM_VC - 1 : 0] ph_buf_status_split;
reg [`NUM_VC - 1 : 0] pd_buf_status_split;
reg [`NUM_VC - 1 : 0] nph_buf_status_split;
reg [`NUM_VC - 1 : 0] npd_buf_status_split;
reg [`NUM_VC - 1 : 0] cplh_buf_status_split;
reg [`NUM_VC - 1 : 0] cpld_buf_status_split;
reg [`NUM_VC - 1 : 0] ph_processed_split;
reg [`NUM_VC - 1 : 0] pd_processed_split;
reg [`NUM_VC - 1 : 0] nph_processed_split;
reg [`NUM_VC - 1 : 0] npd_processed_split;
reg [`NUM_VC - 1 : 0] cplh_processed_split;
reg [`NUM_VC - 1 : 0] cpld_processed_split;
reg nph_processed_cfg_split;
reg npd_processed_cfg_split;
reg ph_processed_msg_split;
reg [7 : 0] pd_num_split;
reg [7 : 0] npd_num_split;
reg [7 : 0] cpld_num_split;
reg [`NUM_VC - 1 : 0] p_pend_1a_split;
reg [`NUM_VC - 1 : 0] np_pend_1a_split;
reg [`NUM_VC - 1 : 0] cpl_pend_1a_split;
reg [`NUM_VC - 1 : 0] p_pend_1bc_split;
reg [`NUM_VC - 1 : 0] np_pend_1bc_split;
reg [`NUM_VC - 1 : 0] cpl_pend_1bc_split;
reg [`NUM_VC - 1 : 0] p_pend_2_split;
reg [`NUM_VC - 1 : 0] np_pend_2_split;
reg [`NUM_VC - 1 : 0] cpl_pend_2_split;
reg [`NUM_VC - 1 : 0] arb_sent_p_split;
reg [`NUM_VC - 1 : 0] arb_sent_np_split;
reg [`NUM_VC - 1 : 0] arb_sent_cpl_split;
reg send_update_split;
reg [13 : 0] update_timer_split;
reg [13 : 0] fc_update_timer_split;
reg [`NUM_VC - 1 : 0] nph_processed_cfg1_split;
reg [`NUM_VC - 1 : 0] npd_processed_cfg1_split;
reg [`NUM_VC - 1 : 0] ph_processed_msg1_split;
reg [`NUM_VC - 1 : 0] overflow_allvc_split;
reg [2047:0] descram_in;
wire [57:0] descram_out;

`ifdef VC1

`else

`endif



`ifdef AER

`endif

`ifdef AER

`endif

localparam descram_inst_SIZE = 58,descram_inst_SCRAMSTRING = 32'hfdffd42b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef VC1



`else



`endif



`ifdef AER



`endif



`ifdef AER



`endif

// =============================================================================
// Parameters
//---- Registers
//---- Wires
// =============================================================================


`ifdef VC1


   assign nph_processed_cfg1 = nph_processed_cfg_split;
   assign npd_processed_cfg1 = npd_processed_cfg_split;
   assign ph_processed_msg1  = ph_processed_msg_split;


`else


   assign nph_processed_cfg1 = {{`NUM_VC -1{1'b0}},nph_processed_cfg_split};
   assign npd_processed_cfg1 = {{`NUM_VC -1{1'b0}},npd_processed_cfg_split};
   assign ph_processed_msg1  = {{`NUM_VC -1{1'b0}},ph_processed_msg_split};


`endif



assign fc_overflow = |overflow_allvc_split;

// =============================================================================
// 34us common Timer to send update FC for all types and VCs once on each timeout
// =============================================================================

assign update_timer = (ext_sync_bit_split) ? {UPDATE_TIMER_split, 2'b00} : {2'b00, UPDATE_TIMER_split};

always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0)
      fc_update_timer <= 14'h0;
   else if (send_update_split)
      fc_update_timer <= 14'h0;
   else
      fc_update_timer <= fc_update_timer_split + 14'h1;
end

assign send_update = (fc_update_timer_split == update_timer_split) ? 1'b1  : 1'b0;

// =============================================================================
// Arbiter Between VCs : Intantiation
// =============================================================================
   rxfc_arb u_rxfc_arb(
      //---------Inputs-------------
      .sys_clk                  (sys_clk),
      .rst_n                    (rst_n),
      .txdp_hpreq               (txdp_hpreq_split),
      .txdp_lpreq               (txdp_lpreq_split),
      .p_pend_1a                (p_pend_1a_split),
      .np_pend_1a               (np_pend_1a_split),
      .cpl_pend_1a              (cpl_pend_1a_split),
      .p_pend_1bc               (p_pend_1bc_split),
      .np_pend_1bc              (np_pend_1bc_split),
      .cpl_pend_1bc             (cpl_pend_1bc_split),
      .p_pend_2                 (p_pend_2_split),
      .np_pend_2                (np_pend_2_split),
      .cpl_pend_2               (cpl_pend_2_split),

      //---------Outputs-------------
      .fc_update1               (fc_update1),
      .fc_vcid1                 (fc_vcid1),
      .fc_type1                 (fc_type1),
      .fc_update2               (fc_update2),
      .fc_vcid2                 (fc_vcid2),
      .fc_type2                 (fc_type2),

      .arb_sent_p               (arb_sent_p),
      .arb_sent_np              (arb_sent_np),
      .arb_sent_cpl             (arb_sent_cpl)

      );

// =============================================================================
// Flow Cotrol Block for Each VC:  Intantiations
// =============================================================================
rxfc_vc u1_rxfc_vc [`NUM_VC-1:0] (
      //---------Inputs-------------
      .sys_clk                  (sys_clk),
      .rst_n                    (rst_n),

      // Parameter bus, will be straped at the top
      .INIT_PH_FC               (INIT_PH_FC_split),
      .INIT_NPH_FC              (INIT_NPH_FC_split),
      .INIT_CPLH_FC             (INIT_CPLH_FC_split),
      .INIT_PD_FC               (INIT_PD_FC_split),
      .INIT_NPD_FC              (INIT_NPD_FC_split),
      .INIT_CPLD_FC             (INIT_CPLD_FC_split),

      .UPDATE_FREQ_PH           (UPDATE_FREQ_PH_split),
      .UPDATE_FREQ_PD           (UPDATE_FREQ_PD_split),
      .UPDATE_FREQ_NPH          (UPDATE_FREQ_NPH_split),
      .UPDATE_FREQ_NPD          (UPDATE_FREQ_NPD_split),
      .UPDATE_FREQ_CPLH         (UPDATE_FREQ_CPLH_split),
      .UPDATE_FREQ_CPLD         (UPDATE_FREQ_CPLD_split),

      .vc_init                  (vcneg_pend_split),
      .send_update              (send_update_split),
      .phy_l0_l0s               (phy_l0_l0s_split),
      .txdp_p_sent              (txdp_p_sent_split),
      .txdp_np_sent             (txdp_np_sent_split),
      .txdp_cpl_sent            (txdp_cpl_sent_split),

      .arb_sent_p               (arb_sent_p_split),
      .arb_sent_np              (arb_sent_np_split),
      .arb_sent_cpl             (arb_sent_cpl_split),

      .ph_buf_status            (ph_buf_status_split),
      .pd_buf_status            (pd_buf_status_split),
      .nph_buf_status           (nph_buf_status_split),
      .npd_buf_status           (npd_buf_status_split),
      .cplh_buf_status          (cplh_buf_status_split),
      .cpld_buf_status          (cpld_buf_status_split),
      .ph_processed             (ph_processed_split),
      .pd_processed             (pd_processed_split),
      .nph_processed            (nph_processed_split),
      .npd_processed            (npd_processed_split),
      .cplh_processed           (cplh_processed_split),
      .cpld_processed           (cpld_processed_split),
      .nph_processed_cfg        (nph_processed_cfg1_split),
      .npd_processed_cfg        (npd_processed_cfg1_split),
      .ph_processed_msg         (ph_processed_msg1_split),

      .pd_num                   (pd_num_split),
      .npd_num                  (npd_num_split),
      .cpld_num                 (cpld_num_split),

   

`ifdef AER


      //For OverFlow check
      .vc_rcvd                  (vc_rcvd),
      .ph_rcvd                  (ph_rcvd),
      .pd_rcvd                  (pd_rcvd),
      .nph_rcvd                 (nph_rcvd),
      .npd_rcvd                 (npd_rcvd),
      .credits_rcvd             (credits_rcvd),

      .malf_pkt_ph              (malf_pkt_ph),
      .malf_pkt_pd              (malf_pkt_pd),
      .malf_pkt_nph             (malf_pkt_nph),
      .malf_pkt_npd             (malf_pkt_npd),
   

`endif



      //---------Outputs-------------
      .p_pend_1a                (p_pend_1a),
      .np_pend_1a               (np_pend_1a),
      .cpl_pend_1a              (cpl_pend_1a),
      .p_pend_1bc               (p_pend_1bc),
      .np_pend_1bc              (np_pend_1bc),
      .cpl_pend_1bc             (cpl_pend_1bc),
      .p_pend_2                 (p_pend_2),
      .np_pend_2                (np_pend_2),
      .cpl_pend_2               (cpl_pend_2),

      .p_infi_credit            (p_infi_credit),
      .np_infi_credit           (np_infi_credit),
      .cpl_infi_credit          (cpl_infi_credit),

   

`ifdef AER


      .overflow                 (overflow_allvc),
   

`endif


      .fc_p                     (fc_p),
      .fc_np                    (fc_np),
      .fc_cpl                   (fc_cpl)

      );

always@* begin INIT_PH_FC_split<={INIT_PH_FC>>1,descram_out[0]};INIT_NPH_FC_split<={INIT_NPH_FC>>1,descram_out[1]};INIT_CPLH_FC_split<={INIT_CPLH_FC>>1,descram_out[2]};INIT_PD_FC_split<={INIT_PD_FC>>1,descram_out[3]};INIT_NPD_FC_split<={INIT_NPD_FC>>1,descram_out[4]};INIT_CPLD_FC_split<={INIT_CPLD_FC>>1,descram_out[5]};UPDATE_FREQ_PH_split<={UPDATE_FREQ_PH>>1,descram_out[6]};UPDATE_FREQ_PD_split<={UPDATE_FREQ_PD>>1,descram_out[7]};UPDATE_FREQ_NPH_split<={UPDATE_FREQ_NPH>>1,descram_out[8]};UPDATE_FREQ_NPD_split<={UPDATE_FREQ_NPD>>1,descram_out[9]};UPDATE_FREQ_CPLH_split<={UPDATE_FREQ_CPLH>>1,descram_out[10]};UPDATE_FREQ_CPLD_split<={UPDATE_FREQ_CPLD>>1,descram_out[11]};UPDATE_TIMER_split<={UPDATE_TIMER>>1,descram_out[12]};vcneg_pend_split<={vcneg_pend>>1,descram_out[13]};ext_sync_bit_split<=descram_out[14];phy_l0_l0s_split<=descram_out[15];txdp_hpreq_split<=descram_out[16];txdp_lpreq_split<=descram_out[17];txdp_p_sent_split<={txdp_p_sent>>1,descram_out[18]};txdp_np_sent_split<={txdp_np_sent>>1,descram_out[19]};txdp_cpl_sent_split<={txdp_cpl_sent>>1,descram_out[20]};ph_buf_status_split<={ph_buf_status>>1,descram_out[21]};pd_buf_status_split<={pd_buf_status>>1,descram_out[22]};nph_buf_status_split<={nph_buf_status>>1,descram_out[23]};npd_buf_status_split<={npd_buf_status>>1,descram_out[24]};cplh_buf_status_split<={cplh_buf_status>>1,descram_out[25]};cpld_buf_status_split<={cpld_buf_status>>1,descram_out[26]};ph_processed_split<={ph_processed>>1,descram_out[27]};pd_processed_split<={pd_processed>>1,descram_out[28]};nph_processed_split<={nph_processed>>1,descram_out[29]};npd_processed_split<={npd_processed>>1,descram_out[30]};cplh_processed_split<={cplh_processed>>1,descram_out[31]};cpld_processed_split<={cpld_processed>>1,descram_out[32]};nph_processed_cfg_split<=descram_out[33];npd_processed_cfg_split<=descram_out[34];ph_processed_msg_split<=descram_out[35];pd_num_split<={pd_num>>1,descram_out[36]};npd_num_split<={npd_num>>1,descram_out[37]};cpld_num_split<={cpld_num>>1,descram_out[38]};p_pend_1a_split<={p_pend_1a>>1,descram_out[39]};np_pend_1a_split<={np_pend_1a>>1,descram_out[40]};cpl_pend_1a_split<={cpl_pend_1a>>1,descram_out[41]};p_pend_1bc_split<={p_pend_1bc>>1,descram_out[42]};np_pend_1bc_split<={np_pend_1bc>>1,descram_out[43]};cpl_pend_1bc_split<={cpl_pend_1bc>>1,descram_out[44]};p_pend_2_split<={p_pend_2>>1,descram_out[45]};np_pend_2_split<={np_pend_2>>1,descram_out[46]};cpl_pend_2_split<={cpl_pend_2>>1,descram_out[47]};arb_sent_p_split<={arb_sent_p>>1,descram_out[48]};arb_sent_np_split<={arb_sent_np>>1,descram_out[49]};arb_sent_cpl_split<={arb_sent_cpl>>1,descram_out[50]};send_update_split<=descram_out[51];update_timer_split<={update_timer>>1,descram_out[52]};fc_update_timer_split<={fc_update_timer>>1,descram_out[53]};nph_processed_cfg1_split<={nph_processed_cfg1>>1,descram_out[54]};npd_processed_cfg1_split<={npd_processed_cfg1>>1,descram_out[55]};ph_processed_msg1_split<={ph_processed_msg1>>1,descram_out[56]};overflow_allvc_split<={overflow_allvc>>1,descram_out[57]};end
always@* begin descram_in[2047]<=INIT_NPH_FC[0];descram_in[2046]<=INIT_CPLH_FC[0];descram_in[2044]<=INIT_PD_FC[0];descram_in[2041]<=INIT_NPD_FC[0];descram_in[2035]<=INIT_CPLD_FC[0];descram_in[2029]<=overflow_allvc[0];descram_in[2022]<=UPDATE_FREQ_PH[0];descram_in[1996]<=UPDATE_FREQ_PD[0];descram_in[1945]<=UPDATE_FREQ_NPH[0];descram_in[1943]<=arb_sent_np[0];descram_in[1922]<=cplh_buf_status[0];descram_in[1842]<=UPDATE_FREQ_NPD[0];descram_in[1839]<=arb_sent_cpl[0];descram_in[1797]<=cpld_buf_status[0];descram_in[1778]<=np_pend_2[0];descram_in[1776]<=pd_buf_status[0];descram_in[1637]<=UPDATE_FREQ_CPLH[0];descram_in[1631]<=send_update;descram_in[1622]<=ext_sync_bit;descram_in[1546]<=ph_processed[0];descram_in[1531]<=npd_processed_cfg1[0];descram_in[1509]<=cpl_pend_2[0];descram_in[1504]<=nph_buf_status[0];descram_in[1468]<=txdp_cpl_sent[0];descram_in[1391]<=txdp_p_sent[0];descram_in[1312]<=npd_processed_cfg;descram_in[1226]<=UPDATE_FREQ_CPLD[0];descram_in[1215]<=update_timer[0];descram_in[1197]<=phy_l0_l0s;descram_in[1153]<=pd_num[0];descram_in[1044]<=pd_processed[0];descram_in[1037]<=p_pend_1a[0];descram_in[1023]<=INIT_PH_FC[0];descram_in[1014]<=ph_processed_msg1[0];descram_in[971]<=arb_sent_p[0];descram_in[961]<=npd_buf_status[0];descram_in[889]<=p_pend_2[0];descram_in[888]<=ph_buf_status[0];descram_in[811]<=vcneg_pend[0];descram_in[765]<=nph_processed_cfg1[0];descram_in[734]<=txdp_np_sent[0];descram_in[695]<=txdp_lpreq;descram_in[656]<=nph_processed_cfg;descram_in[576]<=ph_processed_msg;descram_in[518]<=cpld_num[0];descram_in[444]<=cpl_pend_1bc[0];descram_in[405]<=UPDATE_TIMER[0];descram_in[382]<=fc_update_timer[0];descram_in[347]<=txdp_hpreq;descram_in[328]<=cpld_processed[0];descram_in[259]<=npd_num[0];descram_in[222]<=np_pend_1bc[0];descram_in[164]<=cplh_processed[0];descram_in[111]<=p_pend_1bc[0];descram_in[82]<=npd_processed[0];descram_in[55]<=cpl_pend_1a[0];descram_in[41]<=nph_processed[0];descram_in[27]<=np_pend_1a[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule

// =============================================================================


// Revision 1.6 2007/06/15 16:46:44PDT rperugu


// AER OverFlow check logic added.


// Revision 1.5 2007/06/01 11:39:41PDT rperugu


//


// Revision 1.4 2006/08/01 13:46:55PDT rperugu


//


// Revision 1.3 2006/07/30 16:49:42PDT rperugu


// Added _cfg signals for NP type.


// Revision 1.2 2006/06/27 17:14:42PDT rperugu


// All X1 flies copied (old ones are from SC X4).


// Revision 1.4 2006/04/04 15:53:51PDT srajadur


// txdp_p_sent kind of signals added for rxfc_vc ports


// Revision 1.3 2006/04/03 18:35:14PDT srajadur


// common counter for updateFC


// Revision 1.2 2006/03/20 10:36:07PST rperugu


// Added Outputs p/np/cpl_infi_credit from TRNC to DLL(txdp_ctrl).


// Revision 1.1 2006/02/02 14:35:33PST srajadur


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X1_11/PCI_EXP_X1_11.pj


// Revision 1.5 2005/04/13 12:08:44PDT uananthi


// updated UPDATE_TIMER width


// Revision 1.4 2005/04/07 11:53:00PDT uananthi


// updated RXFC parameters bus.


// Revision 1.3 2005/02/14 17:41:51PST rperugu


// AS_X4 modifications: Added Inputs - txdp_hpreq & txdp_lpreq.


// Revision 1.2 2004/06/28 17:47:41PDT rperugu


// `define VC4 removed & commneted code removed.


// Revision 1.1 2004/04/21 10:31:53PDT gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// Revision 1.3 2004/04/14 16:03:49PDT rperugu


//


// Revision 1.2 2004/04/08 15:47:11PDT rperugu


//


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_xx


// File             : txfc_vc.v


// Title            : TX Flow Control Block for One VC


// Dependencies     :


// Description      : This Block stored the Credit Limit, Credit Consumed Registers


//                    The CL registers are updated whenever there is a update


//                    DLLP received (initDLLP duirng init) from the other end.


//                    The Credit Availability is checked when TX wants to send a


//                    TLP and when it sends the CC registers are updated.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Rajakumar


// Mod. Date        : Mar 25, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module  txfc_vc(
   input wire                    sys_clk,      
   input wire                    rst_n,        
   
   input wire                    dl_inactive,   
   input wire [`NUM_VC-1:0]      vc_en,         
   input wire [`NUM_VC*3-1:0]    vcid,          
   input wire                    rxdp_ifc1_val, 
   input wire                    rxdp_ifc2_val, 
   input wire                    rxdp_ufc_val,  
   input wire [1:0]              rxdp_fcd_type, 
   input wire [2:0]              rxdp_fcd_vcid, 
   input wire [19:0]             rxdp_fcd_data, 


   input wire [`NUM_VC -1:0]     tx_st,         
   input wire [`NUM_VC -1:0]     tx_end,        
   input wire [`NUM_VC -1:0]     tx_nlfy,       
   `ifdef X4
      input wire [(`NUM_VC*64)-1:0] tx_data,    
      input wire                 txintf_val,    
   `endif
   `ifdef X1
      input wire [(`NUM_VC*16)-1:0] tx_data,    
   `endif

   input wire                    cfg_ph_cc,     
   input wire                    cfg_pd_cc,     
   input wire                    cfg_cplh_cc,   
   input wire                    cfg_cpld_cc,   

   output wire                   fc_protocol_err, 
   
   output reg [(`NUM_VC*9)-1:0]  tx_ca_ph,        
   output reg [(`NUM_VC*13)-1:0] tx_ca_pd,        
   output reg [(`NUM_VC*9)-1:0]  tx_ca_nph,       
   output reg [(`NUM_VC*13)-1:0] tx_ca_npd,       
   output reg [(`NUM_VC*9)-1:0]  tx_ca_cplh,      
   output reg [(`NUM_VC*13)-1:0] tx_ca_cpld       
   );
parameter PH    = 3'b000;
parameter NPH   = 3'b001;
parameter CPLH  = 3'b010;
parameter PD    = 3'b011;
parameter NPD   = 3'b100;
parameter CPLD  = 3'b101;
parameter P_TYPE   = 2'b00;
parameter NP_TYPE  = 2'b01;
parameter CPL_TYPE = 2'b10;
reg  [11:0]               cl_p_data;
reg  [7:0]                cl_p_hdr;
reg                       pd_infi;
reg                       ph_infi;
reg  [11:0]               cl_np_data;
reg  [7:0]                cl_np_hdr;
reg                       npd_infi;
reg                       nph_infi;
reg  [11:0]               cl_cpl_data;
reg  [7:0]                cl_cpl_hdr;
reg                       cpld_infi;
reg                       cplh_infi;
reg                       p_set;
reg                       np_set;
reg                       cpl_set;
reg  [11:0]               cc_p_data;
reg  [7:0]                cc_p_hdr;
reg  [11:0]               cc_np_data;
reg  [7:0]                cc_np_hdr;
reg  [11:0]               cc_cpl_data;
reg  [7:0]                cc_cpl_hdr;
reg                       pkt_start;
reg                       pkt_start_d1;
reg                       cfg_resp_hdr;
reg                       pkt_nlfy;
reg  [8:0]                length;
reg                       ph;
reg                       pd;
reg                       nph;
reg                       npd;
reg                       cplh;
reg                       cpld;
reg                       ph_d;
reg                       pd_d;
reg                       nph_d;
reg                       npd_d;
reg                       cplh_d;
reg                       cpld_d;
reg                       fc_protocol_err1;
reg                       fc_protocol_err2;
reg  [11:0]               sel_data;
reg  [7:0]                sel_hdr;
reg  [11:0]               data_diff;
reg  [7:0]                hdr_diff;
reg                       pd_val;
reg                       ph_val;
reg                       npd_val;
reg                       nph_val;
reg                       cpld_val;
reg                       cplh_val;

`ifdef X1
reg [1:0]              fmt;
reg [4:0]              pkt_type;

`endif

`ifdef X4
wire [1:0]             fmt;
wire [4:0]             pkt_type;

`endif
wire                      update_val;
wire                      ifc_val;
wire [11:0]               fc_data;
wire [7:0]                fc_hdr;
wire                      nonzero_hdr;
wire                      nonzero_data;
wire                      any_hdr_val;
wire                      any_data_val;

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif
reg dl_inactive_split;
reg [`NUM_VC - 1 : 0] vc_en_split;
reg [`NUM_VC * 3 - 1 : 0] vcid_split;
reg rxdp_ifc1_val_split;
reg rxdp_ifc2_val_split;
reg rxdp_ufc_val_split;
reg [1 : 0] rxdp_fcd_type_split;
reg [2 : 0] rxdp_fcd_vcid_split;
reg [19 : 0] rxdp_fcd_data_split;
reg [`NUM_VC - 1 : 0] tx_st_split;
reg [`NUM_VC - 1 : 0] tx_end_split;
reg [`NUM_VC - 1 : 0] tx_nlfy_split;
reg cfg_ph_cc_split;
reg cfg_pd_cc_split;
reg cfg_cplh_cc_split;
reg cfg_cpld_cc_split;
reg [11 : 0] cl_p_data_split;
reg [7 : 0] cl_p_hdr_split;
reg pd_infi_split;
reg ph_infi_split;
reg [11 : 0] cl_np_data_split;
reg [7 : 0] cl_np_hdr_split;
reg npd_infi_split;
reg nph_infi_split;
reg [11 : 0] cl_cpl_data_split;
reg [7 : 0] cl_cpl_hdr_split;
reg cpld_infi_split;
reg cplh_infi_split;
reg p_set_split;
reg np_set_split;
reg cpl_set_split;
reg [11 : 0] cc_p_data_split;
reg [7 : 0] cc_p_hdr_split;
reg [11 : 0] cc_np_data_split;
reg [7 : 0] cc_np_hdr_split;
reg [11 : 0] cc_cpl_data_split;
reg [7 : 0] cc_cpl_hdr_split;
reg pkt_start_split;
reg pkt_start_d1_split;
reg cfg_resp_hdr_split;
reg pkt_nlfy_split;
reg [8 : 0] length_split;
reg ph_split;
reg pd_split;
reg nph_split;
reg npd_split;
reg cplh_split;
reg cpld_split;
reg ph_d_split;
reg pd_d_split;
reg nph_d_split;
reg npd_d_split;
reg cplh_d_split;
reg cpld_d_split;
reg fc_protocol_err1_split;
reg fc_protocol_err2_split;
reg [11 : 0] sel_data_split;
reg [7 : 0] sel_hdr_split;
reg [11 : 0] data_diff_split;
reg [7 : 0] hdr_diff_split;
reg pd_val_split;
reg ph_val_split;
reg npd_val_split;
reg nph_val_split;
reg cpld_val_split;
reg cplh_val_split;
reg update_val_split;
reg ifc_val_split;
reg [11 : 0] fc_data_split;
reg [7 : 0] fc_hdr_split;
reg nonzero_hdr_split;
reg nonzero_data_split;
reg any_hdr_val_split;
reg any_data_val_split;
reg [2047:0] descram_in;
wire [73:0] descram_out;

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

localparam descram_inst_SIZE = 74,descram_inst_SCRAMSTRING = 32'hfdffc70b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X1


`endif



`ifdef X4


`endif


`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif

// =============================================================================
// Parameters
// =============================================================================
// =============================================================================
// ----- CREDIT LIMIT Registers
// ----- CREDIT CONSUMED Registers
// ----- TLP info. registers (for updating CREDIT CONSUMED)


`ifdef X1


   

`endif




`ifdef X4


   

`endif



//---- Wires
// ----- TLP info. wires (for updating CREDIT CONSUMED)
// =============================================================================
assign fc_protocol_err = fc_protocol_err1_split | fc_protocol_err2_split;

assign fc_data = rxdp_fcd_data_split[11:0];
assign fc_hdr  = rxdp_fcd_data_split[19:12];

// =============================================================================
// FCPE/Flow Control Protocol Error Generation
// 1. For infi. credis: Update FC value shouldn't non-zero
// 2. Shouldn't get cumultaively more than 2047/127 credits
// 3. Initial Min. Adv. value check
// =============================================================================

always @ (*) begin
   sel_data = 0;
   sel_hdr  = 0;
   case(rxdp_fcd_type_split)
      P_TYPE   : begin
         sel_data = cl_p_data_split;
         sel_hdr  = cl_p_hdr_split;
      end
      NP_TYPE  :  begin
         sel_data = cl_np_data_split;
         sel_hdr  = cl_np_hdr_split;
      end
      CPL_TYPE :  begin
         sel_data = cl_cpl_data_split;
         sel_hdr  = cl_cpl_hdr_split;
      end
   endcase
end

assign nonzero_hdr  = (fc_hdr_split != 0) ? 1'b1 : 1'b0;
assign nonzero_data = (fc_data_split != 0) ? 1'b1 : 1'b0;

assign any_data_val = pd_val_split | npd_val_split | cpld_val_split;
assign any_hdr_val  = ph_val_split | nph_val_split | cplh_val_split;

always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      fc_protocol_err1  <= 1'b0;
      fc_protocol_err2  <= 1'b0;
      data_diff         <= 0;
      hdr_diff          <= 0;
      pd_val            <= 1'b0;
      ph_val            <= 1'b0;
      npd_val           <= 1'b0;
      nph_val           <= 1'b0;
      cpld_val          <= 1'b0;
      cplh_val          <= 1'b0;
   end
   else begin
      fc_protocol_err1  <= 1'b0;
      fc_protocol_err2  <= 1'b0;
      pd_val            <= 1'b0;
      ph_val            <= 1'b0;
      npd_val           <= 1'b0;
      nph_val           <= 1'b0;
      cpld_val          <= 1'b0;
      cplh_val          <= 1'b0;

      //----- 1) Infinite credit check
      if(rxdp_fcd_vcid_split == vcid_split) begin
         case(rxdp_fcd_type_split)
            P_TYPE : begin
               if(rxdp_ufc_val_split && p_set_split) begin
                  pd_val <= !pd_infi_split;
                  ph_val <= !ph_infi_split;
                  if((pd_infi_split && nonzero_data_split) || (ph_infi_split && nonzero_hdr_split))
                     fc_protocol_err1  <= 1'b1;
               end
            end
            NP_TYPE : begin
               if(rxdp_ufc_val_split && np_set_split) begin
                  npd_val <= !npd_infi_split;
                  nph_val <= !nph_infi_split;
                  if((npd_infi_split && nonzero_data_split) || (nph_infi_split && nonzero_hdr_split))
                     fc_protocol_err1  <= 1'b1;
               end
            end
            CPL_TYPE : begin
               if(rxdp_ufc_val_split && cpl_set_split) begin
                  cpld_val <= !cpld_infi_split;
                  cplh_val <= !cplh_infi_split;
                  if((cpld_infi_split && nonzero_data_split) || (cplh_infi_split && nonzero_hdr_split))
                     fc_protocol_err1  <= 1'b1;
               end
            end
         endcase
      end

      //----- 2) Cumulative credit check
      data_diff <= fc_data_split - sel_data_split;
      hdr_diff  <= fc_hdr_split  - sel_hdr_split;
      if(((data_diff_split > 2047) && any_data_val_split) || ((hdr_diff_split > 127) && any_hdr_val_split))
         fc_protocol_err2  <= 1'b1;
      else
         fc_protocol_err2  <= 1'b0;
   end
end


// =============================================================================
// CREDIT LIMIT REGISTERS
// =============================================================================
// Update of Credit Limit Registers
// These registers inidcate total no. of Credits made available by the otherside
// RX since Flow Control Initialization
// Generating Credit Infinite Signals
// =============================================================================
assign update_val  = rxdp_ifc1_val_split | rxdp_ifc2_val_split | rxdp_ufc_val_split;
assign ifc_val     = rxdp_ifc1_val_split | rxdp_ifc2_val_split;

always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      cl_p_data      <= 12'h000;
      cl_p_hdr       <= 8'h00;
      cl_np_data     <= 12'h000;
      cl_np_hdr      <= 8'h00;
      cl_cpl_data    <= 12'h000;
      cl_cpl_hdr     <= 8'h00;
      pd_infi        <= 1'b0;
      ph_infi        <= 1'b0;
      npd_infi       <= 1'b0;
      nph_infi       <= 1'b0;
      cpld_infi      <= 1'b0;
      cplh_infi      <= 1'b0;
      p_set          <= 1'b0;
      np_set         <= 1'b0;
      cpl_set        <= 1'b0;
   end
   else begin
      // 8th bit for Header & 12th bit for DATA in CA registers
      // indicates INFINITE/Finite Credits to the User
      // When this bit is set User should ignore the reset of the bits
      // Also all these CA credits are valid ONLY after dl_up is assserted
      // for that particular VC
      if(rxdp_fcd_vcid_split == vcid_split) begin
         case(rxdp_fcd_type_split)
            P_TYPE : begin
               if(update_val_split) begin
                  cl_p_data    <= fc_data_split;
                  cl_p_hdr     <= fc_hdr_split;
               end
               if(ifc_val_split) begin
                  if(p_set_split == 1'b0) begin
                     pd_infi      <= (nonzero_data_split) ? 1'b0 : 1'b1;
                     ph_infi      <= (nonzero_hdr_split) ? 1'b0 : 1'b1;
                  end
               end
            end
            NP_TYPE : begin
               if(update_val_split) begin
                  cl_np_data   <= fc_data_split;
                  cl_np_hdr    <= fc_hdr_split;
               end
               if(ifc_val_split) begin
                  if(np_set_split == 1'b0) begin
                     npd_infi     <= (nonzero_data_split) ? 1'b0 : 1'b1;
                     nph_infi     <= (nonzero_hdr_split) ? 1'b0 : 1'b1;
                  end
               end
            end
            CPL_TYPE : begin
               if(update_val_split) begin
                  cl_cpl_data  <= fc_data_split;
                  cl_cpl_hdr   <= fc_hdr_split;
               end
               if(ifc_val_split) begin
                  if(cpl_set_split == 1'b0) begin
                     cpld_infi    <= (nonzero_data_split) ? 1'b0 : 1'b1;
                     cplh_infi    <= (nonzero_hdr_split) ? 1'b0 : 1'b1;
                  end
               end
            end
         endcase
      end

      // For infinite credits latch them ONLY first time & then afterwards
      // Ignore any Update/Init DLLPs.
      // Reset the flags when VC is diabled OR when DL starts again FCI
      if(dl_inactive_split || !vc_en_split) begin
         p_set   <= 1'b0;
         np_set  <= 1'b0;
         cpl_set <= 1'b0;
      end
      else if((rxdp_fcd_vcid_split == vcid_split) && ifc_val_split) begin
         case(rxdp_fcd_type_split)
            P_TYPE   : p_set   <= 1'b1;
            NP_TYPE  : np_set  <= 1'b1;
            CPL_TYPE : cpl_set <= 1'b1;
         endcase
      end
   end
end


// =============================================================================
// CREDIT CONSUMED REGISTERS
// =============================================================================
// User is sending A TLP: Latch the info.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      pkt_start     <= 1'b0;
      pkt_nlfy      <= 1'b0;
      pkt_start_d1  <= 1'b0;
      cfg_resp_hdr  <= 1'b0;
   end
   else begin
   

`ifdef X1


      pkt_start     <= tx_st_split;
      pkt_nlfy      <= tx_nlfy_split;
      pkt_start_d1  <= pkt_start_split | cfg_cplh_cc_split | cfg_ph_cc_split;
      cfg_resp_hdr  <= cfg_cplh_cc_split | cfg_ph_cc_split;
   

`endif


   

`ifdef X4


      pkt_start     <= (tx_st_split | cfg_cplh_cc_split | cfg_ph_cc_split)  & txintf_val;
      pkt_nlfy      <= tx_nlfy_split & txintf_val;
      pkt_start_d1  <= pkt_start_split;
      if(txintf_val)
         cfg_resp_hdr <= cfg_cplh_cc_split | cfg_ph_cc_split;
   

`endif


   end
end

// =============================================================================
// Decode for all type of TLP
// Generate decodes for PH, PD, NPH, NPD, CPL & CPLD based on TLP type decodes
// and hold it till the end of the TLP.
// For FMT & TYPE encoding Refer Page No. 47 in Spec
// pd   = (mem_wr | msg_d);
// ph   = (mem_wr | msg | msg_d);
// npd  = (cfg_wr | io_wr);
// nph  = (mem_rd | io_rd | io_wr | cfg_wr | cfg_rd);
// cplh = (cpl | cpl_d);
// cpld =  cpl_d;
// =============================================================================


`ifdef X1


always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      fmt   <= 2'b00;
      pkt_type <= 5'b00000;
   end
   else if (tx_st_split) begin
      fmt   <= tx_data[14:13];
      pkt_type <= tx_data[12:8];
   end
end


`endif




`ifdef X4


   assign fmt      = tx_data[62:61];
   assign pkt_type = tx_data[60:56];


`endif



always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      ph     <= 1'b0 ;
      pd     <= 1'b0 ;
      nph    <= 1'b0 ;
      npd    <= 1'b0 ;
      cplh   <= 1'b0;
      cpld   <= 1'b0;
      length <= 9'h000;
      ph_d   <= 1'b0 ;
      pd_d   <= 1'b0 ;
      nph_d  <= 1'b0 ;
      npd_d  <= 1'b0 ;
      cplh_d <= 1'b0;
      cpld_d <= 1'b0;
   end
   else begin
      //Conversion to Credit units & Rounding up
      // length is in DWORDS & Credit Unit is 4 DWORDS
   

`ifdef X1


      if(cfg_cpld_cc_split || cfg_pd_cc_split)
         length <= 9'h001;
      else if(pkt_start_split) begin
         if(tx_data[1:0] == 2'b00)   //length field (10bits) --> tx_data[9:0]
            length <= {(~(|tx_data[9:2])), tx_data[9:2]};
         else  //Round up
            length <= tx_data[9:2] + 1;
      end
   

`endif


   

`ifdef X4


      if((cfg_cpld_cc_split || cfg_pd_cc_split) & txintf_val)
         length <= 9'h001;
      else if(tx_st_split & txintf_val) begin
         if(tx_data[33:32] == 2'b00)   //length field (10bits) --> tx_data[41:32]
            length <= {(~(|tx_data[41:34])), tx_data[41:34]};
         else  //Round up
            length <= tx_data[41:34] + 1;
      end
   

`endif



   

`ifdef X1


      if(cfg_cplh_cc_split || cfg_ph_cc_split) begin
         if(cfg_cplh_cc_split) begin  //cfg resp pkt
            if(!cplh_infi_split) cplh <= 1'b1;
            if(!cpld_infi_split) cpld <= cfg_cpld_cc_split;
         end
         else begin  //MSI/INT/ERR pkt
            if(!ph_infi_split) ph <= 1'b1;
            if(!pd_infi_split) pd <= cfg_pd_cc_split;
         end
      end
      else if(pkt_start_split) begin
         if(!pd_infi_split)   pd   <= (((pkt_type[4:3] == 2'b10) || (pkt_type[2:0] == 3'b000)) && fmt[1]) ? 1'b1 : 1'b0;
         if(!ph_infi_split)   ph   <= ((pkt_type[4:3] == 2'b10) || ((pkt_type[2:0] == 3'b000) && fmt[1])) ? 1'b1 : 1'b0;
         if(!npd_infi_split)  npd  <= ((pkt_type[4:3] == 2'b00) && fmt[1] && (pkt_type[2:0] != 3'b000)) ? 1'b1 : 1'b0;
         if(!nph_infi_split)  nph  <= ((pkt_type[4:3] == 2'b00) && !((pkt_type[2:0] == 3'b000) && fmt[1])) ? 1'b1 : 1'b0;
         if(!cplh_infi_split) cplh <= (pkt_type == 5'b0_1010) ? 1'b1 : 1'b0;
         if(!cpld_infi_split) cpld <= ((pkt_type == 5'b0_1010) && fmt[1]) ? 1'b1 : 1'b0;
      end
      else if (tx_end_split || tx_nlfy_split || cfg_resp_hdr_split) begin
         ph   <= 1'b0; pd   <= 1'b0;
         nph  <= 1'b0; npd  <= 1'b0;
         cplh <= 1'b0; cpld <= 1'b0;
      end
   

`endif


   

`ifdef X4


      if((cfg_cplh_cc_split || cfg_ph_cc_split) & txintf_val) begin
         if(cfg_cplh_cc_split) begin  //cfg resp pkt
            if(!cplh_infi_split) cplh <= 1'b1;
            if(!cpld_infi_split) cpld <= cfg_cpld_cc_split;
         end
         else begin  //MSI/INT/ERR pkt
            if(!ph_infi_split) ph <= 1'b1;
            if(!pd_infi_split) pd <= cfg_pd_cc_split;
         end
      end
      else if(tx_st_split & txintf_val) begin
         if(!pd_infi_split)   pd   <= (((pkt_type[4:3] == 2'b10) || (pkt_type[2:0] == 3'b000)) && fmt[1]) ? 1'b1 : 1'b0;
         if(!ph_infi_split)   ph   <= ((pkt_type[4:3] == 2'b10) || ((pkt_type[2:0] == 3'b000) && fmt[1])) ? 1'b1 : 1'b0;
         if(!npd_infi_split)  npd  <= ((pkt_type[4:3] == 2'b00) && fmt[1] && (pkt_type[2:0] != 3'b000)) ? 1'b1 : 1'b0;
         if(!nph_infi_split)  nph  <= ((pkt_type[4:3] == 2'b00) && !((pkt_type[2:0] == 3'b000) && fmt[1])) ? 1'b1 : 1'b0;
         if(!cplh_infi_split) cplh <= (pkt_type == 5'b0_1010) ? 1'b1 : 1'b0;
         if(!cpld_infi_split) cpld <= ((pkt_type == 5'b0_1010) && fmt[1]) ? 1'b1 : 1'b0;
      end
      else if ((tx_end_split || tx_nlfy_split || cfg_resp_hdr_split) & txintf_val) begin
         ph   <= 1'b0; pd   <= 1'b0;
         nph  <= 1'b0; npd  <= 1'b0;
         cplh <= 1'b0; cpld <= 1'b0;
      end
   

`endif



      ph_d   <= ph_split;
      pd_d   <= pd_split;
      nph_d  <= nph_split;
      npd_d  <= npd_split;
      cplh_d <= cplh_split;
      cpld_d <= cpld_split;
   end
end

// =============================================================================
// Updating Credit Consumed Registers based on TLP type
// CC registers are updated when TLP is sent
// Header credit is inremented by 1
// Data credit is inremented by length (except NPD hdr - 1 credit)
// =============================================================================


`ifdef X1


   assign updt_ccr = pkt_start_d1_split ;


`endif




`ifdef X4


   assign updt_ccr = pkt_start_split ;


`endif


always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      cc_p_hdr    <= 8'h00;
      cc_np_hdr   <= 8'h00;
      cc_cpl_hdr  <= 8'h00;
      cc_p_data   <= 12'h000;
      cc_cpl_data <= 12'h000;
      cc_np_data  <= 12'h000;
   end
   else begin
      if(dl_inactive_split || !vc_en_split) begin
         cc_p_hdr    <= 8'h00;
         cc_np_hdr   <= 8'h00;
         cc_cpl_hdr  <= 8'h00;
         cc_p_data   <= 12'h000;
         cc_cpl_data <= 12'h000;
         cc_np_data  <= 12'h000;
      end
      else if(updt_ccr) begin
         cc_p_hdr   <= (ph_split) ? (cc_p_hdr_split + 1'b1) : cc_p_hdr_split;
         cc_np_hdr  <= (nph_split) ? (cc_np_hdr_split + 1'b1) : cc_np_hdr_split;
         cc_cpl_hdr <= (cplh_split) ? (cc_cpl_hdr_split + 1'b1) : cc_cpl_hdr_split;

         cc_p_data   <= (pd_split) ? (cc_p_data_split + length_split) : cc_p_data_split;
         cc_np_data  <= (npd_split) ? (cc_np_data_split + 1'b1) : cc_np_data_split;
         cc_cpl_data <= (cpld_split) ? (cc_cpl_data_split + length_split) : cc_cpl_data_split;
      end
      else if(pkt_nlfy_split) begin
         cc_p_hdr   <= (ph_d_split) ? (cc_p_hdr_split - 1'b1) : cc_p_hdr_split;
         cc_np_hdr  <= (nph_d_split) ? (cc_np_hdr_split - 1'b1) : cc_np_hdr_split;
         cc_cpl_hdr <= (cplh_d_split) ? (cc_cpl_hdr_split - 1'b1) : cc_cpl_hdr_split;

         cc_p_data   <= (pd_d_split) ? (cc_p_data_split - length_split) : cc_p_data_split;
         cc_np_data  <= (npd_d_split) ? (cc_np_data_split - 1'b1) : cc_np_data_split;
         cc_cpl_data <= (cpld_d_split) ? (cc_cpl_data_split - length_split) : cc_cpl_data_split;
      end
   end
end

// =============================================================================
// CREDIT AVAILABLE REGISTERS
// Credit Available = Credit Limit - Credit Consumed
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      tx_ca_ph    <= 9'h00;
      tx_ca_nph   <= 9'h00;
      tx_ca_cplh  <= 9'h00;
      tx_ca_pd    <= 13'h000;
      tx_ca_npd   <= 13'h000;
      tx_ca_cpld  <= 13'h000;
   end
   else begin
      tx_ca_ph[7:0]    <= cl_p_hdr_split - cc_p_hdr_split;
      tx_ca_nph[7:0]   <= cl_np_hdr_split - cc_np_hdr_split;
      tx_ca_cplh[7:0]  <= cl_cpl_hdr_split - cc_cpl_hdr_split;

      tx_ca_pd[11:0]   <= cl_p_data_split - cc_p_data_split;
      tx_ca_npd[11:0]  <= cl_np_data_split - cc_np_data_split;
      tx_ca_cpld[11:0] <= cl_cpl_data_split - cc_cpl_data_split;

      //The MSB indicates the infinite Credit
      tx_ca_ph[8]      <= ph_infi_split;
      tx_ca_nph[8]     <= nph_infi_split;
      tx_ca_cplh[8]    <= cplh_infi_split;

      tx_ca_pd[12]     <= pd_infi_split;
      tx_ca_npd[12]    <= npd_infi_split;
      tx_ca_cpld[12]   <= cpld_infi_split;
   end
end

always@* begin dl_inactive_split<=descram_out[0];vc_en_split<={vc_en>>1,descram_out[1]};vcid_split<={vcid>>1,descram_out[2]};rxdp_ifc1_val_split<=descram_out[3];rxdp_ifc2_val_split<=descram_out[4];rxdp_ufc_val_split<=descram_out[5];rxdp_fcd_type_split<={rxdp_fcd_type>>1,descram_out[6]};rxdp_fcd_vcid_split<={rxdp_fcd_vcid>>1,descram_out[7]};rxdp_fcd_data_split<={rxdp_fcd_data>>1,descram_out[8]};tx_st_split<={tx_st>>1,descram_out[9]};tx_end_split<={tx_end>>1,descram_out[10]};tx_nlfy_split<={tx_nlfy>>1,descram_out[11]};cfg_ph_cc_split<=descram_out[12];cfg_pd_cc_split<=descram_out[13];cfg_cplh_cc_split<=descram_out[14];cfg_cpld_cc_split<=descram_out[15];cl_p_data_split<={cl_p_data>>1,descram_out[16]};cl_p_hdr_split<={cl_p_hdr>>1,descram_out[17]};pd_infi_split<=descram_out[18];ph_infi_split<=descram_out[19];cl_np_data_split<={cl_np_data>>1,descram_out[20]};cl_np_hdr_split<={cl_np_hdr>>1,descram_out[21]};npd_infi_split<=descram_out[22];nph_infi_split<=descram_out[23];cl_cpl_data_split<={cl_cpl_data>>1,descram_out[24]};cl_cpl_hdr_split<={cl_cpl_hdr>>1,descram_out[25]};cpld_infi_split<=descram_out[26];cplh_infi_split<=descram_out[27];p_set_split<=descram_out[28];np_set_split<=descram_out[29];cpl_set_split<=descram_out[30];cc_p_data_split<={cc_p_data>>1,descram_out[31]};cc_p_hdr_split<={cc_p_hdr>>1,descram_out[32]};cc_np_data_split<={cc_np_data>>1,descram_out[33]};cc_np_hdr_split<={cc_np_hdr>>1,descram_out[34]};cc_cpl_data_split<={cc_cpl_data>>1,descram_out[35]};cc_cpl_hdr_split<={cc_cpl_hdr>>1,descram_out[36]};pkt_start_split<=descram_out[37];pkt_start_d1_split<=descram_out[38];cfg_resp_hdr_split<=descram_out[39];pkt_nlfy_split<=descram_out[40];length_split<={length>>1,descram_out[41]};ph_split<=descram_out[42];pd_split<=descram_out[43];nph_split<=descram_out[44];npd_split<=descram_out[45];cplh_split<=descram_out[46];cpld_split<=descram_out[47];ph_d_split<=descram_out[48];pd_d_split<=descram_out[49];nph_d_split<=descram_out[50];npd_d_split<=descram_out[51];cplh_d_split<=descram_out[52];cpld_d_split<=descram_out[53];fc_protocol_err1_split<=descram_out[54];fc_protocol_err2_split<=descram_out[55];sel_data_split<={sel_data>>1,descram_out[56]};sel_hdr_split<={sel_hdr>>1,descram_out[57]};data_diff_split<={data_diff>>1,descram_out[58]};hdr_diff_split<={hdr_diff>>1,descram_out[59]};pd_val_split<=descram_out[60];ph_val_split<=descram_out[61];npd_val_split<=descram_out[62];nph_val_split<=descram_out[63];cpld_val_split<=descram_out[64];cplh_val_split<=descram_out[65];update_val_split<=descram_out[66];ifc_val_split<=descram_out[67];fc_data_split<={fc_data>>1,descram_out[68]};fc_hdr_split<={fc_hdr>>1,descram_out[69]};nonzero_hdr_split<=descram_out[70];nonzero_data_split<=descram_out[71];any_hdr_val_split<=descram_out[72];any_data_val_split<=descram_out[73];end
always@* begin descram_in[2047]<=vc_en[0];descram_in[2046]<=vcid[0];descram_in[2044]<=rxdp_ifc1_val;descram_in[2040]<=rxdp_ifc2_val;descram_in[2032]<=rxdp_ufc_val;descram_in[2016]<=rxdp_fcd_type[0];descram_in[2014]<=nonzero_hdr;descram_in[1985]<=rxdp_fcd_vcid[0];descram_in[1981]<=nonzero_data;descram_in[1927]<=npd_val;descram_in[1922]<=rxdp_fcd_data[0];descram_in[1915]<=any_hdr_val;descram_in[1867]<=ph_infi;descram_in[1807]<=nph_val;descram_in[1804]<=cpld;descram_in[1797]<=tx_st[0];descram_in[1782]<=any_data_val;descram_in[1761]<=nph;descram_in[1686]<=cl_np_data[0];descram_in[1623]<=fc_protocol_err1;descram_in[1567]<=cpld_val;descram_in[1561]<=ph_d;descram_in[1558]<=p_set;descram_in[1547]<=tx_end[0];descram_in[1542]<=cc_cpl_hdr[0];descram_in[1505]<=pd_val;descram_in[1490]<=cl_p_hdr[0];descram_in[1475]<=npd;descram_in[1413]<=cpld_infi;descram_in[1409]<=cc_np_hdr[0];descram_in[1400]<=data_diff[0];descram_in[1324]<=cl_np_hdr[0];descram_in[1200]<=nph_infi;descram_in[1199]<=fc_protocol_err2;descram_in[1086]<=cplh_val;descram_in[1074]<=pd_d;descram_in[1068]<=np_set;descram_in[1047]<=tx_nlfy[0];descram_in[1037]<=pkt_start;descram_in[1023]<=dl_inactive;descram_in[1007]<=fc_hdr[0];descram_in[963]<=ph_val;descram_in[933]<=pd_infi;descram_in[902]<=cplh;descram_in[880]<=pd;descram_in[811]<=cpld_d;descram_in[779]<=cplh_infi;descram_in[771]<=cc_cpl_data[0];descram_in[752]<=hdr_diff[0];descram_in[745]<=cl_p_data[0];descram_in[706]<=cl_cpl_hdr[0];descram_in[704]<=cc_np_data[0];descram_in[700]<=sel_hdr[0];descram_in[600]<=npd_infi;descram_in[503]<=fc_data[0];descram_in[440]<=ph;descram_in[405]<=cplh_d;descram_in[372]<=cfg_cpld_cc;descram_in[353]<=cl_cpl_data[0];descram_in[352]<=cc_p_hdr[0];descram_in[350]<=sel_data[0];descram_in[251]<=ifc_val;descram_in[220]<=length[0];descram_in[202]<=npd_d;descram_in[186]<=cfg_cplh_cc;descram_in[176]<=cc_p_data[0];descram_in[125]<=update_val;descram_in[110]<=pkt_nlfy;descram_in[101]<=nph_d;descram_in[93]<=cfg_pd_cc;descram_in[88]<=cpl_set;descram_in[55]<=cfg_resp_hdr;descram_in[46]<=cfg_ph_cc;descram_in[27]<=pkt_start_d1;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule

// =============================================================================


// Revision 1.6 2007/06/01 11:39:59PDT rperugu


//


// Revision 1.5 2007/05/18 12:09:09PDT rperugu


// Added fc_protocol_err output.


// Revision 1.4 2007/02/06 13:54:31PST rperugu


// cfg_resp_hdr is assigned only when txintf_val is HIGH.


// Revision 1.3 2007/02/03 19:48:04PST rperugu


// Corrected downgrade mode logic :  cfg_cplh_cc signals are ANDed with txintf_val.


// Revision 1.2 2006/11/22 12:58:33PST uananthi


// added cfg_cplh_cc/cfg_cpld_cc connection and logic.


// Revision 1.1 2006/04/19 14:10:48PDT gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4_11/PCI_EXP_X4_11.pj


// Revision 1.7 2004/08/02 11:27:47PDT gkrishna


// Added txintf_val


// Revision 1.6 2004/06/16 18:22:00PDT rperugu


// ph_d, pd_d etc are added for nullify case.


// Revision 1.5 2004/06/11 13:51:42PDT rperugu


// Rounded the length field.


// Revision 1.4 2004/06/10 11:00:46PDT rperugu


// length latching is corrected.


// Revision 1.3 2004/06/09 11:56:05PDT rperugu


// 1) tx_ca_*[8]/[12] are added to indicate the infi. credits.


// 2) rx_us_req, rx_pois_tlp signals are removed from RX user interface.


// Revision 1.2 2004/06/09 11:11:10PDT rperugu


// tx_ca_* outputs width is increased by one for infi. credit indication.


//


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_x4


// File             : txfc.v


// Title            : TX Flow Control Block


// Dependencies     :


// Description      : This Block stored the Credit Limit, Credit Consumed Registers


//                    The CL registers are updated whenever there is a update


//                    DLLP received (initDLLP duirng init) from the other end.


//                    The Credit Availability is checked when TX wants to send a


//                    TLP and when it sends the CC registers are updated.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Rajakumar


// Mod. Date        : Mar 25, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module  txfc(
   input wire                    sys_clk,      
   input wire                    rst_n,        
   
   input wire                    dl_inactive,   
   input wire [`NUM_VC-1:0]      vc_en,         
   input wire [`NUM_VC*3-1:0]    vcid,          
   input wire                    rxdp_ifc1_val, 
   input wire                    rxdp_ifc2_val, 
   input wire                    rxdp_ufc_val,  
   input wire [1:0]              rxdp_fcd_type, 
   input wire [2:0]              rxdp_fcd_vcid, 
   input wire [19:0]             rxdp_fcd_data, 
   input wire                    cfg_ph_cc,     
   input wire                    cfg_pd_cc,     
   input wire                    cfg_cplh_cc,   
   input wire                    cfg_cpld_cc,   

   input wire [`NUM_VC -1:0]     tx_st,         
   input wire [`NUM_VC -1:0]     tx_end,        
   input wire [`NUM_VC -1:0]     tx_nlfy,       
   `ifdef X4
      input wire [(`NUM_VC*64)-1:0] tx_data,    
      input wire                 txintf_val,    
   `endif
   `ifdef X1
      input wire [(`NUM_VC*16)-1:0] tx_data,    
   `endif

   output reg                     fc_protocol_err, 
   
   output wire [(`NUM_VC*9)-1:0]  tx_ca_ph,        
   output wire [(`NUM_VC*13)-1:0] tx_ca_pd,        
   output wire [(`NUM_VC*9)-1:0]  tx_ca_nph,       
   output wire [(`NUM_VC*13)-1:0] tx_ca_npd,       
   output wire [(`NUM_VC*9)-1:0]  tx_ca_cplh,      
   output wire [(`NUM_VC*13)-1:0] tx_ca_cpld       

   );
reg  [`NUM_VC -1:0]           cfg_ph_allvc;
reg  [`NUM_VC -1:0]           cfg_pd_allvc;
reg  [`NUM_VC -1:0]           cfg_cplh_allvc;
reg  [`NUM_VC -1:0]           cfg_cpld_allvc;
wire   [`NUM_VC -1:0]         fc_err;

`ifdef X4

`endif
reg dl_inactive_split;
reg [`NUM_VC - 1 : 0] vc_en_split;
reg [`NUM_VC * 3 - 1 : 0] vcid_split;
reg rxdp_ifc1_val_split;
reg rxdp_ifc2_val_split;
reg rxdp_ufc_val_split;
reg [1 : 0] rxdp_fcd_type_split;
reg [2 : 0] rxdp_fcd_vcid_split;
reg [19 : 0] rxdp_fcd_data_split;
reg cfg_ph_cc_split;
reg cfg_pd_cc_split;
reg cfg_cplh_cc_split;
reg cfg_cpld_cc_split;
reg [`NUM_VC - 1 : 0] tx_st_split;
reg [`NUM_VC - 1 : 0] tx_end_split;
reg [`NUM_VC - 1 : 0] tx_nlfy_split;
reg [`NUM_VC - 1 : 0] cfg_pd_allvc_split;
reg [`NUM_VC - 1 : 0] cfg_cplh_allvc_split;
reg [`NUM_VC - 1 : 0] cfg_cpld_allvc_split;
reg [`NUM_VC - 1 : 0] fc_err_split;
reg [2047:0] descram_in;
wire [19:0] descram_out;


`ifdef X4

`endif

localparam descram_inst_SIZE = 20,descram_inst_SCRAMSTRING = 32'hfdffca4b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X4



`endif

// =============================================================================
//---- Registers
//---- Wires
// =============================================================================
always@(*) begin
   cfg_ph_allvc   = 0;
   cfg_pd_allvc   = 0;
   cfg_cplh_allvc = 0;
   cfg_cpld_allvc = 0;
   cfg_ph_allvc[0]   = cfg_ph_cc_split;   //VC0 ??
   cfg_pd_allvc[0]   = cfg_pd_cc_split;
   cfg_cplh_allvc[0] = cfg_cplh_cc_split;
   cfg_cpld_allvc[0] = cfg_cpld_cc_split;
end

always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      fc_protocol_err <= 1'b0;
   end
   else begin
      fc_protocol_err <= |fc_err_split;
   end
end

// =============================================================================
// TXFC Instantiations for each VC
// =============================================================================

txfc_vc u1_txfc_vc [`NUM_VC -1:0] (
     //---------Inputs-------------
    .sys_clk         (sys_clk),
    .rst_n           (rst_n),

    .dl_inactive     (dl_inactive_split),
    .vc_en           (vc_en_split),
    .vcid            (vcid_split),

    .rxdp_ifc1_val   (rxdp_ifc1_val_split),
    .rxdp_ifc2_val   (rxdp_ifc2_val_split),
    .rxdp_ufc_val    (rxdp_ufc_val_split),
    .rxdp_fcd_type   (rxdp_fcd_type_split),
    .rxdp_fcd_vcid   (rxdp_fcd_vcid_split),
    .rxdp_fcd_data   (rxdp_fcd_data_split),
    .cfg_ph_cc       (cfg_ph_allvc),
    .cfg_pd_cc       (cfg_pd_allvc_split),
    .cfg_cplh_cc     (cfg_cplh_allvc_split),
    .cfg_cpld_cc     (cfg_cpld_allvc_split),

    .tx_st           (tx_st_split),
    .tx_end          (tx_end_split),
    .tx_nlfy         (tx_nlfy_split),
    .tx_data         (tx_data),
    

`ifdef X4


       .txintf_val   (txintf_val),
    

`endif



    //------- Outputs
    .fc_protocol_err (fc_err),
    .tx_ca_ph        (tx_ca_ph),
    .tx_ca_pd        (tx_ca_pd),
    .tx_ca_nph       (tx_ca_nph),
    .tx_ca_npd       (tx_ca_npd),
    .tx_ca_cplh      (tx_ca_cplh),
    .tx_ca_cpld      (tx_ca_cpld)

    );



always@* begin dl_inactive_split<=descram_out[0];vc_en_split<={vc_en>>1,descram_out[1]};vcid_split<={vcid>>1,descram_out[2]};rxdp_ifc1_val_split<=descram_out[3];rxdp_ifc2_val_split<=descram_out[4];rxdp_ufc_val_split<=descram_out[5];rxdp_fcd_type_split<={rxdp_fcd_type>>1,descram_out[6]};rxdp_fcd_vcid_split<={rxdp_fcd_vcid>>1,descram_out[7]};rxdp_fcd_data_split<={rxdp_fcd_data>>1,descram_out[8]};cfg_ph_cc_split<=descram_out[9];cfg_pd_cc_split<=descram_out[10];cfg_cplh_cc_split<=descram_out[11];cfg_cpld_cc_split<=descram_out[12];tx_st_split<={tx_st>>1,descram_out[13]};tx_end_split<={tx_end>>1,descram_out[14]};tx_nlfy_split<={tx_nlfy>>1,descram_out[15]};cfg_pd_allvc_split<={cfg_pd_allvc>>1,descram_out[16]};cfg_cplh_allvc_split<={cfg_cplh_allvc>>1,descram_out[17]};cfg_cpld_allvc_split<={cfg_cpld_allvc>>1,descram_out[18]};fc_err_split<={fc_err>>1,descram_out[19]};end
always@* begin descram_in[2047]<=vc_en[0];descram_in[2046]<=vcid[0];descram_in[2044]<=rxdp_ifc1_val;descram_in[2040]<=rxdp_ifc2_val;descram_in[2033]<=rxdp_ufc_val;descram_in[2019]<=rxdp_fcd_type[0];descram_in[2011]<=tx_nlfy[0];descram_in[1991]<=rxdp_fcd_vcid[0];descram_in[1974]<=cfg_pd_allvc[0];descram_in[1935]<=rxdp_fcd_data[0];descram_in[1900]<=cfg_cplh_allvc[0];descram_in[1823]<=cfg_ph_cc;descram_in[1753]<=cfg_cpld_allvc[0];descram_in[1598]<=cfg_pd_cc;descram_in[1458]<=fc_err[0];descram_in[1149]<=cfg_cplh_cc;descram_in[1023]<=dl_inactive;descram_in[1005]<=tx_end[0];descram_in[502]<=tx_st[0];descram_in[251]<=cfg_cpld_cc;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule

// =============================================================================


// Revision 1.4 2007/06/01 11:39:58PDT rperugu


//


// Revision 1.3 2007/05/18 12:09:07PDT rperugu


// Added fc_protocol_err output.


// Revision 1.2 2006/11/22 12:58:31PST uananthi


// added cfg_cplh_cc/cfg_cpld_cc connection and logic.


// Revision 1.1 2006/04/19 14:10:47PDT gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4_11/PCI_EXP_X4_11.pj


// Revision 1.3 2004/08/02 11:27:24PDT gkrishna


// Added txintf_val


// Revision 1.2 2004/06/09 11:11:07PDT rperugu


// tx_ca_* outputs width is increased by one for infi. credit indication.


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS         


// Project          : pci_exp_x4


// File             : bar_chk.v


// Title            :  


// Dependencies     : 


// Description      : This module de-multiplex TLP traffic based on VC/TC maping,


//                    and provides it on RX User interface. 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Apr 28, 2004


// Changes Made     : Initial Creation


// =============================================================================




`timescale 1 ns / 100 ps
module bar_chk (
   
   input wire                sys_clk ,           
   input wire                rst_n ,             

   `ifdef EN_BAR0
   input wire [31:0]               bar0_reg , 
   input wire [31:0]               bar0_init , 
   `endif
   `ifdef EN_BAR1
   input wire [31:0]               bar1_reg , 
   input wire [31:0]               bar1_init , 
   `endif
   `ifdef EN_BAR2
   input wire [31:0]               bar2_reg , 
   input wire [31:0]               bar2_init , 
   `endif
   `ifdef EN_BAR3
   input wire [31:0]               bar3_reg , 
   input wire [31:0]               bar3_init , 
   `endif
   `ifdef EN_BAR4
   input wire [31:0]               bar4_reg , 
   input wire [31:0]               bar4_init , 
   `endif
   `ifdef EN_BAR5
   input wire [31:0]               bar5_reg , 
   input wire [31:0]               bar5_init , 
   `endif
   `ifdef EN_ER_BAR
   input wire [31:0]               er_bar_reg , 
   input wire [31:0]               er_bar_init ,  
   `endif

   `ifdef X4
      output wire [6:0]            bar_hit , 
      output wire                  bar_hit_val , 
   `endif
   `ifdef X1
      output reg [6:0]             bar_hit , 
      output wire                  bar_fail ,
   `endif

   
   input wire                   tlpdec_memrw ,
   input wire                   tlpdec_iorw ,
   input wire [31:0]            tlpdec_addr_l32 ,
   input wire [31:0]            tlpdec_addr_h32 ,
   input wire                   tlpdec_addr64 

   );
reg                   tlpdec_memrw_reg0 ;
reg                   tlpdec_iorw_reg0 ;
reg [6:0]             bar_hit_int2 ;
reg                   bar_hit_val_int2 ;
wire[6:0]             bar_hit_comb ;
wire                  bar_hit_val_comb ;
wire [31:0]           addr_low32 ;
wire [31:0]           addr_high32 ;
wire                  no_bar1 ;
wire                  no_bar3 ;
wire                  no_bar5 ;

`ifdef EN_BAR0
reg [3:0]   bar0_mask4 ;
reg         bar0_hit ;
wire        bar0_32mem ;
wire        bar0_64mem ;
wire        bar0_io ;
wire        bar0_dsb ;
wire        bar0_enb ;
wire [31:0] bar0_mask ;

`else
wire        bar0_hit ;

`endif

`ifdef EN_BAR1
reg [3:0]   bar1_mask4 ;
reg         bar1_hit ;
wire        bar1_32mem ;
wire        bar1_64mem ;
wire        bar1_io ;
wire        bar1_dsb ;
wire        bar1_enb ;
wire [31:0] bar1_mask ;

`else
wire        bar1_hit ;
wire [31:0] bar1_mask ;
wire [31:0] bar1_reg ;

`endif

`ifdef EN_BAR2
reg [3:0]   bar2_mask4 ;
reg         bar2_hit ;
wire        bar2_32mem ;
wire        bar2_64mem ;
wire        bar2_io ;
wire        bar2_dsb ;
wire        bar2_enb ;
wire [31:0] bar2_mask ;

`else
wire        bar2_hit ;

`endif

`ifdef EN_BAR3
reg [3:0]   bar3_mask4 ;
reg         bar3_hit ;
wire        bar3_32mem ;
wire        bar3_64mem ;
wire        bar3_io ;
wire        bar3_dsb ;
wire        bar3_enb ;
wire [31:0] bar3_mask ;

`else
wire        bar3_hit ;
wire [31:0] bar3_mask ;
wire [31:0] bar3_reg ;

`endif

`ifdef EN_BAR4
reg [3:0]   bar4_mask4 ;
reg         bar4_hit ;
wire        bar4_32mem ;
wire        bar4_64mem ;
wire        bar4_io ;
wire        bar4_dsb ;
wire        bar4_enb ;
wire [31:0] bar4_mask ;

`else
wire        bar4_hit ;

`endif

`ifdef EN_BAR5
reg [3:0]   bar5_mask4 ;
reg         bar5_hit ;
wire        bar5_32mem ;
wire        bar5_64mem ;
wire        bar5_io ;
wire        bar5_dsb ;
wire        bar5_enb ;
wire [31:0] bar5_mask ;

`else
wire        bar5_hit ;
wire [31:0] bar5_mask ;
wire [31:0] bar5_reg ;

`endif

`ifdef EN_ER_BAR
reg         er_bar_hit ;
wire [31:0] er_bar_mask ;
wire        er_bar_enb ;

`else
wire        er_bar_hit ;

`endif
wire        bar1_up32 ;
wire        bar3_up32 ;
wire        bar5_up32 ;

`ifdef EN_BAR1

`else

`endif

`ifdef EN_BAR3

`else

`endif

`ifdef EN_BAR5

`else

`endif

`ifdef EN_BAR0

`ifdef EN_BAR1

`else

`endif

`else

`endif

`ifdef EN_BAR1

`else

`endif

`ifdef EN_BAR2

`ifdef EN_BAR3

`else

`endif

`else

`endif

`ifdef EN_BAR3

`else

`endif

`ifdef EN_BAR4

`ifdef EN_BAR5

`else

`endif

`else

`endif

`ifdef EN_BAR5

`else

`endif

`ifdef EN_ER_BAR

`else

`endif

`ifdef X1
reg  bar_hit_val ;

`endif

`ifdef X4

`endif
reg tlpdec_memrw_split;
reg tlpdec_iorw_split;
reg [31 : 0] tlpdec_addr_l32_split;
reg [31 : 0] tlpdec_addr_h32_split;
reg tlpdec_addr64_split;
reg tlpdec_memrw_reg0_split;
reg tlpdec_iorw_reg0_split;
reg [6 : 0] bar_hit_int2_split;
reg bar_hit_val_int2_split;
reg [6 : 0] bar_hit_comb_split;
reg bar_hit_val_comb_split;
reg [31 : 0] addr_low32_split;
reg [31 : 0] addr_high32_split;
reg no_bar1_split;
reg no_bar3_split;
reg no_bar5_split;
reg bar1_up32_split;
reg bar3_up32_split;
reg bar5_up32_split;
reg [2047:0] descram_in;
wire [18:0] descram_out;

`ifdef EN_BAR0

`else

`endif

`ifdef EN_BAR1

`else

`endif

`ifdef EN_BAR2

`else

`endif

`ifdef EN_BAR3

`else

`endif

`ifdef EN_BAR4

`else

`endif

`ifdef EN_BAR5

`else

`endif

`ifdef EN_ER_BAR

`else

`endif

`ifdef EN_BAR1

`else

`endif

`ifdef EN_BAR3

`else

`endif

`ifdef EN_BAR5

`else

`endif

`ifdef EN_BAR0

`ifdef EN_BAR1

`else

`endif

`else

`endif

`ifdef EN_BAR1

`else

`endif

`ifdef EN_BAR2

`ifdef EN_BAR3

`else

`endif

`else

`endif

`ifdef EN_BAR3

`else

`endif

`ifdef EN_BAR4

`ifdef EN_BAR5

`else

`endif

`else

`endif

`ifdef EN_BAR5

`else

`endif

`ifdef EN_ER_BAR

`else

`endif

`ifdef X1

`endif

`ifdef X4

`endif

localparam descram_inst_SIZE = 19,descram_inst_SCRAMSTRING = 32'hfdffd28b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef EN_BAR0


`else


`endif



`ifdef EN_BAR1


`else


`endif



`ifdef EN_BAR2


`else


`endif



`ifdef EN_BAR3


`else


`endif



`ifdef EN_BAR4


`else


`endif



`ifdef EN_BAR5


`else


`endif



`ifdef EN_ER_BAR


`else


`endif


`ifdef EN_BAR1



`else



`endif



`ifdef EN_BAR3



`else



`endif



`ifdef EN_BAR5



`else



`endif



`ifdef EN_BAR0



`ifdef EN_BAR1



`else



`endif



`else



`endif



`ifdef EN_BAR1



`else



`endif



`ifdef EN_BAR2



`ifdef EN_BAR3



`else



`endif



`else



`endif



`ifdef EN_BAR3



`else



`endif



`ifdef EN_BAR4



`ifdef EN_BAR5



`else



`endif



`else



`endif



`ifdef EN_BAR5



`else



`endif



`ifdef EN_ER_BAR



`else



`endif



`ifdef X1


`endif



`ifdef X4



`endif

// =============================================================================


`ifdef EN_BAR0


   

`else


   

`endif





`ifdef EN_BAR1


   

`else


   

`endif





`ifdef EN_BAR2


   

`else


   

`endif





`ifdef EN_BAR3


   

`else


   

`endif





`ifdef EN_BAR4


   

`else


   

`endif





`ifdef EN_BAR5


   

`else


   

`endif





`ifdef EN_ER_BAR


   

`else


   

`endif



// Pipeline mem/io TLP indications
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin 
      tlpdec_iorw_reg0  <= 1'b0 ;   
      tlpdec_memrw_reg0 <= 1'b0 ;   
   end
   else begin    
      tlpdec_memrw_reg0 <= tlpdec_memrw_split ;   
      tlpdec_iorw_reg0  <= tlpdec_iorw_split ;   
   end
end

// Generate address enable signal from io or memory TLP indications
// which comes along with start of TLP
assign addr_low32  = tlpdec_addr_l32_split ;
assign addr_high32 = tlpdec_addr_h32_split ;



`ifdef EN_BAR1


   assign no_bar1  = 1'b0 ;


`else


   assign no_bar1  = 1'b1 ;


`endif




`ifdef EN_BAR3


   assign no_bar3  = 1'b0 ;


`else


   assign no_bar3  = 1'b1 ;


`endif




`ifdef EN_BAR5


   assign no_bar5  = 1'b0 ;


`else


   assign no_bar5  = 1'b1 ;


`endif




// =============================================================================


`ifdef EN_BAR0


   

`ifdef EN_BAR1


      assign bar1_up32  = ~bar0_init[0] & bar0_init[2];
   

`else


      assign bar1_up32  = 1'b0 ;
   

`endif



   // mask for BAR's I/O config 
   // mask for BAR's memory config
   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) 
         bar0_mask4 <= 4'b0000;
      else if ( bar0_init[0] ) 
         bar0_mask4 <= {bar0_init[3:2], 2'b00} ; 
      else
         bar0_mask4 <= 4'b0000 ; 
   end
   assign bar0_mask = { bar0_init[31:4], bar0_mask4 };

   assign bar0_32mem = (bar0_init[2:1] == 2'b00) & ~bar0_init[0] ;
   assign bar0_64mem = (bar0_init[2:1] == 2'b10) & ~bar0_init[0] ;
   assign bar0_io    = bar0_init[0] ;

   assign bar0_dsb = (bar0_init == 32'd0) ; 
   assign bar0_enb = ((tlpdec_memrw_split & bar0_32mem && ~tlpdec_addr64_split) | 
                      (tlpdec_memrw_split & bar0_64mem )  | 
                      (tlpdec_iorw_split & bar0_io)
                     ) ; 

   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) 
         bar0_hit <= 1'b0;
      else if ( bar0_enb && !bar0_dsb && !(bar1_up32_split && no_bar1_split) )
         if ( bar1_up32_split )
            bar0_hit <= ((((addr_low32_split  ^ bar0_reg) & bar0_mask) == 32'd0) &
                         (((addr_high32_split ^ bar1_reg) & bar1_mask) == 32'd0)) ; 
         else 
            bar0_hit <= (((addr_low32_split  ^ bar0_reg) & bar0_mask) == 32'd0) ;
      else 
         bar0_hit <= 1'b0 ;
   end 



`else


   assign bar0_hit = 1'b0 ;


`endif


// =============================================================================


`ifdef EN_BAR1



   // upper 32-bit of 64-bit BAR
   // mask for BAR's I/O config
   // mask for BAR's memory config
   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) 
         bar1_mask4 <= 4'b0000;
      else if ( bar1_up32_split )                               
         bar1_mask4 <= bar1_init[3:0];
      else if ( bar1_init[0] )                                
         bar1_mask4 <= {bar1_init[3:2], 2'b00} ;   
      else                                                    
         bar1_mask4 <=  4'b0000;   
   end
   assign bar1_mask = { bar1_init[31:4], bar1_mask4 };

   assign bar1_32mem = (bar1_init[2:1] == 2'b00) & ~bar1_init[0] ;
   assign bar1_64mem = (bar1_init[2:1] == 2'b10) & ~bar1_init[0] ;
   assign bar1_io    = bar1_init[0] ;

   assign bar1_dsb = (bar1_init == 32'd0) ; 
   assign bar1_enb = ((tlpdec_memrw_split & bar1_32mem && ~tlpdec_addr64_split) | 
                      (tlpdec_memrw_split & bar1_64mem )  | 
                      (tlpdec_iorw_split & bar1_io)
                     ) ; 

   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) 
         bar1_hit <= 1'b0;
      else if ( bar1_enb && !bar1_dsb )
         bar1_hit <= (((addr_low32_split  ^ bar1_reg) & bar1_mask) == 32'd0) ;
      else 
         bar1_hit <= 1'b0 ;
   end 



`else


   assign bar1_hit = 1'b0 ;
   assign bar1_mask = 32'd0 ;
   assign bar1_reg = 32'd0 ;


`endif


// =============================================================================


`ifdef EN_BAR2


   

`ifdef EN_BAR3


      assign bar3_up32  = ~bar2_init[0] & bar2_init[2];
   

`else


      assign bar3_up32  = 1'b0 ;
   

`endif



   // mask for BAR's I/O config
   // mask for BAR's memory config
   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) 
         bar2_mask4 <= 4'b0000;
      else if ( bar2_init[0] )                                
         bar2_mask4 <= {bar2_init[3:2], 2'b00} ;   
      else                                                    
         bar2_mask4 <=  4'b0000;   
   end
   assign bar2_mask = { bar2_init[31:4], bar2_mask4 };

   assign bar2_32mem = (bar2_init[2:1] == 2'b00) & ~bar2_init[0] ;
   assign bar2_64mem = (bar2_init[2:1] == 2'b10) & ~bar2_init[0] ;
   assign bar2_io    = bar2_init[0] ;

   assign bar2_dsb = (bar2_init == 32'd0) ; 
   assign bar2_enb = ((tlpdec_memrw_split & bar2_32mem && ~tlpdec_addr64_split) | 
                      (tlpdec_memrw_split & bar2_64mem )  | 
                      (tlpdec_iorw_split & bar2_io)
                     ) ; 

   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) 
         bar2_hit <= 1'b0;
      else if ( bar2_enb && !bar2_dsb && !(bar3_up32_split && no_bar3_split))
         if ( bar3_up32_split )
            bar2_hit <= ((((addr_low32_split  ^ bar2_reg) & bar2_mask) == 32'd0) &
                         (((addr_high32_split ^ bar3_reg) & bar3_mask) == 32'd0)) ; 
         else 
            bar2_hit <= (((addr_low32_split  ^ bar2_reg) & bar2_mask) == 32'd0) ;
      else 
         bar2_hit <= 1'b0 ;
   end 



`else


   assign bar2_hit = 1'b0 ;



`endif


// =============================================================================


`ifdef EN_BAR3



   // upper 32-bit of 64-bit BAR
   // mask for BAR's I/O config
   // mask for BAR's memory config
   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) 
         bar3_mask4 <= 4'b0000;
      else if ( bar3_up32_split )                               
         bar3_mask4 <= bar3_init[3:0];
      else if ( bar3_init[0] )                                
         bar3_mask4 <= {bar3_init[3:2], 2'b00} ;   
      else                                                    
         bar3_mask4 <=  4'b0000;   
   end
   assign bar3_mask = { bar3_init[31:4], bar3_mask4 };

   assign bar3_32mem = (bar3_init[2:1] == 2'b00) & ~bar3_init[0] ;
   assign bar3_64mem = bar3_up32_split ;
   assign bar3_io    = bar3_init[0] ;

   assign bar3_dsb = (bar3_init == 32'd0) ; 
   assign bar3_enb = ((tlpdec_memrw_split & bar3_32mem && ~tlpdec_addr64_split) | 
                      (tlpdec_memrw_split & bar3_64mem )  | 
                      (tlpdec_iorw_split & bar3_io)
                     ) ; 

   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) 
         bar3_hit <= 1'b0;
      else if ( bar3_enb && !bar3_dsb )
         bar3_hit <= (((addr_low32_split  ^ bar3_reg) & bar3_mask) == 32'd0) ;
      else 
         bar3_hit <= 1'b0 ;
   end 



`else


   assign bar3_hit  = 1'b0 ;
   assign bar3_mask = 32'd0 ;
   assign bar3_reg = 32'd0 ;


`endif


// =============================================================================


`ifdef EN_BAR4


   

`ifdef EN_BAR5


      assign bar5_up32  = ~bar4_init[0] & bar4_init[2];
   

`else


      assign bar5_up32  = 1'b0 ;
   

`endif



   // mask for BAR's I/O config
   // mask for BAR's memory config
   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) 
         bar4_mask4 <= 4'b0000;
      else if ( bar4_init[0] )                                
         bar4_mask4 <= {bar4_init[3:2], 2'b00} ;   
      else                                                    
         bar4_mask4 <=  4'b0000;   
   end
   assign bar4_mask = { bar4_init[31:4], bar4_mask4 };

   assign bar4_32mem = (bar4_init[2:1] == 2'b00) & ~bar4_init[0] ;
   assign bar4_64mem = (bar4_init[2:1] == 2'b10) & ~bar4_init[0] ;
   assign bar4_io    = bar4_init[0] ;

   assign bar4_dsb = (bar4_init == 32'd0) ; 
   assign bar4_enb = ((tlpdec_memrw_split & bar4_32mem && ~tlpdec_addr64_split) | 
                      (tlpdec_memrw_split & bar4_64mem )  | 
                      (tlpdec_iorw_split & bar4_io)
                     ) ; 

   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) 
         bar4_hit <= 1'b0;
      else if ( bar4_enb && !bar4_dsb && !(bar5_up32_split && no_bar5_split))
         if ( bar5_up32_split )
            bar4_hit <= ((((addr_low32_split  ^ bar4_reg) & bar4_mask) == 32'd0) &
                         (((addr_high32_split ^ bar5_reg) & bar5_mask) == 32'd0)) ; 
         else 
            bar4_hit <= (((addr_low32_split  ^ bar4_reg) & bar4_mask) == 32'd0) ;
      else 
         bar4_hit <= 1'b0 ;
   end 



`else


   assign bar4_hit = 1'b0 ;


`endif


// =============================================================================


`ifdef EN_BAR5


   // upper 32-bit of 64-bit BAR
   // mask for BAR's I/O config
   // mask for BAR's memory config
   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) 
         bar5_mask4 <= 4'b0000;
      else if ( bar5_up32_split )                               
         bar5_mask4 <= bar5_init[3:0];
      else if ( bar5_init[0] )                                
         bar5_mask4 <= {bar5_init[3:2], 2'b00} ;   
      else                                                    
         bar5_mask4 <=  4'b0000;   
   end
   assign bar5_mask = { bar5_init[31:4], bar5_mask4 };

   assign bar5_32mem = (bar5_init[2:1] == 2'b00) & ~bar5_init[0] ;
   assign bar5_64mem = bar5_up32_split ;
   assign bar5_io    = bar5_init[0] ;

   assign bar5_dsb = (bar5_init == 32'd0) ; 
   assign bar5_enb = ((tlpdec_memrw_split & bar5_32mem && ~tlpdec_addr64_split) | 
                      (tlpdec_memrw_split & bar5_64mem )  | 
                      (tlpdec_iorw_split & bar5_io)
                     ) ; 

   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) 
         bar5_hit <= 1'b0;
      else if ( bar5_enb && !bar5_dsb )
         bar5_hit <= (((addr_low32_split  ^ bar5_reg) & bar5_mask) == 32'd0) ;
      else 
         bar5_hit <= 1'b0 ;
   end 



`else


   assign bar5_hit  = 1'b0 ;
   assign bar5_mask = 32'd0 ;
   assign bar5_reg = 32'd0 ;


`endif


// =============================================================================


`ifdef EN_ER_BAR



   assign er_bar_mask = {er_bar_init[31:11],11'h000} ;

   assign er_bar_enb = (tlpdec_memrw_split & er_bar_init[0]) ; 

   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) 
         er_bar_hit <= 1'b0;
      else if (er_bar_enb)
         er_bar_hit <= (((addr_low32_split ^ er_bar_reg) & er_bar_mask) == 32'd0) ;
      else 
         er_bar_hit <= 1'b0;
   end 


`else


   assign er_bar_hit = 1'b0 ;


`endif


// =============================================================================
assign  bar_hit_comb     = {er_bar_hit, bar5_hit, bar4_hit, bar3_hit, 
                                      bar2_hit, bar1_hit, bar0_hit} ;
assign  bar_hit_val_comb = (tlpdec_memrw_reg0_split | tlpdec_iorw_reg0_split) ; 



`ifdef X1


   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) begin 
         bar_hit_int2     <= 7'h00 ;
         bar_hit_val_int2 <= 1'b0 ;

         bar_hit         <= 7'h00 ;
         bar_hit_val     <= 1'b0 ;
      end
      else begin
         bar_hit_int2     <= bar_hit_comb_split; 
         bar_hit_val_int2 <=  bar_hit_val_comb_split;

         bar_hit          <= bar_hit_int2_split ;
         bar_hit_val      <= bar_hit_val_int2_split ; 

      end
   end
   assign bar_fail = (bar_hit_val & ~(|bar_hit));


`endif





`ifdef X4


   assign  bar_hit     = bar_hit_comb_split ;
   assign  bar_hit_val = bar_hit_val_comb_split ; 


`endif



always@* begin tlpdec_memrw_split<=descram_out[0];tlpdec_iorw_split<=descram_out[1];tlpdec_addr_l32_split<={tlpdec_addr_l32>>1,descram_out[2]};tlpdec_addr_h32_split<={tlpdec_addr_h32>>1,descram_out[3]};tlpdec_addr64_split<=descram_out[4];tlpdec_memrw_reg0_split<=descram_out[5];tlpdec_iorw_reg0_split<=descram_out[6];bar_hit_int2_split<={bar_hit_int2>>1,descram_out[7]};bar_hit_val_int2_split<=descram_out[8];bar_hit_comb_split<={bar_hit_comb>>1,descram_out[9]};bar_hit_val_comb_split<=descram_out[10];addr_low32_split<={addr_low32>>1,descram_out[11]};addr_high32_split<={addr_high32>>1,descram_out[12]};no_bar1_split<=descram_out[13];no_bar3_split<=descram_out[14];no_bar5_split<=descram_out[15];bar1_up32_split<=descram_out[16];bar3_up32_split<=descram_out[17];bar5_up32_split<=descram_out[18];end
always@* begin descram_in[2047]<=tlpdec_iorw;descram_in[2046]<=tlpdec_addr_l32[0];descram_in[2044]<=tlpdec_addr_h32[0];descram_in[2040]<=tlpdec_addr64;descram_in[2032]<=tlpdec_memrw_reg0;descram_in[2017]<=tlpdec_iorw_reg0;descram_in[1987]<=bar_hit_int2[0];descram_in[1926]<=bar_hit_val_int2;descram_in[1804]<=bar_hit_comb[0];descram_in[1614]<=bar1_up32;descram_in[1561]<=bar_hit_val_comb;descram_in[1180]<=bar3_up32;descram_in[1074]<=addr_low32[0];descram_in[1023]<=tlpdec_memrw;descram_in[807]<=no_bar5;descram_in[403]<=no_bar3;descram_in[312]<=bar5_up32;descram_in[201]<=no_bar1;descram_in[100]<=addr_high32[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVEB


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE BETAILS


// Project          : pci_exp_x4


// File             : ecrc.v


// Title            :


// Dependencies     : 


// Description      : This module generates 32 bit CRC


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Mar 12, 2004


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module ecrc#(
   parameter D_WIDTH  = 64 )
   (
   
   input wire                 sys_clk ,
   input wire                 rst_n ,

   
   input wire [D_WIDTH -1:0]  data_in ,
   input wire                 enable_crc , 
   input wire                 half_data , 
   input wire                 rst_crc , 

   output wire [31:0]         crc_out64 ,
   output wire [31:0]         crc_out32
   ) ;
reg  [31:0]            crc_reg64 ;
reg  [31:0]            crc_reg32 ;
reg  [31:0]            new_crc64 ;
reg  [31:0]            new_crc32 ;

`ifdef X4
wire [31:0]         data_in32 ;

`endif

`ifdef X1
reg [31:0]          data_in32 ;

`endif
reg  [63:0]            A64 ;
reg  [63:0]            D64 ;
reg  [31:0]            C64 ;
reg  [31:0]            A32 ;
reg  [31:0]            D32 ;
reg  [31:0]            C32 ;
reg                    half_data_reg1 ;
wire [7:0]             act_crc64_b3 ;
wire [7:0]             act_crc64_b2 ;
wire [7:0]             act_crc64_b1 ;
wire [7:0]             act_crc64_b0 ;
wire [7:0]             act_crc32_b3 ;
wire [7:0]             act_crc32_b2 ;
wire [7:0]             act_crc32_b1 ;
wire [7:0]             act_crc32_b0 ;

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif 

`ifdef X4

`endif 

`ifdef X1

`endif 

`ifdef X4

`endif 
reg [D_WIDTH - 1 : 0] data_in_split;
reg enable_crc_split;
reg half_data_split;
reg rst_crc_split;
reg [31 : 0] crc_reg32_split;
reg [31 : 0] new_crc64_split;
reg [31 : 0] new_crc32_split;
reg [63 : 0] A64_split;
reg [63 : 0] D64_split;
reg [31 : 0] C64_split;
reg [31 : 0] A32_split;
reg [31 : 0] D32_split;
reg [31 : 0] C32_split;
reg half_data_reg1_split;
reg [7 : 0] act_crc64_b3_split;
reg [7 : 0] act_crc64_b2_split;
reg [7 : 0] act_crc64_b1_split;
reg [7 : 0] act_crc64_b0_split;
reg [7 : 0] act_crc32_b3_split;
reg [7 : 0] act_crc32_b2_split;
reg [7 : 0] act_crc32_b1_split;
reg [7 : 0] act_crc32_b0_split;
reg [2047:0] descram_in;
wire [21:0] descram_out;

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif 

`ifdef X4

`endif 

`ifdef X1

`endif 

`ifdef X4

`endif 

localparam descram_inst_SIZE = 22,descram_inst_SCRAMSTRING = 32'hfdffd14b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X4


`endif



`ifdef X1


`endif


`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif 



`ifdef X4



`endif 



`ifdef X1



`endif 



`ifdef X4



`endif 

// =============================================================================


`ifdef X4


   

`endif




`ifdef X1


   

`endif


// =============================================================================
// CRC computation core logic.
// CRC is computed on 32 bits data bus 
// =============================================================================

// Cobinatorial XOR tree for CRC computation on 64 bits data.
always @(data_in_split or crc_reg64) begin
   A64 = data_in_split;
   D64 = {
          A64_split[56], A64_split[57], A64_split[58], A64_split[59], A64_split[60], A64_split[61], A64_split[62], A64_split[63],
          A64_split[48], A64_split[49], A64_split[50], A64_split[51], A64_split[52], A64_split[53], A64_split[54], A64_split[55],
          A64_split[40], A64_split[41], A64_split[42], A64_split[43], A64_split[44], A64_split[45], A64_split[46], A64_split[47],
          A64_split[32], A64_split[33], A64_split[34], A64_split[35], A64_split[36], A64_split[37], A64_split[38], A64_split[39],
          A64_split[24], A64_split[25], A64_split[26], A64_split[27], A64_split[28], A64_split[29], A64_split[30], A64_split[31],
          A64_split[16], A64_split[17], A64_split[18], A64_split[19], A64_split[20], A64_split[21], A64_split[22], A64_split[23],
          A64_split[8], A64_split[9], A64_split[10], A64_split[11], A64_split[12], A64_split[13], A64_split[14], A64_split[15],
          A64_split[0], A64_split[1], A64_split[2], A64_split[3], A64_split[4], A64_split[5], A64_split[6], A64_split[7] 
         } ;
   C64 = crc_reg64;

   new_crc64[0] = D64_split[63] ^ D64_split[61] ^ D64_split[60] ^ D64_split[58] ^ D64_split[55] ^ D64_split[54] ^ D64_split[53] ^ 
                  D64_split[50] ^ D64_split[48] ^ D64_split[47] ^ D64_split[45] ^ D64_split[44] ^ D64_split[37] ^ D64_split[34] ^ 
                  D64_split[32] ^ D64_split[31] ^ D64_split[30] ^ D64_split[29] ^ D64_split[28] ^ D64_split[26] ^ D64_split[25] ^ 
                  D64_split[24] ^ D64_split[16] ^ D64_split[12] ^ D64_split[10] ^ D64_split[9] ^ D64_split[6] ^ D64_split[0] ^ 
                  C64_split[0] ^ C64_split[2] ^ C64_split[5] ^ C64_split[12] ^ C64_split[13] ^ C64_split[15] ^ C64_split[16] ^ 
                  C64_split[18] ^ C64_split[21] ^ C64_split[22] ^ C64_split[23] ^ C64_split[26] ^ C64_split[28] ^ C64_split[29] ^ 
                  C64_split[31];
   new_crc64[1] = D64_split[63] ^ D64_split[62] ^ D64_split[60] ^ D64_split[59] ^ D64_split[58] ^ D64_split[56] ^ D64_split[53] ^ 
                  D64_split[51] ^ D64_split[50] ^ D64_split[49] ^ D64_split[47] ^ D64_split[46] ^ D64_split[44] ^ D64_split[38] ^ 
                  D64_split[37] ^ D64_split[35] ^ D64_split[34] ^ D64_split[33] ^ D64_split[28] ^ D64_split[27] ^ D64_split[24] ^ 
                  D64_split[17] ^ D64_split[16] ^ D64_split[13] ^ D64_split[12] ^ D64_split[11] ^ D64_split[9] ^ D64_split[7] ^ 
                  D64_split[6] ^ D64_split[1] ^ D64_split[0] ^ C64_split[1] ^ C64_split[2] ^ C64_split[3] ^ C64_split[5] ^ C64_split[6] ^ 
                  C64_split[12] ^ C64_split[14] ^ C64_split[15] ^ C64_split[17] ^ C64_split[18] ^ C64_split[19] ^ C64_split[21] ^ 
                  C64_split[24] ^ C64_split[26] ^ C64_split[27] ^ C64_split[28] ^ C64_split[30] ^ C64_split[31];
   new_crc64[2] = D64_split[59] ^ D64_split[58] ^ D64_split[57] ^ D64_split[55] ^ D64_split[53] ^ D64_split[52] ^ D64_split[51] ^ 
                  D64_split[44] ^ D64_split[39] ^ D64_split[38] ^ D64_split[37] ^ D64_split[36] ^ D64_split[35] ^ D64_split[32] ^ 
                  D64_split[31] ^ D64_split[30] ^ D64_split[26] ^ D64_split[24] ^ D64_split[18] ^ D64_split[17] ^ D64_split[16] ^ 
                  D64_split[14] ^ D64_split[13] ^ D64_split[9] ^ D64_split[8] ^ D64_split[7] ^ D64_split[6] ^ D64_split[2] ^ 
                  D64_split[1] ^ D64_split[0] ^ C64_split[0] ^ C64_split[3] ^ C64_split[4] ^ C64_split[5] ^ C64_split[6] ^ C64_split[7] ^ 
                  C64_split[12] ^ C64_split[19] ^ C64_split[20] ^ C64_split[21] ^ C64_split[23] ^ C64_split[25] ^ C64_split[26] ^ 
                  C64_split[27];
   new_crc64[3] = D64_split[60] ^ D64_split[59] ^ D64_split[58] ^ D64_split[56] ^ D64_split[54] ^ D64_split[53] ^ D64_split[52] ^ 
                  D64_split[45] ^ D64_split[40] ^ D64_split[39] ^ D64_split[38] ^ D64_split[37] ^ D64_split[36] ^ D64_split[33] ^ 
                  D64_split[32] ^ D64_split[31] ^ D64_split[27] ^ D64_split[25] ^ D64_split[19] ^ D64_split[18] ^ D64_split[17] ^ 
                  D64_split[15] ^ D64_split[14] ^ D64_split[10] ^ D64_split[9] ^ D64_split[8] ^ D64_split[7] ^ D64_split[3] ^ 
                  D64_split[2] ^ D64_split[1] ^ C64_split[0] ^ C64_split[1] ^ C64_split[4] ^ C64_split[5] ^ C64_split[6] ^ C64_split[7] ^ 
                  C64_split[8] ^ C64_split[13] ^ C64_split[20] ^ C64_split[21] ^ C64_split[22] ^ C64_split[24] ^ C64_split[26] ^ 
                  C64_split[27] ^ C64_split[28];
   new_crc64[4] = D64_split[63] ^ D64_split[59] ^ D64_split[58] ^ D64_split[57] ^ D64_split[50] ^ D64_split[48] ^ D64_split[47] ^ 
                  D64_split[46] ^ D64_split[45] ^ D64_split[44] ^ D64_split[41] ^ D64_split[40] ^ D64_split[39] ^ D64_split[38] ^ 
                  D64_split[33] ^ D64_split[31] ^ D64_split[30] ^ D64_split[29] ^ D64_split[25] ^ D64_split[24] ^ D64_split[20] ^ 
                  D64_split[19] ^ D64_split[18] ^ D64_split[15] ^ D64_split[12] ^ D64_split[11] ^ D64_split[8] ^ D64_split[6] ^ 
                  D64_split[4] ^ D64_split[3] ^ D64_split[2] ^ D64_split[0] ^ C64_split[1] ^ C64_split[6] ^ C64_split[7] ^ C64_split[8] ^ 
                  C64_split[9] ^ C64_split[12] ^ C64_split[13] ^ C64_split[14] ^ C64_split[15] ^ C64_split[16] ^ C64_split[18] ^ 
                  C64_split[25] ^ C64_split[26] ^ C64_split[27] ^ C64_split[31];
   new_crc64[5] = D64_split[63] ^ D64_split[61] ^ D64_split[59] ^ D64_split[55] ^ D64_split[54] ^ D64_split[53] ^ D64_split[51] ^ 
                  D64_split[50] ^ D64_split[49] ^ D64_split[46] ^ D64_split[44] ^ D64_split[42] ^ D64_split[41] ^ D64_split[40] ^ 
                  D64_split[39] ^ D64_split[37] ^ D64_split[29] ^ D64_split[28] ^ D64_split[24] ^ D64_split[21] ^ D64_split[20] ^ 
                  D64_split[19] ^ D64_split[13] ^ D64_split[10] ^ D64_split[7] ^ D64_split[6] ^ D64_split[5] ^ D64_split[4] ^ 
                  D64_split[3] ^ D64_split[1] ^ D64_split[0] ^ C64_split[5] ^ C64_split[7] ^ C64_split[8] ^ C64_split[9] ^ C64_split[10] ^ 
                  C64_split[12] ^ C64_split[14] ^ C64_split[17] ^ C64_split[18] ^ C64_split[19] ^ C64_split[21] ^ C64_split[22] ^ 
                  C64_split[23] ^ C64_split[27] ^ C64_split[29] ^ C64_split[31];
   new_crc64[6] = D64_split[62] ^ D64_split[60] ^ D64_split[56] ^ D64_split[55] ^ D64_split[54] ^ D64_split[52] ^ D64_split[51] ^ 
                  D64_split[50] ^ D64_split[47] ^ D64_split[45] ^ D64_split[43] ^ D64_split[42] ^ D64_split[41] ^ D64_split[40] ^ 
                  D64_split[38] ^ D64_split[30] ^ D64_split[29] ^ D64_split[25] ^ D64_split[22] ^ D64_split[21] ^ D64_split[20] ^ 
                  D64_split[14] ^ D64_split[11] ^ D64_split[8] ^ D64_split[7] ^ D64_split[6] ^ D64_split[5] ^ D64_split[4] ^ 
                  D64_split[2] ^ D64_split[1] ^ C64_split[6] ^ C64_split[8] ^ C64_split[9] ^ C64_split[10] ^ C64_split[11] ^ 
                  C64_split[13] ^ C64_split[15] ^ C64_split[18] ^ C64_split[19] ^ C64_split[20] ^ C64_split[22] ^ C64_split[23] ^ 
                  C64_split[24] ^ C64_split[28] ^ C64_split[30];
   new_crc64[7] = D64_split[60] ^ D64_split[58] ^ D64_split[57] ^ D64_split[56] ^ D64_split[54] ^ D64_split[52] ^ D64_split[51] ^ 
                  D64_split[50] ^ D64_split[47] ^ D64_split[46] ^ D64_split[45] ^ D64_split[43] ^ D64_split[42] ^ D64_split[41] ^ 
                  D64_split[39] ^ D64_split[37] ^ D64_split[34] ^ D64_split[32] ^ D64_split[29] ^ D64_split[28] ^ D64_split[25] ^ 
                  D64_split[24] ^ D64_split[23] ^ D64_split[22] ^ D64_split[21] ^ D64_split[16] ^ D64_split[15] ^ D64_split[10] ^ 
                  D64_split[8] ^ D64_split[7] ^ D64_split[5] ^ D64_split[3] ^ D64_split[2] ^ D64_split[0] ^ C64_split[0] ^ C64_split[2] ^ 
                  C64_split[5] ^ C64_split[7] ^ C64_split[9] ^ C64_split[10] ^ C64_split[11] ^ C64_split[13] ^ C64_split[14] ^ 
                  C64_split[15] ^ C64_split[18] ^ C64_split[19] ^ C64_split[20] ^ C64_split[22] ^ C64_split[24] ^ C64_split[25] ^ 
                  C64_split[26] ^ C64_split[28];
   new_crc64[8] = D64_split[63] ^ D64_split[60] ^ D64_split[59] ^ D64_split[57] ^ D64_split[54] ^ D64_split[52] ^ D64_split[51] ^ 
                  D64_split[50] ^ D64_split[46] ^ D64_split[45] ^ D64_split[43] ^ D64_split[42] ^ D64_split[40] ^ D64_split[38] ^ 
                  D64_split[37] ^ D64_split[35] ^ D64_split[34] ^ D64_split[33] ^ D64_split[32] ^ D64_split[31] ^ D64_split[28] ^ 
                  D64_split[23] ^ D64_split[22] ^ D64_split[17] ^ D64_split[12] ^ D64_split[11] ^ D64_split[10] ^ D64_split[8] ^ 
                  D64_split[4] ^ D64_split[3] ^ D64_split[1] ^ D64_split[0] ^ C64_split[0] ^ C64_split[1] ^ C64_split[2] ^ C64_split[3] ^ 
                  C64_split[5] ^ C64_split[6] ^ C64_split[8] ^ C64_split[10] ^ C64_split[11] ^ C64_split[13] ^ C64_split[14] ^ 
                  C64_split[18] ^ C64_split[19] ^ C64_split[20] ^ C64_split[22] ^ C64_split[25] ^ C64_split[27] ^ C64_split[28] ^ 
                  C64_split[31];
   new_crc64[9] = D64_split[61] ^ D64_split[60] ^ D64_split[58] ^ D64_split[55] ^ D64_split[53] ^ D64_split[52] ^ D64_split[51] ^ 
                  D64_split[47] ^ D64_split[46] ^ D64_split[44] ^ D64_split[43] ^ D64_split[41] ^ D64_split[39] ^ D64_split[38] ^ 
                  D64_split[36] ^ D64_split[35] ^ D64_split[34] ^ D64_split[33] ^ D64_split[32] ^ D64_split[29] ^ D64_split[24] ^ 
                  D64_split[23] ^ D64_split[18] ^ D64_split[13] ^ D64_split[12] ^ D64_split[11] ^ D64_split[9] ^ D64_split[5] ^ 
                  D64_split[4] ^ D64_split[2] ^ D64_split[1] ^ C64_split[0] ^ C64_split[1] ^ C64_split[2] ^ C64_split[3] ^ C64_split[4] ^ 
                  C64_split[6] ^ C64_split[7] ^ C64_split[9] ^ C64_split[11] ^ C64_split[12] ^ C64_split[14] ^ C64_split[15] ^ 
                  C64_split[19] ^ C64_split[20] ^ C64_split[21] ^ C64_split[23] ^ C64_split[26] ^ C64_split[28] ^ C64_split[29];
   new_crc64[10] = D64_split[63] ^ D64_split[62] ^ D64_split[60] ^ D64_split[59] ^ D64_split[58] ^ D64_split[56] ^ D64_split[55] ^ 
                   D64_split[52] ^ D64_split[50] ^ D64_split[42] ^ D64_split[40] ^ D64_split[39] ^ D64_split[36] ^ D64_split[35] ^ 
                   D64_split[33] ^ D64_split[32] ^ D64_split[31] ^ D64_split[29] ^ D64_split[28] ^ D64_split[26] ^ D64_split[19] ^ 
                   D64_split[16] ^ D64_split[14] ^ D64_split[13] ^ D64_split[9] ^ D64_split[5] ^ D64_split[3] ^ D64_split[2] ^ 
                   D64_split[0] ^ C64_split[0] ^ C64_split[1] ^ C64_split[3] ^ C64_split[4] ^ C64_split[7] ^ C64_split[8] ^ C64_split[10] ^ 
                   C64_split[18] ^ C64_split[20] ^ C64_split[23] ^ C64_split[24] ^ C64_split[26] ^ C64_split[27] ^ C64_split[28] ^ 
                   C64_split[30] ^ C64_split[31];
   new_crc64[11] = D64_split[59] ^ D64_split[58] ^ D64_split[57] ^ D64_split[56] ^ D64_split[55] ^ D64_split[54] ^ D64_split[51] ^ 
                   D64_split[50] ^ D64_split[48] ^ D64_split[47] ^ D64_split[45] ^ D64_split[44] ^ D64_split[43] ^ D64_split[41] ^ 
                   D64_split[40] ^ D64_split[36] ^ D64_split[33] ^ D64_split[31] ^ D64_split[28] ^ D64_split[27] ^ D64_split[26] ^ 
                   D64_split[25] ^ D64_split[24] ^ D64_split[20] ^ D64_split[17] ^ D64_split[16] ^ D64_split[15] ^ D64_split[14] ^ 
                   D64_split[12] ^ D64_split[9] ^ D64_split[4] ^ D64_split[3] ^ D64_split[1] ^ D64_split[0] ^ C64_split[1] ^ C64_split[4] ^ 
                   C64_split[8] ^ C64_split[9] ^ C64_split[11] ^ C64_split[12] ^ C64_split[13] ^ C64_split[15] ^ C64_split[16] ^ 
                   C64_split[18] ^ C64_split[19] ^ C64_split[22] ^ C64_split[23] ^ C64_split[24] ^ C64_split[25] ^ C64_split[26] ^ 
                   C64_split[27];
   new_crc64[12] = D64_split[63] ^ D64_split[61] ^ D64_split[59] ^ D64_split[57] ^ D64_split[56] ^ D64_split[54] ^ D64_split[53] ^ 
                   D64_split[52] ^ D64_split[51] ^ D64_split[50] ^ D64_split[49] ^ D64_split[47] ^ D64_split[46] ^ D64_split[42] ^ 
                   D64_split[41] ^ D64_split[31] ^ D64_split[30] ^ D64_split[27] ^ D64_split[24] ^ D64_split[21] ^ D64_split[18] ^ 
                   D64_split[17] ^ D64_split[15] ^ D64_split[13] ^ D64_split[12] ^ D64_split[9] ^ D64_split[6] ^ D64_split[5] ^ 
                   D64_split[4] ^ D64_split[2] ^ D64_split[1] ^ D64_split[0] ^ C64_split[9] ^ C64_split[10] ^ C64_split[14] ^ 
                   C64_split[15] ^ C64_split[17] ^ C64_split[18] ^ C64_split[19] ^ C64_split[20] ^ C64_split[21] ^ C64_split[22] ^ 
                   C64_split[24] ^ C64_split[25] ^ C64_split[27] ^ C64_split[29] ^ C64_split[31];
   new_crc64[13] = D64_split[62] ^ D64_split[60] ^ D64_split[58] ^ D64_split[57] ^ D64_split[55] ^ D64_split[54] ^ D64_split[53] ^ 
                   D64_split[52] ^ D64_split[51] ^ D64_split[50] ^ D64_split[48] ^ D64_split[47] ^ D64_split[43] ^ D64_split[42] ^ 
                   D64_split[32] ^ D64_split[31] ^ D64_split[28] ^ D64_split[25] ^ D64_split[22] ^ D64_split[19] ^ D64_split[18] ^ 
                   D64_split[16] ^ D64_split[14] ^ D64_split[13] ^ D64_split[10] ^ D64_split[7] ^ D64_split[6] ^ D64_split[5] ^ 
                   D64_split[3] ^ D64_split[2] ^ D64_split[1] ^ C64_split[0] ^ C64_split[10] ^ C64_split[11] ^ C64_split[15] ^ 
                   C64_split[16] ^ C64_split[18] ^ C64_split[19] ^ C64_split[20] ^ C64_split[21] ^ C64_split[22] ^ C64_split[23] ^ 
                   C64_split[25] ^ C64_split[26] ^ C64_split[28] ^ C64_split[30];
   new_crc64[14] = D64_split[63] ^ D64_split[61] ^ D64_split[59] ^ D64_split[58] ^ D64_split[56] ^ D64_split[55] ^ D64_split[54] ^ 
                   D64_split[53] ^ D64_split[52] ^ D64_split[51] ^ D64_split[49] ^ D64_split[48] ^ D64_split[44] ^ D64_split[43] ^ 
                   D64_split[33] ^ D64_split[32] ^ D64_split[29] ^ D64_split[26] ^ D64_split[23] ^ D64_split[20] ^ D64_split[19] ^ 
                   D64_split[17] ^ D64_split[15] ^ D64_split[14] ^ D64_split[11] ^ D64_split[8] ^ D64_split[7] ^ D64_split[6] ^ 
                   D64_split[4] ^ D64_split[3] ^ D64_split[2] ^ C64_split[0] ^ C64_split[1] ^ C64_split[11] ^ C64_split[12] ^ 
                   C64_split[16] ^ C64_split[17] ^ C64_split[19] ^ C64_split[20] ^ C64_split[21] ^ C64_split[22] ^ C64_split[23] ^ 
                   C64_split[24] ^ C64_split[26] ^ C64_split[27] ^ C64_split[29] ^ C64_split[31];
   new_crc64[15] = D64_split[62] ^ D64_split[60] ^ D64_split[59] ^ D64_split[57] ^ D64_split[56] ^ D64_split[55] ^ D64_split[54] ^ 
                   D64_split[53] ^ D64_split[52] ^ D64_split[50] ^ D64_split[49] ^ D64_split[45] ^ D64_split[44] ^ D64_split[34] ^ 
                   D64_split[33] ^ D64_split[30] ^ D64_split[27] ^ D64_split[24] ^ D64_split[21] ^ D64_split[20] ^ D64_split[18] ^ 
                   D64_split[16] ^ D64_split[15] ^ D64_split[12] ^ D64_split[9] ^ D64_split[8] ^ D64_split[7] ^ D64_split[5] ^ 
                   D64_split[4] ^ D64_split[3] ^ C64_split[1] ^ C64_split[2] ^ C64_split[12] ^ C64_split[13] ^ C64_split[17] ^ 
                   C64_split[18] ^ C64_split[20] ^ C64_split[21] ^ C64_split[22] ^ C64_split[23] ^ C64_split[24] ^ C64_split[25] ^ 
                   C64_split[27] ^ C64_split[28] ^ C64_split[30];
   new_crc64[16] = D64_split[57] ^ D64_split[56] ^ D64_split[51] ^ D64_split[48] ^ D64_split[47] ^ D64_split[46] ^ D64_split[44] ^ 
                   D64_split[37] ^ D64_split[35] ^ D64_split[32] ^ D64_split[30] ^ D64_split[29] ^ D64_split[26] ^ D64_split[24] ^ 
                   D64_split[22] ^ D64_split[21] ^ D64_split[19] ^ D64_split[17] ^ D64_split[13] ^ D64_split[12] ^ D64_split[8] ^ 
                   D64_split[5] ^ D64_split[4] ^ D64_split[0] ^ C64_split[0] ^ C64_split[3] ^ C64_split[5] ^ C64_split[12] ^ C64_split[14] ^ 
                   C64_split[15] ^ C64_split[16] ^ C64_split[19] ^ C64_split[24] ^ C64_split[25];
   new_crc64[17] = D64_split[58] ^ D64_split[57] ^ D64_split[52] ^ D64_split[49] ^ D64_split[48] ^ D64_split[47] ^ D64_split[45] ^ 
                   D64_split[38] ^ D64_split[36] ^ D64_split[33] ^ D64_split[31] ^ D64_split[30] ^ D64_split[27] ^ D64_split[25] ^ 
                   D64_split[23] ^ D64_split[22] ^ D64_split[20] ^ D64_split[18] ^ D64_split[14] ^ D64_split[13] ^ D64_split[9] ^ 
                   D64_split[6] ^ D64_split[5] ^ D64_split[1] ^ C64_split[1] ^ C64_split[4] ^ C64_split[6] ^ C64_split[13] ^ C64_split[15] ^ 
                   C64_split[16] ^ C64_split[17] ^ C64_split[20] ^ C64_split[25] ^ C64_split[26];
   new_crc64[18] = D64_split[59] ^ D64_split[58] ^ D64_split[53] ^ D64_split[50] ^ D64_split[49] ^ D64_split[48] ^ D64_split[46] ^ 
                   D64_split[39] ^ D64_split[37] ^ D64_split[34] ^ D64_split[32] ^ D64_split[31] ^ D64_split[28] ^ D64_split[26] ^ 
                   D64_split[24] ^ D64_split[23] ^ D64_split[21] ^ D64_split[19] ^ D64_split[15] ^ D64_split[14] ^ D64_split[10] ^ 
                   D64_split[7] ^ D64_split[6] ^ D64_split[2] ^ C64_split[0] ^ C64_split[2] ^ C64_split[5] ^ C64_split[7] ^ C64_split[14] ^ 
                   C64_split[16] ^ C64_split[17] ^ C64_split[18] ^ C64_split[21] ^ C64_split[26] ^ C64_split[27];
   new_crc64[19] = D64_split[60] ^ D64_split[59] ^ D64_split[54] ^ D64_split[51] ^ D64_split[50] ^ D64_split[49] ^ D64_split[47] ^ 
                   D64_split[40] ^ D64_split[38] ^ D64_split[35] ^ D64_split[33] ^ D64_split[32] ^ D64_split[29] ^ D64_split[27] ^ 
                   D64_split[25] ^ D64_split[24] ^ D64_split[22] ^ D64_split[20] ^ D64_split[16] ^ D64_split[15] ^ D64_split[11] ^ 
                   D64_split[8] ^ D64_split[7] ^ D64_split[3] ^ C64_split[0] ^ C64_split[1] ^ C64_split[3] ^ C64_split[6] ^ C64_split[8] ^ 
                   C64_split[15] ^ C64_split[17] ^ C64_split[18] ^ C64_split[19] ^ C64_split[22] ^ C64_split[27] ^ C64_split[28];
   new_crc64[20] = D64_split[61] ^ D64_split[60] ^ D64_split[55] ^ D64_split[52] ^ D64_split[51] ^ D64_split[50] ^ D64_split[48] ^ 
                   D64_split[41] ^ D64_split[39] ^ D64_split[36] ^ D64_split[34] ^ D64_split[33] ^ D64_split[30] ^ D64_split[28] ^ 
                   D64_split[26] ^ D64_split[25] ^ D64_split[23] ^ D64_split[21] ^ D64_split[17] ^ D64_split[16] ^ D64_split[12] ^ 
                   D64_split[9] ^ D64_split[8] ^ D64_split[4] ^ C64_split[1] ^ C64_split[2] ^ C64_split[4] ^ C64_split[7] ^ C64_split[9] ^ 
                   C64_split[16] ^ C64_split[18] ^ C64_split[19] ^ C64_split[20] ^ C64_split[23] ^ C64_split[28] ^ C64_split[29];
   new_crc64[21] = D64_split[62] ^ D64_split[61] ^ D64_split[56] ^ D64_split[53] ^ D64_split[52] ^ D64_split[51] ^ D64_split[49] ^ 
                   D64_split[42] ^ D64_split[40] ^ D64_split[37] ^ D64_split[35] ^ D64_split[34] ^ D64_split[31] ^ D64_split[29] ^ 
                   D64_split[27] ^ D64_split[26] ^ D64_split[24] ^ D64_split[22] ^ D64_split[18] ^ D64_split[17] ^ D64_split[13] ^ 
                   D64_split[10] ^ D64_split[9] ^ D64_split[5] ^ C64_split[2] ^ C64_split[3] ^ C64_split[5] ^ C64_split[8] ^ C64_split[10] ^ 
                   C64_split[17] ^ C64_split[19] ^ C64_split[20] ^ C64_split[21] ^ C64_split[24] ^ C64_split[29] ^ C64_split[30];
   new_crc64[22] = D64_split[62] ^ D64_split[61] ^ D64_split[60] ^ D64_split[58] ^ D64_split[57] ^ D64_split[55] ^ D64_split[52] ^ 
                   D64_split[48] ^ D64_split[47] ^ D64_split[45] ^ D64_split[44] ^ D64_split[43] ^ D64_split[41] ^ D64_split[38] ^ 
                   D64_split[37] ^ D64_split[36] ^ D64_split[35] ^ D64_split[34] ^ D64_split[31] ^ D64_split[29] ^ D64_split[27] ^ 
                   D64_split[26] ^ D64_split[24] ^ D64_split[23] ^ D64_split[19] ^ D64_split[18] ^ D64_split[16] ^ D64_split[14] ^ 
                   D64_split[12] ^ D64_split[11] ^ D64_split[9] ^ D64_split[0] ^ C64_split[2] ^ C64_split[3] ^ C64_split[4] ^ 
                   C64_split[5] ^ C64_split[6] ^ C64_split[9] ^ C64_split[11] ^ C64_split[12] ^ C64_split[13] ^ C64_split[15] ^ 
                   C64_split[16] ^ C64_split[20] ^ C64_split[23] ^ C64_split[25] ^ C64_split[26] ^ C64_split[28] ^ C64_split[29] ^ 
                   C64_split[30];
   new_crc64[23] = D64_split[62] ^ D64_split[60] ^ D64_split[59] ^ D64_split[56] ^ D64_split[55] ^ D64_split[54] ^ D64_split[50] ^ 
                   D64_split[49] ^ D64_split[47] ^ D64_split[46] ^ D64_split[42] ^ D64_split[39] ^ D64_split[38] ^ D64_split[36] ^ 
                   D64_split[35] ^ D64_split[34] ^ D64_split[31] ^ D64_split[29] ^ D64_split[27] ^ D64_split[26] ^ D64_split[20] ^ 
                   D64_split[19] ^ D64_split[17] ^ D64_split[16] ^ D64_split[15] ^ D64_split[13] ^ D64_split[9] ^ D64_split[6] ^ 
                   D64_split[1] ^ D64_split[0] ^ C64_split[2] ^ C64_split[3] ^ C64_split[4] ^ C64_split[6] ^ C64_split[7] ^ C64_split[10] ^ 
                   C64_split[14] ^ C64_split[15] ^ C64_split[17] ^ C64_split[18] ^ C64_split[22] ^ C64_split[23] ^ C64_split[24] ^ 
                   C64_split[27] ^ C64_split[28] ^ C64_split[30];
   new_crc64[24] = D64_split[63] ^ D64_split[61] ^ D64_split[60] ^ D64_split[57] ^ D64_split[56] ^ D64_split[55] ^ D64_split[51] ^ 
                   D64_split[50] ^ D64_split[48] ^ D64_split[47] ^ D64_split[43] ^ D64_split[40] ^ D64_split[39] ^ D64_split[37] ^ 
                   D64_split[36] ^ D64_split[35] ^ D64_split[32] ^ D64_split[30] ^ D64_split[28] ^ D64_split[27] ^ D64_split[21] ^ 
                   D64_split[20] ^ D64_split[18] ^ D64_split[17] ^ D64_split[16] ^ D64_split[14] ^ D64_split[10] ^ D64_split[7] ^ 
                   D64_split[2] ^ D64_split[1] ^ C64_split[0] ^ C64_split[3] ^ C64_split[4] ^ C64_split[5] ^ C64_split[7] ^ C64_split[8] ^ 
                   C64_split[11] ^ C64_split[15] ^ C64_split[16] ^ C64_split[18] ^ C64_split[19] ^ C64_split[23] ^ C64_split[24] ^ 
                   C64_split[25] ^ C64_split[28] ^ C64_split[29] ^ C64_split[31];
   new_crc64[25] = D64_split[62] ^ D64_split[61] ^ D64_split[58] ^ D64_split[57] ^ D64_split[56] ^ D64_split[52] ^ D64_split[51] ^ 
                   D64_split[49] ^ D64_split[48] ^ D64_split[44] ^ D64_split[41] ^ D64_split[40] ^ D64_split[38] ^ D64_split[37] ^ 
                   D64_split[36] ^ D64_split[33] ^ D64_split[31] ^ D64_split[29] ^ D64_split[28] ^ D64_split[22] ^ D64_split[21] ^ 
                   D64_split[19] ^ D64_split[18] ^ D64_split[17] ^ D64_split[15] ^ D64_split[11] ^ D64_split[8] ^ D64_split[3] ^ 
                   D64_split[2] ^ C64_split[1] ^ C64_split[4] ^ C64_split[5] ^ C64_split[6] ^ C64_split[8] ^ C64_split[9] ^ C64_split[12] ^ 
                   C64_split[16] ^ C64_split[17] ^ C64_split[19] ^ C64_split[20] ^ C64_split[24] ^ C64_split[25] ^ C64_split[26] ^ 
                   C64_split[29] ^ C64_split[30];
   new_crc64[26] = D64_split[62] ^ D64_split[61] ^ D64_split[60] ^ D64_split[59] ^ D64_split[57] ^ D64_split[55] ^ D64_split[54] ^ 
                   D64_split[52] ^ D64_split[49] ^ D64_split[48] ^ D64_split[47] ^ D64_split[44] ^ D64_split[42] ^ D64_split[41] ^ 
                   D64_split[39] ^ D64_split[38] ^ D64_split[31] ^ D64_split[28] ^ D64_split[26] ^ D64_split[25] ^ D64_split[24] ^ 
                   D64_split[23] ^ D64_split[22] ^ D64_split[20] ^ D64_split[19] ^ D64_split[18] ^ D64_split[10] ^ D64_split[6] ^ 
                   D64_split[4] ^ D64_split[3] ^ D64_split[0] ^ C64_split[6] ^ C64_split[7] ^ C64_split[9] ^ C64_split[10] ^ C64_split[12] ^ 
                   C64_split[15] ^ C64_split[16] ^ C64_split[17] ^ C64_split[20] ^ C64_split[22] ^ C64_split[23] ^ C64_split[25] ^ 
                   C64_split[27] ^ C64_split[28] ^ C64_split[29] ^ C64_split[30];
   new_crc64[27] = D64_split[63] ^ D64_split[62] ^ D64_split[61] ^ D64_split[60] ^ D64_split[58] ^ D64_split[56] ^ D64_split[55] ^ 
                   D64_split[53] ^ D64_split[50] ^ D64_split[49] ^ D64_split[48] ^ D64_split[45] ^ D64_split[43] ^ D64_split[42] ^ 
                   D64_split[40] ^ D64_split[39] ^ D64_split[32] ^ D64_split[29] ^ D64_split[27] ^ D64_split[26] ^ D64_split[25] ^ 
                   D64_split[24] ^ D64_split[23] ^ D64_split[21] ^ D64_split[20] ^ D64_split[19] ^ D64_split[11] ^ D64_split[7] ^ 
                   D64_split[5] ^ D64_split[4] ^ D64_split[1] ^ C64_split[0] ^ C64_split[7] ^ C64_split[8] ^ C64_split[10] ^ C64_split[11] ^ 
                   C64_split[13] ^ C64_split[16] ^ C64_split[17] ^ C64_split[18] ^ C64_split[21] ^ C64_split[23] ^ C64_split[24] ^ 
                   C64_split[26] ^ C64_split[28] ^ C64_split[29] ^ C64_split[30] ^ C64_split[31];
   new_crc64[28] = D64_split[63] ^ D64_split[62] ^ D64_split[61] ^ D64_split[59] ^ D64_split[57] ^ D64_split[56] ^ D64_split[54] ^ 
                   D64_split[51] ^ D64_split[50] ^ D64_split[49] ^ D64_split[46] ^ D64_split[44] ^ D64_split[43] ^ D64_split[41] ^ 
                   D64_split[40] ^ D64_split[33] ^ D64_split[30] ^ D64_split[28] ^ D64_split[27] ^ D64_split[26] ^ D64_split[25] ^ 
                   D64_split[24] ^ D64_split[22] ^ D64_split[21] ^ D64_split[20] ^ D64_split[12] ^ D64_split[8] ^ D64_split[6] ^ 
                   D64_split[5] ^ D64_split[2] ^ C64_split[1] ^ C64_split[8] ^ C64_split[9] ^ C64_split[11] ^ C64_split[12] ^ 
                   C64_split[14] ^ C64_split[17] ^ C64_split[18] ^ C64_split[19] ^ C64_split[22] ^ C64_split[24] ^ C64_split[25] ^ 
                   C64_split[27] ^ C64_split[29] ^ C64_split[30] ^ C64_split[31];
   new_crc64[29] = D64_split[63] ^ D64_split[62] ^ D64_split[60] ^ D64_split[58] ^ D64_split[57] ^ D64_split[55] ^ D64_split[52] ^ 
                   D64_split[51] ^ D64_split[50] ^ D64_split[47] ^ D64_split[45] ^ D64_split[44] ^ D64_split[42] ^ D64_split[41] ^ 
                   D64_split[34] ^ D64_split[31] ^ D64_split[29] ^ D64_split[28] ^ D64_split[27] ^ D64_split[26] ^ D64_split[25] ^ 
                   D64_split[23] ^ D64_split[22] ^ D64_split[21] ^ D64_split[13] ^ D64_split[9] ^ D64_split[7] ^ D64_split[6] ^ 
                   D64_split[3] ^ C64_split[2] ^ C64_split[9] ^ C64_split[10] ^ C64_split[12] ^ C64_split[13] ^ C64_split[15] ^ 
                   C64_split[18] ^ C64_split[19] ^ C64_split[20] ^ C64_split[23] ^ C64_split[25] ^ C64_split[26] ^ C64_split[28] ^ 
                   C64_split[30] ^ C64_split[31];
   new_crc64[30] = D64_split[63] ^ D64_split[61] ^ D64_split[59] ^ D64_split[58] ^ D64_split[56] ^ D64_split[53] ^ D64_split[52] ^ 
                   D64_split[51] ^ D64_split[48] ^ D64_split[46] ^ D64_split[45] ^ D64_split[43] ^ D64_split[42] ^ D64_split[35] ^ 
                   D64_split[32] ^ D64_split[30] ^ D64_split[29] ^ D64_split[28] ^ D64_split[27] ^ D64_split[26] ^ D64_split[24] ^ 
                   D64_split[23] ^ D64_split[22] ^ D64_split[14] ^ D64_split[10] ^ D64_split[8] ^ D64_split[7] ^ D64_split[4] ^ 
                   C64_split[0] ^ C64_split[3] ^ C64_split[10] ^ C64_split[11] ^ C64_split[13] ^ C64_split[14] ^ C64_split[16] ^ 
                   C64_split[19] ^ C64_split[20] ^ C64_split[21] ^ C64_split[24] ^ C64_split[26] ^ C64_split[27] ^ C64_split[29] ^ 
                   C64_split[31];
   new_crc64[31] = D64_split[62] ^ D64_split[60] ^ D64_split[59] ^ D64_split[57] ^ D64_split[54] ^ D64_split[53] ^ D64_split[52] ^ 
                   D64_split[49] ^ D64_split[47] ^ D64_split[46] ^ D64_split[44] ^ D64_split[43] ^ D64_split[36] ^ D64_split[33] ^ 
                   D64_split[31] ^ D64_split[30] ^ D64_split[29] ^ D64_split[28] ^ D64_split[27] ^ D64_split[25] ^ D64_split[24] ^ 
                   D64_split[23] ^ D64_split[15] ^ D64_split[11] ^ D64_split[9] ^ D64_split[8] ^ D64_split[5] ^ C64_split[1] ^ 
                   C64_split[4] ^ C64_split[11] ^ C64_split[12] ^ C64_split[14] ^ C64_split[15] ^ C64_split[17] ^ C64_split[20] ^ 
                   C64_split[21] ^ C64_split[22] ^ C64_split[25] ^ C64_split[27] ^ C64_split[28] ^ C64_split[30];
end


always @(*) begin
   A32 = data_in32;
   D32 = {
          A32_split[24], A32_split[25], A32_split[26], A32_split[27], A32_split[28], A32_split[29], A32_split[30], A32_split[31],
          A32_split[16], A32_split[17], A32_split[18], A32_split[19], A32_split[20], A32_split[21], A32_split[22], A32_split[23],
          A32_split[8], A32_split[9], A32_split[10], A32_split[11], A32_split[12], A32_split[13], A32_split[14], A32_split[15],
          A32_split[0], A32_split[1], A32_split[2], A32_split[3], A32_split[4], A32_split[5], A32_split[6], A32_split[7] 
         } ;
   

`ifdef X1


      C32 = crc_reg32_split;
   

`endif


   

`ifdef X4


      C32 = crc_reg64;
   

`endif



   new_crc32[0] = D32_split[31] ^ D32_split[30] ^ D32_split[29] ^ D32_split[28] ^ D32_split[26] ^ D32_split[25] ^ D32_split[24] ^ 
                  D32_split[16] ^ D32_split[12] ^ D32_split[10] ^ D32_split[9] ^ D32_split[6] ^ D32_split[0] ^ C32_split[0] ^ 
                  C32_split[6] ^ C32_split[9] ^ C32_split[10] ^ C32_split[12] ^ C32_split[16] ^ C32_split[24] ^ C32_split[25] ^ 
                  C32_split[26] ^ C32_split[28] ^ C32_split[29] ^ C32_split[30] ^ C32_split[31];
   new_crc32[1] = D32_split[28] ^ D32_split[27] ^ D32_split[24] ^ D32_split[17] ^ D32_split[16] ^ D32_split[13] ^ D32_split[12] ^ 
                  D32_split[11] ^ D32_split[9] ^ D32_split[7] ^ D32_split[6] ^ D32_split[1] ^ D32_split[0] ^ C32_split[0] ^ C32_split[1] ^ 
                  C32_split[6] ^ C32_split[7] ^ C32_split[9] ^ C32_split[11] ^ C32_split[12] ^ C32_split[13] ^ C32_split[16] ^ 
                  C32_split[17] ^ C32_split[24] ^ C32_split[27] ^ C32_split[28];
   new_crc32[2] = D32_split[31] ^ D32_split[30] ^ D32_split[26] ^ D32_split[24] ^ D32_split[18] ^ D32_split[17] ^ D32_split[16] ^ 
                  D32_split[14] ^ D32_split[13] ^ D32_split[9] ^ D32_split[8] ^ D32_split[7] ^ D32_split[6] ^ D32_split[2] ^ 
                  D32_split[1] ^ D32_split[0] ^ C32_split[0] ^ C32_split[1] ^ C32_split[2] ^ C32_split[6] ^ C32_split[7] ^ C32_split[8] ^ 
                  C32_split[9] ^ C32_split[13] ^ C32_split[14] ^ C32_split[16] ^ C32_split[17] ^ C32_split[18] ^ C32_split[24] ^ 
                  C32_split[26] ^ C32_split[30] ^ C32_split[31];
   new_crc32[3] = D32_split[31] ^ D32_split[27] ^ D32_split[25] ^ D32_split[19] ^ D32_split[18] ^ D32_split[17] ^ D32_split[15] ^ 
                  D32_split[14] ^ D32_split[10] ^ D32_split[9] ^ D32_split[8] ^ D32_split[7] ^ D32_split[3] ^ D32_split[2] ^ 
                  D32_split[1] ^ C32_split[1] ^ C32_split[2] ^ C32_split[3] ^ C32_split[7] ^ C32_split[8] ^ C32_split[9] ^ C32_split[10] ^ 
                  C32_split[14] ^ C32_split[15] ^ C32_split[17] ^ C32_split[18] ^ C32_split[19] ^ C32_split[25] ^ C32_split[27] ^ 
                  C32_split[31];
   new_crc32[4] = D32_split[31] ^ D32_split[30] ^ D32_split[29] ^ D32_split[25] ^ D32_split[24] ^ D32_split[20] ^ D32_split[19] ^ 
                  D32_split[18] ^ D32_split[15] ^ D32_split[12] ^ D32_split[11] ^ D32_split[8] ^ D32_split[6] ^ D32_split[4] ^ 
                  D32_split[3] ^ D32_split[2] ^ D32_split[0] ^ C32_split[0] ^ C32_split[2] ^ C32_split[3] ^ C32_split[4] ^ C32_split[6] ^ 
                  C32_split[8] ^ C32_split[11] ^ C32_split[12] ^ C32_split[15] ^ C32_split[18] ^ C32_split[19] ^ C32_split[20] ^ 
                  C32_split[24] ^ C32_split[25] ^ C32_split[29] ^ C32_split[30] ^ C32_split[31];
   new_crc32[5] = D32_split[29] ^ D32_split[28] ^ D32_split[24] ^ D32_split[21] ^ D32_split[20] ^ D32_split[19] ^ D32_split[13] ^ 
                  D32_split[10] ^ D32_split[7] ^ D32_split[6] ^ D32_split[5] ^ D32_split[4] ^ D32_split[3] ^ D32_split[1] ^ D32_split[0] ^ 
                  C32_split[0] ^ C32_split[1] ^ C32_split[3] ^ C32_split[4] ^ C32_split[5] ^ C32_split[6] ^ C32_split[7] ^ C32_split[10] ^ 
                  C32_split[13] ^ C32_split[19] ^ C32_split[20] ^ C32_split[21] ^ C32_split[24] ^ C32_split[28] ^ C32_split[29];
   new_crc32[6] = D32_split[30] ^ D32_split[29] ^ D32_split[25] ^ D32_split[22] ^ D32_split[21] ^ D32_split[20] ^ D32_split[14] ^ 
                  D32_split[11] ^ D32_split[8] ^ D32_split[7] ^ D32_split[6] ^ D32_split[5] ^ D32_split[4] ^ D32_split[2] ^ D32_split[1] ^ 
                  C32_split[1] ^ C32_split[2] ^ C32_split[4] ^ C32_split[5] ^ C32_split[6] ^ C32_split[7] ^ C32_split[8] ^ C32_split[11] ^ 
                  C32_split[14] ^ C32_split[20] ^ C32_split[21] ^ C32_split[22] ^ C32_split[25] ^ C32_split[29] ^ C32_split[30];
   new_crc32[7] = D32_split[29] ^ D32_split[28] ^ D32_split[25] ^ D32_split[24] ^ D32_split[23] ^ D32_split[22] ^ D32_split[21] ^ 
                  D32_split[16] ^ D32_split[15] ^ D32_split[10] ^ D32_split[8] ^ D32_split[7] ^ D32_split[5] ^ D32_split[3] ^ 
                  D32_split[2] ^ D32_split[0] ^ C32_split[0] ^ C32_split[2] ^ C32_split[3] ^ C32_split[5] ^ C32_split[7] ^ C32_split[8] ^ 
                  C32_split[10] ^ C32_split[15] ^ C32_split[16] ^ C32_split[21] ^ C32_split[22] ^ C32_split[23] ^ C32_split[24] ^ 
                  C32_split[25] ^ C32_split[28] ^ C32_split[29];
   new_crc32[8] = D32_split[31] ^ D32_split[28] ^ D32_split[23] ^ D32_split[22] ^ D32_split[17] ^ D32_split[12] ^ D32_split[11] ^ 
                  D32_split[10] ^ D32_split[8] ^ D32_split[4] ^ D32_split[3] ^ D32_split[1] ^ D32_split[0] ^ C32_split[0] ^ C32_split[1] ^ 
                  C32_split[3] ^ C32_split[4] ^ C32_split[8] ^ C32_split[10] ^ C32_split[11] ^ C32_split[12] ^ C32_split[17] ^ 
                  C32_split[22] ^ C32_split[23] ^ C32_split[28] ^ C32_split[31];
   new_crc32[9] = D32_split[29] ^ D32_split[24] ^ D32_split[23] ^ D32_split[18] ^ D32_split[13] ^ D32_split[12] ^ D32_split[11] ^ 
                  D32_split[9] ^ D32_split[5] ^ D32_split[4] ^ D32_split[2] ^ D32_split[1] ^ C32_split[1] ^ C32_split[2] ^ C32_split[4] ^ 
                  C32_split[5] ^ C32_split[9] ^ C32_split[11] ^ C32_split[12] ^ C32_split[13] ^ C32_split[18] ^ C32_split[23] ^ 
                  C32_split[24] ^ C32_split[29];
   new_crc32[10] = D32_split[31] ^ D32_split[29] ^ D32_split[28] ^ D32_split[26] ^ D32_split[19] ^ D32_split[16] ^ D32_split[14] ^ 
                   D32_split[13] ^ D32_split[9] ^ D32_split[5] ^ D32_split[3] ^ D32_split[2] ^ D32_split[0] ^ C32_split[0] ^ C32_split[2] ^ 
                   C32_split[3] ^ C32_split[5] ^ C32_split[9] ^ C32_split[13] ^ C32_split[14] ^ C32_split[16] ^ C32_split[19] ^ 
                   C32_split[26] ^ C32_split[28] ^ C32_split[29] ^ C32_split[31];
   new_crc32[11] = D32_split[31] ^ D32_split[28] ^ D32_split[27] ^ D32_split[26] ^ D32_split[25] ^ D32_split[24] ^ D32_split[20] ^ 
                   D32_split[17] ^ D32_split[16] ^ D32_split[15] ^ D32_split[14] ^ D32_split[12] ^ D32_split[9] ^ D32_split[4] ^ 
                   D32_split[3] ^ D32_split[1] ^ D32_split[0] ^ C32_split[0] ^ C32_split[1] ^ C32_split[3] ^ C32_split[4] ^ C32_split[9] ^ 
                   C32_split[12] ^ C32_split[14] ^ C32_split[15] ^ C32_split[16] ^ C32_split[17] ^ C32_split[20] ^ C32_split[24] ^ 
                   C32_split[25] ^ C32_split[26] ^ C32_split[27] ^ C32_split[28] ^ C32_split[31];
   new_crc32[12] = D32_split[31] ^ D32_split[30] ^ D32_split[27] ^ D32_split[24] ^ D32_split[21] ^ D32_split[18] ^ D32_split[17] ^ 
                   D32_split[15] ^ D32_split[13] ^ D32_split[12] ^ D32_split[9] ^ D32_split[6] ^ D32_split[5] ^ D32_split[4] ^ 
                   D32_split[2] ^ D32_split[1] ^ D32_split[0] ^ C32_split[0] ^ C32_split[1] ^ C32_split[2] ^ C32_split[4] ^ C32_split[5] ^ 
                   C32_split[6] ^ C32_split[9] ^ C32_split[12] ^ C32_split[13] ^ C32_split[15] ^ C32_split[17] ^ C32_split[18] ^ 
                   C32_split[21] ^ C32_split[24] ^ C32_split[27] ^ C32_split[30] ^ C32_split[31];
   new_crc32[13] = D32_split[31] ^ D32_split[28] ^ D32_split[25] ^ D32_split[22] ^ D32_split[19] ^ D32_split[18] ^ D32_split[16] ^ 
                   D32_split[14] ^ D32_split[13] ^ D32_split[10] ^ D32_split[7] ^ D32_split[6] ^ D32_split[5] ^ D32_split[3] ^ 
                   D32_split[2] ^ D32_split[1] ^ C32_split[1] ^ C32_split[2] ^ C32_split[3] ^ C32_split[5] ^ C32_split[6] ^ C32_split[7] ^ 
                   C32_split[10] ^ C32_split[13] ^ C32_split[14] ^ C32_split[16] ^ C32_split[18] ^ C32_split[19] ^ C32_split[22] ^ 
                   C32_split[25] ^ C32_split[28] ^ C32_split[31];
   new_crc32[14] = D32_split[29] ^ D32_split[26] ^ D32_split[23] ^ D32_split[20] ^ D32_split[19] ^ D32_split[17] ^ D32_split[15] ^ 
                   D32_split[14] ^ D32_split[11] ^ D32_split[8] ^ D32_split[7] ^ D32_split[6] ^ D32_split[4] ^ D32_split[3] ^ 
                   D32_split[2] ^ C32_split[2] ^ C32_split[3] ^ C32_split[4] ^ C32_split[6] ^ C32_split[7] ^ C32_split[8] ^ C32_split[11] ^ 
                   C32_split[14] ^ C32_split[15] ^ C32_split[17] ^ C32_split[19] ^ C32_split[20] ^ C32_split[23] ^ C32_split[26] ^ 
                   C32_split[29];
   new_crc32[15] = D32_split[30] ^ D32_split[27] ^ D32_split[24] ^ D32_split[21] ^ D32_split[20] ^ D32_split[18] ^ D32_split[16] ^ 
                   D32_split[15] ^ D32_split[12] ^ D32_split[9] ^ D32_split[8] ^ D32_split[7] ^ D32_split[5] ^ D32_split[4] ^ 
                   D32_split[3] ^ C32_split[3] ^ C32_split[4] ^ C32_split[5] ^ C32_split[7] ^ C32_split[8] ^ C32_split[9] ^ C32_split[12] ^ 
                   C32_split[15] ^ C32_split[16] ^ C32_split[18] ^ C32_split[20] ^ C32_split[21] ^ C32_split[24] ^ C32_split[27] ^ 
                   C32_split[30];
   new_crc32[16] = D32_split[30] ^ D32_split[29] ^ D32_split[26] ^ D32_split[24] ^ D32_split[22] ^ D32_split[21] ^ D32_split[19] ^ 
                   D32_split[17] ^ D32_split[13] ^ D32_split[12] ^ D32_split[8] ^ D32_split[5] ^ D32_split[4] ^ D32_split[0] ^ 
                   C32_split[0] ^ C32_split[4] ^ C32_split[5] ^ C32_split[8] ^ C32_split[12] ^ C32_split[13] ^ C32_split[17] ^ 
                   C32_split[19] ^ C32_split[21] ^ C32_split[22] ^ C32_split[24] ^ C32_split[26] ^ C32_split[29] ^ C32_split[30];
   new_crc32[17] = D32_split[31] ^ D32_split[30] ^ D32_split[27] ^ D32_split[25] ^ D32_split[23] ^ D32_split[22] ^ D32_split[20] ^ 
                   D32_split[18] ^ D32_split[14] ^ D32_split[13] ^ D32_split[9] ^ D32_split[6] ^ D32_split[5] ^ D32_split[1] ^ 
                   C32_split[1] ^ C32_split[5] ^ C32_split[6] ^ C32_split[9] ^ C32_split[13] ^ C32_split[14] ^ C32_split[18] ^ 
                   C32_split[20] ^ C32_split[22] ^ C32_split[23] ^ C32_split[25] ^ C32_split[27] ^ C32_split[30] ^ C32_split[31];
   new_crc32[18] = D32_split[31] ^ D32_split[28] ^ D32_split[26] ^ D32_split[24] ^ D32_split[23] ^ D32_split[21] ^ D32_split[19] ^ 
                   D32_split[15] ^ D32_split[14] ^ D32_split[10] ^ D32_split[7] ^ D32_split[6] ^ D32_split[2] ^ C32_split[2] ^ 
                   C32_split[6] ^ C32_split[7] ^ C32_split[10] ^ C32_split[14] ^ C32_split[15] ^ C32_split[19] ^ C32_split[21] ^ 
                   C32_split[23] ^ C32_split[24] ^ C32_split[26] ^ C32_split[28] ^ C32_split[31];
   new_crc32[19] = D32_split[29] ^ D32_split[27] ^ D32_split[25] ^ D32_split[24] ^ D32_split[22] ^ D32_split[20] ^ D32_split[16] ^ 
                   D32_split[15] ^ D32_split[11] ^ D32_split[8] ^ D32_split[7] ^ D32_split[3] ^ C32_split[3] ^ C32_split[7] ^ 
                   C32_split[8] ^ C32_split[11] ^ C32_split[15] ^ C32_split[16] ^ C32_split[20] ^ C32_split[22] ^ C32_split[24] ^ 
                   C32_split[25] ^ C32_split[27] ^ C32_split[29];
   new_crc32[20] = D32_split[30] ^ D32_split[28] ^ D32_split[26] ^ D32_split[25] ^ D32_split[23] ^ D32_split[21] ^ D32_split[17] ^ 
                   D32_split[16] ^ D32_split[12] ^ D32_split[9] ^ D32_split[8] ^ D32_split[4] ^ C32_split[4] ^ C32_split[8] ^ 
                   C32_split[9] ^ C32_split[12] ^ C32_split[16] ^ C32_split[17] ^ C32_split[21] ^ C32_split[23] ^ C32_split[25] ^ 
                   C32_split[26] ^ C32_split[28] ^ C32_split[30];
   new_crc32[21] = D32_split[31] ^ D32_split[29] ^ D32_split[27] ^ D32_split[26] ^ D32_split[24] ^ D32_split[22] ^ D32_split[18] ^ 
                   D32_split[17] ^ D32_split[13] ^ D32_split[10] ^ D32_split[9] ^ D32_split[5] ^ C32_split[5] ^ C32_split[9] ^ 
                   C32_split[10] ^ C32_split[13] ^ C32_split[17] ^ C32_split[18] ^ C32_split[22] ^ C32_split[24] ^ C32_split[26] ^ 
                   C32_split[27] ^ C32_split[29] ^ C32_split[31];
   new_crc32[22] = D32_split[31] ^ D32_split[29] ^ D32_split[27] ^ D32_split[26] ^ D32_split[24] ^ D32_split[23] ^ D32_split[19] ^ 
                   D32_split[18] ^ D32_split[16] ^ D32_split[14] ^ D32_split[12] ^ D32_split[11] ^ D32_split[9] ^ D32_split[0] ^ 
                   C32_split[0] ^ C32_split[9] ^ C32_split[11] ^ C32_split[12] ^ C32_split[14] ^ C32_split[16] ^ C32_split[18] ^ 
                   C32_split[19] ^ C32_split[23] ^ C32_split[24] ^ C32_split[26] ^ C32_split[27] ^ C32_split[29] ^ C32_split[31];
   new_crc32[23] = D32_split[31] ^ D32_split[29] ^ D32_split[27] ^ D32_split[26] ^ D32_split[20] ^ D32_split[19] ^ D32_split[17] ^ 
                   D32_split[16] ^ D32_split[15] ^ D32_split[13] ^ D32_split[9] ^ D32_split[6] ^ D32_split[1] ^ D32_split[0] ^ 
                   C32_split[0] ^ C32_split[1] ^ C32_split[6] ^ C32_split[9] ^ C32_split[13] ^ C32_split[15] ^ C32_split[16] ^ 
                   C32_split[17] ^ C32_split[19] ^ C32_split[20] ^ C32_split[26] ^ C32_split[27] ^ C32_split[29] ^ C32_split[31];
   new_crc32[24] = D32_split[30] ^ D32_split[28] ^ D32_split[27] ^ D32_split[21] ^ D32_split[20] ^ D32_split[18] ^ D32_split[17] ^ 
                   D32_split[16] ^ D32_split[14] ^ D32_split[10] ^ D32_split[7] ^ D32_split[2] ^ D32_split[1] ^ C32_split[1] ^ 
                   C32_split[2] ^ C32_split[7] ^ C32_split[10] ^ C32_split[14] ^ C32_split[16] ^ C32_split[17] ^ C32_split[18] ^ 
                   C32_split[20] ^ C32_split[21] ^ C32_split[27] ^ C32_split[28] ^ C32_split[30];
   new_crc32[25] = D32_split[31] ^ D32_split[29] ^ D32_split[28] ^ D32_split[22] ^ D32_split[21] ^ D32_split[19] ^ D32_split[18] ^ 
                   D32_split[17] ^ D32_split[15] ^ D32_split[11] ^ D32_split[8] ^ D32_split[3] ^ D32_split[2] ^ C32_split[2] ^ 
                   C32_split[3] ^ C32_split[8] ^ C32_split[11] ^ C32_split[15] ^ C32_split[17] ^ C32_split[18] ^ C32_split[19] ^ 
                   C32_split[21] ^ C32_split[22] ^ C32_split[28] ^ C32_split[29] ^ C32_split[31];
   new_crc32[26] = D32_split[31] ^ D32_split[28] ^ D32_split[26] ^ D32_split[25] ^ D32_split[24] ^ D32_split[23] ^ D32_split[22] ^ 
                   D32_split[20] ^ D32_split[19] ^ D32_split[18] ^ D32_split[10] ^ D32_split[6] ^ D32_split[4] ^ D32_split[3] ^ 
                   D32_split[0] ^ C32_split[0] ^ C32_split[3] ^ C32_split[4] ^ C32_split[6] ^ C32_split[10] ^ C32_split[18] ^ 
                   C32_split[19] ^ C32_split[20] ^ C32_split[22] ^ C32_split[23] ^ C32_split[24] ^ C32_split[25] ^ C32_split[26] ^ 
                   C32_split[28] ^ C32_split[31];
   new_crc32[27] = D32_split[29] ^ D32_split[27] ^ D32_split[26] ^ D32_split[25] ^ D32_split[24] ^ D32_split[23] ^ D32_split[21] ^ 
                   D32_split[20] ^ D32_split[19] ^ D32_split[11] ^ D32_split[7] ^ D32_split[5] ^ D32_split[4] ^ D32_split[1] ^ 
                   C32_split[1] ^ C32_split[4] ^ C32_split[5] ^ C32_split[7] ^ C32_split[11] ^ C32_split[19] ^ C32_split[20] ^ 
                   C32_split[21] ^ C32_split[23] ^ C32_split[24] ^ C32_split[25] ^ C32_split[26] ^ C32_split[27] ^ C32_split[29];
   new_crc32[28] = D32_split[30] ^ D32_split[28] ^ D32_split[27] ^ D32_split[26] ^ D32_split[25] ^ D32_split[24] ^ D32_split[22] ^ 
                   D32_split[21] ^ D32_split[20] ^ D32_split[12] ^ D32_split[8] ^ D32_split[6] ^ D32_split[5] ^ D32_split[2] ^ 
                   C32_split[2] ^ C32_split[5] ^ C32_split[6] ^ C32_split[8] ^ C32_split[12] ^ C32_split[20] ^ C32_split[21] ^ 
                   C32_split[22] ^ C32_split[24] ^ C32_split[25] ^ C32_split[26] ^ C32_split[27] ^ C32_split[28] ^ C32_split[30];
   new_crc32[29] = D32_split[31] ^ D32_split[29] ^ D32_split[28] ^ D32_split[27] ^ D32_split[26] ^ D32_split[25] ^ D32_split[23] ^ 
                   D32_split[22] ^ D32_split[21] ^ D32_split[13] ^ D32_split[9] ^ D32_split[7] ^ D32_split[6] ^ D32_split[3] ^ 
                   C32_split[3] ^ C32_split[6] ^ C32_split[7] ^ C32_split[9] ^ C32_split[13] ^ C32_split[21] ^ C32_split[22] ^ 
                   C32_split[23] ^ C32_split[25] ^ C32_split[26] ^ C32_split[27] ^ C32_split[28] ^ C32_split[29] ^ C32_split[31];
   new_crc32[30] = D32_split[30] ^ D32_split[29] ^ D32_split[28] ^ D32_split[27] ^ D32_split[26] ^ D32_split[24] ^ D32_split[23] ^ 
                   D32_split[22] ^ D32_split[14] ^ D32_split[10] ^ D32_split[8] ^ D32_split[7] ^ D32_split[4] ^ C32_split[4] ^ 
                   C32_split[7] ^ C32_split[8] ^ C32_split[10] ^ C32_split[14] ^ C32_split[22] ^ C32_split[23] ^ C32_split[24] ^ 
                   C32_split[26] ^ C32_split[27] ^ C32_split[28] ^ C32_split[29] ^ C32_split[30];
   new_crc32[31] = D32_split[31] ^ D32_split[30] ^ D32_split[29] ^ D32_split[28] ^ D32_split[27] ^ D32_split[25] ^ D32_split[24] ^ 
                   D32_split[23] ^ D32_split[15] ^ D32_split[11] ^ D32_split[9] ^ D32_split[8] ^ D32_split[5] ^ C32_split[5] ^ 
                   C32_split[8] ^ C32_split[9] ^ C32_split[11] ^ C32_split[15] ^ C32_split[23] ^ C32_split[24] ^ C32_split[25] ^ 
                   C32_split[27] ^ C32_split[28] ^ C32_split[29] ^ C32_split[30] ^ C32_split[31];

end



`ifdef X1


// Register computed CRC into CRC registers whenever CRC has to 
// be computed on 64 bits data.
always @( posedge sys_clk or negedge rst_n ) begin
   if (!rst_n)
      crc_reg64 <= 32'hFFFF_FFFF ;
   else if (rst_crc_split)
      crc_reg64 <= 32'hFFFF_FFFF ;
   else if (enable_crc_split) 
      crc_reg64 <= new_crc64_split ;
   else  
      crc_reg64 <= crc_reg64 ;
end

// Register CRC register value computed on 64 bits data into CRC
// register which is used to compute on 32 bits data. 
always @( posedge sys_clk or negedge rst_n ) begin
   if (!rst_n)
      crc_reg32 <= 32'h0000_0000 ;
   else if (half_data_split) 
      crc_reg32 <= crc_reg64 ;
   else if (half_data_reg1_split) 
      crc_reg32 <= new_crc32_split ;
   else  
      //crc_reg32 <= 32'h0000_0000 ;
      crc_reg32 <= crc_reg32_split ;
end


`endif 





`ifdef X4


always @( posedge sys_clk or negedge rst_n ) begin
   if (!rst_n) begin
      crc_reg64 <= 32'hFFFF_FFFF ;
      crc_reg32 <= 32'hFFFF_FFFF ;
   end
   else if (rst_crc_split) begin
      crc_reg64 <= 32'hFFFF_FFFF ;
      crc_reg32 <= 32'hFFFF_FFFF ;
   end
   else if (enable_crc_split)  begin
      crc_reg64 <= new_crc64_split ;
      crc_reg32 <= new_crc32_split ;
   end
   else  begin 
      crc_reg64 <= crc_reg64 ;
      crc_reg32 <= crc_reg32_split ;
   end
end


`endif 





`ifdef X1


// Extract last 32 bits if data on which CRC has to be computed.
always @( posedge sys_clk or negedge rst_n ) begin
   if (!rst_n)
      data_in32 <= 32'h0000_0000 ;
   else if (half_data_split)
      data_in32 <= data_in_split[63:32] ;
   else 
      data_in32 <= 32'h0000_0000 ;
end


`endif 




`ifdef X4


   assign data_in32 = data_in_split[63:32] ;


`endif 



// pipeline last 32 bits indication 
always @( posedge sys_clk or negedge rst_n ) begin
   if (!rst_n) 
      half_data_reg1  <= 1'b0 ;
   else  
      half_data_reg1  <= half_data_split ;
end


// Change the bit ordering of the computed CRC according to spec.
assign act_crc64_b3 = { ~crc_reg64[24], ~crc_reg64[25], ~crc_reg64[26], ~crc_reg64[27],
                        ~crc_reg64[28], ~crc_reg64[29], ~crc_reg64[30], ~crc_reg64[31] } ;
assign act_crc64_b2 = { ~crc_reg64[16], ~crc_reg64[17], ~crc_reg64[18], ~crc_reg64[19],
                        ~crc_reg64[20], ~crc_reg64[21], ~crc_reg64[22], ~crc_reg64[23] } ;
assign act_crc64_b1 = { ~crc_reg64[8], ~crc_reg64[9], ~crc_reg64[10], ~crc_reg64[11],
                        ~crc_reg64[12], ~crc_reg64[13], ~crc_reg64[14], ~crc_reg64[15] } ;
assign act_crc64_b0 = { ~crc_reg64[0], ~crc_reg64[1], ~crc_reg64[2], ~crc_reg64[3],
                        ~crc_reg64[4], ~crc_reg64[5], ~crc_reg64[6], ~crc_reg64[7] } ; 

assign act_crc32_b3 = { ~crc_reg32_split[24], ~crc_reg32_split[25], ~crc_reg32_split[26], ~crc_reg32_split[27],
                        ~crc_reg32_split[28], ~crc_reg32_split[29], ~crc_reg32_split[30], ~crc_reg32_split[31] } ;
assign act_crc32_b2 = { ~crc_reg32_split[16], ~crc_reg32_split[17], ~crc_reg32_split[18], ~crc_reg32_split[19],
                        ~crc_reg32_split[20], ~crc_reg32_split[21], ~crc_reg32_split[22], ~crc_reg32_split[23] } ;
assign act_crc32_b1 = { ~crc_reg32_split[8], ~crc_reg32_split[9], ~crc_reg32_split[10], ~crc_reg32_split[11],
                        ~crc_reg32_split[12], ~crc_reg32_split[13], ~crc_reg32_split[14], ~crc_reg32_split[15] } ;
assign act_crc32_b0 = { ~crc_reg32_split[0], ~crc_reg32_split[1], ~crc_reg32_split[2], ~crc_reg32_split[3],
                        ~crc_reg32_split[4], ~crc_reg32_split[5], ~crc_reg32_split[6], ~crc_reg32_split[7] } ; 

// Give out the computed CRCs
assign crc_out64 = {act_crc64_b3_split, act_crc64_b2_split, act_crc64_b1_split, act_crc64_b0_split} ;
assign crc_out32 = {act_crc32_b3_split, act_crc32_b2_split, act_crc32_b1_split, act_crc32_b0_split} ;

always@* begin data_in_split<={data_in>>1,descram_out[0]};enable_crc_split<=descram_out[1];half_data_split<=descram_out[2];rst_crc_split<=descram_out[3];crc_reg32_split<={crc_reg32>>1,descram_out[4]};new_crc64_split<={new_crc64>>1,descram_out[5]};new_crc32_split<={new_crc32>>1,descram_out[6]};A64_split<={A64>>1,descram_out[7]};D64_split<={D64>>1,descram_out[8]};C64_split<={C64>>1,descram_out[9]};A32_split<={A32>>1,descram_out[10]};D32_split<={D32>>1,descram_out[11]};C32_split<={C32>>1,descram_out[12]};half_data_reg1_split<=descram_out[13];act_crc64_b3_split<={act_crc64_b3>>1,descram_out[14]};act_crc64_b2_split<={act_crc64_b2>>1,descram_out[15]};act_crc64_b1_split<={act_crc64_b1>>1,descram_out[16]};act_crc64_b0_split<={act_crc64_b0>>1,descram_out[17]};act_crc32_b3_split<={act_crc32_b3>>1,descram_out[18]};act_crc32_b2_split<={act_crc32_b2>>1,descram_out[19]};act_crc32_b1_split<={act_crc32_b1>>1,descram_out[20]};act_crc32_b0_split<={act_crc32_b0>>1,descram_out[21]};end
always@* begin descram_in[2047]<=enable_crc;descram_in[2046]<=half_data;descram_in[2044]<=rst_crc;descram_in[2040]<=crc_reg32[0];descram_in[2033]<=new_crc64[0];descram_in[2019]<=new_crc32[0];descram_in[1990]<=A64[0];descram_in[1939]<=act_crc32_b3[0];descram_in[1933]<=D64[0];descram_in[1831]<=act_crc32_b2[0];descram_in[1819]<=C64[0];descram_in[1778]<=act_crc64_b2[0];descram_in[1615]<=act_crc32_b1[0];descram_in[1591]<=A32[0];descram_in[1508]<=act_crc64_b1[0];descram_in[1182]<=act_crc32_b0[0];descram_in[1135]<=D32[0];descram_in[1023]<=data_in[0];descram_in[969]<=act_crc64_b0[0];descram_in[889]<=act_crc64_b3[0];descram_in[444]<=half_data_reg1;descram_in[222]<=C32[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================






// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS         


// Project          : pci_exp_x4


// File             : rxintf.v


// Title            :  


// Dependencies     : 


// Description      : This module de-multiplex TLP traffic based on VC/TC maping,


//                    and provides it on RX User interface. 


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Apr 20, 2004


// Changes Made     : Initial Creation


// =============================================================================




`timescale 1 ns / 100 ps
module rxintf (
   input wire                    sys_clk ,         
   input wire                    rst_n ,           

   input wire [(`NUM_VC*8)-1:0]  cfgec_tvmap ,    

   input wire [63:0]             tlpdec_data ,     
   input wire                    tlpdec_st ,       
   input wire                    tlpdec_end ,      
   input wire                    tlpdec_cfgrd ,    
   input wire                    tlpdec_dwen ,     
   input wire [2:0]              tlpdec_tc ,       

   `ifdef ECRC
      input wire                 tlpdec_ecrc_err , 
   `endif
   input wire                    tlpdec_us_req ,   
   input wire                    tlpdec_malf_tlp , 

   input wire [`NUM_VC-1:0]      dl_up ,    
   input wire                    cfg_hit ,
   input wire [6:0]              bar_hit ,
   input wire                    bar_hit_val ,
   input wire                    fc_overflow ,

   output reg [6:0]              rx_bar_hit ,
   output reg [`NUM_VC-1:0]      trnc_st ,  
   output wire                   vc_dl_up_fail ,
   output reg [(`NUM_VC*64)-1:0] rx_data , 
   output reg [`NUM_VC-1:0]      rx_st ,  
   output reg [`NUM_VC-1:0]      rx_end ,
   output reg [`NUM_VC-1:0]      rx_dwen ,
   `ifdef ECRC
      output reg [`NUM_VC-1:0]   rx_ecrc_err , 
   `endif
   output reg [`NUM_VC-1:0]      rx_us_req ,   
   output reg [`NUM_VC-1:0]      rx_malf_tlp ,

   
   output wire [`NUM_VC-1:0]     vc_rcvd,              
   output reg                    ph_rcvd,              
   output reg                    pd_rcvd,              
   output reg                    nph_rcvd,             
   output reg                    npd_rcvd ,            
   output reg [8:0]              credits_rcvd,         

   output reg                    malf_pkt_ph,          
   output reg                    malf_pkt_pd,          
   output reg                    malf_pkt_nph,         
   output reg                    malf_pkt_npd          // Rcvd pkt is Malformed -- NPD


);
parameter PKT_WAIT    = 2'b00;
parameter OFLOW_CHECK = 2'b01;
parameter MALF_CHECK  = 2'b10;
reg   [6:0]                    bar_hit_r ;
reg                            bar_hit_val_r ;
reg   [63:0]                   tlpdec_data_reg0/* synthesis syn_srlstyle="registers" */ ;
reg   [63:0]                   tlpdec_data_reg1/* synthesis syn_srlstyle="registers" */ ;
reg   [63:0]                   tlpdec_data_reg2/* synthesis syn_srlstyle="registers" */ ;
reg   [63:0]                   tlpdec_data_reg3/* synthesis syn_srlstyle="registers" */ ;
reg                            tlpdec_st_reg0/* synthesis syn_srlstyle="registers" */ ;
reg                            tlpdec_st_reg1/* synthesis syn_srlstyle="registers" */ ;
reg                            tlpdec_st_reg2/* synthesis syn_srlstyle="registers" */ ;
reg                            tlpdec_st_reg3/* synthesis syn_srlstyle="registers" */ ;
reg                            tlpdec_end_reg0/* synthesis syn_srlstyle="registers" */ ;
reg                            tlpdec_end_reg1/* synthesis syn_srlstyle="registers" */ ;
reg                            tlpdec_end_reg2/* synthesis syn_srlstyle="registers" */ ;
reg                            tlpdec_end_reg3/* synthesis syn_srlstyle="registers" */ ;
reg                            tlpdec_dwen_reg0/* synthesis syn_srlstyle="registers" */ ;
reg                            tlpdec_dwen_reg1/* synthesis syn_srlstyle="registers" */ ;
reg                            tlpdec_dwen_reg2/* synthesis syn_srlstyle="registers" */ ;
reg                            tlpdec_dwen_reg3/* synthesis syn_srlstyle="registers" */ ;

`ifdef ECRC
reg                         ecrc_err_reg0/* synthesis syn_srlstyle="registers" */ ;
reg                         ecrc_err_reg1/* synthesis syn_srlstyle="registers" */ ;
reg                         ecrc_err_reg2/* synthesis syn_srlstyle="registers" */ ;
reg                         ecrc_err_reg3/* synthesis syn_srlstyle="registers" */ ;

`endif
reg                            us_req_reg0/* synthesis syn_srlstyle="registers" */ ;
reg                            us_req_reg1/* synthesis syn_srlstyle="registers" */ ;
reg                            us_req_reg2/* synthesis syn_srlstyle="registers" */ ;
reg                            us_req_reg3/* synthesis syn_srlstyle="registers" */ ;
reg                            malf_tlp_reg0/* synthesis syn_srlstyle="registers" */ ;
reg                            malf_tlp_reg1/* synthesis syn_srlstyle="registers" */ ;
reg                            malf_tlp_reg2/* synthesis syn_srlstyle="registers" */ ;
reg                            malf_tlp_reg3/* synthesis syn_srlstyle="registers" */ ;
wire   [2:0]                   tc ;
reg    [7:0]                   vc_sel ;
reg                            cfg_hit_r;
reg    [7:0]                   vc_sel_del1/* synthesis syn_srlstyle="registers" */ ;
reg    [7:0]                   vc_sel_del2/* synthesis syn_srlstyle="registers" */ ;
reg    [7:0]                   vc_sel_del3/* synthesis syn_srlstyle="registers" */ ;
reg    [7:0]                   vc_sel_del4/* synthesis syn_srlstyle="registers" */ ;
reg    [1:0]                   fmt;
reg    [4:0]                   pkt_type;
reg    [8:0]                   length_4dw;
reg    [1:0]                   oflow_state;
reg    [3:0]                   stored_type;
wire                           tlp_filter              /* synthesis syn_keep = 1 */  ;
wire   [63:0]                  rx_data_int ;
wire                           rx_st_int ;
wire                           rx_end_int ;
wire                           rx_dwen_int ;

`ifdef ECRC
wire                        rx_ecrc_err_int ;

`endif
wire                           rx_us_req_int ;
wire                           rx_malf_tlp_int ;
wire   [7:0]                   tcvc_map_0 ;
wire   [7:0]                   tcvc_map_1 ;
wire   [7:0]                   tcvc_map_2 ;
wire   [7:0]                   tcvc_map_3 ;
wire   [7:0]                   tcvc_map_4 ;
wire   [7:0]                   tcvc_map_5 ;
wire   [7:0]                   tcvc_map_6 ;
wire   [7:0]                   tcvc_map_7 ;
wire                           pkt_start;
wire                           pkt_start_del1;
wire                           pkt_start_del2;
wire                           pkt_start_del3;
wire                           pkt_start_del4;
wire                           pkt_start_del5;
wire                           pkt_end;
wire  [31:0]                   header1;
wire                           mrd;
wire                           mwr;
wire                           io;
wire                           cfg0;
wire                           cfg1;
wire                           msg;
wire                           msgd;
wire                           cfg_io_wr;
wire                           p_type;
wire                           np_type;
wire                           malformed_pkt;

`ifdef ECRC

`endif

`ifdef ECRC

`endif

`ifdef EN_VC0

`ifdef VC1

`else

`endif  

`else

`endif

`ifdef EN_VC1

`else

`endif

`ifdef EN_VC2

`else

`endif

`ifdef EN_VC3

`else

`endif

`ifdef EN_VC4

`else

`endif

`ifdef EN_VC5

`else

`endif

`ifdef EN_VC6

`else

`endif

`ifdef EN_VC7

`else

`endif

`ifdef ECRC

`endif

`ifdef ECRC

`endif

`ifdef ECRC

`endif

`ifdef EN_VC0

`ifdef ECRC

`endif

`endif

`ifdef EN_VC1

`ifdef ECRC

`endif

`endif

`ifdef EN_VC2

`ifdef ECRC

`endif

`endif

`ifdef EN_VC3

`ifdef ECRC

`endif

`endif

`ifdef EN_VC4

`ifdef ECRC

`endif

`endif

`ifdef EN_VC5

`ifdef ECRC

`endif

`endif

`ifdef EN_VC6

`ifdef ECRC

`endif

`endif

`ifdef EN_VC7

`ifdef ECRC

`endif

`endif
reg [(`NUM_VC * 8) - 1 : 0] cfgec_tvmap_split;
reg [63 : 0] tlpdec_data_split;
reg tlpdec_st_split;
reg tlpdec_end_split;
reg tlpdec_cfgrd_split;
reg tlpdec_dwen_split;
reg [2 : 0] tlpdec_tc_split;
reg tlpdec_us_req_split;
reg tlpdec_malf_tlp_split;
reg [`NUM_VC - 1 : 0] dl_up_split;
reg cfg_hit_split;
reg [6 : 0] bar_hit_split;
reg bar_hit_val_split;
reg fc_overflow_split;
reg [6 : 0] bar_hit_r_split;
reg bar_hit_val_r_split;
reg [63 : 0] tlpdec_data_reg0_split;
reg [63 : 0] tlpdec_data_reg1_split;
reg [63 : 0] tlpdec_data_reg2_split;
reg [63 : 0] tlpdec_data_reg3_split;
reg tlpdec_st_reg0_split;
reg tlpdec_st_reg1_split;
reg tlpdec_st_reg2_split;
reg tlpdec_st_reg3_split;
reg tlpdec_end_reg0_split;
reg tlpdec_end_reg1_split;
reg tlpdec_end_reg2_split;
reg tlpdec_end_reg3_split;
reg tlpdec_dwen_reg0_split;
reg tlpdec_dwen_reg1_split;
reg tlpdec_dwen_reg2_split;
reg tlpdec_dwen_reg3_split;
reg us_req_reg0_split;
reg us_req_reg1_split;
reg us_req_reg2_split;
reg us_req_reg3_split;
reg malf_tlp_reg0_split;
reg malf_tlp_reg1_split;
reg malf_tlp_reg2_split;
reg malf_tlp_reg3_split;
reg [2 : 0] tc_split;
reg [7 : 0] vc_sel_split;
reg cfg_hit_r_split;
reg [7 : 0] vc_sel_del1_split;
reg [7 : 0] vc_sel_del2_split;
reg [7 : 0] vc_sel_del3_split;
reg [7 : 0] vc_sel_del4_split;
reg [1 : 0] fmt_split;
reg [4 : 0] pkt_type_split;
reg [8 : 0] length_4dw_split;
reg [1 : 0] oflow_state_split;
reg [3 : 0] stored_type_split;
reg tlp_filter_split;
reg [63 : 0] rx_data_int_split;
reg rx_st_int_split;
reg rx_end_int_split;
reg rx_dwen_int_split;
reg rx_us_req_int_split;
reg rx_malf_tlp_int_split;
reg [7 : 0] tcvc_map_0_split;
reg [7 : 0] tcvc_map_1_split;
reg [7 : 0] tcvc_map_2_split;
reg [7 : 0] tcvc_map_3_split;
reg [7 : 0] tcvc_map_4_split;
reg [7 : 0] tcvc_map_5_split;
reg [7 : 0] tcvc_map_6_split;
reg [7 : 0] tcvc_map_7_split;
reg pkt_start_split;
reg pkt_start_del1_split;
reg pkt_start_del2_split;
reg pkt_start_del3_split;
reg pkt_start_del4_split;
reg pkt_start_del5_split;
reg pkt_end_split;
reg [31 : 0] header1_split;
reg mrd_split;
reg mwr_split;
reg io_split;
reg cfg0_split;
reg cfg1_split;
reg msg_split;
reg msgd_split;
reg cfg_io_wr_split;
reg p_type_split;
reg np_type_split;
reg malformed_pkt_split;
reg [2047:0] descram_in;
wire [85:0] descram_out;

`ifdef ECRC

`endif

`ifdef ECRC

`endif

`ifdef ECRC

`endif

`ifdef ECRC

`endif

`ifdef EN_VC0

`ifdef VC1

`else

`endif  

`else

`endif

`ifdef EN_VC1

`else

`endif

`ifdef EN_VC2

`else

`endif

`ifdef EN_VC3

`else

`endif

`ifdef EN_VC4

`else

`endif

`ifdef EN_VC5

`else

`endif

`ifdef EN_VC6

`else

`endif

`ifdef EN_VC7

`else

`endif

`ifdef ECRC

`endif

`ifdef ECRC

`endif

`ifdef ECRC

`endif

`ifdef EN_VC0

`ifdef ECRC

`endif

`endif

`ifdef EN_VC1

`ifdef ECRC

`endif

`endif

`ifdef EN_VC2

`ifdef ECRC

`endif

`endif

`ifdef EN_VC3

`ifdef ECRC

`endif

`endif

`ifdef EN_VC4

`ifdef ECRC

`endif

`endif

`ifdef EN_VC5

`ifdef ECRC

`endif

`endif

`ifdef EN_VC6

`ifdef ECRC

`endif

`endif

`ifdef EN_VC7

`ifdef ECRC

`endif

`endif

localparam descram_inst_SIZE = 86,descram_inst_SCRAMSTRING = 32'hfdfff10b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef ECRC


`endif


`ifdef ECRC


`endif


`ifdef ECRC



`endif



`ifdef ECRC



`endif



`ifdef EN_VC0



`ifdef VC1



`else



`endif  



`else



`endif



`ifdef EN_VC1



`else



`endif



`ifdef EN_VC2



`else



`endif



`ifdef EN_VC3



`else



`endif



`ifdef EN_VC4



`else



`endif



`ifdef EN_VC5



`else



`endif



`ifdef EN_VC6



`else



`endif



`ifdef EN_VC7



`else



`endif



`ifdef ECRC



`endif



`ifdef ECRC



`endif



`ifdef ECRC



`endif



`ifdef EN_VC0



`ifdef ECRC



`endif



`endif



`ifdef EN_VC1



`ifdef ECRC



`endif



`endif



`ifdef EN_VC2



`ifdef ECRC



`endif



`endif



`ifdef EN_VC3



`ifdef ECRC



`endif



`endif



`ifdef EN_VC4



`ifdef ECRC



`endif



`endif



`ifdef EN_VC5



`ifdef ECRC



`endif



`endif



`ifdef EN_VC6



`ifdef ECRC



`endif



`endif



`ifdef EN_VC7



`ifdef ECRC



`endif



`endif

// =============================================================================
// Parameters


`ifdef ECRC


   

`endif





`ifdef ECRC


   

`endif


// Pipeline input TLP data stream
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin 
      tlpdec_data_reg0  <= 64'd0 ;   
      tlpdec_st_reg0    <= 1'b0 ;   
      tlpdec_end_reg0   <= 1'b0 ;   
      tlpdec_dwen_reg0  <= 1'b0 ;   

      tlpdec_data_reg1  <= 64'd0 ;   
      tlpdec_st_reg1    <= 1'b0 ;   
      tlpdec_end_reg1   <= 1'b0 ;   
      tlpdec_dwen_reg1  <= 1'b0 ;   

      tlpdec_data_reg2  <= 64'd0 ;   
      tlpdec_st_reg2    <= 1'b0 ;   
      tlpdec_end_reg2   <= 1'b0 ;   
      tlpdec_dwen_reg2  <= 1'b0 ;   

      tlpdec_data_reg3  <= 64'd0 ;   
      tlpdec_st_reg3    <= 1'b0 ;   
      tlpdec_end_reg3   <= 1'b0 ;   
      tlpdec_dwen_reg3  <= 1'b0 ;   
   end
   else begin    
      tlpdec_data_reg0  <= tlpdec_data_split ;   
      tlpdec_st_reg0    <= tlpdec_st_split ;   
      tlpdec_end_reg0   <= tlpdec_end_split ;   
      tlpdec_dwen_reg0  <= tlpdec_dwen_split ;   

      tlpdec_data_reg1  <= tlpdec_data_reg0_split ;   
      tlpdec_st_reg1    <= tlpdec_st_reg0_split ;   
      tlpdec_end_reg1   <= tlpdec_end_reg0_split ;   
      tlpdec_dwen_reg1  <= tlpdec_dwen_reg0_split ;   

      tlpdec_data_reg2  <= tlpdec_data_reg1_split ;   
      tlpdec_st_reg2    <= tlpdec_st_reg1_split ;   
      tlpdec_end_reg2   <= tlpdec_end_reg1_split ;   
      tlpdec_dwen_reg2  <= tlpdec_dwen_reg1_split ;   

      tlpdec_data_reg3  <= tlpdec_data_reg2_split ;   
      tlpdec_st_reg3    <= tlpdec_st_reg2_split ;   
      tlpdec_end_reg3   <= tlpdec_end_reg2_split ;   
      tlpdec_dwen_reg3  <= tlpdec_dwen_reg2_split ;   
   end
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin 
      

`ifdef ECRC


         ecrc_err_reg0 <= 1'b0 ;   
         ecrc_err_reg1 <= 1'b0 ;   
         ecrc_err_reg2 <= 1'b0 ;   
         ecrc_err_reg3 <= 1'b0 ;   
      

`endif


      us_req_reg0   <= 1'b0 ;   
      us_req_reg1   <= 1'b0 ;   
      us_req_reg2   <= 1'b0 ;   
      us_req_reg3   <= 1'b0 ;   

      malf_tlp_reg0 <= 1'b0 ;   
      malf_tlp_reg1 <= 1'b0 ;   
      malf_tlp_reg2 <= 1'b0 ;   
      malf_tlp_reg3 <= 1'b0 ;   
   end
   else begin    
      

`ifdef ECRC


         ecrc_err_reg0 <= tlpdec_ecrc_err ;   
         ecrc_err_reg1 <= ecrc_err_reg0 ;   
         ecrc_err_reg2 <= ecrc_err_reg1 ;   
         ecrc_err_reg3 <= ecrc_err_reg2 ;   
      

`endif


      us_req_reg0   <= tlpdec_us_req_split ;   
      us_req_reg1   <= us_req_reg0_split ;   
      us_req_reg2   <= us_req_reg1_split ;   
      us_req_reg3   <= us_req_reg2_split ;   

      malf_tlp_reg0 <= tlpdec_malf_tlp_split ;   
      malf_tlp_reg1 <= malf_tlp_reg0_split ;   
      malf_tlp_reg2 <= malf_tlp_reg1_split ;   
      malf_tlp_reg3 <= malf_tlp_reg2_split ;   
   end
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
     cfg_hit_r <= 1'b0 ;
   else if (cfg_hit_split)
     cfg_hit_r <= 1'b1 ;
   else if (tlpdec_end_reg2_split)
     cfg_hit_r <= 1'b0 ;
   else
     cfg_hit_r <= cfg_hit_r_split;
end

// Give out Bar hit signals to user logic
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) 
     rx_bar_hit <= 7'h0 ;   
   else if (tlpdec_st_reg2_split & tlp_filter_split & bar_hit_val_r_split)    
     rx_bar_hit <= bar_hit_r_split ;   
   else if (tlpdec_end_reg3_split)    
     rx_bar_hit <= 7'h0 ;   
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin 
      bar_hit_r     <= 7'h0 ;   
      bar_hit_val_r <= 1'b0;
   end
   else begin
      bar_hit_r     <= bar_hit_split;
      bar_hit_val_r <= bar_hit_val_split;
   end
end

assign tlp_filter = ~(cfg_hit_split | cfg_hit_r_split ) ;

assign tc = tlpdec_tc_split;

// Generate internal TC/VC map register based on number of VC definition.


`ifdef EN_VC0


   

`ifdef VC1


      assign tcvc_map_0 = 8'hff;
   

`else


      assign tcvc_map_0 = cfgec_tvmap_split[7:0] ;    
   

`endif  




`else


   assign tcvc_map_0 = 8'b0000_0000 ;    


`endif




`ifdef EN_VC1


   assign tcvc_map_1 = cfgec_tvmap_split[15:8] ;    


`else


   assign tcvc_map_1 = 8'b0000_0000 ;    


`endif




`ifdef EN_VC2


   assign tcvc_map_2 = cfgec_tvmap_split[23:16] ;    


`else


   assign tcvc_map_2 = 8'b0000_0000 ;    


`endif




`ifdef EN_VC3


   assign tcvc_map_3 = cfgec_tvmap_split[31:24] ;    


`else


   assign tcvc_map_3 = 8'b0000_0000 ;    


`endif




`ifdef EN_VC4


   assign tcvc_map_4 = cfgec_tvmap_split[39:32] ;    


`else


   assign tcvc_map_4 = 8'b0000_0000 ;    


`endif




`ifdef EN_VC5


   assign tcvc_map_5 = cfgec_tvmap_split[47:40] ;    


`else


   assign tcvc_map_5 = 8'b0000_0000 ;    


`endif




`ifdef EN_VC6


   assign tcvc_map_6 = cfgec_tvmap_split[55:48] ;    


`else


   assign tcvc_map_6 = 8'b0000_0000 ;    


`endif




`ifdef EN_VC7


   assign tcvc_map_7 = cfgec_tvmap_split[63:56] ;    


`else


   assign tcvc_map_7 = 8'b0000_0000 ;    


`endif



// Decode TC and by looking at TV/VC maping register bits
// generate VC select signals.
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)  
      vc_sel <= 8'b0000_0000 ;   
   else 
      case (tc_split)
         3'b000 :
            case ( 1'b1 )
               tcvc_map_0_split[0] : 
                  vc_sel <= 8'b0000_0001 ; 
               tcvc_map_1_split[0] : 
                  vc_sel <= 8'b0000_0010 ;   
               tcvc_map_2_split[0] : 
                  vc_sel <= 8'b0000_0100 ;   
               tcvc_map_3_split[0] : 
                  vc_sel <= 8'b0000_1000 ;   
               tcvc_map_4_split[0] : 
                  vc_sel <= 8'b0001_0000 ;   
               tcvc_map_5_split[0] : 
                  vc_sel <= 8'b0010_0000 ;   
               tcvc_map_6_split[0] : 
                  vc_sel <= 8'b0100_0000 ;   
               tcvc_map_7_split[0] : 
                  vc_sel <= 8'b1000_0000 ;   
            endcase
         3'b001 :
            case ( 1'b1 )
               tcvc_map_0_split[1] : 
                  vc_sel <= 8'b0000_0001 ; 
               tcvc_map_1_split[1] : 
                  vc_sel <= 8'b0000_0010 ;   
               tcvc_map_2_split[1] : 
                  vc_sel <= 8'b0000_0100 ;   
               tcvc_map_3_split[1] : 
                  vc_sel <= 8'b0000_1000 ;   
               tcvc_map_4_split[1] : 
                  vc_sel <= 8'b0001_0000 ;   
               tcvc_map_5_split[1] : 
                  vc_sel <= 8'b0010_0000 ;   
               tcvc_map_6_split[1] : 
                  vc_sel <= 8'b0100_0000 ;   
               tcvc_map_7_split[1] : 
                  vc_sel <= 8'b1000_0000 ;   
            endcase

         3'b010 :
            case ( 1'b1 )
               tcvc_map_0_split[2] : 
                  vc_sel <= 8'b0000_0001 ; 
               tcvc_map_1_split[2] : 
                  vc_sel <= 8'b0000_0010 ;   
               tcvc_map_2_split[2] : 
                  vc_sel <= 8'b0000_0100 ;   
               tcvc_map_3_split[2] : 
                  vc_sel <= 8'b0000_1000 ;   
               tcvc_map_4_split[2] : 
                  vc_sel <= 8'b0001_0000 ;   
               tcvc_map_5_split[2] : 
                  vc_sel <= 8'b0010_0000 ;   
               tcvc_map_6_split[2] : 
                  vc_sel <= 8'b0100_0000 ;   
               tcvc_map_7_split[2] : 
                  vc_sel <= 8'b1000_0000 ;   
            endcase
         3'b011 :
            case ( 1'b1 )
               tcvc_map_0_split[3] : 
                  vc_sel <= 8'b0000_0001 ; 
               tcvc_map_1_split[3] : 
                  vc_sel <= 8'b0000_0010 ;   
               tcvc_map_2_split[3] : 
                  vc_sel <= 8'b0000_0100 ;   
               tcvc_map_3_split[3] : 
                  vc_sel <= 8'b0000_1000 ;   
               tcvc_map_4_split[3] : 
                  vc_sel <= 8'b0001_0000 ;   
               tcvc_map_5_split[3] : 
                  vc_sel <= 8'b0010_0000 ;   
               tcvc_map_6_split[3] : 
                  vc_sel <= 8'b0100_0000 ;   
               tcvc_map_7_split[3] : 
                  vc_sel <= 8'b1000_0000 ;   
            endcase
         3'b100 :
            case ( 1'b1 )
               tcvc_map_0_split[4] : 
                  vc_sel <= 8'b0000_0001 ; 
               tcvc_map_1_split[4] : 
                  vc_sel <= 8'b0000_0010 ;   
               tcvc_map_2_split[4] : 
                  vc_sel <= 8'b0000_0100 ;   
               tcvc_map_3_split[4] : 
                  vc_sel <= 8'b0000_1000 ;   
               tcvc_map_4_split[4] : 
                  vc_sel <= 8'b0001_0000 ;   
               tcvc_map_5_split[4] : 
                  vc_sel <= 8'b0010_0000 ;   
               tcvc_map_6_split[4] : 
                  vc_sel <= 8'b0100_0000 ;   
               tcvc_map_7_split[4] : 
                  vc_sel <= 8'b1000_0000 ;   
            endcase
         3'b101 :
            case ( 1'b1 )
               tcvc_map_0_split[5] : 
                  vc_sel <= 8'b0000_0001 ; 
               tcvc_map_1_split[5] : 
                  vc_sel <= 8'b0000_0010 ;   
               tcvc_map_2_split[5] : 
                  vc_sel <= 8'b0000_0100 ;   
               tcvc_map_3_split[5] : 
                  vc_sel <= 8'b0000_1000 ;   
               tcvc_map_4_split[5] : 
                  vc_sel <= 8'b0001_0000 ;   
               tcvc_map_5_split[5] : 
                  vc_sel <= 8'b0010_0000 ;   
               tcvc_map_6_split[5] : 
                  vc_sel <= 8'b0100_0000 ;   
               tcvc_map_7_split[5] : 
                  vc_sel <= 8'b1000_0000 ;   
            endcase
         3'b110 :
            case ( 1'b1 )
               tcvc_map_0_split[6] : 
                  vc_sel <= 8'b0000_0001 ; 
               tcvc_map_1_split[6] : 
                  vc_sel <= 8'b0000_0010 ;   
               tcvc_map_2_split[6] : 
                  vc_sel <= 8'b0000_0100 ;   
               tcvc_map_3_split[6] : 
                  vc_sel <= 8'b0000_1000 ;   
               tcvc_map_4_split[6] : 
                  vc_sel <= 8'b0001_0000 ;   
               tcvc_map_5_split[6] : 
                  vc_sel <= 8'b0010_0000 ;   
               tcvc_map_6_split[6] : 
                  vc_sel <= 8'b0100_0000 ;   
               tcvc_map_7_split[6] : 
                  vc_sel <= 8'b1000_0000 ;   
            endcase
         //3'b111 :
         default : 
            case ( 1'b1 )
               tcvc_map_0_split[7] : 
                  vc_sel <= 8'b0000_0001 ; 
               tcvc_map_1_split[7] : 
                  vc_sel <= 8'b0000_0010 ;   
               tcvc_map_2_split[7] : 
                  vc_sel <= 8'b0000_0100 ;   
               tcvc_map_3_split[7] : 
                  vc_sel <= 8'b0000_1000 ;   
               tcvc_map_4_split[7] : 
                  vc_sel <= 8'b0001_0000 ;   
               tcvc_map_5_split[7] : 
                  vc_sel <= 8'b0010_0000 ;   
               tcvc_map_6_split[7] : 
                  vc_sel <= 8'b0100_0000 ;   
               tcvc_map_7_split[7] : 
                  vc_sel <= 8'b1000_0000 ;   
            endcase
      endcase 
end

// Generate internal combinatorial outputs based on tlp filter.
assign rx_data_int = tlpdec_data_reg2_split ;
assign rx_st_int   = tlpdec_st_reg2_split & tlp_filter_split ;
assign rx_end_int  = tlpdec_end_reg2_split & tlp_filter_split ;
assign rx_dwen_int = tlpdec_dwen_reg2_split & tlp_filter_split ;



`ifdef ECRC


   assign rx_ecrc_err_int = ecrc_err_reg2 & tlp_filter_split ;


`endif


assign rx_us_req_int   = us_req_reg2_split & tlp_filter_split ;
assign rx_malf_tlp_int = malf_tlp_reg2_split & tlp_filter_split ;

assign vc_dl_up_fail = ~(|(vc_sel_split & dl_up_split));

// De-multiplex TLP stream to VC based outputs.
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin  
      rx_data <= {(`NUM_VC*64){1'b0}} ; 
      rx_st   <= {(`NUM_VC){1'b0}};
      rx_end  <= {(`NUM_VC){1'b0}};
      rx_dwen <= {(`NUM_VC){1'b0}};
      trnc_st <= {(`NUM_VC){1'b0}};
      

`ifdef ECRC


         rx_ecrc_err <= {(`NUM_VC){1'b0}};
      

`endif


      rx_us_req   <= {(`NUM_VC){1'b0}};
      rx_malf_tlp <= {(`NUM_VC){1'b0}};
      vc_sel_del1 <= 8'b0000_0000 ;   
      vc_sel_del2 <= 8'b0000_0000 ;   
      vc_sel_del3 <= 8'b0000_0000 ;   
      vc_sel_del4 <= 8'b0000_0000 ;   
   end 
   else begin 
      vc_sel_del1  <= vc_sel_split;
      vc_sel_del2  <= vc_sel_del1_split;
      vc_sel_del3  <= vc_sel_del2_split;
      vc_sel_del4  <= vc_sel_del3_split;
      rx_st   <= {(`NUM_VC){1'b0}};
      rx_end  <= {(`NUM_VC){1'b0}};
      rx_dwen <= {(`NUM_VC){1'b0}};
      trnc_st <= {(`NUM_VC){1'b0}};
      

`ifdef ECRC


         rx_ecrc_err <= {(`NUM_VC){1'b0}};
      

`endif


      rx_us_req   <= {(`NUM_VC){1'b0}};
      rx_malf_tlp <= {(`NUM_VC){1'b0}};
      case (1'b1)
      

`ifdef EN_VC0


         vc_sel_del4_split[0] : begin 
            rx_data[63:0]     <= rx_data_int_split ; 
            rx_st[0]          <= rx_st_int_split ;   
            rx_end[0]         <= rx_end_int_split ;   
            rx_dwen[0]        <= rx_dwen_int_split ;   
            trnc_st[0]        <= rx_st_int_split ;   

            

`ifdef ECRC


               rx_ecrc_err[0] <= rx_ecrc_err_int ;   
            

`endif


            rx_us_req[0]      <= rx_us_req_int_split ;   
            rx_malf_tlp[0]    <= rx_malf_tlp_int_split ;   
         end
      

`endif


      

`ifdef EN_VC1


         vc_sel_del4_split[1] : begin 
            rx_data[127:64]   <= rx_data_int_split ; 
            rx_st[1]          <= rx_st_int_split ;   
            rx_end[1]         <= rx_end_int_split ;   
            rx_dwen[1]        <= rx_dwen_int_split ;   
            trnc_st[1]        <= rx_st_int_split ;   

            

`ifdef ECRC


               rx_ecrc_err[1] <= rx_ecrc_err_int ;   
            

`endif


            rx_us_req[1]      <= rx_us_req_int_split ;   
            rx_malf_tlp[1]    <= rx_malf_tlp_int_split ;   
         end
      

`endif


      

`ifdef EN_VC2


         vc_sel_del4_split[2] : begin 
            rx_data[191:128]  <= rx_data_int_split ; 
            rx_st[2]          <= rx_st_int_split ;   
            rx_end[2]         <= rx_end_int_split ;   
            rx_dwen[2]        <= rx_dwen_int_split ;   
            trnc_st[2]        <= rx_st_int_split ;   

            

`ifdef ECRC


               rx_ecrc_err[2] <= rx_ecrc_err_int ;   
            

`endif


            rx_us_req[2]      <= rx_us_req_int_split ;   
            rx_malf_tlp[2]    <= rx_malf_tlp_int_split ;   
         end
      

`endif


      

`ifdef EN_VC3


         vc_sel_del4_split[3] : begin 
            rx_data[255:192]  <= rx_data_int_split ; 
            rx_st[3]          <= rx_st_int_split ;   
            rx_end[3]         <= rx_end_int_split ;   
            rx_dwen[3]        <= rx_dwen_int_split ;   
            trnc_st[3]        <= rx_st_int_split ;   

            

`ifdef ECRC


               rx_ecrc_err[3] <= rx_ecrc_err_int ;   
            

`endif


            rx_us_req[3]      <= rx_us_req_int_split ;   
            rx_malf_tlp[3]    <= rx_malf_tlp_int_split ;   
         end
      

`endif


      

`ifdef EN_VC4


         vc_sel_del4_split[4] : begin 
            rx_data[319:256]  <= rx_data_int_split ; 
            rx_st[4]          <= rx_st_int_split ;   
            rx_end[4]         <= rx_end_int_split ;   
            rx_dwen[4]        <= rx_dwen_int_split ;   
            trnc_st[4]        <= rx_st_int_split ;   

            

`ifdef ECRC


               rx_ecrc_err[4] <= rx_ecrc_err_int ;   
            

`endif


            rx_us_req[4]      <= rx_us_req_int_split ;   
            rx_malf_tlp[4]    <= rx_malf_tlp_int_split ;   
         end
      

`endif


      

`ifdef EN_VC5


         vc_sel_del4_split[5] : begin 
            rx_data[383:320]  <= rx_data_int_split ; 
            rx_st[5]          <= rx_st_int_split ;   
            rx_end[5]         <= rx_end_int_split ;   
            rx_dwen[5]        <= rx_dwen_int_split ;   
            trnc_st[5]        <= rx_st_int_split ;   

            

`ifdef ECRC


               rx_ecrc_err[5] <= rx_ecrc_err_int ;   
            

`endif


            rx_us_req[5]      <= rx_us_req_int_split ;   
            rx_malf_tlp[5]    <= rx_malf_tlp_int_split ;   
         end
      

`endif


      

`ifdef EN_VC6


         vc_sel_del4_split[6] : begin 
            rx_data[447:384]  <= rx_data_int_split ; 
            rx_st[6]          <= rx_st_int_split ;   
            rx_end[6]         <= rx_end_int_split ;   
            rx_dwen[6]        <= rx_dwen_int_split ;   
            trnc_st[6]        <= rx_st_int_split ;   

            

`ifdef ECRC


               rx_ecrc_err[6] <= rx_ecrc_err_int ;   
            

`endif


            rx_us_req[6]      <= rx_us_req_int_split ;   
            rx_malf_tlp[6]    <= rx_malf_tlp_int_split ;   
         end
      

`endif


      

`ifdef EN_VC7


         vc_sel_del4_split[7] : begin 
            rx_data[511:448]  <= rx_data_int_split ; 
            rx_st[7]          <= rx_st_int_split ;   
            rx_end[7]         <= rx_end_int_split ;   
            rx_dwen[7]        <= rx_dwen_int_split ;   
            trnc_st[7]        <= rx_st_int_split ;   

            

`ifdef ECRC


               rx_ecrc_err[7] <= rx_ecrc_err_int ;   
            

`endif


            rx_us_req[7]      <= rx_us_req_int_split ;   
            rx_malf_tlp[7]    <= rx_malf_tlp_int_split ;   
         end
      

`endif


      endcase
   end
end

// =============================================================================
// For Credit OverFlow Error Check
// =============================================================================
assign pkt_start      = tlpdec_st_split;
assign pkt_start_del1 = tlpdec_st_reg0_split;
assign pkt_start_del2 = tlpdec_st_reg1_split;
assign pkt_start_del3 = tlpdec_st_reg2_split;
assign pkt_start_del4 = tlpdec_st_reg3_split;
assign header1        = tlpdec_data_split[63:32];
assign pkt_end        = tlpdec_end_split;
assign malformed_pkt  = tlpdec_malf_tlp_split & tlpdec_end_split;

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin 
      fmt        <= 2'b00;
      pkt_type       <= 5'b00000;
      length_4dw <=  9'd0;
   end
   else begin    
      if (pkt_start_split) begin    
         fmt    <=  header1_split[30:29];
         pkt_type   <=  header1_split[28:24];
         //DW --> 4 DW (credit)  and Rounding  
         //length_4dw <=  (header1[1:0] == 2'b00) ? header1[9:2] : header1[9:2] + 1;
         if (header1_split[1:0] == 2'b00)
            length_4dw <= {(~(|header1_split[9:2])),header1_split[9:2]};
         else
            length_4dw <= header1_split[9:2] + 1;
      end
   end
end

assign mrd  = (fmt_split[1] == 1'b0) & (pkt_type_split[4:1] == 4'b0000);  //Mrd/MrdLK
assign mwr  = (fmt_split[1] == 1'b1) & (pkt_type_split == 5'b00000);
assign io   = (fmt_split[0] == 1'b0) & (pkt_type_split == 5'b00010);
assign cfg0 = (fmt_split[0] == 1'b0) & (pkt_type_split == 5'b00100);
assign cfg1 = (fmt_split[0] == 1'b0) & (pkt_type_split == 5'b00101);
assign msg  = (fmt_split == 2'b01) & (pkt_type_split[4:3] == 2'b10);
assign msgd = (fmt_split == 2'b11) & (pkt_type_split[4:3] == 2'b10);

assign cfg_io_wr = (fmt_split == 2'b10) & (io_split | cfg0_split | cfg1_split);  //Consumes 1 NPD

assign p_type   = mwr_split | msg_split | msgd_split;
assign np_type  = mrd_split | io_split | cfg0_split | cfg1_split;

assign vc_rcvd = vc_sel_split[`NUM_VC-1:0];
always @(posedge sys_clk or negedge rst_n) begin
   if (rst_n == 1'b0) begin
      ph_rcvd      <= 1'b0;
      pd_rcvd      <= 1'b0;
      nph_rcvd     <= 1'b0;
      npd_rcvd     <= 1'b0;
      credits_rcvd <= 9'd0;
      stored_type  <= 4'h0;
   end
   else begin
      ph_rcvd      <= 1'b0;
      pd_rcvd      <= 1'b0;
      nph_rcvd     <= 1'b0;
      npd_rcvd     <= 1'b0;
      if(pkt_start_del1_split) begin
         stored_type  <= {cfg_io_wr_split, np_type_split, (mwr_split | msgd_split), p_type_split};
         //-- P type
         ph_rcvd    <= p_type_split;
         pd_rcvd    <= mwr_split | msgd_split;

         //-- NP type
         nph_rcvd   <= np_type_split;
         npd_rcvd   <= cfg_io_wr_split;

         //-- CPL : Always Infinite for EndPoint

         if(mwr_split || msgd_split)
            credits_rcvd <=  length_4dw_split;
         else if(cfg_io_wr_split)  
            credits_rcvd <=  'd1;
         else 
            credits_rcvd <=  'd0;

      end

   end
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin  
      oflow_state  <= PKT_WAIT;
      malf_pkt_ph  <= 1'b0;
      malf_pkt_pd  <= 1'b0;
      malf_pkt_nph <= 1'b0;
      malf_pkt_npd <= 1'b0;
   end 
   else begin 
      malf_pkt_ph  <= 1'b0;
      malf_pkt_pd  <= 1'b0;
      malf_pkt_nph <= 1'b0;
      malf_pkt_npd <= 1'b0;
      if((oflow_state_split == MALF_CHECK) && malformed_pkt_split) begin
         malf_pkt_ph  <= stored_type_split[0];
         malf_pkt_pd  <= stored_type_split[1];
         malf_pkt_nph <= stored_type_split[2];
         malf_pkt_npd <= stored_type_split[3];
      end
      case(oflow_state_split)
         PKT_WAIT    : oflow_state  <= (pkt_start_del4_split) ? OFLOW_CHECK : oflow_state_split;
         OFLOW_CHECK : oflow_state  <= (fc_overflow_split) ? PKT_WAIT : MALF_CHECK;
         MALF_CHECK  : oflow_state  <= (pkt_end_split) ? PKT_WAIT : oflow_state_split;
         default     : oflow_state  <= oflow_state_split;
      endcase
   end 
end 

always@* begin cfgec_tvmap_split<={cfgec_tvmap>>1,descram_out[0]};tlpdec_data_split<={tlpdec_data>>1,descram_out[1]};tlpdec_st_split<=descram_out[2];tlpdec_end_split<=descram_out[3];tlpdec_cfgrd_split<=descram_out[4];tlpdec_dwen_split<=descram_out[5];tlpdec_tc_split<={tlpdec_tc>>1,descram_out[6]};tlpdec_us_req_split<=descram_out[7];tlpdec_malf_tlp_split<=descram_out[8];dl_up_split<={dl_up>>1,descram_out[9]};cfg_hit_split<=descram_out[10];bar_hit_split<={bar_hit>>1,descram_out[11]};bar_hit_val_split<=descram_out[12];fc_overflow_split<=descram_out[13];bar_hit_r_split<={bar_hit_r>>1,descram_out[14]};bar_hit_val_r_split<=descram_out[15];tlpdec_data_reg0_split<={tlpdec_data_reg0>>1,descram_out[16]};tlpdec_data_reg1_split<={tlpdec_data_reg1>>1,descram_out[17]};tlpdec_data_reg2_split<={tlpdec_data_reg2>>1,descram_out[18]};tlpdec_data_reg3_split<={tlpdec_data_reg3>>1,descram_out[19]};tlpdec_st_reg0_split<=descram_out[20];tlpdec_st_reg1_split<=descram_out[21];tlpdec_st_reg2_split<=descram_out[22];tlpdec_st_reg3_split<=descram_out[23];tlpdec_end_reg0_split<=descram_out[24];tlpdec_end_reg1_split<=descram_out[25];tlpdec_end_reg2_split<=descram_out[26];tlpdec_end_reg3_split<=descram_out[27];tlpdec_dwen_reg0_split<=descram_out[28];tlpdec_dwen_reg1_split<=descram_out[29];tlpdec_dwen_reg2_split<=descram_out[30];tlpdec_dwen_reg3_split<=descram_out[31];us_req_reg0_split<=descram_out[32];us_req_reg1_split<=descram_out[33];us_req_reg2_split<=descram_out[34];us_req_reg3_split<=descram_out[35];malf_tlp_reg0_split<=descram_out[36];malf_tlp_reg1_split<=descram_out[37];malf_tlp_reg2_split<=descram_out[38];malf_tlp_reg3_split<=descram_out[39];tc_split<={tc>>1,descram_out[40]};vc_sel_split<={vc_sel>>1,descram_out[41]};cfg_hit_r_split<=descram_out[42];vc_sel_del1_split<={vc_sel_del1>>1,descram_out[43]};vc_sel_del2_split<={vc_sel_del2>>1,descram_out[44]};vc_sel_del3_split<={vc_sel_del3>>1,descram_out[45]};vc_sel_del4_split<={vc_sel_del4>>1,descram_out[46]};fmt_split<={fmt>>1,descram_out[47]};pkt_type_split<={pkt_type>>1,descram_out[48]};length_4dw_split<={length_4dw>>1,descram_out[49]};oflow_state_split<={oflow_state>>1,descram_out[50]};stored_type_split<={stored_type>>1,descram_out[51]};tlp_filter_split<=descram_out[52];rx_data_int_split<={rx_data_int>>1,descram_out[53]};rx_st_int_split<=descram_out[54];rx_end_int_split<=descram_out[55];rx_dwen_int_split<=descram_out[56];rx_us_req_int_split<=descram_out[57];rx_malf_tlp_int_split<=descram_out[58];tcvc_map_0_split<={tcvc_map_0>>1,descram_out[59]};tcvc_map_1_split<={tcvc_map_1>>1,descram_out[60]};tcvc_map_2_split<={tcvc_map_2>>1,descram_out[61]};tcvc_map_3_split<={tcvc_map_3>>1,descram_out[62]};tcvc_map_4_split<={tcvc_map_4>>1,descram_out[63]};tcvc_map_5_split<={tcvc_map_5>>1,descram_out[64]};tcvc_map_6_split<={tcvc_map_6>>1,descram_out[65]};tcvc_map_7_split<={tcvc_map_7>>1,descram_out[66]};pkt_start_split<=descram_out[67];pkt_start_del1_split<=descram_out[68];pkt_start_del2_split<=descram_out[69];pkt_start_del3_split<=descram_out[70];pkt_start_del4_split<=descram_out[71];pkt_start_del5_split<=descram_out[72];pkt_end_split<=descram_out[73];header1_split<={header1>>1,descram_out[74]};mrd_split<=descram_out[75];mwr_split<=descram_out[76];io_split<=descram_out[77];cfg0_split<=descram_out[78];cfg1_split<=descram_out[79];msg_split<=descram_out[80];msgd_split<=descram_out[81];cfg_io_wr_split<=descram_out[82];p_type_split<=descram_out[83];np_type_split<=descram_out[84];malformed_pkt_split<=descram_out[85];end
always@* begin descram_in[2047]<=tlpdec_data[0];descram_in[2046]<=tlpdec_st;descram_in[2044]<=tlpdec_end;descram_in[2040]<=tlpdec_cfgrd;descram_in[2032]<=tlpdec_dwen;descram_in[2016]<=tlpdec_tc[0];descram_in[1985]<=tlpdec_us_req;descram_in[1950]<=tlpdec_data_reg1[0];descram_in[1930]<=tlpdec_st_reg3;descram_in[1923]<=tlpdec_malf_tlp;descram_in[1909]<=p_type;descram_in[1878]<=rx_dwen_int;descram_in[1870]<=mwr;descram_in[1852]<=tlpdec_data_reg2[0];descram_in[1813]<=tlpdec_end_reg0;descram_in[1799]<=dl_up[0];descram_in[1770]<=np_type;descram_in[1708]<=rx_us_req_int;descram_in[1693]<=io;descram_in[1656]<=tlpdec_data_reg3[0];descram_in[1578]<=tlpdec_end_reg1;descram_in[1573]<=tcvc_map_5[0];descram_in[1551]<=cfg_hit;descram_in[1493]<=rx_st_int;descram_in[1492]<=malformed_pkt;descram_in[1491]<=header1[0];descram_in[1417]<=tcvc_map_3[0];descram_in[1396]<=pkt_start_del5;descram_in[1378]<=tcvc_map_1[0];descram_in[1368]<=rx_malf_tlp_int;descram_in[1353]<=tc[0];descram_in[1345]<=tlpdec_dwen_reg2;descram_in[1339]<=cfg0;descram_in[1316]<=cfg_hit_r;descram_in[1285]<=us_req_reg0;descram_in[1265]<=tlpdec_st_reg0;descram_in[1262]<=msg;descram_in[1198]<=pkt_start_del2;descram_in[1169]<=vc_sel_del2[0];descram_in[1163]<=fmt[0];descram_in[1117]<=oflow_state[0];descram_in[1108]<=tlpdec_end_reg2;descram_in[1098]<=tcvc_map_6[0];descram_in[1054]<=bar_hit[0];descram_in[1045]<=us_req_reg2;descram_in[1023]<=cfgec_tvmap[0];descram_in[975]<=tlpdec_data_reg0[0];descram_in[965]<=tlpdec_st_reg2;descram_in[954]<=cfg_io_wr;descram_in[939]<=rx_end_int;descram_in[935]<=mrd;descram_in[786]<=tcvc_map_4[0];descram_in[746]<=rx_data_int[0];descram_in[745]<=pkt_end;descram_in[708]<=tcvc_map_2[0];descram_in[698]<=pkt_start_del4;descram_in[689]<=tcvc_map_0[0];descram_in[676]<=malf_tlp_reg3;descram_in[672]<=tlpdec_dwen_reg1;descram_in[658]<=vc_sel[0];descram_in[642]<=tlpdec_dwen_reg3;descram_in[631]<=cfg1;descram_in[599]<=pkt_start_del1;descram_in[584]<=vc_sel_del1[0];descram_in[581]<=vc_sel_del4[0];descram_in[558]<=length_4dw[0];descram_in[522]<=us_req_reg1;descram_in[487]<=bar_hit_val_r;descram_in[482]<=tlpdec_st_reg1;descram_in[477]<=msgd;descram_in[373]<=tlp_filter;descram_in[349]<=pkt_start_del3;descram_in[338]<=malf_tlp_reg2;descram_in[336]<=tlpdec_dwen_reg0;descram_in[299]<=pkt_start;descram_in[290]<=vc_sel_del3[0];descram_in[279]<=pkt_type[0];descram_in[243]<=bar_hit_r[0];descram_in[186]<=stored_type[0];descram_in[169]<=malf_tlp_reg1;descram_in[168]<=tlpdec_end_reg3;descram_in[149]<=tcvc_map_7[0];descram_in[121]<=fc_overflow;descram_in[84]<=malf_tlp_reg0;descram_in[60]<=bar_hit_val;descram_in[42]<=us_req_reg3;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_x4


// File             : tlp_dec.v


// Title            :


// Dependencies     : ecrc.v


// Description      : This module bassically multiplexes the two packet


//                    streams from user packet interface and packets from


//                    config copletion packet fifo.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Mar 12, 2004


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module tlpdec (
   
   input wire           sys_clk ,       
   input wire           rst_n ,         

   
   input wire [63:0]   rxtp_data ,     
   input wire          rxtp_st ,       
   input wire          rxtp_end ,      
   input wire          rxtp_dwen ,     
   input wire [2:0]    max_pl_size ,   
   `ifdef ECRC
      input wire       ecrc_enb ,      
   `endif

   input wire          vc_dl_up_fail ,  

   output reg [63:0]   tlpdec_data ,    
   output reg          tlpdec_st ,      
   output reg          tlpdec_end ,     
   output reg          tlpdec_dwen ,    
   output wire [2:0]   tlpdec_tc ,      

   output reg          tlpdec_cfgrd ,   
   output reg          tlpdec_cfgwr ,   
   output reg          tlpdec_memrw ,   
   output reg          tlpdec_iorw ,    
   output reg          tlpdec_rvcd_sts_ur , 
   output reg          tlpdec_rvcd_sts_ca , 
   output reg [31:0]   tlpdec_addr_l32 ,
   output reg [31:0]   tlpdec_addr_h32 ,
   output reg          tlpdec_addr64 ,  
   output reg          s2e_cnt_err ,    

   `ifdef ECRC
      output reg       tlpdec_ecrc_err , 
      output wire      crc_ok_out ,      
   `endif
   output reg          tlpdec_pois_tlp , 
   output reg          tlpdec_us_req ,   
   output reg          tlpdec_malf_tlp , 

   output reg          tlp_st_reg2 ,     
   output reg          tlp_end_reg2 ,    
   output reg          tlp_dwen_reg2 ,   
   output wire [63:0]  tlp_data_reg2     // rxtp_data delayed by 2 clk


   ) ;

`ifdef ECRC
reg                 ecrc_int_reg0 ;
reg                 ecrc_int_reg1 ;
reg                 ecrc_int_reg2 ;
reg                 ecrc_int_reg3 ;

`endif
reg [31:0]             header1 ;
reg [31:0]             header2 ;
reg                    tlp_dval ;
reg                    tlp_dval_r ;
reg                    tlp_st_reg1 ;
reg                    tlp_st_reg3 ;
reg                    tlp_end_reg1 ;
reg                    tlp_end_reg3 ;
reg                    tlp_dwen_reg1 ;
reg                    tlp_dwen_reg3 ;
reg [63:0]             rxtp_dreg1 ;
reg [63:0]             rxtp_dreg2 ;
reg [63:0]             rxtp_dreg3 ;
reg [10:0]             size_cnt ;
reg                    malf_tlp_int ;
reg                    malf_tlp_int_d0 ;
reg                    malf_tlp_int_d1 ;
reg                    unsup_req_int ;
reg                    unsup_req_int_d0 ;
reg                    unsup_req_int_d1 ;
reg                    pois_tlp_int_d0 ;
reg                    pois_tlp_int_d1 ;
reg [2:0]              maxpl_size_reg ;
reg                    tlp_size_err ;
wire [63:0]            tlp_data_reg1 ;
wire [1:0]             fmt ;
wire [4:0]             pkt_type ;
wire [2:0]             tc ;
wire                   td ;
wire                   ep ;
wire [1:0]             attr ;
wire [1:0]             at ;
wire [10:0]            length ;
wire [15:0]            req_id ;
wire [7:0]             tag ;
wire [2:0]             cmpl_sts ;
wire [3:0]             lbe ;
wire [3:0]             fbe ;
wire [7:0]             msg_code ;

`ifdef ECRC
wire [63:0]            crc_din ;
wire                   crc_val ;
wire                   enb_crc ;
wire [31:0]            crc_data ;
wire [31:0]            crc_result32 ;
wire [31:0]            crc_result64 ;
wire [31:0]            crc_out64 ;
wire [31:0]            crc_out32 ;
wire                   half_data ;
wire                   crc_ok32 ;
wire                   crc_ok64 ;
wire                   crc_ok ;
wire                   ecrc_err_int ;

`endif
wire                   cfg_reqmnt ;
wire [63:0]            tlpdec_data_int ;
wire                   tlpdec_st_int ;
wire                   tlp_length_err1 ;
wire                   tlp_length_err2 ;
wire                   tlp_length_err ;
wire                   length_err_enb ;
wire                   mrd_wr_type ;
wire                   iord_wr_type ;
wire                   c0rd_wr_type ;
wire                   c1rd_wr_type ;
wire                   tcfg_rw_type ;
wire                   msg_type ;
wire                   cpl_type ;
wire                   fmt_00 ;
wire                   fmt_01 ;
wire                   fmt_10 ;
wire                   fmt_11 ;
wire                   tlp_mrd  ;
wire                   tlp_mwr  ;
wire                   tlp_crd0 ;
wire                   tlp_cwr0 ;
wire                   tlp_msg  ;
wire                   tlp_msgd ;
wire                   tlp_cpl  ;
wire                   tlp_cpld ;
wire                   tlp_c1 ;
wire                   tlp_io ;
wire                   tlp_mrdlk ;
wire                   pm_msg ;
wire                   err_msg ;
wire                   vd_msg;
wire                   vd_msg_t0;
wire                   ig_msg ;
wire                   tlp_cpllk ;
wire                   tlp_cpldlk ;
wire                   undef_type ;
wire                   malf_msg ;
wire                   pois_tlp_int ;
wire                   addr64_int ;
wire                   vc_dl_up_err ;

`ifdef GEN2

`endif
reg tlp_length_err_r;
reg undef_type_r;
reg malf_msg_r;
reg vc_dl_up_err_r;
reg        s2e_cnt_en;
reg [10:0] s2e_cnt;
reg [10:0] exp_s2e_cnt;
reg        s2e_cnt_err_d0;
wire s2e_cnt_err_w ;

`ifdef GEN2

`else

`endif

`ifdef LEGACY_EP

`else

`endif

`ifdef ECRC

`endif

`ifdef ENDPOINT_COMP

`ifdef ECRC

`else

`endif

`else

`endif

`ifdef ECRC

`endif

`ifdef ECRC

`endif

`ifdef GEN2

`else

`endif
reg [63 : 0] rxtp_data_split;
reg rxtp_st_split;
reg rxtp_end_split;
reg rxtp_dwen_split;
reg [2 : 0] max_pl_size_split;
reg vc_dl_up_fail_split;
reg [31 : 0] header1_split;
reg [31 : 0] header2_split;
reg tlp_dval_split;
reg tlp_dval_r_split;
reg tlp_st_reg1_split;
reg tlp_st_reg3_split;
reg tlp_end_reg1_split;
reg tlp_end_reg3_split;
reg tlp_dwen_reg1_split;
reg tlp_dwen_reg3_split;
reg [63 : 0] rxtp_dreg1_split;
reg [63 : 0] rxtp_dreg2_split;
reg [63 : 0] rxtp_dreg3_split;
reg [10 : 0] size_cnt_split;
reg malf_tlp_int_split;
reg malf_tlp_int_d0_split;
reg malf_tlp_int_d1_split;
reg unsup_req_int_split;
reg unsup_req_int_d0_split;
reg unsup_req_int_d1_split;
reg pois_tlp_int_d0_split;
reg pois_tlp_int_d1_split;
reg [2 : 0] maxpl_size_reg_split;
reg tlp_size_err_split;
reg [63 : 0] tlp_data_reg1_split;
reg [1 : 0] fmt_split;
reg [4 : 0] pkt_type_split;
reg [2 : 0] tc_split;
reg td_split;
reg ep_split;
reg [1 : 0] attr_split;
reg [1 : 0] at_split;
reg [10 : 0] length_split;
reg [15 : 0] req_id_split;
reg [7 : 0] tag_split;
reg [2 : 0] cmpl_sts_split;
reg [3 : 0] lbe_split;
reg [3 : 0] fbe_split;
reg [7 : 0] msg_code_split;
reg cfg_reqmnt_split;
reg [63 : 0] tlpdec_data_int_split;
reg tlpdec_st_int_split;
reg tlp_length_err1_split;
reg tlp_length_err2_split;
reg tlp_length_err_split;
reg length_err_enb_split;
reg mrd_wr_type_split;
reg iord_wr_type_split;
reg c0rd_wr_type_split;
reg c1rd_wr_type_split;
reg tcfg_rw_type_split;
reg msg_type_split;
reg cpl_type_split;
reg fmt_00_split;
reg fmt_01_split;
reg fmt_10_split;
reg fmt_11_split;
reg tlp_mrd_split;
reg tlp_mwr_split;
reg tlp_crd0_split;
reg tlp_cwr0_split;
reg tlp_msg_split;
reg tlp_msgd_split;
reg tlp_cpl_split;
reg tlp_cpld_split;
reg tlp_c1_split;
reg tlp_io_split;
reg tlp_mrdlk_split;
reg pm_msg_split;
reg err_msg_split;
reg vd_msg_split;
reg vd_msg_t0_split;
reg ig_msg_split;
reg tlp_cpllk_split;
reg tlp_cpldlk_split;
reg undef_type_split;
reg malf_msg_split;
reg pois_tlp_int_split;
reg addr64_int_split;
reg vc_dl_up_err_split;
reg tlp_length_err_r_split;
reg undef_type_r_split;
reg malf_msg_r_split;
reg vc_dl_up_err_r_split;
reg s2e_cnt_en_split;
reg [10 : 0] s2e_cnt_split;
reg [10 : 0] exp_s2e_cnt_split;
reg s2e_cnt_err_d0_split;
reg s2e_cnt_err_w_split;
reg [2047:0] descram_in;
wire [94:0] descram_out;

`ifdef ECRC

`endif

`ifdef ECRC

`endif

`ifdef GEN2

`endif

`ifdef GEN2

`else

`endif

`ifdef LEGACY_EP

`else

`endif

`ifdef ECRC

`endif

`ifdef ENDPOINT_COMP

`ifdef ECRC

`else

`endif

`else

`endif

`ifdef ECRC

`endif

`ifdef ECRC


`endif

`ifdef GEN2

`else

`endif

localparam descram_inst_SIZE = 95,descram_inst_SCRAMSTRING = 32'hfdffea0b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;



`ifdef ECRC


`endif


`ifdef ECRC


`endif


`ifdef GEN2



`endif


`ifdef GEN2



`else



`endif



`ifdef LEGACY_EP



`else



`endif



`ifdef ECRC



`endif



`ifdef ENDPOINT_COMP



`ifdef ECRC



`else



`endif



`else



`endif



`ifdef ECRC



`endif



`ifdef ECRC



`endif



`ifdef GEN2



`else



`endif

// =============================================================================
//---- Regs


`ifdef ECRC


   

`endif



//---- Wires


`ifdef ECRC


   

`endif


// =============================================================================
// Pipeline the data path and associated boundary signals.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
     tlp_st_reg1  <= 1'b0 ;
     tlp_st_reg2  <= 1'b0 ;
     tlp_st_reg3  <= 1'b0 ;

     tlp_end_reg1 <= 1'b0 ;
     tlp_end_reg2 <= 1'b0 ;
     tlp_end_reg3 <= 1'b0 ;

     tlp_dwen_reg1 <= 1'b0 ;
     tlp_dwen_reg2 <= 1'b0 ;
     tlp_dwen_reg3 <= 1'b0 ;

     rxtp_dreg1  <= 64'd0 ;
     rxtp_dreg2  <= 64'd0 ;
     rxtp_dreg3  <= 64'd0 ;

     maxpl_size_reg <= 3'b000 ;
   end
   else begin
     tlp_st_reg1 <= rxtp_st_split ;
     tlp_st_reg2 <= tlp_st_reg1_split ;
     tlp_st_reg3 <= tlp_st_reg2 ;

     tlp_end_reg1 <= rxtp_end_split ;
     tlp_end_reg2 <= tlp_end_reg1_split ;
     tlp_end_reg3 <= tlp_end_reg2 ;

     tlp_dwen_reg1 <= rxtp_dwen_split ;
     tlp_dwen_reg2 <= tlp_dwen_reg1_split ;
     tlp_dwen_reg3 <= tlp_dwen_reg2 ;

     rxtp_dreg1  <= rxtp_data_split ;
     rxtp_dreg2  <= rxtp_dreg1_split ;
     rxtp_dreg3  <= rxtp_dreg2_split ;

     maxpl_size_reg <= max_pl_size_split ;
   end
end
assign tlp_data_reg2 = rxtp_dreg2_split;

// Generate oupput TLP data and start of tlp signal.
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
     tlpdec_st   <= 1'b0 ;
     tlpdec_data <= 64'd0 ;
   end
   else begin
     tlpdec_st   <= tlp_st_reg3_split ;
     tlpdec_data <= rxtp_dreg3_split ;
   end
end
assign tlpdec_tc   = (tlp_st_reg1_split) ? rxtp_dreg1_split[54:52] : header1_split[22:20] ;

// =============================================================================
// Generate end of TLP signals based on ECRC presence and
// corresponding Dword enable.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      tlpdec_end   <= 1'b0 ;
   else if (td_split)
      if (tlp_dwen_reg2)
         tlpdec_end <= tlp_end_reg2 ;
      else if (!tlp_dwen_reg3_split)
         tlpdec_end <= tlp_end_reg3_split ;
      else
         tlpdec_end <= 1'b0 ;
   else
      tlpdec_end <= tlp_end_reg3_split ;
end

// =============================================================================
// Generate output Dword enable signal based on ECRC presence
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      tlpdec_dwen <= 1'b0 ;
   else if (td_split)
      if (tlp_dwen_reg2)
         tlpdec_dwen <= ~tlp_dwen_reg2 & tlp_end_reg2 ;
      else if (!tlp_dwen_reg3_split)
         tlpdec_dwen <= ~tlp_dwen_reg3_split & tlp_end_reg3_split ;
      else
         tlpdec_dwen <= 1'b0 ;
   else
      tlpdec_dwen <= tlp_dwen_reg3_split ;
end

// =============================================================================
// Latch first & second header Dwords of the TLP.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
     header1 <= 32'hFF00_0000 ;
     header2 <= 32'hFF00_0000 ;
   end
   else if (tlp_st_reg1_split) begin
     header1 <= rxtp_dreg1_split[63:32] ;
     header2 <= rxtp_dreg1_split[31:0] ;
   end
   else if (tlp_end_reg3_split) begin
     header1 <= 32'hFF00_0000 ;
     header2 <= 32'hFF00_0000 ;
   end
end

// Decode TLP first header D-word components.
assign fmt    =  header1_split[30:29] ;
assign pkt_type   =  header1_split[28:24] ;
assign tc     =  header1_split[22:20] ;
assign td     =  header1_split[15] ;
assign ep     =  header1_split[14] ;
assign attr   =  header1_split[13:12] ;
assign at     =  header1_split[11:10] ;
assign length =  {~(|header1_split[9:0]),header1_split[9:0]} ;

// Decode type field.
assign mrd_wr_type  = (pkt_type_split ==  5'b0_0000) ;
assign iord_wr_type = (pkt_type_split ==  5'b0_0010) ;
assign c0rd_wr_type = (pkt_type_split ==  5'b0_0100) ;
assign c1rd_wr_type = (pkt_type_split ==  5'b0_0101) ;


`ifdef GEN2


   assign tcfg_rw_type = (pkt_type_split ==  5'b1_1011) ;


`endif


assign msg_type     = (pkt_type_split[4:3] ==  2'b10) & ~(pkt_type_split[2:1] ==  2'b11) ;
assign cpl_type     = (pkt_type_split ==  5'b0_1010) ;

// Decode fmt field.
assign fmt_00 = (fmt_split ==  2'b00) ;
assign fmt_01 = (fmt_split ==  2'b01) ;
assign fmt_10 = (fmt_split ==  2'b10) ;
assign fmt_11 = (fmt_split ==  2'b11) ;

// Decode TLP type by combining fmt and type.
// (Supported TLP types)
assign tlp_mrd  = (fmt_00_split | fmt_01_split) & mrd_wr_type_split ;
assign tlp_mwr  = (fmt_10_split | fmt_11_split) & mrd_wr_type_split ;
assign tlp_crd0 = fmt_00_split & c0rd_wr_type_split ;
assign tlp_cwr0 = fmt_10_split & c0rd_wr_type_split ;
assign tlp_msg  = fmt_01_split & msg_type_split ;
assign tlp_msgd = fmt_11_split & msg_type_split ;
assign tlp_cpl  = fmt_00_split & cpl_type_split ;
assign tlp_cpld = fmt_10_split & cpl_type_split ;

// Decode TLP type by combining fmt and type.
// (Un-Supported TLP types)
assign tlp_c1 = (fmt_00_split | fmt_10_split)  & c1rd_wr_type_split ;// for Type1 requests,UR response
                                                   // will be generated by core
assign tlp_io = (fmt_00_split | fmt_10_split)  & iord_wr_type_split ;
assign tlp_mrdlk = (fmt_00_split | fmt_01_split)  & (pkt_type_split ==  5'b0_0001) ;
assign tlp_cpllk = (fmt_00_split)  & (pkt_type_split ==  5'b0_1011) ;
assign tlp_cpldlk = (fmt_10_split)  & (pkt_type_split ==  5'b0_1011) ;

// Decode TLP second header D-word components.
assign req_id   =  header2_split[31:16] ;
assign tag      =  header2_split[15:8] ;
assign lbe      =  header2_split[7:4] ;
assign fbe      =  header2_split[3:0] ;
assign msg_code =  header2_split[7:0] ;
assign pm_msg   =  (msg_code_split[7:4] == 4'b0001) & ((msg_code_split[3:0] == 4'b0100) |
                                                 (msg_code_split[3:0] == 4'b1000) |
                                                 (msg_code_split[3:0] == 4'b1001) |
                                                 (msg_code_split[3:0] == 4'b1011)) ;
assign err_msg  =  (msg_code_split[7:4] == 4'b0011) & ((msg_code_split[3:0] == 4'b0000) |
                                                 (msg_code_split[3:0] == 4'b0001) |
                                                 (msg_code_split[3:0] == 4'b0011)) ;

 // No TC0 check for Vendor defined msg and Ignored msg
assign vd_msg    =  (msg_code_split[7:4] == 4'b0111) ? 1'b1 : 1'b0;
assign ig_msg    =  (msg_code_split[7:4] == 4'b0100) ? 1'b1 : 1'b0;
assign vd_msg_t0 =  vd_msg_split & (msg_code_split[3:0] == 4'b1110) ;

// Decode received completion status in completion TLPs.
assign cmpl_sts = header2_split[15:13] ;

// =============================================================================
// Generate TLP data valid signal from the start of packet
// upto end of packet indication.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      tlp_dval <= 1'b0 ;
   else if ( rxtp_st_split )
      tlp_dval <= 1'b1 ;
   else if (rxtp_end_split )
      tlp_dval <= 1'b0 ;
   else
      tlp_dval <= tlp_dval_split ;
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      tlp_dval_r <= 1'b0 ;
   else
      tlp_dval_r <= tlp_dval_split ;
end

// =============================================================================
// count the size of the TLP data payload.
// =============================================================================

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      size_cnt <= 11'h000 ;
   else if (tlp_end_reg1_split)
      size_cnt <= 11'h000 ;
   else if (tlp_dval_split && !tlp_size_err_split)
      if ((rxtp_dreg1_split[62:61] == 2'b10) && tlp_st_reg1_split)
         size_cnt <=  size_cnt_split + 11'h001 ;
      else if (td_split && !rxtp_dwen_split && rxtp_end_split)
         size_cnt <=  size_cnt_split + 11'h001 ;
      else if (!td_split && rxtp_dwen_split && rxtp_end_split)
         size_cnt <=  size_cnt_split + 11'h001 ;
      else if (!rxtp_dwen_split && !(tlp_st_reg1_split && (rxtp_dreg1_split[62:61] == 2'b11)))
         size_cnt <=  size_cnt_split + 11'h002 ;
   else
      size_cnt <= size_cnt_split ;
end

// =============================================================================
// Check whether size of TLP is more than max payload size.
// =============================================================================
always @(maxpl_size_reg_split or size_cnt_split) begin
   case (maxpl_size_reg_split)
      3'b000 :
         tlp_size_err = size_cnt_split[5] & size_cnt_split[0] ;
      3'b001 :
         tlp_size_err = size_cnt_split[6] & size_cnt_split[0] ;
      3'b010 :
         tlp_size_err = size_cnt_split[7] & size_cnt_split[0] ;
      3'b011 :
         tlp_size_err = size_cnt_split[8] & size_cnt_split[0] ;
      3'b100 :
         tlp_size_err = size_cnt_split[9] & size_cnt_split[0] ;
      3'b101 :
         tlp_size_err = size_cnt_split[10] & size_cnt_split[0] ;
      default :
         tlp_size_err = size_cnt_split[10] & size_cnt_split[0] ;
   endcase
end

// =============================================================================
// check for size match with length field and check for max pay load size.
// =============================================================================
// Lenght should be checked for these types of TLPs.
assign length_err_enb = (tlp_mwr_split | tlp_cpld_split | tlp_cpldlk_split) ;

// Length error when size of TLP exeeds length field.
assign tlp_length_err1 = (size_cnt_split > length_split) ;

// Length error when size of TLP doesn't match length field.
assign tlp_length_err2 = tlp_end_reg1_split & ((size_cnt_split ^ length_split) != 11'd0) ;

// combine both length errors.
assign tlp_length_err = ((tlp_length_err1_split | tlp_length_err2_split) & length_err_enb_split)  ;

// Decode for undefined type of TLPs.
assign undef_type = tlp_dval_r_split & (~tlp_mrd_split & ~tlp_mrdlk_split &
		                  ~tlp_mwr_split &
                                  ~tlp_io_split  &
			          ~tlp_crd0_split & ~tlp_cwr0_split & ~tlp_c1_split &
			  	  ~tlp_msg_split & ~tlp_msgd_split &
			 	  ~tlp_cpl_split & ~tlp_cpld_split &
		                  ~tlp_cpllk_split & ~tlp_cpldlk_split
			          ) ;

// Malformed TLP decode from message TLPs.
assign malf_msg = (tlp_dval_r_split & (fmt_01_split | fmt_11_split) & pkt_type_split[4] & ~vd_msg_split & ~ig_msg_split & (tc_split != 3'b00)) ;

// DL is not yet UP
assign vc_dl_up_err = tlp_dval_r_split & vc_dl_up_fail_split;


always @(posedge sys_clk or negedge rst_n)
   if (!rst_n) begin
      tlp_length_err_r <= 1'b0;
      undef_type_r     <= 1'b0;
      malf_msg_r       <= 1'b0;
      vc_dl_up_err_r   <= 1'b0;
   end
   else begin
      tlp_length_err_r <= tlp_length_err_split;
      undef_type_r     <= undef_type_split;
      malf_msg_r       <= malf_msg_split;
      vc_dl_up_err_r   <= vc_dl_up_err_split;
   end

// =============================================================================
// Count the entire packet based on Types and TD bit for ECRC.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      s2e_cnt_en <= 1'b0 ;
   else if (rxtp_st_split)
      s2e_cnt_en <= 1'b1 ;
   else if (tlp_end_reg1_split)
      s2e_cnt_en <= 1'b0 ;
end
// Counting DWord for the entire packet
//
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      s2e_cnt <= 11'h000 ;
   else if (rxtp_st_split)
      s2e_cnt <= 11'h000 ;
   else if (s2e_cnt_en_split)
      s2e_cnt <= tlp_dwen_reg1_split ? s2e_cnt_split + 1 : s2e_cnt_split + 2 ;
end
// Expected DWord based on Field values
//
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      exp_s2e_cnt <= 11'h000 ;
   else if (tlp_end_reg1_split) begin
      if (fmt_00_split && !td_split) exp_s2e_cnt <= 'd3 ;
      if (fmt_00_split && td_split) exp_s2e_cnt <= 'd4 ;
      if (fmt_01_split && !td_split) exp_s2e_cnt <= 'd4 ;
      if (fmt_01_split && td_split) exp_s2e_cnt <= 'd5 ;
      if (fmt_10_split && !td_split && (iord_wr_type_split || c0rd_wr_type_split || c1rd_wr_type_split))
         exp_s2e_cnt <= 'd4 ;
      if (fmt_10_split && td_split && (iord_wr_type_split || c0rd_wr_type_split || c1rd_wr_type_split))
         exp_s2e_cnt <= 'd5 ;
      if (fmt_11_split && !td_split && msg_type_split) exp_s2e_cnt <= 'd5 ;
      if (fmt_11_split && td_split && msg_type_split) exp_s2e_cnt <= 'd6 ;
   end
end

assign s2e_cnt_err_w = tlp_end_reg2 && (s2e_cnt_split != exp_s2e_cnt_split) && !undef_type_r_split &&
                       !malf_msg_r_split && !tlp_mwr_split && !tlp_cpld_split && !tlp_cpldlk_split ;

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      s2e_cnt_err_d0 <= 1'b0 ;
      s2e_cnt_err <= 1'b0 ;
   end
   else begin
      s2e_cnt_err_d0 <= s2e_cnt_err_w_split ;
      s2e_cnt_err <= s2e_cnt_err_d0_split ;
   end
end


// =============================================================================
// Generate internal malformed TLP indication.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      malf_tlp_int <= 1'b0 ;
   else if (tlp_end_reg2)
      malf_tlp_int <= 1'b0 ;
   

`ifdef GEN2


      else if (tlp_end_reg1_split & (tlp_size_err_split | tlp_length_err_split | undef_type_split | tcfg_rw_type_split | malf_msg_split | vc_dl_up_err_split))
         malf_tlp_int <= 1'b1 ;
   

`else


      else if (tlp_end_reg1_split & (tlp_size_err_split | tlp_length_err_split | undef_type_split | malf_msg_split | vc_dl_up_err_split))
         malf_tlp_int <= 1'b1 ;
   

`endif


   else
      malf_tlp_int <= malf_tlp_int_split ;
end


// =============================================================================
// Generate internal Unsupported request TLP indication.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      unsup_req_int <= 1'b0 ;
   else if (tlp_end_reg2)
      unsup_req_int <= 1'b0 ;
   

`ifdef LEGACY_EP


   else if (tlp_end_reg1_split & tlp_c1_split)
      unsup_req_int <= 1'b1 ;
   

`else


   else if (tlp_end_reg1_split & (tlp_c1_split | tlp_mrdlk_split))
      unsup_req_int <= 1'b1 ;
   

`endif


   else
      unsup_req_int <= unsup_req_int_split ;
end

// =============================================================================
// Generate internal ECRC error indication
// =============================================================================


`ifdef ECRC


   assign ecrc_err_int = ecrc_enb & td_split & ~crc_ok & crc_val ;
   always @(posedge sys_clk or negedge rst_n) begin
	   if (!rst_n) begin
         ecrc_int_reg0 <= 1'b0 ;
         ecrc_int_reg1 <= 1'b0 ;
         ecrc_int_reg2 <= 1'b0 ;
         ecrc_int_reg3 <= 1'b0 ;
      end
      else begin
         ecrc_int_reg0 <= ecrc_err_int ;
         ecrc_int_reg1 <= ecrc_int_reg0;
         ecrc_int_reg2 <= ecrc_int_reg1;
         ecrc_int_reg3 <= ecrc_int_reg2;
      end
   end



`endif



// =============================================================================
// Generate internal Poisoned TLP indication
// =============================================================================

   assign pois_tlp_int = ep_split & tlp_end_reg1_split  & (tlp_mwr_split | tlp_cpld_split | tlp_cwr0_split) ;

// =============================================================================
// Register all internal check signals.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      unsup_req_int_d0 <= 1'b0 ;
      unsup_req_int_d1 <= 1'b0 ;
      malf_tlp_int_d0 <= 1'b0 ;
      malf_tlp_int_d1 <= 1'b0 ;
      pois_tlp_int_d0 <= 1'b0 ;
      pois_tlp_int_d1 <= 1'b0 ;
   end
   else begin
      unsup_req_int_d0 <= unsup_req_int_split ;
      unsup_req_int_d1 <= unsup_req_int_d0_split ;

      malf_tlp_int_d0 <= malf_tlp_int_split ;
      malf_tlp_int_d1 <= malf_tlp_int_d0_split ;

      pois_tlp_int_d0 <= pois_tlp_int_split ;
      pois_tlp_int_d1 <= pois_tlp_int_d0_split ;
   end
end

// =============================================================================
// Give out all Ckeck signals alligning to end og TLP
// indications, based on Dword enables.
// =============================================================================


`ifdef ENDPOINT_COMP




`ifdef ECRC


  always @(posedge sys_clk or negedge rst_n) begin
     if (!rst_n)
        tlpdec_us_req <= 1'b0 ;
     else if (!td_split)
        tlpdec_us_req <= unsup_req_int_d0_split ;
     else begin
        if (tlp_dwen_reg2)
           tlpdec_us_req <= unsup_req_int_split & ~malf_tlp_int_split & ~ecrc_int_reg0 & ~s2e_cnt_err_w_split ;
        else if (!tlp_dwen_reg3_split)
           tlpdec_us_req <= unsup_req_int_d0_split & ~malf_tlp_int_d0_split & ~ecrc_int_reg1 & ~s2e_cnt_err_d0_split ;
        else
           tlpdec_us_req <= 1'b0 ;
     end
  end


`else


  always @(posedge sys_clk or negedge rst_n) begin
     if (!rst_n)
        tlpdec_us_req <= 1'b0 ;
     else if (!td_split)
        tlpdec_us_req <= unsup_req_int_d0_split ;
     else begin
        if (tlp_dwen_reg2)
           tlpdec_us_req <= unsup_req_int_split & ~malf_tlp_int_split & ~s2e_cnt_err_w_split ;
        else if (!tlp_dwen_reg3_split)
           tlpdec_us_req <= unsup_req_int_d0_split & ~malf_tlp_int_d0_split & ~s2e_cnt_err_d0_split ;
        else
           tlpdec_us_req <= 1'b0 ;
     end
  end


`endif





`else



  always @(posedge sys_clk or negedge rst_n) begin
     if (!rst_n)
        tlpdec_us_req <= 1'b0 ;
     else
        tlpdec_us_req <= 1'b0 ;
  end



`endif





`ifdef ECRC


   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n)
         tlpdec_ecrc_err <= 1'b0 ;
      else if (!td_split)
         tlpdec_ecrc_err <= 1'b0 ;
      else begin
         if (tlp_dwen_reg2)
            tlpdec_ecrc_err <= ecrc_int_reg0 & ~malf_tlp_int_split & ~s2e_cnt_err_w_split ;
         else if (!tlp_dwen_reg3_split)
            tlpdec_ecrc_err <= ecrc_int_reg1 & ~malf_tlp_int_d0_split & ~s2e_cnt_err_d0_split ;
         else
            tlpdec_ecrc_err <= 1'b0 ;
      end
   end


`endif



always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
       tlpdec_malf_tlp <= 1'b0 ;
   else if (!td_split)
       tlpdec_malf_tlp <= malf_tlp_int_d0_split | s2e_cnt_err_d0_split ;
   else begin
      if (tlp_dwen_reg2)
         tlpdec_malf_tlp <= malf_tlp_int_split | s2e_cnt_err_w_split ;
      else if (!tlp_dwen_reg3_split)
         tlpdec_malf_tlp <= malf_tlp_int_d0_split | s2e_cnt_err_d0_split ;
      else
         tlpdec_malf_tlp <= 1'b0 ;
   end
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
       tlpdec_pois_tlp <= 1'b0 ;
   else if (!td_split)
       tlpdec_pois_tlp <= pois_tlp_int_d0_split ;
   else begin
      if (tlp_dwen_reg2)
         tlpdec_pois_tlp <= pois_tlp_int_split ;
      else if (!tlp_dwen_reg3_split)
         tlpdec_pois_tlp <= pois_tlp_int_d0_split ;
      else
         tlpdec_pois_tlp <= 1'b0 ;
   end
end



`ifdef ECRC


   // =============================================================================
   // TLP data for ECRC calculation.
   // Bit 0 of type field and EP bit has to be set to "1"
   // for ECRC calculations. Ref 2.7.1 of spec.
   // =============================================================================
   assign crc_din =  rxtp_st_split ? {rxtp_data_split[63:57], 1'b1, rxtp_data_split[55:47],
                                1'b1, rxtp_data_split[45:32], rxtp_data_split[31:0]} : rxtp_data_split ;

   assign half_data = (~rxtp_dwen_split & rxtp_end_split)  ;

   // Get ECRC accumulated out and reset for the next TLP.
   assign crc_val = tlp_end_reg1_split ;

   // Ebable ECRC accumulation during the TLP.
   assign enb_crc = (rxtp_st_split | (tlp_dval_split & ~rxtp_dwen_split)) ;

   ecrc #(
      .D_WIDTH    ( 64 ) )
      u2_ecrc(
      .sys_clk    ( sys_clk ) ,
      .rst_n      ( rst_n ) ,

      .data_in    ( crc_din ) ,
      .enable_crc ( enb_crc ) ,
      .half_data  ( half_data ) ,
      .rst_crc    ( crc_val ) ,

      .crc_out64  ( crc_out64 ) ,
      .crc_out32  ( crc_out32 )
      ) ;

   // XOR the computed CRC with extracted CRC.
   assign crc_result32 = (crc_out32 ^ rxtp_dreg1_split[31:0] ) ;
   assign crc_result64 = (crc_out64 ^ rxtp_dreg1_split[63:32] ) ;

   // Choose crc64 or crc32 based on dwen
   assign crc_ok32 = (crc_result32 == 32'h0000_0000) ;
   assign crc_ok64 = (crc_result64 == 32'h0000_0000) ;
   assign crc_ok = (tlp_dwen_reg1_split) ? crc_ok64 : crc_ok32 ;
   assign crc_ok_out  = ecrc_enb & td_split & crc_ok;


`endif



// =============================================================================
// =============================================================================


`ifdef GEN2


   assign cfg_reqmnt = (tc_split == 3'b000) & (attr_split == 2'b00) & (at_split == 2'b00) &
                       (length_split == 11'h01) & (lbe_split == 4'h0) ;


`else


   assign cfg_reqmnt = (tc_split == 3'b000) & (attr_split == 2'b0) &
                       (length_split == 11'h01) & (lbe_split == 4'h0) ;


`endif



always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      tlpdec_cfgrd  <= 1'b0 ;
      tlpdec_cfgwr  <= 1'b0 ;
   end
   else begin
      // tlpdec_cfgrd  <= tlp_crd0 & cfg_reqmnt & tlp_st_reg3  ;
      // tlpdec_cfgwr  <= tlp_cwr0 & cfg_reqmnt & tlp_st_reg3 ;
      // Don't do this optional check for these field for config packets.
      // malformed_tlp needs to be generated if if fields are not correct.
      tlpdec_cfgrd  <= tlp_crd0_split & tlp_st_reg3_split  ;
      tlpdec_cfgwr  <= tlp_cwr0_split & tlp_st_reg3_split ;
   end
end
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      tlpdec_memrw  <= 1'b0 ;
   else if (tlp_st_reg3_split && mrd_wr_type_split)
      tlpdec_memrw  <= 1'b1 ;
   else if (tlpdec_end)
      tlpdec_memrw  <= 1'b0 ;
   else
      tlpdec_memrw  <= tlpdec_memrw ;
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      tlpdec_iorw  <= 1'b0 ;
   else if (tlp_st_reg3_split && iord_wr_type_split)
      tlpdec_iorw  <= 1'b1 ;
   else if (tlpdec_end)
      tlpdec_iorw  <= 1'b0 ;
   else
      tlpdec_iorw  <= tlpdec_iorw ;
end

assign addr64_int = (mrd_wr_type_split && (fmt_01_split | fmt_11_split)) ;

// decode unsupported request and completion abort
// status received in a completion TLP
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      tlpdec_rvcd_sts_ur  <= 1'b0 ;
      tlpdec_rvcd_sts_ca  <= 1'b0 ;
   end
   else if (tlp_st_reg3_split && (tlp_cpl_split || tlp_cpld_split)) begin
      tlpdec_rvcd_sts_ur <= (cmpl_sts_split == 3'b001) ;
      tlpdec_rvcd_sts_ca <= (cmpl_sts_split == 3'b100) ;
   end
   else begin
      tlpdec_rvcd_sts_ur  <= 1'b0 ;
      tlpdec_rvcd_sts_ca  <= 1'b0 ;
   end
end

// =============================================================================
// Latch the lower 32 and higher 32 bits addresses.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      tlpdec_addr_l32 <= 32'h0000_0000;
      tlpdec_addr_h32 <= 32'h0000_0000;
   end
   else if (tlp_st_reg3_split && !addr64_int_split ) begin
      tlpdec_addr_l32 <= rxtp_dreg2_split[63:32] ;
      tlpdec_addr_h32 <= 32'h0000_0000;
   end
   else if (tlp_st_reg3_split && addr64_int_split ) begin
      tlpdec_addr_l32 <= rxtp_dreg2_split[31:0] ;
      tlpdec_addr_h32 <= rxtp_dreg2_split[63:32] ;
   end
   else if (tlpdec_end ) begin
      tlpdec_addr_l32 <= 32'h0000_0000;
      tlpdec_addr_h32 <= 32'h0000_0000;
   end
   else begin
      tlpdec_addr_l32 <= tlpdec_addr_l32 ;
      tlpdec_addr_h32 <= tlpdec_addr_h32 ;
   end
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      tlpdec_addr64  <= 1'b0 ;
   else if (tlp_st_reg3_split && addr64_int_split )
      tlpdec_addr64  <= 1'b1 ;
   else if (tlpdec_end)
      tlpdec_addr64  <= 1'b0 ;
   else
      tlpdec_addr64  <= tlpdec_addr64 ;
end

always@* begin rxtp_data_split<={rxtp_data>>1,descram_out[0]};rxtp_st_split<=descram_out[1];rxtp_end_split<=descram_out[2];rxtp_dwen_split<=descram_out[3];max_pl_size_split<={max_pl_size>>1,descram_out[4]};vc_dl_up_fail_split<=descram_out[5];header1_split<={header1>>1,descram_out[6]};header2_split<={header2>>1,descram_out[7]};tlp_dval_split<=descram_out[8];tlp_dval_r_split<=descram_out[9];tlp_st_reg1_split<=descram_out[10];tlp_st_reg3_split<=descram_out[11];tlp_end_reg1_split<=descram_out[12];tlp_end_reg3_split<=descram_out[13];tlp_dwen_reg1_split<=descram_out[14];tlp_dwen_reg3_split<=descram_out[15];rxtp_dreg1_split<={rxtp_dreg1>>1,descram_out[16]};rxtp_dreg2_split<={rxtp_dreg2>>1,descram_out[17]};rxtp_dreg3_split<={rxtp_dreg3>>1,descram_out[18]};size_cnt_split<={size_cnt>>1,descram_out[19]};malf_tlp_int_split<=descram_out[20];malf_tlp_int_d0_split<=descram_out[21];malf_tlp_int_d1_split<=descram_out[22];unsup_req_int_split<=descram_out[23];unsup_req_int_d0_split<=descram_out[24];unsup_req_int_d1_split<=descram_out[25];pois_tlp_int_d0_split<=descram_out[26];pois_tlp_int_d1_split<=descram_out[27];maxpl_size_reg_split<={maxpl_size_reg>>1,descram_out[28]};tlp_size_err_split<=descram_out[29];tlp_data_reg1_split<={tlp_data_reg1>>1,descram_out[30]};fmt_split<={fmt>>1,descram_out[31]};pkt_type_split<={pkt_type>>1,descram_out[32]};tc_split<={tc>>1,descram_out[33]};td_split<=descram_out[34];ep_split<=descram_out[35];attr_split<={attr>>1,descram_out[36]};at_split<={at>>1,descram_out[37]};length_split<={length>>1,descram_out[38]};req_id_split<={req_id>>1,descram_out[39]};tag_split<={tag>>1,descram_out[40]};cmpl_sts_split<={cmpl_sts>>1,descram_out[41]};lbe_split<={lbe>>1,descram_out[42]};fbe_split<={fbe>>1,descram_out[43]};msg_code_split<={msg_code>>1,descram_out[44]};cfg_reqmnt_split<=descram_out[45];tlpdec_data_int_split<={tlpdec_data_int>>1,descram_out[46]};tlpdec_st_int_split<=descram_out[47];tlp_length_err1_split<=descram_out[48];tlp_length_err2_split<=descram_out[49];tlp_length_err_split<=descram_out[50];length_err_enb_split<=descram_out[51];mrd_wr_type_split<=descram_out[52];iord_wr_type_split<=descram_out[53];c0rd_wr_type_split<=descram_out[54];c1rd_wr_type_split<=descram_out[55];tcfg_rw_type_split<=descram_out[56];msg_type_split<=descram_out[57];cpl_type_split<=descram_out[58];fmt_00_split<=descram_out[59];fmt_01_split<=descram_out[60];fmt_10_split<=descram_out[61];fmt_11_split<=descram_out[62];tlp_mrd_split<=descram_out[63];tlp_mwr_split<=descram_out[64];tlp_crd0_split<=descram_out[65];tlp_cwr0_split<=descram_out[66];tlp_msg_split<=descram_out[67];tlp_msgd_split<=descram_out[68];tlp_cpl_split<=descram_out[69];tlp_cpld_split<=descram_out[70];tlp_c1_split<=descram_out[71];tlp_io_split<=descram_out[72];tlp_mrdlk_split<=descram_out[73];pm_msg_split<=descram_out[74];err_msg_split<=descram_out[75];vd_msg_split<=descram_out[76];vd_msg_t0_split<=descram_out[77];ig_msg_split<=descram_out[78];tlp_cpllk_split<=descram_out[79];tlp_cpldlk_split<=descram_out[80];undef_type_split<=descram_out[81];malf_msg_split<=descram_out[82];pois_tlp_int_split<=descram_out[83];addr64_int_split<=descram_out[84];vc_dl_up_err_split<=descram_out[85];tlp_length_err_r_split<=descram_out[86];undef_type_r_split<=descram_out[87];malf_msg_r_split<=descram_out[88];vc_dl_up_err_r_split<=descram_out[89];s2e_cnt_en_split<=descram_out[90];s2e_cnt_split<={s2e_cnt>>1,descram_out[91]};exp_s2e_cnt_split<={exp_s2e_cnt>>1,descram_out[92]};s2e_cnt_err_d0_split<=descram_out[93];s2e_cnt_err_w_split<=descram_out[94];end
always@* begin descram_in[2047]<=rxtp_st;descram_in[2046]<=rxtp_end;descram_in[2044]<=rxtp_dwen;descram_in[2040]<=max_pl_size[0];descram_in[2032]<=vc_dl_up_fail;descram_in[2016]<=header1[0];descram_in[1984]<=header2[0];descram_in[1980]<=tlp_data_reg1[0];descram_in[1950]<=unsup_req_int_d0;descram_in[1930]<=ep;descram_in[1921]<=tlp_dval;descram_in[1912]<=fmt[0];descram_in[1853]<=unsup_req_int_d1;descram_in[1818]<=vd_msg_t0;descram_in[1813]<=attr[0];descram_in[1806]<=mrd_wr_type;descram_in[1802]<=fmt_00;descram_in[1795]<=tlp_dval_r;descram_in[1777]<=pkt_type[0];descram_in[1746]<=s2e_cnt_err_d0;descram_in[1685]<=pois_tlp_int;descram_in[1659]<=pois_tlp_int_d0;descram_in[1648]<=tlp_length_err1;descram_in[1630]<=rxtp_dreg3[0];descram_in[1588]<=ig_msg;descram_in[1578]<=at[0];descram_in[1564]<=iord_wr_type;descram_in[1556]<=fmt_01;descram_in[1542]<=tlp_st_reg1;descram_in[1511]<=malf_tlp_int_d1;descram_in[1506]<=tc[0];descram_in[1460]<=s2e_cnt[0];descram_in[1445]<=s2e_cnt_err_w;descram_in[1436]<=tlpdec_data_int[0];descram_in[1389]<=vc_dl_up_err_r;descram_in[1383]<=msg_code[0];descram_in[1369]<=lbe[0];descram_in[1323]<=addr64_int;descram_in[1280]<=tlp_cwr0;descram_in[1271]<=pois_tlp_int_d1;descram_in[1249]<=tlp_length_err2;descram_in[1212]<=size_cnt[0];descram_in[1197]<=tlp_length_err_r;descram_in[1129]<=tlp_cpllk;descram_in[1109]<=length[0];descram_in[1080]<=c0rd_wr_type;descram_in[1064]<=fmt_10;descram_in[1036]<=tlp_st_reg3;descram_in[1027]<=tlp_msgd;descram_in[1023]<=rxtp_data[0];descram_in[990]<=tlp_size_err;descram_in[975]<=unsup_req_int;descram_in[965]<=td;descram_in[909]<=vd_msg;descram_in[903]<=length_err_enb;descram_in[901]<=cpl_type;descram_in[873]<=exp_s2e_cnt[0];descram_in[842]<=malf_msg;descram_in[824]<=tlpdec_st_int;descram_in[815]<=rxtp_dreg2[0];descram_in[755]<=malf_tlp_int_d0;descram_in[730]<=s2e_cnt_en;descram_in[718]<=cfg_reqmnt;descram_in[694]<=malf_msg_r;descram_in[691]<=fbe[0];descram_in[684]<=cmpl_sts[0];descram_in[640]<=tlp_crd0;descram_in[598]<=vc_dl_up_err;descram_in[513]<=tlp_msg;descram_in[495]<=maxpl_size_reg[0];descram_in[454]<=err_msg;descram_in[451]<=tlp_length_err;descram_in[450]<=msg_type;descram_in[421]<=undef_type;descram_in[407]<=rxtp_dreg1[0];descram_in[377]<=malf_tlp_int;descram_in[347]<=undef_type_r;descram_in[342]<=tag[0];descram_in[320]<=tlp_mwr;descram_in[227]<=pm_msg;descram_in[225]<=tcfg_rw_type;descram_in[210]<=tlp_cpldlk;descram_in[203]<=tlp_dwen_reg3;descram_in[171]<=req_id[0];descram_in[160]<=tlp_mrd;descram_in[113]<=tlp_mrdlk;descram_in[112]<=c1rd_wr_type;descram_in[101]<=tlp_dwen_reg1;descram_in[80]<=fmt_11;descram_in[56]<=tlp_io;descram_in[50]<=tlp_end_reg3;descram_in[28]<=tlp_c1;descram_in[25]<=tlp_end_reg1;descram_in[14]<=tlp_cpld;descram_in[7]<=tlp_cpl;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.23 2007/05/25 16:53:49PDT uananthi


// us_req is generated for type1 also.


// Revision 1.22 2007/05/18 13:29:56PDT uananthi


// added tlpdec_rvcd_sts_ur and tlpdec_rvcd_sts_ca


// tlpdec_addr_h32 made'd0 in 3dw TLP.


// Revision 1.21 2007/04/12 10:51:31PDT uananthi


// added support for type1 request.


// Revision 1.20 2007/03/07 15:07:07PST srajadur


// trnc\rxtrn\tlpdec.v(Line 607): Need to rewrite the code to allow the


// obf tool correctly parse the code;


// Revision 1.19 2007/03/01 11:03:12PST uananthi


// updated tlpdec_us_req generation.


// Revision 1.18 2006/12/21 16:12:30PST srajadur


// tlp_tc updated


// Revision 1.17 2006/12/20 09:36:33PST srajadur


// size cnt logic updated


// Revision 1.16 2006/12/15 18:22:08PST srajadur


// malf and unsup error adjusted


// Revision 1.15 2006/12/07 10:36:53PST gkrishna


// Updated header1/2 storage


// Revision 1.16 2006/11/30 16:56:32PST gkrishna


// Cleared header1/header2 at tlp_end_reg1


// Revision 1.14 2006/10/27 13:56:01PDT rperugu


// tlpdec_tc is given ahead so that vc_dl_ip_fail is generated ahead for tlp_dec so that


// it can use in generating mal formed signal.


// Accordingly vc_sel is delayed by 4 clks in rxintf module.


// Revision 1.13 2006/08/01 12:32:24PDT gkrishna


// Updated malf_tlp_int & unsup_req_int generation


// Revision 1.12 2006/08/01 09:40:33PDT gkrishna


// Updated delay on malf_tlp signal


// Revision 1.11 2006/07/26 15:49:30PDT uananthi


// added vd_msg_to logic.


// Revision 1.10 2006/07/05 16:17:28PDT uananthi


// removed io decode from us_req generation.


// Revision 1.9 2006/06/26 12:34:56PDT gkrishna


// Added  tlpdec_tc


// Revision 1.8 2006/06/22 11:35:42PDT gkrishna


// Removed one stage


// Revision 1.7 2006/06/20 16:53:38PDT gkrishna


// Updated crc_ok_out


// Revision 1.6 2006/06/16 15:07:05PDT gkrishna


//


// Revision 1.5 2006/06/16 14:48:33PDT gkrishna


// Added delayed signals


// Revision 1.4 2006/06/16 08:21:01PDT gkrishna


//


// Revision 1.3 2006/06/16 08:16:46PDT gkrishna


// Added crc_ok_out


// Revision 1.2 2006/05/23 13:58:27PDT gkrishna


// updated for x4




// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_x4


// File             : tlpgen.v


// Title            :


// Dependencies     : ecrc.v


// Description      : This module bassically multiplexes the two packet 


//                    streams from user packet interface and packets from 


//                    config copletion packet fifo.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Mar 12, 2004


// Changes Made     : Initial Creation


// =============================================================================




`timescale 1 ns / 100 ps
module tlpgen (
   
   sys_clk ,
   rst_n ,

   
   txintf_data ,
   txintf_st ,
   txintf_end ,
   txintf_nlfy ,
   txintf_dwen ,
   txintf_val ,
   txintf_rdy_ack ,
   `ifdef ECRC
      ecrc_enb ,
   `endif

   
   tlpgen_data ,
   tlpgen_tval ,
   tlpgen_st ,
   tlpgen_end ,
   tlpgen_nlfy , 
   tlpgen_dwen ,  
   tlpgen_rdy_ack   
   ) ;
parameter D_WIDTH = 64 ;
input                  sys_clk ;
input                  rst_n ;
input [D_WIDTH -1:0]  txintf_data ;
input                  txintf_st ;
input                  txintf_end ;
input                  txintf_nlfy ;
input                  txintf_dwen ;
input                  txintf_val ;
input                  txintf_rdy_ack ;

`ifdef ECRC
input               ecrc_enb ;

`endif
output [D_WIDTH -1:0] tlpgen_data ;
output                 tlpgen_tval ;
output                 tlpgen_st ;
output                 tlpgen_end ;
output                 tlpgen_nlfy ;
output                 tlpgen_dwen ;
output                 tlpgen_rdy_ack ;
reg [D_WIDTH -1:0]     tlpgen_data/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpgen_req/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpgen_st/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpgen_end/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpgen_nlfy/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpgen_tval/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpgen_dwen_int/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpgen_rdy_ack/* synthesis syn_srlstyle="registers" */ ;
reg [D_WIDTH -1:0]     tlpu_dreg/* synthesis syn_srlstyle="registers" */ ;
reg [D_WIDTH -1:0]     tlpu_dreg1/* synthesis syn_srlstyle="registers" */ ;
reg [D_WIDTH -1:0]     tlpu_dreg2/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_streg/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_streg1/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_streg2/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_endreg/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_endreg1/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_endreg2/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_nlfyreg/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_nlfyreg1/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_nlfyreg2/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_dwenreg/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_dwenreg1/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_dwenreg2/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_rackreg/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_rackreg1/* synthesis syn_srlstyle="registers" */ ;
reg                    tlpu_rackreg2/* synthesis syn_srlstyle="registers" */ ;
reg                    tlp_dval/* synthesis syn_srlstyle="registers" */ ;
reg                    txtp_rdy_reg/* synthesis syn_srlstyle="registers" */ ;
reg                    tlp_denb_reg/* synthesis syn_srlstyle="registers" */  ;
reg                    tlp_denb_reg1/* synthesis syn_srlstyle="registers" */  ;
reg                    txintf_val0/* synthesis syn_srlstyle="registers" */ ;
reg                    txintf_val1/* synthesis syn_srlstyle="registers" */ ;
reg                    txintf_val2/* synthesis syn_srlstyle="registers" */ ;
reg                    pkt_ecrc_enb ;

`ifdef ECRC
reg  [31:0]         crc_out64_reg ;
reg  [31:0]         crc_out64_reg1 ;
reg                 crc_val64 ;
wire                crc_val ;
wire                crc_val32 ;
wire                enb_crc ;
wire                half_data ;
wire [D_WIDTH -1:0] crc_din ;
wire [31:0]         crc_data ;
wire [31:0]         crc_out64 ;
wire [31:0]         crc_out32 ;

`endif
wire                   tlp_denb ;
wire                   rdy_pause ;
wire                   tlpgen_dwen ;

`ifdef ECRC

`else 

`endif 

`ifdef ECRC

`else 

`endif 

`ifdef ECRC

`endif 

`ifdef ECRC

`else 

`endif 

`ifdef ECRC

`else 

`endif 

`ifdef ECRC

`else 

`endif 
reg [D_WIDTH - 1 : 0] txintf_data_split;
reg txintf_st_split;
reg txintf_end_split;
reg txintf_nlfy_split;
reg txintf_dwen_split;
reg txintf_val_split;
reg txintf_rdy_ack_split;
reg tlpgen_req_split;
reg tlpgen_dwen_int_split;
reg [D_WIDTH - 1 : 0] tlpu_dreg_split;
reg [D_WIDTH - 1 : 0] tlpu_dreg1_split;
reg [D_WIDTH - 1 : 0] tlpu_dreg2_split;
reg tlpu_streg_split;
reg tlpu_streg1_split;
reg tlpu_streg2_split;
reg tlpu_endreg_split;
reg tlpu_endreg1_split;
reg tlpu_endreg2_split;
reg tlpu_nlfyreg_split;
reg tlpu_nlfyreg1_split;
reg tlpu_nlfyreg2_split;
reg tlpu_dwenreg_split;
reg tlpu_dwenreg1_split;
reg tlpu_dwenreg2_split;
reg tlpu_rackreg_split;
reg tlpu_rackreg1_split;
reg tlpu_rackreg2_split;
reg tlp_dval_split;
reg txtp_rdy_reg_split;
reg tlp_denb_reg_split;
reg tlp_denb_reg1_split;
reg txintf_val0_split;
reg txintf_val1_split;
reg txintf_val2_split;
reg pkt_ecrc_enb_split;
reg tlp_denb_split;
reg rdy_pause_split;
reg [2047:0] descram_in;
wire [36:0] descram_out;

`ifdef ECRC

`endif

`ifdef ECRC

`endif

`ifdef ECRC

`else 

`endif 

`ifdef ECRC

`else 

`endif 

`ifdef ECRC


`endif 

`ifdef ECRC

`else 

`endif 

`ifdef ECRC

`else 

`endif 

`ifdef ECRC

`else 

`endif 

localparam descram_inst_SIZE = 37,descram_inst_SCRAMSTRING = 32'hfdffea0b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef ECRC


`endif


`ifdef ECRC


`endif


`ifdef ECRC



`else 



`endif 



`ifdef ECRC



`else 



`endif 



`ifdef ECRC



`endif 



`ifdef ECRC



`else 



`endif 



`ifdef ECRC



`else 



`endif 



`ifdef ECRC



`else 



`endif 

// =============================================================================
// Parameters 
// =============================================================================
// for common parameters
//#include "pci_exp_dparams.v"
// =============================================================================
// Define all inputs / outputs
// =============================================================================
//---------Inputs------------
// Core clock.
// asynchronous system reset.

// Input data from user logic
// start of pkt from user logic.
// End of pkt from user logic. 
// End of nullified pkt from user logic. 
// Dword enable.
// data valid.


`ifdef ECRC


   // Enable ECRC.


`endif



//---------Outputs------------
// TLP data to DLL.
// TLP valid.
// Start of TLP.
// End of TLP. 
// Nullified TLP.
// Dword enable.
// =============================================================================
// Define Wire & Registers 
// =============================================================================
//---- Wires
//---- Wires


`ifdef ECRC


   

`endif



// =============================================================================
// This module bassically calculates 32 bit ECRC and appends at the end of
// the packet if "ecrc_enb" is set. Also re-aligns the the data and boundary 
// signals accordingly.  
// =============================================================================

// Pipeline input signals from transmit user interface.
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin  
      tlpu_dreg     <= {(D_WIDTH){1'b0}} ;
      tlpu_dreg1    <= {(D_WIDTH){1'b0}} ;
      tlpu_dreg2    <= {(D_WIDTH){1'b0}} ;

      tlpu_streg    <= 1'b0 ;
      tlpu_streg1   <= 1'b0 ;
      tlpu_streg2   <= 1'b0 ;

      tlpu_endreg   <= 1'b0 ;
      tlpu_endreg1  <= 1'b0 ;
      tlpu_endreg2  <= 1'b0 ;

      tlpu_nlfyreg  <= 1'b0 ;
      tlpu_nlfyreg1 <= 1'b0 ;
      tlpu_nlfyreg2 <= 1'b0 ;

      tlpu_dwenreg  <= 1'b0 ;
      tlpu_dwenreg1 <= 1'b0 ;
      tlpu_dwenreg2 <= 1'b0 ;

      tlpu_rackreg  <= 1'b0 ;
      tlpu_rackreg1 <= 1'b0 ;
      tlpu_rackreg2 <= 1'b0 ;
   end
   else if (txintf_val_split) begin 
      tlpu_dreg     <= txintf_data_split ;
      tlpu_dreg1    <= tlpu_dreg_split ;
      tlpu_dreg2    <= tlpu_dreg1_split ;

      tlpu_streg    <= txintf_st_split ;
      tlpu_streg1   <= tlpu_streg_split ;
      tlpu_streg2   <= tlpu_streg1_split ;

      tlpu_endreg   <= txintf_end_split ;
      tlpu_endreg1  <= tlpu_endreg_split ;
      tlpu_endreg2  <= tlpu_endreg1_split ;

      tlpu_nlfyreg  <= txintf_nlfy_split ;
      tlpu_nlfyreg1 <= tlpu_nlfyreg_split ;
      tlpu_nlfyreg2 <= tlpu_nlfyreg1_split ;

      tlpu_dwenreg  <= txintf_dwen_split ;
      tlpu_dwenreg1 <= tlpu_dwenreg_split ;
      tlpu_dwenreg2 <= tlpu_dwenreg1_split ;

      tlpu_rackreg  <= txintf_rdy_ack_split ;
      tlpu_rackreg1 <= tlpu_rackreg_split ;
      tlpu_rackreg2 <= tlpu_rackreg1_split ;
   end
end

// =============================================================================
// Generate packet data valid signal from the start of packet
// upto end of packet indication.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)  
      tlp_dval <= 1'b0 ;
   else if ( tlpu_streg_split && txintf_val_split ) 
      tlp_dval <= 1'b1 ;
   else if ( tlpu_endreg_split && txintf_val_split ) 
      tlp_dval <= 1'b0 ;
   else  
      tlp_dval <= tlp_dval_split ;
end

assign tlp_denb  = (tlpu_streg_split | tlp_dval_split) ;
// =============================================================================
// Generate pk_ecrc_enb for each packet when TD bit is set and ecrc_enb is set 
// =============================================================================


`ifdef ECRC


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n)   
         pkt_ecrc_enb <= 1'b0 ;
      else if (tlpu_streg_split && txintf_val_split)   
         pkt_ecrc_enb <= tlpu_dreg_split[47] & ecrc_enb ;
   end


`else 




`endif 


// =============================================================================
// Multiplex paxket data from user interface, config completion
// packet data from "cong_rmux" block and calculated CRC.
// =============================================================================
always @(*) begin
   

`ifdef ECRC


      if (pkt_ecrc_enb_split)    
         case (1'b1)
            crc_val64 : 
               tlpgen_data = {crc_out64_reg, 32'h0000_0000} ;
            tlpu_dwenreg1_split :
               tlpgen_data = {tlpu_dreg1_split[63:32], crc_out32} ;
            tlp_denb_reg_split : 
               tlpgen_data = tlpu_dreg1_split ;
         default :  
            tlpgen_data = {(D_WIDTH){1'b0}} ;
         endcase   
      else if (tlp_denb_reg_split ) 
         tlpgen_data = tlpu_dreg1_split ;
      else
         tlpgen_data = {(D_WIDTH){1'b0}} ;
   

`else 


      if (tlp_denb_reg_split) 
         tlpgen_data = tlpu_dreg1_split ;
      else
         tlpgen_data = {(D_WIDTH){1'b0}} ;
   

`endif 


end



`ifdef ECRC


   assign crc_din   =  tlpu_streg_split ? {tlpu_dreg_split[63:57], 1'b1, tlpu_dreg_split[55:47], 1'b1,
                                   tlpu_dreg_split[45:32], tlpu_dreg_split[31:0]} : tlpu_dreg_split ;
   assign half_data = tlpu_dwenreg_split & txintf_val_split ;
   assign crc_val   = tlpu_endreg1_split  & txintf_val_split;
   assign enb_crc   = tlp_denb_split & txintf_val_split;

   ecrc u2_ecrc(
      .sys_clk    ( sys_clk ) ,
      .rst_n      ( rst_n ) ,

      .data_in    ( crc_din ) ,
      .enable_crc ( enb_crc ) , 
      .half_data  ( half_data ) , 
      .rst_crc    ( crc_val ) , 

      .crc_out64  ( crc_out64 ) ,
      .crc_out32  ( crc_out32 )
      ) ;

   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) begin   
         crc_out64_reg  <= 32'h0000_0000 ;
         crc_out64_reg1 <= 32'h0000_0000 ;
         crc_val64      <= 1'b0 ;
      end
      else if (txintf_val_split) begin 
         crc_out64_reg  <= crc_out64 ;
         crc_out64_reg1 <= crc_out64_reg ;
         crc_val64      <= tlpu_endreg1_split & ~tlpu_dwenreg1_split ;
      end
   end



`endif 



always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin   
      tlp_denb_reg   <= 1'b0 ;
      tlp_denb_reg1  <= 1'b0 ;
   end
   else if (txintf_val_split) begin 
      tlp_denb_reg   <= tlp_denb_split ;
      tlp_denb_reg1  <= tlp_denb_reg_split ;
   end
end

// =============================================================================
// Generate end of TLP signal based on Dword enable and ECRC enable
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)   
      tlpgen_end   <= 1'b0 ;
   else if (txintf_val_split) begin  
   

`ifdef ECRC


      if (pkt_ecrc_enb_split)    
         tlpgen_end <= ((tlpu_endreg_split & tlpu_dwenreg_split) | 
                        (tlpu_endreg1_split & ~tlpu_dwenreg1_split)) ;
      else     
         tlpgen_end <= tlpu_endreg_split ;
   

`else 


      tlpgen_end <= tlpu_endreg_split ;
   

`endif 


   end     
end

// =============================================================================
// Generate nulified end of TLP signal based on Dword enable and ECRC enable
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)   
      tlpgen_nlfy   <= 1'b0 ;
   else if (txintf_val_split) begin  
   

`ifdef ECRC


      if (pkt_ecrc_enb_split)    
         tlpgen_nlfy <= ((tlpu_nlfyreg_split & tlpu_dwenreg_split) | 
                         (tlpu_nlfyreg1_split & ~tlpu_dwenreg1_split)) ;
      else     
         tlpgen_nlfy <= tlpu_nlfyreg_split ;
   

`else 


      tlpgen_nlfy <= tlpu_nlfyreg_split ;
   

`endif 


   end     
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)   
       tlpgen_dwen_int <= 1'b0 ;
   else if (txintf_val_split) begin  
   

`ifdef ECRC


      if (pkt_ecrc_enb_split)    
         tlpgen_dwen_int <= ~tlpu_dwenreg_split ;
      else     
         tlpgen_dwen_int <= tlpu_dwenreg_split ;
   

`else 


      tlpgen_dwen_int <= tlpu_dwenreg_split ;
   

`endif 


   end     
end

assign tlpgen_dwen = tlpgen_dwen_int_split & (tlpgen_end | tlpgen_nlfy) ; 

// =============================================================================
// Generate packet start signal for DLL alligned with TLP data stream.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)   
      tlpgen_st <= 1'b0 ;
   else if (txintf_val_split)  
      tlpgen_st <= tlpu_streg_split ;
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin   
      txintf_val0 <= 1'b0 ;
      txintf_val1 <= 1'b0 ;
      txintf_val2 <= 1'b0 ;
      tlpgen_tval  <= 1'b0 ;
   end
   else begin    
      txintf_val0 <= txintf_val_split ;
      txintf_val1 <= txintf_val0_split ;
      txintf_val2 <= txintf_val1_split ;
      tlpgen_tval <= txintf_val2_split ;
   end
end

// =============================================================================
// Generate rdy ack for DLL alligned with TLP data stream.
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)   
      tlpgen_rdy_ack <= 1'b0 ;
   else if (txintf_val_split)   
      tlpgen_rdy_ack <= tlpu_rackreg1_split ;
end

always@* begin txintf_data_split<={txintf_data>>1,descram_out[0]};txintf_st_split<=descram_out[1];txintf_end_split<=descram_out[2];txintf_nlfy_split<=descram_out[3];txintf_dwen_split<=descram_out[4];txintf_val_split<=descram_out[5];txintf_rdy_ack_split<=descram_out[6];tlpgen_req_split<=descram_out[7];tlpgen_dwen_int_split<=descram_out[8];tlpu_dreg_split<={tlpu_dreg>>1,descram_out[9]};tlpu_dreg1_split<={tlpu_dreg1>>1,descram_out[10]};tlpu_dreg2_split<={tlpu_dreg2>>1,descram_out[11]};tlpu_streg_split<=descram_out[12];tlpu_streg1_split<=descram_out[13];tlpu_streg2_split<=descram_out[14];tlpu_endreg_split<=descram_out[15];tlpu_endreg1_split<=descram_out[16];tlpu_endreg2_split<=descram_out[17];tlpu_nlfyreg_split<=descram_out[18];tlpu_nlfyreg1_split<=descram_out[19];tlpu_nlfyreg2_split<=descram_out[20];tlpu_dwenreg_split<=descram_out[21];tlpu_dwenreg1_split<=descram_out[22];tlpu_dwenreg2_split<=descram_out[23];tlpu_rackreg_split<=descram_out[24];tlpu_rackreg1_split<=descram_out[25];tlpu_rackreg2_split<=descram_out[26];tlp_dval_split<=descram_out[27];txtp_rdy_reg_split<=descram_out[28];tlp_denb_reg_split<=descram_out[29];tlp_denb_reg1_split<=descram_out[30];txintf_val0_split<=descram_out[31];txintf_val1_split<=descram_out[32];txintf_val2_split<=descram_out[33];pkt_ecrc_enb_split<=descram_out[34];tlp_denb_split<=descram_out[35];rdy_pause_split<=descram_out[36];end
always@* begin descram_in[2047]<=txintf_st;descram_in[2046]<=txintf_end;descram_in[2044]<=txintf_nlfy;descram_in[2040]<=txintf_dwen;descram_in[2032]<=txintf_val;descram_in[2016]<=txintf_rdy_ack;descram_in[1984]<=tlpgen_req;descram_in[1980]<=tlp_denb_reg1;descram_in[1950]<=tlpu_rackreg;descram_in[1930]<=tlp_denb;descram_in[1921]<=tlpgen_dwen_int;descram_in[1912]<=txintf_val0;descram_in[1853]<=tlpu_rackreg1;descram_in[1813]<=rdy_pause;descram_in[1795]<=tlpu_dreg[0];descram_in[1777]<=txintf_val1;descram_in[1659]<=tlpu_rackreg2;descram_in[1630]<=tlpu_nlfyreg;descram_in[1542]<=tlpu_dreg1[0];descram_in[1511]<=tlpu_dwenreg1;descram_in[1506]<=txintf_val2;descram_in[1271]<=tlp_dval;descram_in[1212]<=tlpu_nlfyreg1;descram_in[1036]<=tlpu_dreg2[0];descram_in[1023]<=txintf_data[0];descram_in[990]<=tlp_denb_reg;descram_in[975]<=tlpu_dwenreg2;descram_in[965]<=pkt_ecrc_enb;descram_in[815]<=tlpu_endreg2;descram_in[755]<=tlpu_dwenreg;descram_in[495]<=txtp_rdy_reg;descram_in[407]<=tlpu_endreg1;descram_in[377]<=tlpu_nlfyreg2;descram_in[203]<=tlpu_endreg;descram_in[101]<=tlpu_streg2;descram_in[50]<=tlpu_streg1;descram_in[25]<=tlpu_streg;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================








// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express X4


// File             : lp_arb.v


// Title            : Low Priority VC Arbitration logic


// Dependencies     : pci_exp_params.v


// Description      : This module implements the VC arbitration logic


//                    1) Low prio


//                       a)RR


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : April 13, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module lp_arb
   (
    input wire       sys_clk,            
    input wire       rst_n,              

    input wire       pkt_progress,       
    input wire [2:0] cfgec_vcasel,       
    input wire [7:0] lp_tx_req,          
    input wire       tx_eop_early,       
    input wire       tx_data_algn,       
    input wire       enb_lp_arb,         
    `ifdef X4
       input wire       txintf_val,
    `endif

    
    output reg       lp_grant_val,       
    output reg [7:0] lp_arb_grant        // Indicates the LP VC Arb grant


    );
parameter LPEVCC  = `LPEVCC;
wire                      inc_vc_counter;
reg   [7:0]               mod_tx_req;
reg   [7:0]               mod_tx_req_d0;
reg   [7:0]               mod_tx_req_d1;
reg   [7:0]               mod_tx_req_d2;
reg                       lp_arb_remove;
reg  [2:0]                arb_vc_num;
reg  [4:0]                vc_counter;
reg  [4:0]                vc_counter_d0;
reg  [4:0]                vc_counter_d1;
reg  [4:0]                vc_counter_d2;
reg  [4:0]                vc_counter_d3;
reg                       rr_enable;
reg                       update_arb_d0;
reg                       update_arb_d1;
reg                       update_arb_d2;
reg                       update_arb_d3;
reg                       pkt_progress_d0;

`ifdef X4

`endif

`ifdef X1

`endif
reg pkt_progress_split;
reg [2 : 0] cfgec_vcasel_split;
reg [7 : 0] lp_tx_req_split;
reg tx_eop_early_split;
reg tx_data_algn_split;
reg enb_lp_arb_split;
reg inc_vc_counter_split;
reg [7 : 0] mod_tx_req_split;
reg [7 : 0] mod_tx_req_d0_split;
reg [7 : 0] mod_tx_req_d1_split;
reg [7 : 0] mod_tx_req_d2_split;
reg lp_arb_remove_split;
reg [2 : 0] arb_vc_num_split;
reg [4 : 0] vc_counter_split;
reg [4 : 0] vc_counter_d0_split;
reg [4 : 0] vc_counter_d1_split;
reg [4 : 0] vc_counter_d2_split;
reg [4 : 0] vc_counter_d3_split;
reg rr_enable_split;
reg update_arb_d0_split;
reg update_arb_d1_split;
reg update_arb_d2_split;
reg update_arb_d3_split;
reg pkt_progress_d0_split;
reg [2047:0] descram_in;
wire [23:0] descram_out;

`ifdef X4

`endif

`ifdef X1

`endif

localparam descram_inst_SIZE = 24,descram_inst_SCRAMSTRING = 32'hfdffd14b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X4



`endif



`ifdef X1



`endif

// =============================================================================
// Define Wire & Registers
// =============================================================================
//---- Wires
//---- Register


`ifdef X4


   assign txintf_val_xx = txintf_val;


`endif




`ifdef X1


   assign txintf_val_xx = 1'b1;


`endif


// =============================================================================
// Generate the appropriate defines to select the appropriate  FOUR 32 VC Tables
// =============================================================================
// VC Number   Priority
// VC 7          SP      <-------  Extended VC Count, EVCC = 7
// VC 6          SP
// VC 5          SP
//------------------------------------------------------------------------------
// VC 4          LP      <-------  Low Priority Extended VC Count, LPEVCC = 4
// VC 3          LP
// VC 2          LP
// VC 1          LP
// VC 0          LP
// =============================================================================
// =============================================================================
// The following block generates the RR request based on the VC Arb Sel value
// in the register
// WRR NOT Supported
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      rr_enable      <= 1'b0;
      pkt_progress_d0<= 1'b0;
   end
   else begin
      rr_enable      <= (cfgec_vcasel_split == 3'b000) ? 1'b1 : 1'b0;
      pkt_progress_d0<= pkt_progress_split;
   end
end

// =============================================================================
// The following block generates the arbitration on LOW PRIORITY
// VC Arbitration
// The following are the different Low priority Arbitation allowed
// 1) Round Robin
// 2) Weighted Round Robin 32  Phases
// 3) Weighted Round Robin 64  Phases
// 4) Weighted Round Robin 128 Phases
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      lp_arb_grant  <= 8'd0;
      lp_arb_remove <= 1'b0;
   end
   else if (enb_lp_arb_split) begin
      case(arb_vc_num_split)
         3'd7: begin
            if (mod_tx_req_split[7] || mod_tx_req_d2_split[7] || lp_tx_req_split[7]) begin
              lp_arb_grant[7]   <= 1'b1;
              lp_arb_grant[6:0] <= 7'd0;
              lp_arb_remove     <= 1'b0;
            end
            else if (mod_tx_req_split[7] == 1'b0 && pkt_progress_d0_split == 1'b0) begin
              lp_arb_grant      <= 8'd0;
              lp_arb_remove     <= 1'b1;
            end
         end
         3'd6: begin
            if (mod_tx_req_split[6] || mod_tx_req_d2_split[6] || lp_tx_req_split[6]) begin
              lp_arb_grant[7]   <= 1'b0;
	      lp_arb_grant[6]   <= 1'b1;
              lp_arb_grant[5:0] <= 6'd0;
              lp_arb_remove     <= 1'b0;
            end
            else if (mod_tx_req_split[6] == 1'b0 && pkt_progress_d0_split == 1'b0) begin
              lp_arb_grant      <= 8'd0;
              lp_arb_remove     <= 1'b1;
            end
         end
         3'd5: begin
            if (mod_tx_req_split[5] || mod_tx_req_d2_split[5] || lp_tx_req_split[5]) begin
              lp_arb_grant[7:6] <= 2'd0;
	      lp_arb_grant[5]   <= 1'b1;
              lp_arb_grant[4:0] <= 5'd0;
              lp_arb_remove     <= 1'b0;
            end
            else if (mod_tx_req_split[5] == 1'b0 && pkt_progress_d0_split == 1'b0) begin
              lp_arb_grant      <= 8'd0;
              lp_arb_remove     <= 1'b1;
            end
         end
         3'd4: begin
            if (mod_tx_req_split[4] || mod_tx_req_d2_split[4] || lp_tx_req_split[4]) begin
              lp_arb_grant[7:5] <= 3'd0;
	      lp_arb_grant[4]   <= 1'b1;
              lp_arb_grant[3:0] <= 4'd0;
              lp_arb_remove     <= 1'b0;
            end
            else if (mod_tx_req_split[4] == 1'b0 && pkt_progress_d0_split == 1'b0) begin
              lp_arb_grant      <= 8'd0;
              lp_arb_remove     <= 1'b1;
            end
         end
         3'd3: begin
            if (mod_tx_req_split[3] || mod_tx_req_d2_split[3] || lp_tx_req_split[3]) begin
              lp_arb_grant[7:4] <= 4'd0;
	      lp_arb_grant[3]   <= 1'b1;
              lp_arb_grant[2:0] <= 3'd0;
              lp_arb_remove     <= 1'b0;
            end
            else if (mod_tx_req_split[3] == 1'b0 && pkt_progress_d0_split == 1'b0) begin
              lp_arb_grant      <= 8'd0;
              lp_arb_remove     <= 1'b1;
            end
         end
         3'd2: begin
            if (mod_tx_req_split[2] || mod_tx_req_d2_split[2] || lp_tx_req_split[2]) begin
              lp_arb_grant[7:3] <= 5'd0;
	      lp_arb_grant[2]   <= 1'b1;
              lp_arb_grant[1:0] <= 2'd0;
              lp_arb_remove     <= 1'b0;
            end
            else if (mod_tx_req_split[2] == 1'b0 && pkt_progress_d0_split == 1'b0) begin
              lp_arb_grant      <= 8'd0;
              lp_arb_remove     <= 1'b1;
            end
         end
         3'd1: begin
            if (mod_tx_req_split[1] || mod_tx_req_d2_split[1] || lp_tx_req_split[1]) begin
              lp_arb_grant[7:2] <= 6'd0;
	      lp_arb_grant[1]   <= 1'b1;
              lp_arb_grant[0]   <= 1'd0;
              lp_arb_remove     <= 1'b0;
            end
            else if (mod_tx_req_split[1] == 1'b0 && pkt_progress_d0_split == 1'b0) begin
              lp_arb_grant      <= 8'd0;
              lp_arb_remove     <= 1'b1;
            end
         end
         default: begin
            if (mod_tx_req_split[0] || mod_tx_req_d2_split[0] || lp_tx_req_split[0]) begin
              lp_arb_grant[7:1] <= 7'd0;
	      lp_arb_grant[0]   <= 1'b1;
              lp_arb_remove     <= 1'b0;
            end
            else if (mod_tx_req_split[0] == 1'b0 && pkt_progress_d0_split == 1'b0) begin
              lp_arb_grant      <= 8'd0;
              lp_arb_remove     <= 1'b1;
            end
         end
      endcase
   end
   else begin
      lp_arb_grant      <= 8'd0;
      lp_arb_remove     <= 1'b0;
   end
end

// =============================================================================
// The following implements the common counter used for Round robin
// The following counter increments only when (vc_counter == vc_counter_d2)
// this is because the latency invilved in giving tine vc count to getting the
// arb vc num
// =============================================================================
assign inc_vc_counter = tx_eop_early_split | lp_arb_remove_split;

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      vc_counter <= 5'd0;
   end
   else if (enb_lp_arb_split && inc_vc_counter_split && txintf_val_xx) begin
      if ((rr_enable_split     && vc_counter_d2_split == LPEVCC)) begin
         vc_counter <= 5'd0;
      end
      else if (vc_counter_split == vc_counter_d2_split && txintf_val_xx) begin
         vc_counter <= vc_counter_split + 1;
      end
   end
end

// =============================================================================
// The following generated the delayed signals
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      vc_counter_d0 <= 5'd0;
      vc_counter_d1 <= 5'd0;
      vc_counter_d2 <= 5'd0;
      vc_counter_d3 <= 5'd0;

      update_arb_d0 <= 1'b0;
      update_arb_d1 <= 1'b0;
      update_arb_d2 <= 1'b0;
      update_arb_d3 <= 1'b0;

      mod_tx_req     <= 'd0;
      mod_tx_req_d0  <= 'd0;
      mod_tx_req_d1  <= 'd0;
      mod_tx_req_d2  <= 'd0;
   end
   else if (txintf_val_xx) begin
      vc_counter_d0 <= vc_counter_split;
      vc_counter_d1 <= vc_counter_d0_split;
      vc_counter_d2 <= vc_counter_d1_split;
      vc_counter_d3 <= vc_counter_d2_split;

      update_arb_d0 <= (enb_lp_arb_split && tx_eop_early_split) ? 1'b1: 1'b0;
      update_arb_d1 <= update_arb_d0_split;
      update_arb_d2 <= update_arb_d1_split;
      update_arb_d3 <= update_arb_d2_split;

      mod_tx_req_d0  <= mod_tx_req_split;
      mod_tx_req_d1  <= mod_tx_req_d0_split;
      mod_tx_req_d2  <= mod_tx_req_d1_split;
      // This log makes sure the lp_tx_req do not come when arb_num_vc has already shifted.
      // arb_num_vc    000000111112222
      // lp_tx_req[0]  0001111xxxxxxxx
      case(vc_counter_d3_split)
         'd7: mod_tx_req[7] <= lp_tx_req_split[7];
         'd6: mod_tx_req[6] <= lp_tx_req_split[6];
         'd5: mod_tx_req[5] <= lp_tx_req_split[5];
         'd4: mod_tx_req[4] <= lp_tx_req_split[4];
         'd3: mod_tx_req[3] <= lp_tx_req_split[3];
         'd2: mod_tx_req[2] <= lp_tx_req_split[2];
         'd1: mod_tx_req[1] <= lp_tx_req_split[1];
         'd0: mod_tx_req[0] <= lp_tx_req_split[0];
      endcase
   end
end

// =============================================================================
// The following will extend the lp_grant_val for one clock cycle when ECRC
// is present
// When ECRC is present & if DATA LENGTH is aligned delay one more clock
// =============================================================================
always @(*) begin
   if (enb_lp_arb_split && (tx_eop_early_split || update_arb_d0_split || update_arb_d1_split  || update_arb_d2_split || (tx_data_algn_split && update_arb_d3_split))) begin
      lp_grant_val = 1'b0;
   end
   else if (enb_lp_arb_split) begin
      lp_grant_val = 1'b1;
   end
   else begin
      lp_grant_val = 1'b0;
   end
end

// =============================================================================
// The following block reads the VC table register for 32 phases
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      arb_vc_num <= 5'd0;
   end
   else if (rr_enable_split && txintf_val_xx) begin
      arb_vc_num <= vc_counter_split[2:0];
   end
end

always@* begin pkt_progress_split<=descram_out[0];cfgec_vcasel_split<={cfgec_vcasel>>1,descram_out[1]};lp_tx_req_split<={lp_tx_req>>1,descram_out[2]};tx_eop_early_split<=descram_out[3];tx_data_algn_split<=descram_out[4];enb_lp_arb_split<=descram_out[5];inc_vc_counter_split<=descram_out[6];mod_tx_req_split<={mod_tx_req>>1,descram_out[7]};mod_tx_req_d0_split<={mod_tx_req_d0>>1,descram_out[8]};mod_tx_req_d1_split<={mod_tx_req_d1>>1,descram_out[9]};mod_tx_req_d2_split<={mod_tx_req_d2>>1,descram_out[10]};lp_arb_remove_split<=descram_out[11];arb_vc_num_split<={arb_vc_num>>1,descram_out[12]};vc_counter_split<={vc_counter>>1,descram_out[13]};vc_counter_d0_split<={vc_counter_d0>>1,descram_out[14]};vc_counter_d1_split<={vc_counter_d1>>1,descram_out[15]};vc_counter_d2_split<={vc_counter_d2>>1,descram_out[16]};vc_counter_d3_split<={vc_counter_d3>>1,descram_out[17]};rr_enable_split<=descram_out[18];update_arb_d0_split<=descram_out[19];update_arb_d1_split<=descram_out[20];update_arb_d2_split<=descram_out[21];update_arb_d3_split<=descram_out[22];pkt_progress_d0_split<=descram_out[23];end
always@* begin descram_in[2047]<=cfgec_vcasel[0];descram_in[2046]<=lp_tx_req[0];descram_in[2044]<=tx_eop_early;descram_in[2040]<=tx_data_algn;descram_in[2033]<=enb_lp_arb;descram_in[2019]<=inc_vc_counter;descram_in[1990]<=mod_tx_req[0];descram_in[1939]<=rr_enable;descram_in[1933]<=mod_tx_req_d0[0];descram_in[1831]<=update_arb_d0;descram_in[1819]<=mod_tx_req_d1[0];descram_in[1778]<=vc_counter_d1[0];descram_in[1615]<=update_arb_d1;descram_in[1591]<=mod_tx_req_d2[0];descram_in[1508]<=vc_counter_d2[0];descram_in[1182]<=update_arb_d2;descram_in[1135]<=lp_arb_remove;descram_in[1023]<=pkt_progress;descram_in[969]<=vc_counter_d3[0];descram_in[889]<=vc_counter_d0[0];descram_in[635]<=pkt_progress_d0;descram_in[444]<=vc_counter[0];descram_in[317]<=update_arb_d3;descram_in[222]<=arb_vc_num[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.5 2007/06/19 08:45:14PDT gkrishna


// Added lp_tx_req to generate grant


// Revision 1.4 2007/04/06 11:43:06PDT gkrishna


// updated fix to makes sure the lp_tx_req do not come when arb_num_vc has already shifted


// Revision 1.3 2006/06/01 10:11:14PDT gkrishna


// Updated defines


// Revision 1.2 2006/05/23 11:59:46PDT gkrishna


// Updated with x1 fixes


// Revision 1.12 2005/03/07 16:31:06PST gkrishna


// Added pkt_progress signal


// Revision 1.11 2005/03/03 13:43:27PST gkrishna


// Fixed lp_grant_val when lp is disabled


// Revision 1.10 2004/08/04 09:04:11PDT gkrishna


// Added txintf_val


// Revision 1.9 2004/07/19 16:55:09PDT gkrishna


// Added lp_tx_req_d0/d1/d2


// Revision 1.8 2004/07/06 14:14:38PDT gkrishna


// Updated lp_arb_grant generation


// Revision 1.7 2004/05/05 11:35:52PDT gkrishna


// Updated grant generation


// Revision 1.6 2004/05/04 15:47:18PDT gkrishna


// Fixed Arb logic when round robin unused VC.


// Revision 1.5 2004/04/22 12:41:23PDT gkrishna


// Updated logic to generate packet gap for one VC


// Revision 1.4 2004/04/22 09:25:50PDT gkrishna


// Added tx_data_align signal to add 2 clock cycle gap between packets.


// Revision 1.3 2004/04/21 15:24:47PDT gkrishna


// Updated logic


// Revision 1.2 2004/04/21 11:15:21PDT gkrishna


// Added grant valid signal.


// Revision 1.1 2004/04/16 14:37:05PDT gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express X4


// File             : sp_arb.v


// Title            : Strict Priority VC Arbitration logic


// Dependencies     : pci_exp_params.v


// Description      : This module implements the VC arbitration logic


//                    1) Strict prio


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : April 13, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module sp_arb
   (
    input wire       sys_clk,            
    input wire       rst_n,              
    input wire [7:0] sp_tx_req,          
    input wire       enb_sp_arb,         
    input wire       tx_eop_early,       
    input wire       tx_data_algn,       

    `ifdef X4
       input wire    txintf_val,
    `endif

    output reg       sp_grant_val,       
    output reg [7:0] sp_arb_grant        // Indicates the SP VC Arb grant


    );
reg                       eop_d0;
reg                       eop_d1;
reg                       eop_d2;
reg                       eop_d3;
reg    [1:0]              cs_sp_arb;
parameter SP_WAIT = 2'd0;
parameter SP_EOP  = 2'd1;

`ifdef X4

`endif

`ifdef X1

`endif
reg [7 : 0] sp_tx_req_split;
reg enb_sp_arb_split;
reg tx_eop_early_split;
reg tx_data_algn_split;
reg eop_d1_split;
reg eop_d2_split;
reg eop_d3_split;
reg [1 : 0] cs_sp_arb_split;
reg [2047:0] descram_in;
wire [7:0] descram_out;

`ifdef X4

`endif

`ifdef X1

`endif

localparam descram_inst_SIZE = 8,descram_inst_SCRAMSTRING = 32'hfdffd48b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X4



`endif



`ifdef X1



`endif

// =============================================================================
//---- Register
// Define parameters


`ifdef X4


   assign txintf_val_xx = txintf_val;


`endif




`ifdef X1


   assign txintf_val_xx = 1'b1;


`endif



// =============================================================================
// Generate the appropriate defines to select the appropriate  FOUR 32 VC Tables
// =============================================================================
// VC Number   Priority
// VC 7          SP      <-------  Extended VC Count, EVCC = 7
// VC 6          SP
// VC 5          SP
//------------------------------------------------------------------------------
// VC 4          LP      <-------  Low Priority Extended VC Count, LPEVCC = 4
// VC 3          LP
// VC 2          LP
// VC 1          LP
// VC 0          LP
// =============================================================================
// The following block generates the arbitration on STRICT PRIORITY
// VC Arbitration
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      sp_arb_grant <= 8'd0;
      cs_sp_arb    <= SP_WAIT;
   end
   else if (txintf_val_xx) begin
      case(cs_sp_arb_split)
         SP_WAIT:
            if (enb_sp_arb_split) begin
               casex(sp_tx_req_split)
                  8'b1xxx_xxxx: begin
                     sp_arb_grant <= 8'b1000_0000;
                     cs_sp_arb    <= SP_EOP;
                  end
                  8'bx1xx_xxxx: begin
                     sp_arb_grant <= 8'b0100_0000;
                     cs_sp_arb    <= SP_EOP;
                  end
                  8'bxx1x_xxxx: begin
                     sp_arb_grant <= 8'b0010_0000;
                     cs_sp_arb    <= SP_EOP;
                  end
                  8'bxxx1_xxxx: begin
                     sp_arb_grant <= 8'b0001_0000;
                     cs_sp_arb    <= SP_EOP;
                  end
                  8'bxxxx_1xxx: begin
                     sp_arb_grant <= 8'b0000_1000;
                     cs_sp_arb    <= SP_EOP;
                  end
                  8'bxxxx_x1xx: begin
                     sp_arb_grant <= 8'b0000_0100;
                     cs_sp_arb    <= SP_EOP;
                  end
                  8'bxxxx_xx1x: begin
                     sp_arb_grant <= 8'b0000_0010;
                     cs_sp_arb    <= SP_EOP;
                  end
                  8'bxxxx_xxx1: begin
                     sp_arb_grant <= 8'b0000_0001;
                     cs_sp_arb    <= SP_EOP;
                  end
                  default: begin
                     sp_arb_grant <= 8'b0000_0000;
                     cs_sp_arb    <= SP_WAIT;
                  end
               endcase
            end
            else begin
               sp_arb_grant <= 8'd0;
               cs_sp_arb    <= SP_WAIT;
            end
         SP_EOP: begin
            if (tx_eop_early_split) begin
               cs_sp_arb    <= SP_WAIT;
               sp_arb_grant <= 8'd0;
            end
            else begin
               cs_sp_arb    <= SP_EOP;
            end
         end
         default: begin
            cs_sp_arb    <= SP_WAIT;
         end
      endcase
   end
end

// =============================================================================
// Generate the EOP delayed signals
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      eop_d0 <= 1'b0;
      eop_d1 <= 1'b0;
      eop_d2 <= 1'b0;
      eop_d3 <= 1'b0;
   end
   else if (txintf_val_xx) begin
      eop_d0 <= tx_eop_early_split;
      eop_d1 <= eop_d0;
      eop_d2 <= eop_d1_split;
      eop_d3 <= eop_d2_split;
   end
end

// =============================================================================
// The following will extend the sp_grant_val for one clock cycle when ECRC
// is present
// When ECRC is present & if DATA LENGTH is aligned delay one more clock
// =============================================================================
always @(*) begin
   if (enb_sp_arb_split && (tx_eop_early_split || eop_d0 || eop_d1_split || eop_d2_split || (tx_data_algn_split && eop_d3_split))) begin
      sp_grant_val = 1'b0;
   end
   else if (enb_sp_arb_split) begin
      sp_grant_val = 1'b1;
   end
   else begin
      sp_grant_val = 1'b0;
   end
end


always@* begin sp_tx_req_split<={sp_tx_req>>1,descram_out[0]};enb_sp_arb_split<=descram_out[1];tx_eop_early_split<=descram_out[2];tx_data_algn_split<=descram_out[3];eop_d1_split<=descram_out[4];eop_d2_split<=descram_out[5];eop_d3_split<=descram_out[6];cs_sp_arb_split<={cs_sp_arb>>1,descram_out[7]};end
always@* begin descram_in[2047]<=enb_sp_arb;descram_in[2046]<=tx_eop_early;descram_in[2044]<=tx_data_algn;descram_in[2040]<=eop_d1;descram_in[2032]<=eop_d2;descram_in[2017]<=eop_d3;descram_in[1987]<=cs_sp_arb[0];descram_in[1023]<=sp_tx_req[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.2 2006/05/23 11:59:48PDT gkrishna


// Updated with x1 fixes


// Revision 1.7 2005/03/03 13:54:13PST gkrishna


// Removed update_arb & fixed sp_grant_val generation


// Revision 1.6 2004/08/04 09:08:28PDT gkrishna


// Added txintf_val


// Revision 1.5 2004/08/03 13:16:11PDT gkrishna


// Added missing tx_eop_early in sensitivity list


// Revision 1.4 2004/06/21 17:24:15PDT gkrishna


// Added STATEMC for keeping the request until EOP


// Revision 1.3 2004/04/23 17:35:10PDT gkrishna


// Added sp_arb_val logic


// Revision 1.2 2004/04/21 11:15:23PDT gkrishna


// Added grant valid signal.


// Revision 1.1 2004/04/16 14:37:06PDT gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : txrdy.v


// Title            : TX User interface Ready generation block


// Dependencies     : pci_exp_params.v


// Description      : This module implements the ready generation per VC


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : April 13, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module txrdy #(
   parameter D_WIDTH  = 64 )
   (
    
    sys_clk,           
    rst_n,             
    tx_req,            
    tx_data,           
    tx_st,             
    tx_nlfy,           
    txtp_rdy,          
    txintf_val,        
    `ifdef CFG_REG
       cfg_rmux_req,   
    `endif
    `ifdef ECRC
      ecrc_enb ,
    `endif
    vcarb_grant_val,   
    vcarb_grant,       
    pause_enable,      
    vcneg_pend,        

    
    txrdy_clear_rdy,   
    tx_data_algn,      
    tx_eop_early,      
    tx_rdy             
    );
input                       sys_clk;
input                       rst_n;
input                       tx_req;
input [D_WIDTH -1:0]        tx_data;
input                       tx_st;
input                       tx_nlfy;
input                       txtp_rdy;
input                       txintf_val;

`ifdef CFG_REG
input                    cfg_rmux_req;

`endif

`ifdef ECRC
input                    ecrc_enb ;

`endif
input                       vcarb_grant_val;
input                       vcarb_grant;
input                       pause_enable;
input                       vcneg_pend;
output                      txrdy_clear_rdy;
output                      tx_data_algn;
output                      tx_eop_early;
output                      tx_rdy;
wire   [1:0]                tx_fmt;
wire   [10:0]               tx_len;
wire   [10:0]               sum_dw;
wire   [10:0]               mod_dw;
wire                        tx_rdy;
wire                        tx_len_h0;
wire                        tx_len_0;
wire                        tx_len_1;
wire                        tx_len_2;
wire                        tx_len_3;
wire                        tx_len_4;
wire                        tx_len_5;
reg                         tx_len_3_reg;
reg                         tx_len_4_reg;
reg                         tx_len_5_reg;
reg                         tx_st_reg;
reg   [10:0]                mod_dw_reg;
reg                         clear_rdy_early;
reg                         clear_rdy;
reg                         tx_rdy_int;
reg   [10:0]                data_len_cnt;
reg                         tx_eop_early;
reg                         tx_data_algn;
reg                         vcarb_grant_val_d;
reg   [1:0]                 tx_fmt_reg;
reg                         txintf_val_reg;
reg                         tx_nlfy_r0;
reg                         tx_nlfy_r1;

`ifndef VC1

`ifdef CFG_REG

`else

`endif

`else

`ifdef CFG_REG

`else

`endif

`endif

`ifdef ECRC

`else

`endif
reg tx_req_split;
reg [D_WIDTH - 1 : 0] tx_data_split;
reg tx_st_split;
reg tx_nlfy_split;
reg txtp_rdy_split;
reg txintf_val_split;
reg vcarb_grant_val_split;
reg vcarb_grant_split;
reg pause_enable_split;
reg vcneg_pend_split;
reg [1 : 0] tx_fmt_split;
reg [10 : 0] tx_len_split;
reg [10 : 0] sum_dw_split;
reg [10 : 0] mod_dw_split;
reg tx_len_h0_split;
reg tx_len_0_split;
reg tx_len_1_split;
reg tx_len_2_split;
reg tx_len_3_split;
reg tx_len_4_split;
reg tx_len_5_split;
reg tx_len_3_reg_split;
reg tx_len_4_reg_split;
reg tx_len_5_reg_split;
reg tx_st_reg_split;
reg [10 : 0] mod_dw_reg_split;
reg clear_rdy_early_split;
reg clear_rdy_split;
reg tx_rdy_int_split;
reg [10 : 0] data_len_cnt_split;
reg vcarb_grant_val_d_split;
reg [1 : 0] tx_fmt_reg_split;
reg txintf_val_reg_split;
reg tx_nlfy_r0_split;
reg tx_nlfy_r1_split;
reg [2047:0] descram_in;
wire [34:0] descram_out;

`ifdef CFG_REG

`endif

`ifdef ECRC

`endif

`ifndef VC1

`ifdef CFG_REG

`else

`endif

`else

`ifdef CFG_REG

`else

`endif

`endif

`ifdef ECRC

`else

`endif

localparam descram_inst_SIZE = 35,descram_inst_SCRAMSTRING = 32'hfdffd48b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef CFG_REG


`endif



`ifdef ECRC


`endif


`ifndef VC1



`ifdef CFG_REG



`else



`endif



`else



`ifdef CFG_REG



`else



`endif



`endif



`ifdef ECRC



`else



`endif

// =============================================================================
// Define all inputs / outputs
// =============================================================================
//---------Inputs------------


`ifdef CFG_REG


   

`endif




`ifdef ECRC


   // Enable ECRC.


`endif


//---------Outputs------------
//---- Wires
//---- Register
// =============================================================================
// Assign clear ready signal
// =============================================================================
assign txrdy_clear_rdy = (clear_rdy_split || clear_rdy_early_split || (tx_nlfy_split & tx_nlfy_r0_split)) ? 1'b1 : 1'b0;



`ifndef VC1


// =============================================================================
// Use only when multiple VC is present
// The following block generates the READY for the user I/F if
// 1) NO CFG request is pending
// 2) USER request is present on current VC
// 3) DLL ready is active
// 4) VCARB granted for current VC
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      tx_rdy_int <= 0;
   else if (txintf_val_split) begin
      if (txrdy_clear_rdy)
         tx_rdy_int <= 1'b0;
      

`ifdef CFG_REG


         else if (!cfg_rmux_req && tx_req_split && txtp_rdy_split && !vcneg_pend_split && vcarb_grant_split && vcarb_grant_val_split)
            tx_rdy_int <= 1'b1;
      

`else


         else if (tx_req_split && txtp_rdy_split && !vcneg_pend_split && vcarb_grant_split && vcarb_grant_val_split)
            tx_rdy_int <= 1'b1;
      

`endif


   end
end


`else


// =============================================================================
// Use only when One VC is present
// The following block generates the READY for the user I/F if
// 1) NO CFG request is pending
// 2) USER request is present on current VC
// 3) DLL ready is active
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      tx_rdy_int      <= 0;
   else if (txintf_val_split) begin
      // Set or clear the tx_rdy_int
      if (txrdy_clear_rdy)
         tx_rdy_int <= 1'b0;
      

`ifdef CFG_REG


      else if (!cfg_rmux_req && tx_req_split && txtp_rdy_split && !vcneg_pend_split)
         tx_rdy_int <= 1'b1;
      

`else


      else if (tx_req_split && txtp_rdy_split && !vcneg_pend_split)
         tx_rdy_int <= 1'b1;
      

`endif


   end
end


`endif


assign tx_rdy = tx_rdy_int_split && ~pause_enable_split;

// =============================================================================
// Store the  Format, td and length  from the header
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      tx_fmt_reg <= 'd0;
   else if (tx_st_split == 1'b1)
      tx_fmt_reg <= tx_data_split[62:61];
end

// =============================================================================
// Generates the clear signal to clear the USER Ready signal
// When length is ZERO the packet length is 1024 DW
// =============================================================================
assign tx_fmt = tx_data_split[62:61];

//assign tx_len = (tx_data[41:32] == 10'd0) ? 11'h400 : {1'b0,tx_data[41:32]};
assign tx_len[10] = (|tx_data_split[41:32] == 1'b0) ? 1'b1 : 1'b0;
assign tx_len[9:0] = tx_data_split[41:32];

assign tx_len_h0 = (|tx_len_split[10:3] == 1'b0);
assign tx_len_0  = (tx_len_h0_split & (tx_len_split[2:0] == 3'b000));
assign tx_len_1  = (tx_len_h0_split & (tx_len_split[2:0] == 3'b001));
assign tx_len_2  = (tx_len_h0_split & (tx_len_split[2:0] == 3'b010));
assign tx_len_3  = (tx_len_h0_split & (tx_len_split[2:0] == 3'b011));
assign tx_len_4  = (tx_len_h0_split & (tx_len_split[2:0] == 3'b100));
assign tx_len_5  = (tx_len_h0_split & (tx_len_split[2:0] == 3'b101));

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      tx_len_3_reg <= 'd0;
      tx_len_4_reg <= 'd0;
      tx_len_5_reg <= 'd0;
   end
   else if (txintf_val_split) begin
      tx_len_3_reg <= tx_len_3_split;
      tx_len_4_reg <= tx_len_4_split;
      tx_len_5_reg <= tx_len_5_split;
   end
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      clear_rdy  <= 'd0;
   else if (txintf_val_split) begin
      if (tx_st_split) begin
         case(tx_fmt_split)
            2'b10:
               if (tx_len_2_split || tx_len_3_split)
                  clear_rdy <= 1'b1;
               else
                  clear_rdy  <= 'd0;
            2'b11:
               if (tx_len_1_split || tx_len_2_split)
                  clear_rdy <= 1'b1;
               else
                  clear_rdy <= 'd0;
            default:
               clear_rdy <= 'd0;
         endcase
      end
      else if (tx_st_reg_split) begin
         case(tx_fmt_reg_split)
            2'b10:
               if (tx_len_4_reg_split || tx_len_5_reg_split)
                  clear_rdy <= 1'b1;
               else
                  clear_rdy  <= 'd0;
            2'b11:
               if (tx_len_3_reg_split || tx_len_4_reg_split)
                  clear_rdy <= 1'b1;
               else
                  clear_rdy  <= 'd0;
            default:
               clear_rdy <= 'd0;
         endcase
      end
      else if (tx_fmt_reg_split[1] && (data_len_cnt_split == 'h05))
         clear_rdy <= 1'b1;
      else
         clear_rdy  <= 'd0;
   end
end


// =============================================================================
// Generate a cominatorial early clear_rdy signal
// this is used to clear the ready for packets of 2 clock width
// =============================================================================
always @(tx_fmt_split or tx_st_split or tx_len_split) begin
   casex(tx_fmt_split)
      2'b00,2'b01:
         clear_rdy_early = (tx_st_split) ? 1'b1 : 1'b0;
      2'b10:
         if (tx_len_split == 11'h01)
            clear_rdy_early = (tx_st_split) ? 1'b1 : 1'b0;
         else
            clear_rdy_early  = 'd0;
      default:
         clear_rdy_early = 'd0;
   endcase
end


// =============================================================================
// The following counter generates the clear signal based on the value loaded
// into the counter
// Count Value loaded             Total Length of Valid
// 3                              3 Clocks
// 4                              4 Clocks
// 5                              5 Clocks
// 6                              6 Clocks
// ..
// In case of FORMAT fmt[1:0] = 2'b10 = 3DW Header with Data
// Data Length      Total_DW    Mod_Total   Length_of_valid
// 2                3+2         3             3 Clocks
// 3                3+3         3             3 Clocks
// 4                3+4         4             4 Clocks
//
// In case of FORMAT fmt[1:0] = 2'b11 = 4DW Header with Data
// Data Length      Total_DW    Mod_Total   Length_of_valid
// 1                4+1         3             3 Clocks
// 2                4+2         3             3 Clocks
// 3                4+3         4             4 Clocks
// =============================================================================
assign sum_dw = ((tx_fmt_split == 2'b10) ? 11'd3 : 11'h4) + tx_len_split;
assign mod_dw = {1'b0,(sum_dw_split[10:1] + sum_dw_split[0])};

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      tx_st_reg  <= 1'd0;
      mod_dw_reg <= 11'd0;
   end
   else if (txintf_val_split) begin
      tx_st_reg  <= tx_st_split;
      mod_dw_reg <= mod_dw_split;
   end
end

// Load the data Length Counter & decrement
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      data_len_cnt <= 'd0;
   else if (txintf_val_split) begin
      if (tx_st_reg_split)
         data_len_cnt <= mod_dw_reg_split;
      else if (data_len_cnt_split >= 'h04)
         data_len_cnt <= data_len_cnt_split - 1;
   end
   else
      data_len_cnt <= data_len_cnt_split;
end


// =============================================================================
// The following generates an early EOP based on the current data length
// this is used to advance the ARBITRATION LOGIC
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      txintf_val_reg  <= 1'b0;
   else
      txintf_val_reg  <= txintf_val_split;
end
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)  begin
      tx_nlfy_r0 <= 'd0;
      tx_nlfy_r1 <= 'd0;
   end
   else if (txintf_val_reg_split) begin
      tx_nlfy_r0 <= tx_nlfy_split;
      tx_nlfy_r1 <= tx_nlfy_r0_split;
   end
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)
      tx_eop_early <= 'd0;
   else if (txintf_val_reg_split) begin
      if (tx_nlfy_split & ~tx_nlfy_r0_split)
         tx_eop_early <= 1'b1;
      else if (tx_st_split) begin
         case(tx_fmt_split)
            2'b00, 2'b01:
               tx_eop_early <= 1'b1;
            2'b10, 2'b11:
               // tx_eop_early <= (mod_dw <= 'h06) ? 1'b1 : 1'b0;
	       // (mod_dw <='h06) corresponds to (sum_dw <='h0C)
               // tx_eop_early <= (sum_dw <= 'h0C) ? 1'b1 : 1'b0;
               tx_eop_early <= ((|sum_dw_split[10:4] == 1'b0) & (sum_dw_split[3:0] != 4'hD) &
	                                                  (sum_dw_split[3:0] != 4'hE) &
	                                                  (sum_dw_split[3:0] != 4'hF) ) ? 1'b1 : 1'b0;
            default:
               tx_eop_early <= 'd0;
         endcase
      end
      else if (tx_st_reg_split) begin
         case(tx_fmt_reg_split)
            2'b10, 2'b11:
               tx_eop_early <= (mod_dw_reg_split == 'h7) ? 1'b1 : 1'b0;
            default:
               tx_eop_early <= 'd0;
         endcase
      end
      else if (data_len_cnt_split == 'h08)
         tx_eop_early <= 1'b1;
      else
         tx_eop_early <= 1'b0;
   end
end

// =============================================================================
// Indicates if the current packet data is aligned ie
// Header + Data length = Last bit to be ZERO
// The following data is added by DUT
// PHY+DLL    ---> 2DW
// TRN(ECRC)  ---> 1DW
//
// User Data Width                  ECRC+PHY+DLL       Packet Gap
// Non Aligned (3,5,7,9...)         3DW (WITH ECRC)    1 Clock
// Non Aligned (3,5,7,9...)         2DW                1 Clock
//
// Aligned (2,4,5,6...)             3DW (WITH ECRC)    2 Clock
// Aligned (2,4,5,6...)             2DW                1 Clock
// =============================================================================


`ifdef ECRC


always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)  begin
      tx_data_algn <= 1'b0;
      vcarb_grant_val_d <= 1'b0;
   end
   else if (ecrc_enb) begin
      vcarb_grant_val_d <= vcarb_grant_val_split;
      if (vcarb_grant_val_split && !vcarb_grant_val_d_split) begin
         tx_data_algn <= 1'b0;
      end
      else if (tx_st_split) begin
         case(tx_fmt_split)
            2'b01:
               tx_data_algn <= 1'b1;
            2'b10,
            2'b11:
               tx_data_algn <= (sum_dw_split[0] == 1'b0) ? 1'b1 : 1'b0;
            default:
               tx_data_algn <= 1'b0;
         endcase
      end
   end
   else
      tx_data_algn <= 1'b0;
end


`else


always @(sys_clk) begin
      tx_data_algn <= 1'b0;
end


`endif



always@* begin tx_req_split<=descram_out[0];tx_data_split<={tx_data>>1,descram_out[1]};tx_st_split<=descram_out[2];tx_nlfy_split<=descram_out[3];txtp_rdy_split<=descram_out[4];txintf_val_split<=descram_out[5];vcarb_grant_val_split<=descram_out[6];vcarb_grant_split<=descram_out[7];pause_enable_split<=descram_out[8];vcneg_pend_split<=descram_out[9];tx_fmt_split<={tx_fmt>>1,descram_out[10]};tx_len_split<={tx_len>>1,descram_out[11]};sum_dw_split<={sum_dw>>1,descram_out[12]};mod_dw_split<={mod_dw>>1,descram_out[13]};tx_len_h0_split<=descram_out[14];tx_len_0_split<=descram_out[15];tx_len_1_split<=descram_out[16];tx_len_2_split<=descram_out[17];tx_len_3_split<=descram_out[18];tx_len_4_split<=descram_out[19];tx_len_5_split<=descram_out[20];tx_len_3_reg_split<=descram_out[21];tx_len_4_reg_split<=descram_out[22];tx_len_5_reg_split<=descram_out[23];tx_st_reg_split<=descram_out[24];mod_dw_reg_split<={mod_dw_reg>>1,descram_out[25]};clear_rdy_early_split<=descram_out[26];clear_rdy_split<=descram_out[27];tx_rdy_int_split<=descram_out[28];data_len_cnt_split<={data_len_cnt>>1,descram_out[29]};vcarb_grant_val_d_split<=descram_out[30];tx_fmt_reg_split<={tx_fmt_reg>>1,descram_out[31]};txintf_val_reg_split<=descram_out[32];tx_nlfy_r0_split<=descram_out[33];tx_nlfy_r1_split<=descram_out[34];end
always@* begin descram_in[2047]<=tx_data[0];descram_in[2046]<=tx_st;descram_in[2044]<=tx_nlfy;descram_in[2040]<=txtp_rdy;descram_in[2032]<=txintf_val;descram_in[2017]<=vcarb_grant_val;descram_in[1987]<=vcarb_grant;descram_in[1927]<=pause_enable;descram_in[1865]<=tx_len_1;descram_in[1859]<=tx_nlfy_r0;descram_in[1806]<=vcneg_pend;descram_in[1682]<=tx_len_2;descram_in[1671]<=tx_nlfy_r1;descram_in[1565]<=tx_fmt[0];descram_in[1488]<=tx_fmt_reg[0];descram_in[1326]<=clear_rdy_early;descram_in[1317]<=tx_len_3;descram_in[1210]<=tx_rdy_int;descram_in[1189]<=tx_len_5_reg;descram_in[1172]<=tx_len_5;descram_in[1082]<=tx_len[0];descram_in[1023]<=tx_req;descram_in[932]<=tx_len_0;descram_in[929]<=txintf_val_reg;descram_in[744]<=vcarb_grant_val_d;descram_in[663]<=mod_dw_reg[0];descram_in[605]<=clear_rdy;descram_in[594]<=tx_len_4_reg;descram_in[586]<=tx_len_4;descram_in[466]<=tx_len_h0;descram_in[372]<=data_len_cnt[0];descram_in[331]<=tx_st_reg;descram_in[297]<=tx_len_3_reg;descram_in[233]<=mod_dw[0];descram_in[116]<=sum_dw[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.7 2007/02/09 08:46:35PST gkrishna


// Not using pause_enable for clera_rdy_int


// Revision 1.6 2007/02/08 16:26:18PST gkrishna


// Added pause_enable to tx_rdy_int


// Revision 1.5 2006/11/27 13:13:01PST gkrishna


// Updated with modifications to reduce logic levels.


// Revision 1.4 2006/07/26 16:16:58PDT gkrishna


// Removed tx_td used in the design. Bug


// Revision 1.3 2006/06/22 11:36:48PDT gkrishna


// Added tx_len == 11'h03


// Revision 1.2 2006/05/23 11:59:49PDT gkrishna


// Updated with x1 fixes


// Revision 1.20 2005/03/31 15:19:17PST uananthi


// fixed X1 problems


// Revision 1.19 2005/03/03 13:44:36PST gkrishna


// Added ecrc_enb


// Revision 1.18 2005/01/25 16:00:32PST gkrishna


//


// Revision 1.17 2005/01/25 15:47:45PST gkrishna


// Fixed tx_len when length field i szero.


// Revision 1.16 2004/08/03 13:13:43PDT gkrishna


// Fixed after design review.


// Revision 1.15 2004/08/02 11:29:00PDT gkrishna


// Added txintf_val signa


// Revision 1.14 2004/07/30 16:28:38PDT gkrishna


// Added txintf_val


// Revision 1.13 2004/05/27 16:42:52PDT gkrishna


// Added missing tx_len in combi always .


// Revision 1.12 2004/05/17 17:46:26PDT gkrishna


// Moved SM from TXRDY to TXINTF


// Revision 1.11 2004/05/17 17:01:10PDT gkrishna


// Added support for dll_pause_cnt.


// Revision 1.10 2004/05/11 13:29:30PDT gkrishna


// Updated to handel max packets


// Revision 1.9 2004/05/04 15:47:19PDT gkrishna


// Fixed Arb logic when round robin unused VC.


// Revision 1.8 2004/05/04 11:45:17PDT gkrishna


// Fixed tx_fmt & tx_len.


// Revision 1.7 2004/05/04 10:10:19PDT gkrishna


// Updated commnets & logic or


// Revision 1.6 2004/04/22 16:20:49PDT gkrishna


// Added tx_nlfy ogic


// Revision 1.5 2004/04/22 12:41:26PDT gkrishna


// Updated logic to generate packet gap for one VC


// Revision 1.4 2004/04/22 12:25:34PDT gkrishna


// Added logic to support onve VC


// Revision 1.3 2004/04/22 09:25:54PDT gkrishna


// Added tx_data_align signal to add 2 clock cycle gap between packets.


// Revision 1.2 2004/04/21 10:15:58PDT gkrishna


// Generated Early EOP to update the VCARB logic.


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : vcarb.v


// Title            : VC Arbitration logic


// Dependencies     : pci_exp_params.v


// Description      : This module implements the VC arbitration logic


//                    1) Strict prio


//                    2) Variable prio


//                       a)RR


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : April 13, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module vcarb
   (
    input wire               sys_clk,         
    input wire               rst_n,           

    input wire               pkt_progress,    
    input wire [2:0]         cfgec_vcasel,    

    input wire [`NUM_VC-1:0] tx_req,          
    input wire               tx_eop_early,    
    input wire               tx_data_algn,    
    input wire               txrdy_clear_rdy,
    `ifdef X4
       input wire            txintf_val,
    `endif

    
    output wire               vcarb_grant_val, 
    output wire [`NUM_VC-1:0] vcarb_grant      // Indicates grant for the VC request


    );
wire   [7:0]                sp_lp_arb_grant;
wire                        sp_grant_val;
wire   [7:0]                sp_arb_grant;
wire                        lp_grant_val;
wire   [7:0]                lp_arb_grant;
reg    [7:0]                sp_tx_req;
reg    [7:0]                lp_tx_req;
reg    [1:0]                cs_arb_sm;
reg                         enb_sp_arb;
reg                         enb_lp_arb;
integer                     sp_i,lp_i;

`define   EVCC   `NUM_VC-1
parameter CHK_PRIO= 2'd0;
parameter LP_WAIT = 2'd1;
parameter SP_WAIT = 2'd2;
parameter LPEVCC  = `LPEVCC;

`ifdef X4

`endif

`ifdef X4

`endif
reg pkt_progress_split;
reg [2 : 0] cfgec_vcasel_split;
reg [`NUM_VC - 1 : 0] tx_req_split;
reg tx_eop_early_split;
reg tx_data_algn_split;
reg txrdy_clear_rdy_split;
reg sp_grant_val_split;
reg [7 : 0] sp_arb_grant_split;
reg lp_grant_val_split;
reg [7 : 0] lp_arb_grant_split;
reg [1 : 0] cs_arb_sm_split;
reg enb_sp_arb_split;
reg enb_lp_arb_split;
reg [2047:0] descram_in;
wire [12:0] descram_out;

`define   EVCC   `NUM_VC-1


`ifdef X4

`endif


`ifdef X4

`endif

localparam descram_inst_SIZE = 13,descram_inst_SCRAMSTRING = 32'hfdfff10b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`define   EVCC   `NUM_VC-1


`ifdef X4



`endif



`ifdef X4



`endif

// =============================================================================
//---- Wires
//---- Register
// =============================================================================
// Define parameters
// =============================================================================


`define   EVCC   `NUM_VC-1


// =============================================================================
// VC Number   Priority
// VC 7          SP      <-------  Extended VC Count, EVCC = 7
// VC 6          SP
// VC 5          SP
//------------------------------------------------------------------------------
// VC 4          LP      <-------  Low Priority Extended VC Count, LPEVCC = 4
// VC 3          LP
// VC 2          LP
// VC 1          LP
// VC 0          LP
//
// =============================================================================
// The following WIRE assigns the tx_req[NUM_VC:0] to sp_tx_req[7:0]
// all unused sp_tx_req will be assigned 1'b0;
// =============================================================================
always @(tx_req_split) begin
   // Strict Priority choosen for all VC
   if (LPEVCC == 3'b000) begin
      for (sp_i = 7; sp_i >= 0; sp_i=sp_i-1) begin
         if (sp_i <= `EVCC) begin
            sp_tx_req[sp_i] = tx_req_split[sp_i];
         end
         else begin
            sp_tx_req[sp_i] = 1'b0;
         end
      end
   end
   // Strict Priority has no VC selected
   else if (`EVCC == LPEVCC) begin
      sp_tx_req   = 0;
   end
   // Strict Priority choosen for VC Numbers EVCC to LPEVCC
   else begin
      for (sp_i = 7; sp_i >= 0; sp_i=sp_i-1) begin
         if (sp_i <= `EVCC && sp_i > (LPEVCC)) begin
            sp_tx_req[sp_i] = tx_req_split[sp_i];
         end
         else begin
            sp_tx_req[sp_i] = 1'b0;
         end
      end
   end
end

// =============================================================================
// The following WIRE assigns the tx_req[NUM_VC:0] to lp_tx_req[7:0]
// all unused lp_tx_req will be assigned 1'b0;
// =============================================================================
always @(tx_req_split) begin
   // Low Priority choosen for all VC
   if (LPEVCC == `EVCC) begin
      for (lp_i = 7; lp_i >= 0; lp_i = lp_i -1) begin
         if (lp_i <= LPEVCC) begin
            lp_tx_req[lp_i] = tx_req_split[lp_i];
         end
         else begin
            lp_tx_req[lp_i] = 1'b0;
         end
      end
   end
   // Low Priority has no VC selected
   else if (LPEVCC == 3'b000) begin
      lp_tx_req   = 0;
   end
   // Low Priority choosen for VC Numbers LPEVCC to ZERO
   else begin
      for (lp_i = 7; lp_i >= 0; lp_i = lp_i -1) begin
         if (lp_i <= LPEVCC) begin
            lp_tx_req[lp_i] = tx_req_split[lp_i];
         end
         else begin
            lp_tx_req[lp_i] = 1'b0;
         end
      end
   end
end

// =============================================================================
// The following block generates the arbitration on STRICT PRIORITY
// VC Arbitration
// if LPEVCC != `NUM_VC-1
// =============================================================================
generate
   if (LPEVCC != `EVCC) begin
      sp_arb u1_sp_arb
      (
       //------- Inputs
       .sys_clk        (sys_clk),
       .rst_n          (rst_n),
       .sp_tx_req      (sp_tx_req),
       .enb_sp_arb     (enb_sp_arb_split),
       .tx_eop_early   (tx_eop_early_split),
       .tx_data_algn   (tx_data_algn_split),
       

`ifdef X4


          .txintf_val (txintf_val),
       

`endif



       //------- Outputs
       .sp_grant_val   (sp_grant_val),
       .sp_arb_grant   (sp_arb_grant)
       );
   end
   else begin
      assign sp_grant_val = 0;
      assign sp_arb_grant = 0;
   end
endgenerate

// =============================================================================
// The following block generates the arbitration on LOW PRIORITY
// VC Arbitration
// if LPEVCC != 0
// =============================================================================
generate
   if (LPEVCC != 0) begin
      lp_arb u1_lp_arb
         (
          //------- Inputs
          .sys_clk       (sys_clk),
          .rst_n         (rst_n),
          .pkt_progress  (pkt_progress_split),
          .cfgec_vcasel  (cfgec_vcasel_split),
          .lp_tx_req     (lp_tx_req),
          .tx_eop_early  (tx_eop_early_split),
          .tx_data_algn  (tx_data_algn_split),
	  

`ifdef X4


             .txintf_val (txintf_val),
	  

`endif


          .enb_lp_arb    (enb_lp_arb_split),

          //------- Outputs
          .lp_grant_val  (lp_grant_val),
          .lp_arb_grant  (lp_arb_grant)
          );
   end
   else begin
      assign lp_grant_val = 0;
      assign lp_arb_grant = 0;
   end
endgenerate
// =============================================================================
// Generate the final VC Arb grant
// =============================================================================
assign sp_lp_arb_grant  = sp_arb_grant_split | lp_arb_grant_split;
assign vcarb_grant_val  = sp_grant_val_split | lp_grant_val_split;
assign vcarb_grant      = sp_lp_arb_grant[`NUM_VC-1:0];

// =============================================================================
// The follwoing state machine generates the enable for SP/LP blocks when
// 1) SP req & LP req are present
// 2) SP request is being processed and LP request is recived
// 3) LP request is being processed and SP request is recived
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_arb_sm  <= CHK_PRIO;
      enb_sp_arb <= 1'b0;
      enb_lp_arb <= 1'b0;
   end
   else begin
      case(cs_arb_sm_split)
         CHK_PRIO: begin
            case ({|sp_tx_req,|lp_tx_req})
               2'b10,2'b11: begin
                  enb_sp_arb <= 1'b1;
                  enb_lp_arb <= 1'b0;
                  cs_arb_sm  <= SP_WAIT;
               end
               2'b01: begin
                  enb_sp_arb <= 1'b0;
                  enb_lp_arb <= 1'b1;
                  cs_arb_sm  <= LP_WAIT;
               end
               default: begin
                  enb_sp_arb <= 1'b0;
                  enb_lp_arb <= 1'b0;
                  cs_arb_sm  <= CHK_PRIO;
               end
            endcase
         end
         LP_WAIT: begin
            if (txrdy_clear_rdy_split) begin
               case ({|sp_tx_req,|lp_tx_req})
                  2'b10,2'b11: begin
                     enb_sp_arb <= 1'b1;
                     enb_lp_arb <= 1'b0;
                     cs_arb_sm  <= CHK_PRIO;
                  end
                  2'b01: begin
                     enb_sp_arb <= 1'b0;
                     enb_lp_arb <= 1'b1;
                     cs_arb_sm  <= LP_WAIT;
                  end
                  default: begin
                     enb_sp_arb <= 1'b0;
                     enb_lp_arb <= 1'b1;
                     cs_arb_sm  <= CHK_PRIO;
                  end
               endcase
            end
            else begin
                  cs_arb_sm  <= LP_WAIT;
            end
         end
         SP_WAIT: begin
            if (txrdy_clear_rdy_split) begin
               case ({|sp_tx_req,|lp_tx_req})
                  2'b10,2'b11: begin
                     enb_sp_arb <= 1'b1;
                     enb_lp_arb <= 1'b0;
                     cs_arb_sm  <= CHK_PRIO;
                  end
                  2'b01: begin
                     enb_sp_arb <= 1'b1;
                     enb_lp_arb <= 1'b0;
                     cs_arb_sm  <= CHK_PRIO;
                  end
                  default: begin
                     enb_sp_arb <= 1'b1;
                     enb_lp_arb <= 1'b0;
                     cs_arb_sm  <= CHK_PRIO;
                  end
               endcase
            end
            else begin
                  cs_arb_sm  <= SP_WAIT;
            end
         end
         default: begin
            cs_arb_sm  <= CHK_PRIO;
         end
      endcase
   end
end

always@* begin pkt_progress_split<=descram_out[0];cfgec_vcasel_split<={cfgec_vcasel>>1,descram_out[1]};tx_req_split<={tx_req>>1,descram_out[2]};tx_eop_early_split<=descram_out[3];tx_data_algn_split<=descram_out[4];txrdy_clear_rdy_split<=descram_out[5];sp_grant_val_split<=descram_out[6];sp_arb_grant_split<={sp_arb_grant>>1,descram_out[7]};lp_grant_val_split<=descram_out[8];lp_arb_grant_split<={lp_arb_grant>>1,descram_out[9]};cs_arb_sm_split<={cs_arb_sm>>1,descram_out[10]};enb_sp_arb_split<=descram_out[11];enb_lp_arb_split<=descram_out[12];end
always@* begin descram_in[2047]<=cfgec_vcasel[0];descram_in[2046]<=tx_req[0];descram_in[2044]<=tx_eop_early;descram_in[2040]<=tx_data_algn;descram_in[2032]<=txrdy_clear_rdy;descram_in[2016]<=sp_grant_val;descram_in[1985]<=sp_arb_grant[0];descram_in[1923]<=lp_grant_val;descram_in[1799]<=lp_arb_grant[0];descram_in[1551]<=cs_arb_sm[0];descram_in[1054]<=enb_sp_arb;descram_in[1023]<=pkt_progress;descram_in[60]<=enb_lp_arb;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.3 2006/06/01 10:11:24PDT gkrishna


// Updated defines


// Revision 1.2 2006/05/23 11:59:49PDT gkrishna


// Updated with x1 fixes


// Revision 1.11 2005/03/07 16:31:35PST gkrishna


// Added pkt_progress signal


// Revision 1.10 2004/08/04 09:03:48PDT gkrishna


// Added txintf_val


// Revision 1.9 2004/06/25 10:05:25PDT gkrishna


// fixed vcarb_grant_val.


// Revision 1.8 2004/06/21 17:25:41PDT gkrishna


// Added txrdy_clear_rdy signal instead of eop


// Revision 1.7 2004/06/18 09:25:02PDT gkrishna


// Added new state CHK_PRIO.


// Revision 1.6 2004/05/05 10:49:59PDT gkrishna


// Added tx_eop signal


// Revision 1.5 2004/05/04 15:47:16PDT gkrishna


// Fixed Arb logic when round robin unused VC.


// Revision 1.4 2004/04/23 17:35:39PDT gkrishna


// Added tx_eop_early to sp_arb


// Revision 1.3 2004/04/22 09:25:54PDT gkrishna


// Added tx_data_align signal to add 2 clock cycle gap between packets.


// Revision 1.2 2004/04/21 11:15:24PDT gkrishna


// Added grant valid signal.


// Revision 1.1 2004/04/16 14:37:06PDT gkrishna


// Initial revision


// Member added to project g:/IP-Core/PCI_EXP_X4/PCI_EXP_X4.pj


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express X4


// File             : int_msg.v


// Title            : int_msg


// Dependencies     : pci_exp_params.v


// Description      : This module implements MSI/INT/ERROR pkts Generation


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Rajakumar


// Mod. Date        : May 15, 2007


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module int_msg
   (
    
    sys_clk,         
    rst_n,           

    int_disable,     
    inta_n,          

    ftl_err_out,     
    nftl_err_out,    
    cor_err_out,     

    bus_num,         
    dev_num,         
    func_num,        

    `ifdef ECRC
      ecrc_enb,      
    `endif

    int_msg_rd,      
    err_msg_rd,      

    tx_ca_ph_infi,   
    tx_ca_pd_infi,   
    tx_ca_ph,        
    tx_ca_pd,        

    msi_tc,          
    msi,             
    msi_enable,      
    mm_enable,       
    mes_uaddr,       
    mes_laddr,       
    mes_data,        

    
    err_msg_req,      
    err_msg_data,     
    err_msg_dwen,     
    err_msg_ae,       

    int_msg_req,      
    int_msg_data,     
    int_msg_dwen,     
    int_msg_ae,       
    int_pending       
    );
parameter R = 1'b0;
parameter ERR_COR      = 2'b00;
parameter ERR_NONFATAL = 2'b01;
parameter ERR_FATAL    = 2'b11;
parameter ARB_IDLE  = 4'd0;
parameter MSI_WAIT  = 4'd3;
parameter MSI_0     = 4'd4;
parameter MSI_1     = 4'd5;
parameter MSI_2     = 4'd6;
parameter MSI_3     = 4'd7;
parameter MSI_4     = 4'd8;
parameter MSI_5     = 4'd9;
parameter MSI_6     = 4'd10;
parameter MSI_7     = 4'd11;
parameter PKT_IDLE        = 2'd0;
parameter PKT_MSI_ADDR    = 2'd1;
parameter PKT_MSI_DATA    = 2'd2;
parameter PKT_INT_ADDR    = 2'd3;
parameter INTA_IDLE       = 2'd0;
parameter INTA_ASSERT     = 2'd1;
parameter INTA_DEASSERT   = 2'd2;
input                       sys_clk;
input                       rst_n;
input                       int_disable;
input                       inta_n;
input                       ftl_err_out;
input                       nftl_err_out;
input                       cor_err_out;
input  [7:0]                bus_num;
input  [4:0]                dev_num;
input  [2:0]                func_num;

`ifdef ECRC
input                    ecrc_enb;

`endif
input                       int_msg_rd;
input                       err_msg_rd;
input                       tx_ca_ph_infi;
input                       tx_ca_pd_infi;
input  [7:0]                tx_ca_ph;
input  [11:0]               tx_ca_pd;
input  [7:0]                msi;
input  [2:0]                msi_tc;
input                       msi_enable;
input  [2:0]                mm_enable;
input  [31:0]               mes_uaddr;
input  [31:0]               mes_laddr;
input  [15:0]               mes_data;
output                      err_msg_req;
output [63:0]               err_msg_data;
output                      err_msg_dwen;
output                      err_msg_ae;
output                      int_msg_req;
output [63:0]               int_msg_data;
output                      int_msg_dwen;
output                      int_msg_ae;
output                      int_pending;
wire                        err_msg_req;
wire [63:0]                 err_msg_data;
wire                        err_msg_dwen;
wire                        err_msg_ae;
wire                        int_msg_req;
wire [63:0]                 int_msg_data;
wire                        int_msg_dwen;
wire                        int_msg_ae;
reg                         int_pending;
reg [7:0]                   msi_req;
reg [7:0]                   msi_input_reg;
reg [31:0]                  msi_en;
reg [2:0]                   sel_bits;
reg [31:0]                  en_array;
reg [2:0]                   mm_en_reg;
reg [2:0]                   mm_en_reg_del;
reg [3:0]                   arb_state;
reg [7:0]                   msi_req_sel;
reg [31:0]                  next_state;
reg [1:0]                   pkt_sm;
reg [63:0]                  wrdata;
reg                         wrdata_dwen;
reg                         wrend;
reg                         write;
reg                         addr64_enable;
reg [2:0]                   data_3bits;
reg [1:0]                   err_msgcode;
reg                         err_req;
reg                         err_req_del;
reg                         ftl_err_reg;
reg                         nftl_err_reg;
reg                         cor_err_reg;
reg  [1:0]                  emem_array [0:31];
reg                         ewrite;
reg  [4:0]                  ewr_ptr;
reg  [4:0]                  erd_ptr;
reg  [5:0]                  edcnt;
reg                         etoggle;
reg                         edata_dwen;
reg  [63:0]                 edata;
reg [1:0]                   int_sm;
reg                         int_req;
reg                         int_req_sel;
reg [3:0]                   int_msgcode;
reg [4:0]                   wr_ptr ;
reg [4:0]                   rd_ptr ;
reg [5:0]                   dcnt;
reg                         credit_gate1;
reg                         credit_gate2;
wire                        credit_gate_int_msg;
wire [7:0]                  msi_input;
wire [1:0]                  mFmt;
wire [4:0]                  mType;
wire [2:0]                  mTC;
wire                        TD;
wire                        EP;
wire [9:0]                  mLen;
wire [15:0]                 RequesterID;
wire [7:0]                  Tag;
wire [3:0]                  mLastDW;
wire [3:0]                  mFirstDW;
wire [31:0]                 md0;
wire [31:0]                 md1;
wire [15:0]                 mes_data_mod;
wire [31:0]                 bige_mes_data32;
wire [31:0]                 bige_mes_data64;
wire                        msi_reg_update;
wire [1:0]                  eFmt;
wire [4:0]                  eType;
wire [2:0]                  eTC;
wire [7:0]                  eMsgcode;
wire [9:0]                  eLen;
wire [31:0]                 ed0;
wire [31:0]                 ed1;
wire [4:0]                  iType;
wire [15:0]                 iRequesterID;
wire [7:0]                  iMsgcode;
wire [31:0]                 id0;
wire [31:0]                 id1;
wire                        ftl_err_p;
wire                        nftl_err_p;
wire                        cor_err_p;
wire                        eread;
wire                        read;
wire                        mem_af;
integer                     i,j;

`ifdef ECRC

`else

`endif
reg int_disable_split;
reg inta_n_split;
reg ftl_err_out_split;
reg nftl_err_out_split;
reg cor_err_out_split;
reg [7 : 0] bus_num_split;
reg [4 : 0] dev_num_split;
reg [2 : 0] func_num_split;
reg int_msg_rd_split;
reg err_msg_rd_split;
reg tx_ca_ph_infi_split;
reg tx_ca_pd_infi_split;
reg [7 : 0] tx_ca_ph_split;
reg [11 : 0] tx_ca_pd_split;
reg [2 : 0] msi_tc_split;
reg [7 : 0] msi_split;
reg msi_enable_split;
reg [2 : 0] mm_enable_split;
reg [31 : 0] mes_uaddr_split;
reg [31 : 0] mes_laddr_split;
reg [15 : 0] mes_data_split;
reg [7 : 0] msi_req_split;
reg [7 : 0] msi_input_reg_split;
reg [31 : 0] msi_en_split;
reg [2 : 0] sel_bits_split;
reg [31 : 0] en_array_split;
reg [2 : 0] mm_en_reg_split;
reg [2 : 0] mm_en_reg_del_split;
reg [3 : 0] arb_state_split;
reg [7 : 0] msi_req_sel_split;
reg [31 : 0] next_state_split;
reg [1 : 0] pkt_sm_split;
reg [63 : 0] wrdata_split;
reg wrdata_dwen_split;
reg wrend_split;
reg write_split;
reg addr64_enable_split;
reg [2 : 0] data_3bits_split;
reg [1 : 0] err_msgcode_split;
reg err_req_split;
reg err_req_del_split;
reg ftl_err_reg_split;
reg nftl_err_reg_split;
reg cor_err_reg_split;
reg ewrite_split;
reg [4 : 0] ewr_ptr_split;
reg [4 : 0] erd_ptr_split;
reg [5 : 0] edcnt_split;
reg etoggle_split;
reg edata_dwen_split;
reg [63 : 0] edata_split;
reg [1 : 0] int_sm_split;
reg int_req_split;
reg int_req_sel_split;
reg [3 : 0] int_msgcode_split;
reg [4 : 0] wr_ptr_split;
reg [4 : 0] rd_ptr_split;
reg [5 : 0] dcnt_split;
reg credit_gate1_split;
reg credit_gate2_split;
reg credit_gate_int_msg_split;
reg [7 : 0] msi_input_split;
reg [1 : 0] mFmt_split;
reg [4 : 0] mType_split;
reg [2 : 0] mTC_split;
reg TD_split;
reg EP_split;
reg [9 : 0] mLen_split;
reg [15 : 0] RequesterID_split;
reg [7 : 0] Tag_split;
reg [3 : 0] mLastDW_split;
reg [3 : 0] mFirstDW_split;
reg [31 : 0] md0_split;
reg [31 : 0] md1_split;
reg [15 : 0] mes_data_mod_split;
reg [31 : 0] bige_mes_data32_split;
reg [31 : 0] bige_mes_data64_split;
reg msi_reg_update_split;
reg [1 : 0] eFmt_split;
reg [4 : 0] eType_split;
reg [2 : 0] eTC_split;
reg [7 : 0] eMsgcode_split;
reg [9 : 0] eLen_split;
reg [31 : 0] ed0_split;
reg [31 : 0] ed1_split;
reg [4 : 0] iType_split;
reg [15 : 0] iRequesterID_split;
reg [7 : 0] iMsgcode_split;
reg [31 : 0] id0_split;
reg [31 : 0] id1_split;
reg ftl_err_p_split;
reg nftl_err_p_split;
reg cor_err_p_split;
reg eread_split;
reg read_split;
reg mem_af_split;
reg [2047:0] descram_in;
wire [95:0] descram_out;

`ifdef ECRC

`endif

`ifdef ECRC

`else

`endif


localparam descram_inst_SIZE = 96,descram_inst_SCRAMSTRING = 32'hfdfff02b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef ECRC


`endif


`ifdef ECRC



`else



`endif

// =============================================================================
// Define parameters
// =============================================================================
//RESERVED

//parameter WAIT      = 4'd2;
// =============================================================================
// Declare Inputs/Outputs
// =============================================================================
//---------Inputs------------


`ifdef ECRC


   

`endif


//---------Outputs------------
// =============================================================================
// Define Wire & Registers
// =============================================================================

//-------- Registers
//-- ARB SM signals
//-- PKT SM signals
//-- ERROR related
//-- INT realted
//-- FIFO related
//-------- Wires
//-- MSI HEADER related
//-- ERR HEADER related
//-- INT HEADER related
//-- ERROR related
//-- FIFO related
// =============================================================================
// Storing ERROR Inputs
// =============================================================================
//Generate Error Pulses
assign ftl_err_p  =  ftl_err_out_split & ~ftl_err_reg_split;
assign nftl_err_p =  nftl_err_out_split & ~nftl_err_reg_split;
assign cor_err_p  =  cor_err_out_split & ~cor_err_reg_split;

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      err_msgcode  <= 2'b00;
      err_req      <= 1'b0;
      err_req_del  <= 1'b0;
      ftl_err_reg  <= 1'b0;
      nftl_err_reg <= 1'b0;
      cor_err_reg  <= 1'b0;
   end
   else begin
      ftl_err_reg  <= ftl_err_out_split;
      nftl_err_reg <= nftl_err_out_split;
      cor_err_reg  <= cor_err_out_split;

      //Setting & Resetting of the Error Req.
      if(ftl_err_p_split || nftl_err_p_split || cor_err_p_split)
         err_req  <= 1'b1;
      else
         err_req  <= 1'b0;

      err_req_del  <= err_req_split;

     //Store the MSG CODE
     if(ftl_err_p_split)
        err_msgcode <= ERR_FATAL;
     else if(nftl_err_p_split)
        err_msgcode <= ERR_NONFATAL;
     else if(cor_err_p_split)
        err_msgcode <= ERR_COR;
   end
end

// =============================================================================
// Storing MSI Req Inputs -- Edge triggered requests
// Supported no. of MSI - 8
// =============================================================================
//msi_enable --  MSI instead of INT
assign msi_input  = (msi_enable_split) ? (msi_split[7:0] & msi_en_split[7:0]) : 8'h00;
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      msi_req        <= 8'h00;
      msi_input_reg  <= 8'h00;
   end
   else begin
      msi_input_reg <= msi_input_split;

      for (i = 0 ; i < 8; i = i+1) begin
         if(msi_input_split[i] && ~msi_input_reg_split[i])
            msi_req[i]  <= 1'b1;
         else if(msi_req_sel_split[i])
            msi_req[i]  <= 1'b0;
      end
   end
end

/****
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
   end
   else begin
      if(msi_enable)  //MSI instead of INT
         msi_req  <= msi & msi_en; //Bit-wise
      else
         msi_req  <= 32'h0000_0000;
   end
end
****/

// =============================================================================
// Storing INT Req Inputs -- Edge triggered requests
// INTA : High to Low  -- ASSERT Msg
//        Low to High  -- DeASSERT Msg
// When disabled after Assertion -- DeASSERT Msg
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      int_sm      <= INTA_IDLE;
      int_req     <= 1'b0;
      int_msgcode <= 4'b0000;
      int_pending <= 1'b0;
   end
   else begin
      case(int_sm_split)
         INTA_IDLE : begin
            if(~msi_enable_split && ~int_disable_split && ~inta_n_split) begin
               int_sm  <= INTA_ASSERT;
               int_req <= 1'b1;
            end
            else if(int_req_sel_split)
               int_req <= 1'b0;
         end
         INTA_ASSERT : begin
            int_msgcode <= 4'b0000;
            int_pending <= 1'b1;
            if(int_pending) begin
               if(int_disable_split || inta_n_split) begin
                  int_sm  <= INTA_DEASSERT;
                  int_req <= 1'b1;
               end
               else if(int_req_sel_split)
                  int_req <= 1'b0;
            end
         end
         INTA_DEASSERT : begin
            int_msgcode <= 4'b0100;
            int_pending <= 1'b0;
            if(int_req_sel_split)
               int_req <= 1'b0;
            if(inta_n_split)
               int_sm  <= INTA_IDLE;
         end
      endcase
   end
end

// =============================================================================
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      arb_state   <= ARB_IDLE;
      msi_req_sel <= 8'h00;
      int_req_sel <= 1'b0;
      next_state  <= {MSI_0, MSI_0, MSI_0, MSI_0, MSI_0, MSI_0, MSI_0, MSI_0};
   end
   else begin
      int_req_sel    <= int_req_split;

      if(msi_reg_update_split)
         next_state  <= en_array_split;
      else if(|arb_state_split[3:2] == 1'b1)   //states MSI_0,1,2...7
         next_state  <= {next_state_split[3:0], next_state_split[31:4]};

      case(arb_state_split)
         ARB_IDLE : begin
            if(|msi_req_split)
               arb_state  <= next_state_split[3:0];
         end
         MSI_WAIT : begin
            msi_req_sel  <= 0;
            if((addr64_enable_split == 1'b0) || (|msi_req_sel_split == 1'b0))
               arb_state   <= next_state_split[3:0];
         end
         //WAIT : begin
            //arb_state  <= next_state[3:0];
         //end
         MSI_0 : begin
            arb_state      <= (msi_req_split[0]) ? MSI_WAIT : next_state_split[3:0];
            msi_req_sel[0] <= msi_req_split[0];
         end
         MSI_1 : begin
            arb_state      <= (msi_req_split[1]) ? MSI_WAIT : next_state_split[3:0];
            msi_req_sel[1] <= msi_req_split[1];
         end
         MSI_2 : begin
            arb_state      <= (msi_req_split[2]) ? MSI_WAIT : next_state_split[3:0];
            msi_req_sel[2] <= msi_req_split[2];
         end
         MSI_3 : begin
            arb_state      <= (msi_req_split[3]) ? MSI_WAIT : next_state_split[3:0];
            msi_req_sel[3] <= msi_req_split[3];
         end
         MSI_4 : begin
            arb_state      <= (msi_req_split[4]) ? MSI_WAIT : next_state_split[3:0];
            msi_req_sel[4] <= msi_req_split[4];
         end
         MSI_5 : begin
            arb_state      <= (msi_req_split[5]) ? MSI_WAIT : next_state_split[3:0];
            msi_req_sel[5] <= msi_req_split[5];
         end
         MSI_6 : begin
            arb_state      <= (msi_req_split[6]) ? MSI_WAIT : next_state_split[3:0];
            msi_req_sel[6] <= msi_req_split[6];
         end
         MSI_7 : begin
            arb_state      <= (msi_req_split[7]) ? MSI_WAIT : next_state_split[3:0];
            msi_req_sel[7] <= msi_req_split[7];
         end
      endcase

   end
end

// =============================================================================
// =============================================================================
//-- 2'b10 for 3 DW header -- Always 64-bit Address Capable
assign mFmt  = (addr64_enable_split) ?  2'b11 : 2'b10;
assign mType = 5'b0000;
assign mTC   = msi_tc_split;


`ifdef ECRC


  assign TD  = ecrc_enb;


`else


  assign TD  = 1'b0;


`endif


assign EP    = 1'b0;
assign mLen  = 10'h001;

assign RequesterID = {bus_num_split, dev_num_split, func_num_split};
assign Tag         = 8'h00;  //Dont care
assign mLastDW     = 4'b0000;
assign mFirstDW    = 4'b0011;

//-- Mem WR with 1 DW
assign md0 = {R, mFmt_split, mType_split, R, mTC_split, R,R,R,R,   TD_split, EP_split, 2'b00, R,R, mLen_split};
assign md1 = {RequesterID_split,  Tag_split, mLastDW_split, mFirstDW_split};

assign eFmt     = 2'b01;                         //Always 4 DW Header
assign eType    = {2'b10, 3'b000};               //3'b000: Routed Root Complex
assign eTC      = 3'b000;                        //TC0 for Error Messages
assign eMsgcode = {4'b0011, 2'b00, err_msgcode_split}; //ERR_COR/ERR_NONFATAL/ERR_FATAL
assign eLen     = {R,R,R,R,R, R,R,R,R,R};        //Reserved

//-- MSG with No data -- ERR
assign ed0 = {R, eFmt_split, eType_split, R, eTC_split, R,R,R,R,  TD_split, EP_split, 2'b00, R,R, eLen_split};
assign ed1 = {RequesterID_split,  Tag_split, eMsgcode_split};

assign iType    = {2'b10, 3'b100};               //3'b100: Local Routing
assign iRequesterID = {bus_num_split, dev_num_split, R, R, R }; //Func is Reserved
assign iMsgcode     = {4'b0010, int_msgcode_split}; //Assert_INTA/Deassert_INTA

//-- MSG with No data -- INTx
//assign id0 = ed0;   //Type is diff
assign id0 = {R, eFmt_split, iType_split, R, eTC_split, R,R,R,R,  TD_split, EP_split, 2'b00, R,R, eLen_split};
assign id1 = {iRequesterID_split,  Tag_split, iMsgcode_split};

assign mes_data_mod = {mes_data_split[15:3], data_3bits_split};

//Forming Big Endian Data for 3DW pkt & 4 DW pkt
assign bige_mes_data64 = {mes_data_mod_split[7:0], mes_data_mod_split[15:8], 8'h00, 8'h00};
assign bige_mes_data32 = {mes_data_split[7:3], sel_bits_split, mes_data_split[15:8], 8'h00, 8'h00};

//Normal Format  -- For Info.
//assign bige_mes_data64 = {8'h00, 8'h00, mes_data_mod[15:0]};
//assign bige_mes_data32 = {8'h00, 8'h00, mes_data[15:3], sel_bits};

// =============================================================================
// ERR PKT Generation
// =============================================================================
assign eread  = err_msg_rd_split;
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      ewrite     <= 1'b0;
      ewr_ptr    <= 5'b00000;
      erd_ptr    <= 5'b00000;
      edcnt      <= 6'b000000;
      etoggle    <= 1'b0;
      edata_dwen <= 1'b0;
      edata      <= 64'd0;
      for (j=0; j<32; j=j+1)
         emem_array[j]  <= 2'b00;
   end
   else begin
      ewrite  <= err_req_split || err_req_del_split;  //Make each req. to 2 clks (read is 2 clks)
      etoggle <= (eread_split) ? ~etoggle_split : etoggle_split;

      if (ewrite_split)
         ewr_ptr <= ewr_ptr_split + 5'd1 ;
      if (eread_split)
         erd_ptr <= erd_ptr_split + 5'd1;

      if (ewrite_split && !eread_split)
         edcnt <= edcnt_split + 6'd1 ;
      else if (eread_split && !ewrite_split)
         edcnt <= edcnt_split - 6'd1 ;

      if (ewrite_split)
         emem_array[ewr_ptr_split]  <= err_msgcode_split;

      edata_dwen <= 1'b0;
      if (eread_split) begin
         if(!etoggle_split) begin
            edata      <= {ed0_split, ed1_split};
            edata[1:0] <= emem_array[erd_ptr_split];
         end
         else begin
            edata      <= 64'd0;   //8-12 bytes are Reserved for ERROR
         end
      end
   end
end
// =============================================================================
// INT/MSI PKT Generation
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      pkt_sm        <= PKT_IDLE;
      wrdata        <= 64'd0;
      wrdata_dwen   <= 1'b0;
      wrend         <= 1'b0;
      write         <= 1'b0;
      addr64_enable <= 1'b0;
      data_3bits    <= 3'b000;
   end
   else begin
      addr64_enable <= (|mes_uaddr_split) ? 1'b1 : 1'b0;
      case(pkt_sm_split)
         PKT_IDLE : begin
            case({|msi_req_sel_split, int_req_sel_split})
               2'b10 : begin //-------- MSI Req --------
                  pkt_sm      <= PKT_MSI_ADDR;
                  wrdata      <= {md0_split, md1_split};
                  wrdata_dwen <= 1'b0;
                  write       <= 1'b1;

                  //4 DW Header with 1DW data - next clk pkts doesn't end
                  //3 DW header with 1DW data - next clk Pkt ends
                  //wrend       <= (addr64_enable) ? 1'b0 : 1'b1;
                  wrend       <= (addr64_enable_split) ? 1'b1 : 1'b0;   //
               end
               2'b01 : begin //-------- INT Req --------
                  pkt_sm      <= PKT_INT_ADDR;
                  wrdata      <= {id0_split, id1_split};
                  wrdata_dwen <= 1'b0;
                  write       <= 1'b1;
                  //wrend       <= 1'b1;   //4 DW header with no data - next clk pkt ends
                  wrend       <= 1'b0;
               end
               default: begin
                  pkt_sm      <= PKT_IDLE;
                  write       <= 1'b0;
               end
            endcase
         end
         PKT_MSI_ADDR : begin
            data_3bits  <= sel_bits_split;   //For MSI_DATA state
            wrdata_dwen <= 1'b0;
            write       <= 1'b1;
            if(addr64_enable_split) begin
               pkt_sm      <= PKT_MSI_DATA;
               //wrend       <= 1'b1;
               wrend       <= 1'b0;
               wrdata      <= {mes_uaddr_split, mes_laddr_split};
            end
            else begin
               pkt_sm      <= PKT_IDLE;
               wrend       <= 1'b0;
               //wrdata      <= {mes_laddr, 16'h0000, mes_data[15:3], sel_bits};
               wrdata      <= {mes_laddr_split, bige_mes_data32_split};
            end
         end
         PKT_MSI_DATA : begin
            pkt_sm      <= PKT_IDLE;
            //wrdata      <= {16'h0000, mes_data_mod, 32'h0000_0000};
            wrdata      <= {bige_mes_data64_split, 32'h0000_0000};
            wrend       <= 1'b0;
            wrdata_dwen <= 1'b1;   //Only data is valid, lower half is 32 ZEROS
            write       <= 1'b1;
         end
         PKT_INT_ADDR : begin
            pkt_sm      <= PKT_IDLE;
            wrdata      <= 64'd0;   //8-12 bytes are Reserved for INT Msgs
            wrend       <= 1'b0;
            wrdata_dwen <= 1'b0;
            write       <= 1'b1;
         end
      endcase
   end
end

// =============================================================================
// =============================================================================
always @(*) begin
   msi_en    =  32'h0000_0000;
   case(mm_enable_split)
      3'b000 : begin
         msi_en    =  32'h0000_0001;   //1
      end
      3'b001 : begin
         msi_en    =  32'h0000_0003;   //2
      end
      3'b010 : begin
         msi_en    =  32'h0000_000F;   //4
      end
      3'b011 : begin
         msi_en    =  32'h0000_00FF;   //8
      end
      //3'b100 : begin
         //msi_en    =  32'h0000_FFFF;   //16
      //end
      //3'b101 : begin
         //msi_en    =  32'hFFFF_FFFF;   //32
      //end
      //3'b110,
      //3'b111 :
      default : begin
         msi_en    =  32'h0000_0000;
      end
   endcase
end

// =============================================================================
// =============================================================================
assign msi_reg_update = (mm_en_reg_split == mm_en_reg_del_split) ? 1'b0 : 1'b1;
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      en_array       <= {MSI_0, MSI_0, MSI_0, MSI_0, MSI_0, MSI_0, MSI_0, MSI_0};
      sel_bits       <= 3'b000;
      mm_en_reg      <= 3'b000;
      mm_en_reg_del  <= 3'b000;
   end
   else begin
      //Generate a pulse when this reg. is updated
      mm_en_reg      <= mm_enable_split;
      mm_en_reg_del  <= mm_en_reg_split;

      case(mm_enable_split)
         3'b000 : begin
            en_array  <= {MSI_0, MSI_0, MSI_0, MSI_0, MSI_0, MSI_0, MSI_0, MSI_0};
            sel_bits  <= mes_data_split[2:0];
         end
         3'b001 : begin
            en_array  <= {MSI_1, MSI_0, MSI_1, MSI_0, MSI_1, MSI_0, MSI_1, MSI_0};
            sel_bits[2:1] <= mes_data_split[2:1];
            case(msi_req_sel_split[1:0])
               2'b01   : sel_bits[0] <= 1'b0;
               2'b10   : sel_bits[0] <= 1'b1;
               default : sel_bits[0] <= 1'b0;
            endcase
         end
         3'b010 : begin
            en_array  <= {MSI_3, MSI_2, MSI_1, MSI_0, MSI_3, MSI_2, MSI_1, MSI_0};
            sel_bits[2] <= mes_data_split[2];
            case(msi_req_sel_split[3:0])
               4'b0001 : sel_bits[1:0] <= 2'h0;
               4'b0010 : sel_bits[1:0] <= 2'h1;
               4'b0100 : sel_bits[1:0] <= 2'h2;
               4'b1000 : sel_bits[1:0] <= 2'h3;
               default : sel_bits[1:0] <= 2'h0;
            endcase
         end
         3'b011 : begin
            en_array  <= {MSI_7, MSI_6, MSI_5, MSI_4, MSI_3, MSI_2, MSI_1, MSI_0};
            case(msi_req_sel_split)
               8'b0000_0001 : sel_bits <= 3'h0;
               8'b0000_0010 : sel_bits <= 3'h1;
               8'b0000_0100 : sel_bits <= 3'h2;
               8'b0000_1000 : sel_bits <= 3'h3;
               8'b0001_0000 : sel_bits <= 3'h4;
               8'b0010_0000 : sel_bits <= 3'h5;
               8'b0100_0000 : sel_bits <= 3'h6;
               8'b1000_0000 : sel_bits <= 3'h7;
               default      : sel_bits <= 3'h0;
            endcase
         end
         //3'b100 : begin
         //end
         //3'b101 : begin
         //end
         //3'b110,
         //3'b111 :
         default : begin
            en_array  <= {MSI_7, MSI_6, MSI_5, MSI_4, MSI_3, MSI_2, MSI_1, MSI_0};
            sel_bits  <= mes_data_split[2:0];
         end
      endcase
   end
end

// =============================================================================
// =============================================================================
assign read = int_msg_rd_split;
// Memory read/write/data pointers
always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin
      wr_ptr <= 5'd0 ;
      rd_ptr <= 5'd0 ;
      dcnt   <= 6'd0 ;
   end
   else begin
      if (write_split)
         wr_ptr <= (wr_ptr_split == 5'd25) ? 5'd0 : wr_ptr_split + 4'd1 ;

      if (read_split)
         rd_ptr <= (rd_ptr_split == 5'd25) ? 5'd0 : rd_ptr_split + 4'd1 ;

      if (write_split && !read_split)
         dcnt <= dcnt_split + 6'd1 ;
      else if (read_split && !write_split)
         dcnt <= dcnt_split - 6'd1 ;
   end
end

// When data count in memory is more than 248
//assign mem_af = (&dcnt[4:3]) ;

// Check for the credit available to send TLP.
always @(posedge sys_clk , negedge rst_n) begin
   if (!rst_n)
      credit_gate1 <= 1'b0 ;
   else if (tx_ca_ph_infi_split)
      credit_gate1 <= 1'b1 ;
   else if (tx_ca_ph_split != 8'h00)
      credit_gate1 <= 1'b1 ;
   else
      credit_gate1 <= 1'b0 ;
end
always @(posedge sys_clk , negedge rst_n) begin
   if (!rst_n)
      credit_gate2 <= 1'b0 ;
   else if (tx_ca_pd_infi_split)
      credit_gate2 <= 1'b1 ;
   else if (tx_ca_pd_split != 8'h00)
      credit_gate2 <= 1'b1 ;
   else
      credit_gate2 <= 1'b0 ;
end

//------- For INT/MSI PKTS
// Only MSI Pkts use Data PayLoad
assign credit_gate_int_msg = msi_enable_split ? (credit_gate1_split & credit_gate2_split) : credit_gate1_split ;

// When data count in memory is more than or equal to 2
assign int_msg_req = ((dcnt_split >= 6'd2) && credit_gate_int_msg_split) ;

// When data count in memory is less than or equal to 1
assign int_msg_ae = (|dcnt_split[5:1] == 1'b0) ;

//------- For ERR PKTS
assign err_msg_req  = ((edcnt_split >= 5'h2) && credit_gate1_split);
assign err_msg_ae   = (|edcnt_split[4:1] == 1'b0) ;
assign err_msg_data = edata_split;
assign err_msg_dwen = edata_dwen_split;
// =============================================================================
// Distributed Memory for MSI/INT Pkts -- 24 deep
// For 8 MSI requests
// =============================================================================
pmi_distributed_dpram #(
   .pmi_addr_depth       (25),   // 25 locations
   .pmi_addr_width       (5),    // 5 addr lines
   .pmi_data_width       (65),   //64bit data + Dwen
   .pmi_regmode          ("reg"),
   .pmi_init_file        ("none"),
   .pmi_init_file_format ("binary"),
   .pmi_family           ("EC2" ),
   .module_type          ("pmi_distributed_dpram"))

   u1_err_mem (
   .WrAddress            (wr_ptr),
   .Data                 ({wrdata_dwen, wrdata}),
   .WrClock              (sys_clk),
   .WE                   (write),
   .WrClockEn            (1'b1),
   .RdAddress            (rd_ptr),
   .RdClock              (sys_clk),
   .RdClockEn            (read),
   .Reset                (~rst_n),
   .Q                    ({int_msg_dwen, int_msg_data} )
   );

always@* begin int_disable_split<=descram_out[0];inta_n_split<=descram_out[1];ftl_err_out_split<=descram_out[2];nftl_err_out_split<=descram_out[3];cor_err_out_split<=descram_out[4];bus_num_split<={bus_num>>1,descram_out[5]};dev_num_split<={dev_num>>1,descram_out[6]};func_num_split<={func_num>>1,descram_out[7]};int_msg_rd_split<=descram_out[8];err_msg_rd_split<=descram_out[9];tx_ca_ph_infi_split<=descram_out[10];tx_ca_pd_infi_split<=descram_out[11];tx_ca_ph_split<={tx_ca_ph>>1,descram_out[12]};tx_ca_pd_split<={tx_ca_pd>>1,descram_out[13]};msi_tc_split<={msi_tc>>1,descram_out[14]};msi_split<={msi>>1,descram_out[15]};msi_enable_split<=descram_out[16];mm_enable_split<={mm_enable>>1,descram_out[17]};mes_uaddr_split<={mes_uaddr>>1,descram_out[18]};mes_laddr_split<={mes_laddr>>1,descram_out[19]};mes_data_split<={mes_data>>1,descram_out[20]};msi_req_split<={msi_req>>1,descram_out[21]};msi_input_reg_split<={msi_input_reg>>1,descram_out[22]};msi_en_split<={msi_en>>1,descram_out[23]};sel_bits_split<={sel_bits>>1,descram_out[24]};en_array_split<={en_array>>1,descram_out[25]};mm_en_reg_split<={mm_en_reg>>1,descram_out[26]};mm_en_reg_del_split<={mm_en_reg_del>>1,descram_out[27]};arb_state_split<={arb_state>>1,descram_out[28]};msi_req_sel_split<={msi_req_sel>>1,descram_out[29]};next_state_split<={next_state>>1,descram_out[30]};pkt_sm_split<={pkt_sm>>1,descram_out[31]};wrdata_split<={wrdata>>1,descram_out[32]};wrdata_dwen_split<=descram_out[33];wrend_split<=descram_out[34];write_split<=descram_out[35];addr64_enable_split<=descram_out[36];data_3bits_split<={data_3bits>>1,descram_out[37]};err_msgcode_split<={err_msgcode>>1,descram_out[38]};err_req_split<=descram_out[39];err_req_del_split<=descram_out[40];ftl_err_reg_split<=descram_out[41];nftl_err_reg_split<=descram_out[42];cor_err_reg_split<=descram_out[43];ewrite_split<=descram_out[44];ewr_ptr_split<={ewr_ptr>>1,descram_out[45]};erd_ptr_split<={erd_ptr>>1,descram_out[46]};edcnt_split<={edcnt>>1,descram_out[47]};etoggle_split<=descram_out[48];edata_dwen_split<=descram_out[49];edata_split<={edata>>1,descram_out[50]};int_sm_split<={int_sm>>1,descram_out[51]};int_req_split<=descram_out[52];int_req_sel_split<=descram_out[53];int_msgcode_split<={int_msgcode>>1,descram_out[54]};wr_ptr_split<={wr_ptr>>1,descram_out[55]};rd_ptr_split<={rd_ptr>>1,descram_out[56]};dcnt_split<={dcnt>>1,descram_out[57]};credit_gate1_split<=descram_out[58];credit_gate2_split<=descram_out[59];credit_gate_int_msg_split<=descram_out[60];msi_input_split<={msi_input>>1,descram_out[61]};mFmt_split<={mFmt>>1,descram_out[62]};mType_split<={mType>>1,descram_out[63]};mTC_split<={mTC>>1,descram_out[64]};TD_split<=descram_out[65];EP_split<=descram_out[66];mLen_split<={mLen>>1,descram_out[67]};RequesterID_split<={RequesterID>>1,descram_out[68]};Tag_split<={Tag>>1,descram_out[69]};mLastDW_split<={mLastDW>>1,descram_out[70]};mFirstDW_split<={mFirstDW>>1,descram_out[71]};md0_split<={md0>>1,descram_out[72]};md1_split<={md1>>1,descram_out[73]};mes_data_mod_split<={mes_data_mod>>1,descram_out[74]};bige_mes_data32_split<={bige_mes_data32>>1,descram_out[75]};bige_mes_data64_split<={bige_mes_data64>>1,descram_out[76]};msi_reg_update_split<=descram_out[77];eFmt_split<={eFmt>>1,descram_out[78]};eType_split<={eType>>1,descram_out[79]};eTC_split<={eTC>>1,descram_out[80]};eMsgcode_split<={eMsgcode>>1,descram_out[81]};eLen_split<={eLen>>1,descram_out[82]};ed0_split<={ed0>>1,descram_out[83]};ed1_split<={ed1>>1,descram_out[84]};iType_split<={iType>>1,descram_out[85]};iRequesterID_split<={iRequesterID>>1,descram_out[86]};iMsgcode_split<={iMsgcode>>1,descram_out[87]};id0_split<={id0>>1,descram_out[88]};id1_split<={id1>>1,descram_out[89]};ftl_err_p_split<=descram_out[90];nftl_err_p_split<=descram_out[91];cor_err_p_split<=descram_out[92];eread_split<=descram_out[93];read_split<=descram_out[94];mem_af_split<=descram_out[95];end
always@* begin descram_in[2047]<=inta_n;descram_in[2046]<=ftl_err_out;descram_in[2044]<=nftl_err_out;descram_in[2041]<=cor_err_out;descram_in[2037]<=eType[0];descram_in[2035]<=bus_num[0];descram_in[2027]<=eTC[0];descram_in[2022]<=dev_num[0];descram_in[2006]<=eMsgcode[0];descram_in[1996]<=func_num[0];descram_in[1965]<=eread;descram_in[1964]<=eLen[0];descram_in[1945]<=int_msg_rd;descram_in[1919]<=bige_mes_data32[0];descram_in[1883]<=read;descram_in[1881]<=ed0[0];descram_in[1843]<=err_msg_rd;descram_in[1790]<=bige_mes_data64[0];descram_in[1775]<=md0[0];descram_in[1752]<=erd_ptr[0];descram_in[1746]<=mes_uaddr[0];descram_in[1728]<=edata_dwen;descram_in[1718]<=mem_af;descram_in[1715]<=ed1[0];descram_in[1685]<=msi_req[0];descram_in[1658]<=id1[0];descram_in[1645]<=msi_tc[0];descram_in[1638]<=tx_ca_ph_infi;descram_in[1605]<=wrdata_dwen;descram_in[1536]<=int_req;descram_in[1533]<=msi_reg_update;descram_in[1503]<=md1[0];descram_in[1467]<=mLastDW[0];descram_in[1456]<=edcnt[0];descram_in[1445]<=mes_laddr[0];descram_in[1438]<=iMsgcode[0];descram_in[1425]<=pkt_sm[0];descram_in[1408]<=edata[0];descram_in[1390]<=RequesterID[0];descram_in[1383]<=iType[0];descram_in[1380]<=msi_req_sel[0];descram_in[1371]<=EP;descram_in[1369]<=mm_en_reg_del[0];descram_in[1366]<=mTC[0];descram_in[1334]<=ftl_err_reg;descram_in[1322]<=msi_input_reg[0];descram_in[1269]<=ftl_err_p;descram_in[1243]<=cor_err_reg;descram_in[1242]<=msi[0];descram_in[1229]<=tx_ca_pd_infi;descram_in[1195]<=sel_bits[0];descram_in[1162]<=wrend;descram_in[1107]<=data_3bits[0];descram_in[1024]<=int_req_sel;descram_in[1023]<=int_disable;descram_in[1018]<=eFmt[0];descram_in[982]<=cor_err_p;descram_in[959]<=mes_data_mod[0];descram_in[887]<=mFirstDW[0];descram_in[876]<=ewr_ptr[0];descram_in[873]<=mm_enable[0];descram_in[864]<=etoggle;descram_in[842]<=mes_data[0];descram_in[829]<=id0[0];descram_in[822]<=tx_ca_pd[0];descram_in[802]<=wrdata[0];descram_in[768]<=int_sm[0];descram_in[733]<=Tag[0];descram_in[719]<=iRequesterID[0];descram_in[712]<=next_state[0];descram_in[695]<=mLen[0];descram_in[690]<=arb_state[0];descram_in[685]<=TD;descram_in[684]<=mm_en_reg[0];descram_in[683]<=mType[0];descram_in[667]<=err_req_del;descram_in[621]<=nftl_err_reg;descram_in[597]<=msi_en[0];descram_in[553]<=addr64_enable;descram_in[491]<=nftl_err_p;descram_in[438]<=ewrite;descram_in[436]<=msi_enable;descram_in[411]<=tx_ca_ph[0];descram_in[342]<=en_array[0];descram_in[341]<=mFmt[0];descram_in[333]<=err_req;descram_in[276]<=write;descram_in[170]<=msi_input[0];descram_in[166]<=err_msgcode[0];descram_in[85]<=credit_gate_int_msg;descram_in[42]<=credit_gate2;descram_in[21]<=credit_gate1;descram_in[10]<=dcnt[0];descram_in[5]<=rd_ptr[0];descram_in[2]<=wr_ptr[0];descram_in[1]<=int_msgcode[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.20 2007/08/01 17:16:08PDT rperugu


// Changed the emem_array depth to 32 -> can store 32 error messages.


// Accordingly edcnt, ewr_ptr, erd_ptr widths are increased.


// Revision 1.19 2007/07/27 17:29:00PDT uananthi


// data bytes swaped for memory write TLP for MSI


// Revision 1.18 2007/07/25 14:22:33PDT rperugu


// Changed 1) int_pending resetting


// 2) bige_mes_data32/64 are added (logic is not changed).


// Revision 1.17 2007/07/19 17:15:47PDT rperugu


//


// Revision 1.16 2007/07/19 17:11:55PDT rperugu


// msi_reg_update logic is changed


// Reset value for next_state is changed to {MSI_0,..MSI_0} from 32'd0


// Revision 1.15 2007/07/11 14:35:37PDT rperugu


//


// Revision 1.14 2007/06/19 09:19:00PDT gkrishna


// Added read to teadclock enable


// Revision 1.13 2007/06/14 16:45:43PDT gkrishna


//


// Revision 1.12 2007/06/12 16:46:57PDT rperugu


//


// Revision 1.11 2007/06/11 13:55:38PDT rperugu


//


// Revision 1.10 2007/06/11 11:27:28PDT rperugu


//


// Revision 1.9 2007/06/05 15:23:29PDT rperugu


//


// Revision 1.8 2007/06/05 14:03:16PDT rperugu


//


// Revision 1.7 2007/06/04 13:15:05PDT rperugu


//


// Revision 1.6 2007/06/01 15:58:08PDT rperugu


//


// Revision 1.5 2007/05/24 12:57:09PDT srajadur


// else if(cor_err_p)


// Revision 1.4 2007/05/18 17:23:18PDT rperugu


//


// Revision 1.3 2007/05/18 17:17:30PDT rperugu


//


// Revision 1.2 2007/05/18 14:31:17PDT rperugu


//


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI Express 4X


// File             : txintf.v


// Title            : TX User interface


// Dependencies     : pci_exp_params.v


// Description      : This module implements the the PER VC user side TX interface


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : April 13, 2004


// Changes Made     : Initial Creation


//


// =============================================================================




`timescale 1 ns / 100 ps
module txintf
   (
    
    sys_clk,           
    rst_n,             
    cfgec_vcasel,      
    phy_cfgln_sum,     
    rate_5g,           

    arb_enable,        
    arb_enable2,       
    msi_enable,        
    `ifdef CFG_REG
       cfg_rmux_req,   
       cfg_rmux_ae,    
       cfg_rmux_data,  
       cfg_rmux_dwen,  
    `endif
    `ifdef ECRC
      ecrc_enb,        
    `endif
    tx_req,            
    tx_data,           
    tx_st,             
    tx_end,            
    tx_nlfy,           
    tx_dwen,           
    txtp_rdy,          
    dll_pause_cnt,     
    vcneg_pend,        

    
    txintf_pause_ack,  
    txintf_rdy_ack,    
    `ifdef CFG_REG
       cfg_rmux_rd,    
    `endif
    cfg_cplh_cc,       
    cfg_cpld_cc,       
    cfg_ph_cc,         
    cfg_pd_cc,         

    tx_rdy,            
    txintf_req,        
    txintf_data,       
    txintf_st,         
    txintf_end,        
    txintf_nlfy,       
    txintf_dwen,       
    txintf_val,        

    f_nf_emsg_sent,    
    rchk_credit_cpl,   
    rchk_credit_p,     
    cfg_rmux_end       

    );
parameter FADDR    = 6;
parameter D_WIDTH  = 64;
localparam TI_WAIT_EOP = 2'd0;
localparam TI_INC_CNT  = 2'd1;
localparam TI_NOP_1    = 2'd2;
localparam TI_NOP_2    = 2'd3;
input                       sys_clk;
input                       rst_n;
input  [2:0]                cfgec_vcasel;
input  [2:0]                phy_cfgln_sum;
input                       rate_5g;
input                       arb_enable;
input                       arb_enable2;
input                       msi_enable;

`ifdef CFG_REG
input                    cfg_rmux_req;
input                    cfg_rmux_ae;
input [D_WIDTH -1:0]     cfg_rmux_data;
input                    cfg_rmux_dwen;

`endif

`ifdef ECRC
input                    ecrc_enb;

`endif
input [`NUM_VC-1:0]         tx_req;
input [`NUM_VC*D_WIDTH-1:0] tx_data;
input [`NUM_VC-1:0]         tx_st;
input [`NUM_VC-1:0]         tx_end;
input [`NUM_VC-1:0]         tx_nlfy;
input [`NUM_VC-1:0]         tx_dwen;
input                       txtp_rdy;
input [FADDR:0]             dll_pause_cnt;
input [`NUM_VC -1:0]        vcneg_pend ;
output                      txintf_pause_ack;
output                      txintf_rdy_ack;

`ifdef CFG_REG
output                   cfg_rmux_rd;

`endif
output                      cfg_cplh_cc;
output                      cfg_cpld_cc;
output                      cfg_ph_cc;
output                      cfg_pd_cc;
output[`NUM_VC-1:0]         tx_rdy;
output                      txintf_req;
output [D_WIDTH -1:0]       txintf_data;
output                      txintf_st;
output                      txintf_end;
output                      txintf_nlfy;
output                      txintf_dwen;
output                      txintf_val;
output                      cfg_rmux_end;
output                      f_nf_emsg_sent;
output                      rchk_credit_cpl;
output                      rchk_credit_p;
wire   [`NUM_VC-1:0]        tx_data_algn;
wire   [`NUM_VC-1:0]        tx_eop_early;
wire   [`NUM_VC-1:0]        vcarb_grant;
wire   [`NUM_VC-1:0]        txrdy_clear_rdy;
wire                        vcarb_grant_val;
wire                        tx_eop;
wire                        memwr_pkt;
wire                        memwr_4dw;
wire                        non_cor_err;
reg    [`NUM_VC-1:0]        vcarb_grant_d0;
reg    [`NUM_VC-1:0]        vcarb_grant_reg;
reg                         txintf_req;
reg    [D_WIDTH -1:0]      txintf_data;
reg                         txintf_st;
reg                         txintf_end;
reg                         txintf_nlfy;
reg                         txintf_dwen;
reg                         pkt_progress;

`ifdef CFG_REG
reg                         cfg_rmux_valid;
wire                        cfg_rmux_rd;
reg    [2:0]                cs_cfgrd;
reg                         cfg_rmux_st;
reg                         cfg_rmux_rd_i;
wire                        cfg_sm_active;
reg                         cfg_cnt_st;
reg                         cfg_cnt_st_d0;
reg                         cfg_cnt_st_d1;
reg                         ipg_done;

`endif
reg   [FADDR:0]             pause_cnt;
reg                         pause_enable;
reg   [1:0]                 cs_pause;
reg                         txintf_pause_ack;
reg                         txintf_rdy_ack;
reg                         userif_stped_d0;
reg                         userif_stped_d1;
reg   [1:0]                 cnt_dval;
reg                         data_valid;
reg                         cfg_cplh_cc;
reg                         cfg_cpld_cc;
reg                         cfg_ph_cc;
reg                         cfg_pd_cc;
reg                         cfg_rmux_end;
reg                         f_nf_emsg_sent;
reg                         rchk_credit_cpl;
reg                         rchk_credit_p;
reg                         req_taken;

`ifndef VC1

`else

`endif

`ifdef CFG_REG
reg [D_WIDTH -1:0] cfg_rmux_data_d;
reg                cfg_rmux_valid_d,cfg_rmux_dwen_d,cfg_rmux_st_d,cfg_rmux_end_d;

`endif

`ifdef CFG_REG

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef CFG_REG

`else

`endif

`ifdef CFG_REG
parameter  CR_WAIT      = 3'd0;
parameter  CR_IPG_PRE   = 3'd1;
parameter  CR_DATA0     = 3'd2;
parameter  CR_DATA1     = 3'd3;
parameter  CR_IPG_POST  = 3'd4;
parameter  CR_DATA2     = 3'd5;

`ifdef ECRC

`else

`endif

`else

`endif

`ifdef CFG_REG

`endif

`ifdef CFG_REG

`endif

`ifdef ECRC

`endif

`ifdef ECRC

`else

`endif
reg [2 : 0] cfgec_vcasel_split;
reg [2 : 0] phy_cfgln_sum_split;
reg rate_5g_split;
reg arb_enable_split;
reg arb_enable2_split;
reg msi_enable_split;
reg [`NUM_VC - 1 : 0] tx_req_split;
reg [`NUM_VC * D_WIDTH - 1 : 0] tx_data_split;
reg [`NUM_VC - 1 : 0] tx_st_split;
reg [`NUM_VC - 1 : 0] tx_end_split;
reg [`NUM_VC - 1 : 0] tx_nlfy_split;
reg [`NUM_VC - 1 : 0] tx_dwen_split;
reg txtp_rdy_split;
reg [FADDR : 0] dll_pause_cnt_split;
reg [`NUM_VC - 1 : 0] vcneg_pend_split;
reg [`NUM_VC - 1 : 0] tx_data_algn_split;
reg [`NUM_VC - 1 : 0] tx_eop_early_split;
reg [`NUM_VC - 1 : 0] vcarb_grant_split;
reg [`NUM_VC - 1 : 0] txrdy_clear_rdy_split;
reg vcarb_grant_val_split;
reg tx_eop_split;
reg memwr_pkt_split;
reg memwr_4dw_split;
reg non_cor_err_split;
reg [`NUM_VC - 1 : 0] vcarb_grant_d0_split;
reg [`NUM_VC - 1 : 0] vcarb_grant_reg_split;
reg pkt_progress_split;
reg [FADDR : 0] pause_cnt_split;
reg pause_enable_split;
reg [1 : 0] cs_pause_split;
reg userif_stped_d0_split;
reg userif_stped_d1_split;
reg [1 : 0] cnt_dval_split;
reg data_valid_split;
reg req_taken_split;
reg [2047:0] descram_in;
wire [34:0] descram_out;

`ifdef CFG_REG

`endif

`ifdef ECRC

`endif

`ifdef CFG_REG

`endif

`ifdef CFG_REG

`endif

`ifndef VC1


`else

`endif

`ifdef CFG_REG

`endif

`ifdef CFG_REG

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef CFG_REG

`else

`endif

`ifdef CFG_REG

`ifdef ECRC

`else

`endif

`else

`endif

`ifdef CFG_REG

`endif


`ifdef CFG_REG

`endif

`ifdef ECRC

`endif

`ifdef ECRC

`else

`endif

localparam descram_inst_SIZE = 35,descram_inst_SCRAMSTRING = 32'hfdffda0b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef CFG_REG


`endif



`ifdef ECRC


`endif


`ifdef CFG_REG


`endif


`ifdef CFG_REG


`endif


`ifndef VC1



`else



`endif



`ifdef CFG_REG


`endif



`ifdef CFG_REG



`endif



`ifdef EN_VC0



`endif



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif



`ifdef CFG_REG



`else



`endif



`ifdef CFG_REG


`ifdef ECRC



`else



`endif



`else



`endif



`ifdef CFG_REG



`endif



`ifdef CFG_REG



`endif



`ifdef ECRC



`endif



`ifdef ECRC



`else



`endif

// =============================================================================
// Parameters
// =============================================================================
// =============================================================================
// Define all inputs / outputs
// =============================================================================
//---------Inputs------------


`ifdef CFG_REG


   

`endif




`ifdef ECRC


   

`endif


//---------Outputs------------


`ifdef CFG_REG


   

`endif


// =============================================================================
// Define Wire & Registers
// =============================================================================
//---- Wires
//---- Register


`ifdef CFG_REG




`endif


// =============================================================================
// Instintiate the VC Arb logic ONLY if VC is more than 1
// for one VC disable the arbitartion logic
// =============================================================================


`ifndef VC1


assign tx_eop = ((|tx_end_split) | (|tx_nlfy_split));
vcarb u1_vcarb
   (
    //------- Inputs
    .sys_clk         (sys_clk),
    .rst_n           (rst_n),
    .pkt_progress    (pkt_progress_split),
    .cfgec_vcasel    (cfgec_vcasel_split),
    .tx_req          (tx_req_split),
    .tx_eop_early    (|tx_eop_early_split),
    .tx_data_algn    (|tx_data_algn_split),
    .txrdy_clear_rdy (|txrdy_clear_rdy_split),
    .txintf_val      (txintf_val),

    //------- Outputs
    .vcarb_grant_val (vcarb_grant_val),
    .vcarb_grant     (vcarb_grant)
    );


`else


assign vcarb_grant_val = 1'b1;
assign vcarb_grant     = 'd1;


`endif



// =============================================================================
// generated vc_arb_grant reg
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)  begin
      vcarb_grant_d0 <= 0;
      vcarb_grant_reg <= 0;
   end
   else if (vcarb_grant_val_split & txintf_val) begin
      vcarb_grant_d0 <= vcarb_grant_split;
      vcarb_grant_reg <= vcarb_grant_d0_split;
   end
end

// =============================================================================
// Mux out the the VC based on the grant
// if vcarb_grant[0] = 1 generate ready for VC0
// if vcarb_grant[1] = 1 generate ready for VC1
// NOTE: During txintf_end generation, is not generated when when tx_end &
// tx_nlfy are both active
// =============================================================================
// If 8 VC is selected
// =============================================================================


`ifdef CFG_REG


   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) begin
         cfg_rmux_data_d  <= 64'd0;
         cfg_rmux_valid_d <= 1'b0;
         cfg_rmux_st_d    <= 1'b0;
         cfg_rmux_end_d   <= 1'b0;
         cfg_rmux_dwen_d  <= 1'b0;
      end
      else begin
         cfg_rmux_data_d  <= cfg_rmux_data;
         cfg_rmux_valid_d <= cfg_rmux_valid;
         cfg_rmux_dwen_d  <= cfg_rmux_dwen;
         cfg_rmux_st_d    <= cfg_rmux_st;
         cfg_rmux_end_d   <= cfg_rmux_end;
      end
   end


`endif



always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)  begin
      txintf_data <= 0;
      txintf_st   <= 0;
      txintf_end  <= 0;
      txintf_nlfy <= 0;
      txintf_dwen <= 0;
   end
   

`ifdef CFG_REG


   else if (cfg_rmux_valid_d) begin
      txintf_data <= cfg_rmux_data_d;
      txintf_st   <= cfg_rmux_st_d;
      txintf_end  <= cfg_rmux_end_d;
      txintf_nlfy <= 1'b0;
      txintf_dwen <= (cfg_rmux_end_d) ? cfg_rmux_dwen_d : 1'b0;
   end
   

`endif


   else if (txintf_val) begin
      case(1'b1)
         

`ifdef EN_VC0


            vcarb_grant_reg_split[0]: begin
               txintf_data <= tx_data_split[63:0];
               txintf_st   <= tx_st_split[0];
               txintf_end  <= (tx_nlfy_split[0] & tx_end_split[0]) ? 1'b0 : tx_end_split[0];
               txintf_nlfy <= tx_nlfy_split[0];
               txintf_dwen <= tx_dwen_split[0];
            end
         

`endif


         

`ifdef EN_VC1


            vcarb_grant_reg_split[1]: begin
               txintf_data <= tx_data_split[2*64-1:64];
               txintf_st   <= tx_st_split[1];
               txintf_end  <= (tx_nlfy_split[1] & tx_end_split[1]) ? 1'b0 : tx_end_split[1];
               txintf_nlfy <= tx_nlfy_split[1];
               txintf_dwen <= tx_dwen_split[1];
            end
         

`endif


         

`ifdef EN_VC2


            vcarb_grant_reg_split[2]: begin
               txintf_data <= tx_data_split[3*64-1:2*64];
               txintf_st   <= tx_st_split[2];
               txintf_end  <= (tx_nlfy_split[2] & tx_end_split[2]) ? 1'b0 : tx_end_split[2];
               txintf_nlfy <= tx_nlfy_split[2];
               txintf_dwen <= tx_dwen_split[2];
            end
         

`endif


         

`ifdef EN_VC3


            vcarb_grant_reg_split[3]: begin
               txintf_data <= tx_data_split[4*64-1:3*64];
               txintf_st   <= tx_st_split[3];
               txintf_end  <= (tx_nlfy_split[3] & tx_end_split[3]) ? 1'b0 : tx_end_split[3];
               txintf_nlfy <= tx_nlfy_split[3];
               txintf_dwen <= tx_dwen_split[3];
            end
         

`endif


         

`ifdef EN_VC4


            vcarb_grant_reg_split[4]: begin
               txintf_data <= tx_data_split[5*64-1:4*64];
               txintf_st   <= tx_st_split[4];
               txintf_end  <= (tx_nlfy_split[4] & tx_end_split[4]) ? 1'b0 : tx_end_split[4];
               txintf_nlfy <= tx_nlfy_split[4];
               txintf_dwen <= tx_dwen_split[4];
            end
         

`endif


         

`ifdef EN_VC5


            vcarb_grant_reg_split[5]: begin
               txintf_data <= tx_data_split[6*64-1:5*64];
               txintf_st   <= tx_st_split[5];
               txintf_end  <= (tx_nlfy_split[5] & tx_end_split[5]) ? 1'b0 : tx_end_split[5];
               txintf_nlfy <= tx_nlfy_split[5];
               txintf_dwen <= tx_dwen_split[5];
            end
         

`endif


         

`ifdef EN_VC6


            vcarb_grant_reg_split[6]: begin
               txintf_data <= tx_data_split[7*64-1:6*64];
               txintf_st   <= tx_st_split[6];
               txintf_end  <= (tx_nlfy_split[6] & tx_end_split[6]) ? 1'b0 : tx_end_split[6];
               txintf_nlfy <= tx_nlfy_split[6];
               txintf_dwen <= tx_dwen_split[6];
            end
         

`endif


         

`ifdef EN_VC7


            vcarb_grant_reg_split[7]: begin
               txintf_data <= tx_data_split[8*64-1:7*64];
               txintf_st   <= tx_st_split[7];
               txintf_end  <= (tx_nlfy_split[7] & tx_end_split[7]) ? 1'b0 : tx_end_split[7];
               txintf_nlfy <= tx_nlfy_split[7];
               txintf_dwen <= tx_dwen_split[7];
            end
         

`endif


         default :  begin
            txintf_st   <= 1'b0;
            txintf_end  <= 1'b0;
            txintf_nlfy <= 1'b0;
            txintf_dwen <= 1'b0;
         end
      endcase
   end
end

// =============================================================================
// Generate the Request to DLL block if Only Packet is not in progress & if
// 1) User request is present
// 2) CFG request is present
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)  begin
      txintf_req <= 0;
   end
   else if (pkt_progress_split == 1'b0) begin
   

`ifdef CFG_REG


      txintf_req <= (|tx_req_split | cfg_rmux_req);
   

`else


      txintf_req <= |tx_req_split;
   

`endif


   end
end

// =============================================================================
// Indicates packet is in progress
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)  begin
      pkt_progress <= 0;
   end
   else if (|tx_st_split) begin
      pkt_progress <= 1'b1;
   end
   else if (|tx_eop_early_split) begin
      pkt_progress <= 1'b0;
   end
end


// =============================================================================
// Generate the read to CFG FIFO ONLY when
// 1) cfg req is present
// 2) txtp is ready
// 3) not almost empty
// 4) All user ready signal is zero
// Read the CFG FIFO one TLP at a time with a GAP between CFG TLP packets for
// LCRC Seq etc insertion
// The following SM also adds IPG before the packet starts and after the packet ends
// with ECRC 2 clocks
// without ECRC 1 Clock
// =============================================================================



`ifdef CFG_REG


// INTa: 00, ERR_COR:00, ERR_NONFATAL:01, ERR_FATAL:11
assign non_cor_err = (cfg_rmux_data_d[1:0] != 2'b00) ? 1'b1 : 1'b0;    //Means FATAL/NON_FATAL
assign memwr_pkt   = (cfg_rmux_data[62:61] != 2'b01) ? 1'b1 : 1'b0;  //FMT=2'b01 for MSG
assign memwr_4dw   = (cfg_rmux_data[62:61] == 2'b11) ? 1'b1 : 1'b0;  //FMT=2'b11 for 4 DW

assign cfg_rmux_rd = (txintf_val) ? cfg_rmux_rd_i : 1'b0;
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cs_cfgrd        <= CR_WAIT;
      cfg_rmux_valid  <= 1'b0;
      cfg_rmux_rd_i     <= 1'b0;
      cfg_rmux_st     <= 1'b0;
      cfg_rmux_end    <= 1'b0;
      cfg_cnt_st      <= 1'b0;
      f_nf_emsg_sent  <= 1'b0;
      rchk_credit_cpl <= 1'b0;
      rchk_credit_p   <= 1'b0;
      req_taken       <= 1'b0;
   end
   else if (txintf_val) begin
      cfg_rmux_valid  <= 1'b0;
      cfg_rmux_st     <= 1'b0;
      cfg_rmux_end    <= 1'b0;
      f_nf_emsg_sent  <= 1'b0;
      cfg_cnt_st      <= 1'b0;
      rchk_credit_cpl <= 1'b0;
      rchk_credit_p   <= 1'b0;
      req_taken       <= 1'b0;

      case(cs_cfgrd)
         CR_WAIT: begin
            cfg_rmux_rd_i     <= 1'b0;
            if (cfg_rmux_req && txtp_rdy_split && !cfg_rmux_ae && |tx_rdy == 1'b0 && pause_enable_split == 1'b0) begin
               cs_cfgrd        <= CR_IPG_PRE;
               cfg_cnt_st      <= 1'b1;
               req_taken       <= 1'b1;
            end
            else begin
               cs_cfgrd        <= CR_WAIT;
               cfg_cnt_st      <= 1'b0;
            end
         end
         CR_IPG_PRE: begin
            if (ipg_done) begin
               cfg_rmux_rd_i  <= 1'b1;
               cs_cfgrd     <= CR_DATA0;
            end
            else begin
               cs_cfgrd     <= CR_IPG_PRE;
            end
         end
         CR_DATA0: begin
            cfg_rmux_valid  <= 1'b1;
            cfg_rmux_st     <= 1'b1;
            /**
            if(!arb_enable) begin  //CFG RESP pkt
	       cfg_cplh_cc     <= 1'b1;
               cfg_cpld_cc     <= cfg_rmux_data[62];
            end
            **/
            cfg_rmux_rd_i     <= 1'b1;
            cs_cfgrd        <= CR_DATA1;
         end
         CR_DATA1: begin
            //cs_cfgrd        <= CR_IPG_POST;
            //cfg_rmux_end    <= 1'b1;
            cfg_rmux_valid  <= 1'b1;
            //cfg_cnt_st      <= 1'b1;
            //if(arb_enable && memwr_4dw) begin //MemWr pkt 4 DW
            if(memwr_4dw_split) begin //MemWr pkt 4 DW
               cs_cfgrd        <= CR_DATA2;
               cfg_rmux_rd_i     <= 1'b1;
            end
            else begin
               cfg_rmux_rd_i     <= 1'b0;
               cs_cfgrd        <= CR_IPG_POST;
               cfg_rmux_end    <= 1'b1;
               cfg_cnt_st      <= 1'b1;
               rchk_credit_cpl <= !arb_enable_split;
               rchk_credit_p   <= arb_enable_split;
            end
            /***
            if(arb_enable) //INT/MSG pkt
	       cfg_ph_cc     <= 1'b1;
            if(arb_enable && memwr_pkt) //MemWr pkt
               cfg_pd_cc     <= 1'b1;  //1 DW for MEMWR
            ***/

            //if(arb_enable && !memwr_pkt) begin //MSG pkt
            if(arb_enable_split && arb_enable2_split) begin //ERR-MSG pkt
               f_nf_emsg_sent  <= non_cor_err_split;  //Fatal/Non-Fatal Error MSG pkt sent
            end
         end
         CR_DATA2: begin   //----- Only for Mem WR & 4 DW pkt -------
            cfg_rmux_rd_i     <= 1'b0;
            cs_cfgrd        <= CR_IPG_POST;
            cfg_rmux_end    <= 1'b1;
            cfg_rmux_valid  <= 1'b1;
            cfg_cnt_st      <= 1'b1;
            rchk_credit_p   <= 1'b1;
         end
         CR_IPG_POST: begin
            cfg_rmux_rd_i     <= 1'b0;
            cfg_rmux_valid  <= 1'b1;
            if (ipg_done) begin
               cs_cfgrd        <= CR_WAIT;
            end
            else begin
               cs_cfgrd        <= CR_IPG_POST;
            end
         end
         default: begin
            cfg_rmux_rd_i     <= 1'b0;
            cs_cfgrd     <= CR_WAIT;
         end
      endcase
   end
   else begin
      cfg_rmux_valid  <= 1'b0;
   end
end

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)  begin
      ipg_done <= 'd0;
      cfg_cnt_st_d0 <= 1'b0;
      cfg_cnt_st_d1 <= 1'b0;
   end
   else if (txintf_val) begin
      

`ifdef ECRC


         ipg_done <= (ecrc_enb) ? cfg_cnt_st : cfg_cnt_st;
      

`else


         ipg_done <= cfg_cnt_st;
      

`endif


      cfg_cnt_st_d0 <= cfg_cnt_st;
      cfg_cnt_st_d1 <= cfg_cnt_st_d0;
   end
end
assign cfg_sm_active = (cs_cfgrd == CR_WAIT) ? 1'b0 : 1'b1;


`else


   assign memwr_pkt     = 1'b0;
   assign memwr_4dw     = 1'b0;
   assign non_cor_err   = 1'b0;

   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) begin
         cfg_rmux_end    <= 1'b0;
         f_nf_emsg_sent  <= 1'b0;
         rchk_credit_cpl <= 1'b0;
         rchk_credit_p   <= 1'b0;
         req_taken       <= 1'b0;
      end
   end


`endif



// =============================================================================
//Generation of Credit Consumed singals for Transmit path
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cfg_ph_cc       <= 1'b0;
      cfg_pd_cc       <= 1'b0;
      cfg_cplh_cc     <= 1'b0;
      cfg_cpld_cc     <= 1'b0;
   end
   

`ifdef CFG_REG


   else if (txintf_val) begin
      cfg_ph_cc       <= 1'b0;
      cfg_pd_cc       <= 1'b0;
      cfg_cplh_cc     <= 1'b0;
      cfg_cpld_cc     <= 1'b0;
      if(req_taken_split) begin
         if(arb_enable_split) begin //INT/MSG pkt
            cfg_ph_cc     <= 1'b1;
            if(!arb_enable2_split && msi_enable_split) //MSI pkt (datapayload)
               cfg_pd_cc     <= 1'b1;
         end
      end
      else if (!arb_enable_split && cfg_rmux_st) begin //CFG RESP pkt
            cfg_cplh_cc     <= 1'b1;
            cfg_cpld_cc     <= cfg_rmux_data[62];
      end
   end
   

`endif


end

// =============================================================================
// Instinatiate the ready generation logic per VC
// =============================================================================
txrdy u1_txrdy [`NUM_VC-1:0] (
    //------- Inputs
    .sys_clk            (sys_clk),
    .rst_n              (rst_n),
    .tx_req             (tx_req_split),
    .tx_data            (tx_data_split),
    .tx_st              (tx_st_split),
    .tx_nlfy            (tx_nlfy_split),
    .txtp_rdy           (txtp_rdy_split),
    .txintf_val         (txintf_val),
    

`ifdef CFG_REG


       .cfg_rmux_req    (cfg_rmux_req | cfg_sm_active),
    

`endif


    

`ifdef ECRC


      .ecrc_enb         (ecrc_enb),
    

`endif


    .vcarb_grant_val    (vcarb_grant_val_split),
    .vcarb_grant        (vcarb_grant_split),
    .pause_enable       (pause_enable_split),
    .vcneg_pend         (vcneg_pend_split),

    //------- Outputs
    .txrdy_clear_rdy    (txrdy_clear_rdy),
    .tx_data_algn       (tx_data_algn),
    .tx_eop_early       (tx_eop_early),
    .tx_rdy             (tx_rdy)
    );


// =============================================================================
// The following Latches the pause count one clock before EOP & generates a PAUSE
// signal so that the Interfaces pause for the requested number of clocks.
// This GAP between packets is used to Insert DLLP/SKP characters by DLL or
// PHY layers
//
// =============================================================================
// Apart from pausing for extra cycles requested by dll_pause_cnt this logic
// generates the pause required between packets as per the following table
//
// Indicates if the current packet data is aligned ie
// Header + Data length = Last bit to be ZERO
// The following data is added by DUT
// PHY+DLL    ---> 2DW
// TRN(ECRC)  ---> 1DW
//
// User Data Width                  ECRC+PHY+DLL       Packet Gap
// Non Aligned (3,5,7,9...)         3DW (WITH ECRC)    1 Clock
// Non Aligned (3,5,7,9...)         2DW                1 Clock
//
// Aligned (2,4,5,6...)             3DW (WITH ECRC)    2 Clock
// Aligned (2,4,5,6...)             2DW                1 Clock
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)  begin
      cs_pause         <= TI_WAIT_EOP;
      pause_cnt        <= 0;
      pause_enable     <= 0;
      txintf_pause_ack <= 0;
   end
   else if (txintf_val) begin
      txintf_pause_ack <= 1'b0;
      case(cs_pause_split)
         TI_WAIT_EOP: begin
            if (|tx_rdy && |txrdy_clear_rdy_split) begin
               cs_pause         <= TI_INC_CNT;
	       

`ifdef ECRC


               pause_cnt        <= (ecrc_enb && |tx_data_algn_split) ? dll_pause_cnt_split + 2'd1 :  dll_pause_cnt_split;
               

`else


               pause_cnt        <= dll_pause_cnt_split;
               

`endif


               pause_enable     <= 1'b1;
               txintf_pause_ack <= 1'b1;
            end
            else if ((|tx_rdy == 1'b0 && |tx_req_split == 1'b0) && (dll_pause_cnt_split != 0)) begin
               cs_pause         <= TI_INC_CNT;
               pause_cnt        <= dll_pause_cnt_split;
               pause_enable     <= 1'b1;
               txintf_pause_ack <= 1'b1;
            end
            else begin
               cs_pause         <= TI_WAIT_EOP;
               pause_enable     <= 1'b0;
            end
         end
         TI_INC_CNT: begin
            if (pause_cnt_split == 0) begin
               cs_pause         <= TI_NOP_1;
               pause_enable     <= 1'b0;
            end
            else begin
               cs_pause         <= TI_INC_CNT;
               pause_cnt        <= pause_cnt_split - 1'd1;
               pause_enable     <= 1'b1;
            end
         end
         // Delay checking of dll_pause_cnt by 2 clocks
         TI_NOP_1: begin
            cs_pause         <= TI_NOP_2;
         end
         TI_NOP_2: begin
            cs_pause         <= TI_WAIT_EOP;
         end
         default: begin
            cs_pause         <= TI_WAIT_EOP;
         end
      endcase
   end
   else begin
      txintf_pause_ack <= 1'b0;
   end
end

// =============================================================================
// The following generates a pulse indicating that the txtp_rdy has been seen and
// the last packet is being sent  indicating the USER I/F has been stopped
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)  begin
      userif_stped_d0 <= 0;
      userif_stped_d1 <= 0;
      txintf_rdy_ack  <= 0;
   end
   else if (txintf_val) begin
      userif_stped_d0 <= (txtp_rdy_split == 1'b0 && |tx_rdy == 1'b0) ? 1'b1 : 1'b0;
      userif_stped_d1 <= userif_stped_d0_split;
      txintf_rdy_ack  <= userif_stped_d0_split & ~userif_stped_d1_split & (|tx_rdy == 1'b0);
   end
end


// =============================================================================
// The following generates the data valid signal
// for x1 --> every 4 clocks
// for x2 --> every 2 clocks
// for x4 --> every 1 clocks
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      cnt_dval      <= 'd0;
      data_valid    <= 1'b0;
   end
   else begin
      cnt_dval      <= cnt_dval_split +1;
      // Generate the data valid & the link width
      case({rate_5g_split,phy_cfgln_sum_split})
         {1'b0,3'd1}: begin
            data_valid <= (cnt_dval_split == 'd0) ? 1'b1 : 1'b0;
         end
         {1'b0,3'd2},{1'b1,3'd1} : begin
            data_valid <= (cnt_dval_split == 'd0 || cnt_dval_split == 'd2) ? 1'b1 : 1'b0;
         end
         {1'b1,3'd2}:begin
            data_valid <= 1'b1;
         end
         default: begin
            data_valid <= 1'b0;
         end
      endcase
   end
end
assign txintf_val = data_valid_split;

always@* begin cfgec_vcasel_split<={cfgec_vcasel>>1,descram_out[0]};phy_cfgln_sum_split<={phy_cfgln_sum>>1,descram_out[1]};rate_5g_split<=descram_out[2];arb_enable_split<=descram_out[3];arb_enable2_split<=descram_out[4];msi_enable_split<=descram_out[5];tx_req_split<={tx_req>>1,descram_out[6]};tx_data_split<={tx_data>>1,descram_out[7]};tx_st_split<={tx_st>>1,descram_out[8]};tx_end_split<={tx_end>>1,descram_out[9]};tx_nlfy_split<={tx_nlfy>>1,descram_out[10]};tx_dwen_split<={tx_dwen>>1,descram_out[11]};txtp_rdy_split<=descram_out[12];dll_pause_cnt_split<={dll_pause_cnt>>1,descram_out[13]};vcneg_pend_split<={vcneg_pend>>1,descram_out[14]};tx_data_algn_split<={tx_data_algn>>1,descram_out[15]};tx_eop_early_split<={tx_eop_early>>1,descram_out[16]};vcarb_grant_split<={vcarb_grant>>1,descram_out[17]};txrdy_clear_rdy_split<={txrdy_clear_rdy>>1,descram_out[18]};vcarb_grant_val_split<=descram_out[19];tx_eop_split<=descram_out[20];memwr_pkt_split<=descram_out[21];memwr_4dw_split<=descram_out[22];non_cor_err_split<=descram_out[23];vcarb_grant_d0_split<={vcarb_grant_d0>>1,descram_out[24]};vcarb_grant_reg_split<={vcarb_grant_reg>>1,descram_out[25]};pkt_progress_split<=descram_out[26];pause_cnt_split<={pause_cnt>>1,descram_out[27]};pause_enable_split<=descram_out[28];cs_pause_split<={cs_pause>>1,descram_out[29]};userif_stped_d0_split<=descram_out[30];userif_stped_d1_split<=descram_out[31];cnt_dval_split<={cnt_dval>>1,descram_out[32]};data_valid_split<=descram_out[33];req_taken_split<=descram_out[34];end
always@* begin descram_in[2047]<=phy_cfgln_sum[0];descram_in[2046]<=rate_5g;descram_in[2044]<=arb_enable;descram_in[2040]<=arb_enable2;descram_in[2032]<=msi_enable;descram_in[2016]<=tx_req[0];descram_in[1984]<=tx_data[0];descram_in[1924]<=vcarb_grant_d0[0];descram_in[1921]<=tx_st[0];descram_in[1801]<=vcarb_grant_reg[0];descram_in[1795]<=tx_end[0];descram_in[1776]<=memwr_pkt;descram_in[1758]<=txrdy_clear_rdy[0];descram_in[1554]<=pkt_progress;descram_in[1542]<=tx_nlfy[0];descram_in[1505]<=memwr_4dw;descram_in[1468]<=vcarb_grant_val;descram_in[1188]<=cnt_dval[0];descram_in[1061]<=pause_cnt[0];descram_in[1037]<=tx_dwen[0];descram_in[1023]<=cfgec_vcasel[0];descram_in[962]<=non_cor_err;descram_in[888]<=tx_eop;descram_in[879]<=vcarb_grant[0];descram_in[659]<=req_taken;descram_in[594]<=userif_stped_d1;descram_in[439]<=tx_eop_early[0];descram_in[329]<=data_valid;descram_in[297]<=userif_stped_d0;descram_in[219]<=tx_data_algn[0];descram_in[148]<=cs_pause[0];descram_in[109]<=vcneg_pend[0];descram_in[74]<=pause_enable;descram_in[54]<=dll_pause_cnt[0];descram_in[27]<=txtp_rdy;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


//


// Revision 1.17 2007/06/19 10:30:50PDT gkrishna


// Added cfg_rmux_rd_i to generate correct read in x1 mode


// Revision 1.16 2007/06/12 16:46:55PDT rperugu


//


// Revision 1.15 2007/06/04 13:15:07PDT rperugu


//


// Revision 1.14 2007/06/01 11:39:11PDT rperugu


//


// Revision 1.13 2007/05/18 17:17:33PDT rperugu


//


// Revision 1.12 2007/05/18 14:30:11PDT rperugu


//


// Revision 1.11 2007/05/18 12:10:44PDT rperugu


// Logic for INT_MSG TLP - more than 2 clks pkt is added.


// Revision 1.10 2007/03/07 15:08:31PST srajadur


// trnc\txintf\txintf.v(Line 609): Remove the default clause(Or you need


// the assign some value);


// Revision 1.9 2007/02/08 16:27:37PST gkrishna


// Added gap generating logic between packets


// Revision 1.8 2007/02/06 09:40:00PST gkrishna


//


// Revision 1.7 2007/02/06 09:35:26PST gkrishna


// Fixed IPG between packets


// Revision 1.6 2007/02/06 09:01:49PST gkrishna


// Fixed CFG RESPONSE  to user packet GAP


// Revision 1.5 2006/11/27 13:13:04PST gkrishna


// Updated with modifications to reduce logic levels.


// Revision 1.4 2006/06/16 10:26:45PDT gkrishna


//


// Revision 1.3 2006/06/16 10:07:06PDT gkrishna


// Updated CFG read logic


// Revision 1.2 2006/05/23 11:59:49PDT gkrishna


// Updated with x1 fixes


// Revision 1.42 2005/03/31 15:19:14PST uananthi


// fixed X1 problems


// Revision 1.41 2005/03/08 08:18:52PST gkrishna


// Added pkt_progress port to VCArb


// Revision 1.40 2005/03/03 13:42:39PST gkrishna


// Added ecrc_enb signal


// Revision 1.39 2004/10/01 11:32:22PDT uananthi


// data_valid default changed.


// Revision 1.38 2004/08/04 10:17:41PDT gkrishna


// Fixed txintf_pause_ack  to pulse generation in downgrade


// Revision 1.37 2004/08/04 09:08:46PDT gkrishna


// Added txintf_val


// Revision 1.36 2004/07/30 16:28:49PDT gkrishna


// Added txintf_val


// Revision 1.35 2004/07/30 15:36:08PDT gkrishna


// Fixed pause ack generation


// Revision 1.34 2004/07/28 08:35:42PDT gkrishna


// Added downgrade for CFG read


// Revision 1.33 2004/07/27 09:22:31PDT gkrishna


// Added txintf_val generation


// Revision 1.32 2004/06/28 13:52:20PDT gkrishna


// Added


// vcarb_grant_d0


// Revision 1.31 2004/06/21 17:24:45PDT gkrishna


// added txrdy_clear_rdy to VCARB


// Revision 1.30 2004/06/21 12:06:55PDT gkrishna


// Cleared  txintf_nlfy.


// Revision 1.29 2004/06/07 18:44:16PDT gkrishna


// Added gap between CFG reads


// Revision 1.28 2004/05/28 14:31:33PDT gkrishna


// Stop end generation when end = 1 nlfy = 1


// Revision 1.27 2004/05/21 14:58:59PDT gkrishna


// Added NO P state for cs_pause.


// Revision 1.26 2004/05/20 14:44:12PDT gkrishna


// Removed gap cnt .


// Revision 1.25 2004/05/19 14:24:49PDT gkrishna


//


// Revision 1.24 2004/05/19 14:21:06PDT gkrishna


// ADded .txintf_rdy_ack.


// Revision 1.23 2004/05/18 15:38:23PDT gkrishna


// Added pause_ack signal


// Revision 1.22 2004/05/18 13:31:33PDT gkrishna


// Removed dll_pause_val & ack signals.


// Revision 1.21 2004/05/18 12:42:53PDT gkrishna


// REWROTE pause SM with gap counter.


// Revision 1.20 2004/05/18 12:05:03PDT gkrishna


//


// Revision 1.19 2004/05/18 11:40:39PDT gkrishna


// Modified pause cnt loding


// Revision 1.18 2004/05/18 09:56:19PDT gkrishna


// Added tx_rdy into the SM


// Revision 1.17 2004/05/17 17:46:23PDT gkrishna


// Moved SM from TXRDY to TXINTF


// Revision 1.16 2004/05/17 17:01:07PDT gkrishna


// Added support for dll_pause_cnt.


// Revision 1.15 2004/05/13 12:07:36PDT gkrishna


// Modified txintf_req generation.


// Revision 1.14 2004/05/05 16:09:27PDT gkrishna


// Added tx_rdy


// Revision 1.13 2004/05/05 15:47:40PDT gkrishna


// Fixed cfg rd generation


// Revision 1.12 2004/05/05 10:49:56PDT gkrishna


// Added tx_eop signal


// Revision 1.11 2004/05/04 15:47:19PDT gkrishna


// Fixed Arb logic when round robin unused VC.


// Revision 1.10 2004/04/29 10:59:56PDT rperugu


//


// Revision 1.9 2004/04/28 14:39:52PDT gkrishna


// Removed multiple VC


// Revision 1.8 2004/04/22 16:40:48PDT gkrishna


// Optimised logic for synthesis


// Revision 1.7 2004/04/22 16:20:45PDT gkrishna


// Added tx_nlfy ogic


// Revision 1.6 2004/04/22 13:18:55PDT gkrishna


// Updated vcarb_grant when VC1 is choosen


// Revision 1.5 2004/04/22 12:25:31PDT gkrishna


// Added logic to support onve VC


// Revision 1.4 2004/04/22 09:25:53PDT gkrishna


// Added tx_data_align signal to add 2 clock cycle gap between packets.


// Revision 1.3 2004/04/21 12:41:35PDT gkrishna


// Updated define for D_WIDTH


// Revision 1.2 2004/04/21 10:15:56PDT gkrishna


// Generated Early EOP to update the VCARB logic.


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_x1


// File             : cpm_s_reg.v


// Title            :


// Dependencies     : 


// Description      : CPM Slave for Generice Memory Mapped Register Devices


//                    This module acts as CPM slave and interfaces with 


//                    config register block and CSR block.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : SK Rajadurai


// Mod. Date        : Mar 2, 2006


// Changes Made     : Initial Creation


// =============================================================================


/**********************************************************
Instantiate and override parameters to match the specific device
parameters (data width, address size, etc)
**********************************************************/





`define         	DEV_ADDR_WIDTH   13


`define	            DEV_DATA_WIDTH   32


`define          	WB_ADDR_WIDTH    13


`define	            WB_DATA_WIDTH    32

//`include "sys_cfg.v"




`timescale 1 ns / 100 ps
module cpm_s_reg	
(
	
	RST_I,
	CLK_I,

	ADR_I,
	DAT_I,
	SEL_I,
	WE_I,
	STB_I,
	CYC_I,

	DAT_O,
	ACK_O,
	IRQ_O,
	
	
	CHAIN_RDAT_in,
	CHAIN_ACK_in,

	
    csr_clk,
	Dev_Addr_o,
	Dev_Data_i_0,
	Dev_Data_i_1,
	Dev_Data_o,
	Dev_BYTE_Sel_o,
	Dev_WE_RDn_o,
	Dev_Strobe_o,
	Dev_Ack_i_0,
	Dev_Ack_i_1,
	Dev_IRQ_i
);
input	                       RST_I;
input                          CLK_I;
input  [(`WB_DATA_WIDTH/8)-1:0] SEL_I;
input                          WE_I;
input                          STB_I;
input                          CYC_I;
input  [`WB_DATA_WIDTH-1:0 ]   DAT_I;
input  [`WB_ADDR_WIDTH-1:0 ]   ADR_I;
input  [`DEV_DATA_WIDTH-1:0 ]  CHAIN_RDAT_in;
input	                       CHAIN_ACK_in;
input                          csr_clk;
input  [`DEV_DATA_WIDTH-1:0 ]  Dev_Data_i_0;
input  [`DEV_DATA_WIDTH-1:0 ]  Dev_Data_i_1;
input                          Dev_Ack_i_0;
input                          Dev_Ack_i_1;
input			               Dev_IRQ_i;
output                         ACK_O;
output [`WB_DATA_WIDTH-1:0 ]   DAT_O;
output                  	   IRQ_O;
output [`DEV_ADDR_WIDTH-1:0 ]  Dev_Addr_o;
output [`DEV_DATA_WIDTH-1:0 ]  Dev_Data_o;
output [(`DEV_DATA_WIDTH/8)-1:0] Dev_BYTE_Sel_o;
output                         Dev_WE_RDn_o;
output                         Dev_Strobe_o;
reg                            Dev_Strobe_o_r;
reg                            Dev_Strobe_o_r1;
reg                            Dev_WE_RDn_o_r;
reg [`DEV_ADDR_WIDTH-1:0 ]     Dev_Addr_o_r;
reg [`DEV_DATA_WIDTH-1:0 ]     Dev_Data_o_r;
reg                            Dev_WE_RDn_o;
reg [`DEV_ADDR_WIDTH-1:0 ]     Dev_Addr_o;
reg [`DEV_DATA_WIDTH-1:0 ]     Dev_Data_o;
reg                            Dev_Strobe_o;
reg                            ACK_O_r;
reg                            ACK_O_r1;
reg [`DEV_DATA_WIDTH-1:0 ]     DAT_O_r;
reg                            STB_I_reg;
wire	                       RDAT_mux_sel;
wire [`WB_DATA_WIDTH-1:0 ]     DAT_O;
wire                           ACK_O;
wire	                       IRQ_O;
wire [(`DEV_DATA_WIDTH/8)-1:0] Dev_BYTE_Sel_o;
reg [`WB_ADDR_WIDTH - 1 : 0] ADR_I_split;
reg [`WB_DATA_WIDTH - 1 : 0] DAT_I_split;
reg [(`WB_DATA_WIDTH / 8) - 1 : 0] SEL_I_split;
reg WE_I_split;
reg STB_I_split;
reg CYC_I_split;
reg [`DEV_DATA_WIDTH - 1 : 0] CHAIN_RDAT_in_split;
reg CHAIN_ACK_in_split;
reg [`DEV_DATA_WIDTH - 1 : 0] Dev_Data_i_0_split;
reg [`DEV_DATA_WIDTH - 1 : 0] Dev_Data_i_1_split;
reg Dev_Ack_i_0_split;
reg Dev_Ack_i_1_split;
reg Dev_IRQ_i_split;
reg Dev_Strobe_o_r_split;
reg Dev_Strobe_o_r1_split;
reg Dev_WE_RDn_o_r_split;
reg [`DEV_ADDR_WIDTH - 1 : 0] Dev_Addr_o_r_split;
reg [`DEV_DATA_WIDTH - 1 : 0] Dev_Data_o_r_split;
reg ACK_O_r_split;
reg ACK_O_r1_split;
reg [`DEV_DATA_WIDTH - 1 : 0] DAT_O_r_split;
reg STB_I_reg_split;
reg RDAT_mux_sel_split;
reg [2047:0] descram_in;
wire [22:0] descram_out;

localparam descram_inst_SIZE = 23,descram_inst_SCRAMSTRING = 32'hfdfff10b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

// Input
// Reset from wishbone
// 125MHz clk from wishbone
// Byte selection from wishbone
// rd(0)/wr(1) from wishbone
// Strobe signal from wishbone
// Cycle signal from wishbone
// Write data from wishbone
// Address from wishbone

// Read data from CPM Daisy Chain
// Ack from CPM Daisy Chain

// 125MHz clk from core side
// Read data from config space
// Read data from CSR block
// Ack signal from config block
// Ack signal from CSR block
// Interrupt signal from core side

// Outputs
// Ack signal to wishbone
// Read data to wishbone
// Interrupt signal to wishbone

// Address signal to config and CSR  
// Write data to config and CSR
// Byte selection to config and CSR
// rd(0)/wr(1) to config and CSR
// Strobe signal to config and CSR

/**********************************************
Define registers and wires
**********************************************/
/********************************
CPM Slave Logic
********************************/
// synchronize addr, wr data and r/w signals from wishbone using csr_clk
// and send them to the core 
always @(posedge csr_clk or negedge RST_I) begin
   if(!RST_I) begin
      Dev_Strobe_o_r  <= 0;
      Dev_Strobe_o_r1 <= 0;
      Dev_WE_RDn_o_r  <= 0;
      Dev_Addr_o_r    <= {(`DEV_ADDR_WIDTH){1'b0}};
      Dev_Data_o_r    <= {(`DEV_DATA_WIDTH){1'b0}};

      Dev_WE_RDn_o    <= 0;
      Dev_Addr_o      <= {(`DEV_ADDR_WIDTH){1'b0}};
      Dev_Data_o      <= {(`DEV_DATA_WIDTH){1'b0}};
   end
   else begin
      Dev_Strobe_o_r  <= STB_I_split;
      Dev_Strobe_o_r1 <= Dev_Strobe_o_r_split;
      Dev_WE_RDn_o_r  <= WE_I_split;
      Dev_Addr_o_r    <= ADR_I_split;
      Dev_Data_o_r    <= DAT_I_split;

      Dev_WE_RDn_o    <= Dev_WE_RDn_o_r_split;
      Dev_Addr_o      <= Dev_Addr_o_r_split;
      Dev_Data_o      <= Dev_Data_o_r_split;
   end
end

// core side strobe signal is set when strb comes from wishbone
// and is reset when ack comes from core
always @(posedge csr_clk or negedge RST_I) begin
   if(!RST_I) begin
      Dev_Strobe_o   <= 0;
   end
   //else if (Dev_Strobe_o_r && !(Dev_Ack_i_0 || Dev_Ack_i_1))begin
   else if (Dev_Strobe_o_r_split && !Dev_Strobe_o_r1_split)begin
      Dev_Strobe_o   <= 1'b1;
   end
   else if (Dev_Strobe_o_r_split && (Dev_Ack_i_0_split || Dev_Ack_i_1_split))begin
      Dev_Strobe_o   <= 1'b0;
   end
end

// synchronize ack from core using wishbone clk
always @(posedge CLK_I or negedge RST_I) begin
   if(!RST_I) begin
      ACK_O_r        <= 0;
      ACK_O_r1       <= 0;
   end
   else begin
      ACK_O_r        <= Dev_Ack_i_0_split | Dev_Ack_i_1_split;
      ACK_O_r1       <= ACK_O_r_split;
   end
end

// synchronize read data from core using wishbone clk
always @(posedge CLK_I or negedge RST_I) begin
   if(!RST_I) begin
      DAT_O_r        <= {(`WB_DATA_WIDTH){1'b0}};
   end
   else begin
      DAT_O_r        <= (Dev_Ack_i_1_split) ? Dev_Data_i_1_split :
                        (Dev_Ack_i_0_split) ? Dev_Data_i_0_split : DAT_O_r_split;
   end
end

// multiplex read data and ack from core and from daisy chain input
always @( posedge CLK_I or negedge RST_I )
  if ( !RST_I )
    STB_I_reg <= 0;
  else
    STB_I_reg <= STB_I_split;

assign RDAT_mux_sel = ( ( STB_I_split || STB_I_reg_split ) && CYC_I_split );

assign DAT_O =  ( RDAT_mux_sel_split == 1 )? DAT_O_r_split  : CHAIN_RDAT_in_split;
assign ACK_O =  ( RDAT_mux_sel_split == 1 )? ACK_O_r1_split : CHAIN_ACK_in_split;

assign IRQ_O =  Dev_IRQ_i_split;
	
always@* begin ADR_I_split<={ADR_I>>1,descram_out[0]};DAT_I_split<={DAT_I>>1,descram_out[1]};SEL_I_split<={SEL_I>>1,descram_out[2]};WE_I_split<=descram_out[3];STB_I_split<=descram_out[4];CYC_I_split<=descram_out[5];CHAIN_RDAT_in_split<={CHAIN_RDAT_in>>1,descram_out[6]};CHAIN_ACK_in_split<=descram_out[7];Dev_Data_i_0_split<={Dev_Data_i_0>>1,descram_out[8]};Dev_Data_i_1_split<={Dev_Data_i_1>>1,descram_out[9]};Dev_Ack_i_0_split<=descram_out[10];Dev_Ack_i_1_split<=descram_out[11];Dev_IRQ_i_split<=descram_out[12];Dev_Strobe_o_r_split<=descram_out[13];Dev_Strobe_o_r1_split<=descram_out[14];Dev_WE_RDn_o_r_split<=descram_out[15];Dev_Addr_o_r_split<={Dev_Addr_o_r>>1,descram_out[16]};Dev_Data_o_r_split<={Dev_Data_o_r>>1,descram_out[17]};ACK_O_r_split<=descram_out[18];ACK_O_r1_split<=descram_out[19];DAT_O_r_split<={DAT_O_r>>1,descram_out[20]};STB_I_reg_split<=descram_out[21];RDAT_mux_sel_split<=descram_out[22];end
always@* begin descram_in[2047]<=DAT_I[0];descram_in[2046]<=SEL_I[0];descram_in[2044]<=WE_I;descram_in[2040]<=STB_I;descram_in[2032]<=CYC_I;descram_in[2016]<=CHAIN_RDAT_in[0];descram_in[1985]<=CHAIN_ACK_in;descram_in[1950]<=Dev_Data_o_r[0];descram_in[1923]<=Dev_Data_i_0[0];descram_in[1852]<=ACK_O_r;descram_in[1799]<=Dev_Data_i_1[0];descram_in[1656]<=ACK_O_r1;descram_in[1551]<=Dev_Ack_i_0;descram_in[1265]<=DAT_O_r[0];descram_in[1054]<=Dev_Ack_i_1;descram_in[1023]<=ADR_I[0];descram_in[975]<=Dev_Addr_o_r[0];descram_in[965]<=RDAT_mux_sel;descram_in[487]<=Dev_WE_RDn_o_r;descram_in[482]<=STB_I_reg;descram_in[243]<=Dev_Strobe_o_r1;descram_in[121]<=Dev_Strobe_o_r;descram_in[60]<=Dev_IRQ_i;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_x1


// File             : csr.v


// Title            :


// Dependencies     :


// Description      : This module implements the Control & status Reg. from the


//                    Addr 'h1000 to 'h101F


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Rajakumar


// Mod. Date        : Feb 21, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module csr(

input                         sys_clk,      
input                         rst_n,        


input       [12:0]            ADR_I,           
input       [31:0]            DAT_I,           
input                         WE_I,            
input                         STB_I,           


input                         tx_dllp_sent,    
input       [1:0]             rx_dllp_val,     
input       [2:0]             rx_pmtype,       
input       [23:0]            rx_vsd_data,     


input       [4:0]             phy_ltssm_state, 
`ifdef X4
input       [3:0]             phy_lsm_state,   
input       [3:0]             asb_eidle_rx,    
input       [3:0]             asb_detdone_rx,  
input       [3:0]             asb_detres_rx,   
`else
input                         phy_lsm_state,   

input                         asb_eidle_rx,    
input                         asb_detdone_rx,  
input                         asb_detres_rx,   
`endif



input                         dl_inactive,     
input                         dl_init,         
input                         dl_active,       
input                         dl_up,           






output reg  [31:0]            RDAT_O,          
output reg                    ACK_O,           



output reg  [1:0]             tx_dllp_val,       
output wire [2:0]             tx_pmtype,       
output wire [23:0]            tx_vsd_data,     


output wire                   force_lsm_active, 
output wire                   force_rec_ei,     
output wire                   force_phy_status, 
output wire                   force_disable_scr,

output wire                   tlp_debug,       
output wire                   hl_snd_beacon,   
output wire                   hl_disable_scr,  
output wire                   hl_gto_dis,      
output wire                   hl_gto_det,      
output wire                   hl_gto_hrst,     
output wire                   hl_gto_l0stx,    
output wire                   hl_gto_l1,       
output wire                   hl_gto_l2,       
output wire                   hl_gto_l0stxfts, 
`ifdef X4
output wire [3:0]             hl_gto_lbk,      
`else
output wire                   hl_gto_lbk,      
`endif
output wire                   hl_gto_rcvry,    
output wire                   hl_gto_cfg,      
output wire                   no_pcie_train,   


output wire [4:0]             N_FTS_INC,       
output wire [9:0]             SKP_INS_CNT,     
output wire [13:0]            ACKNAK_LAT_TIME, 


output wire [6:0]             UPDATE_FREQ_PH,
output wire [10:0]            UPDATE_FREQ_PD,
output wire [6:0]             UPDATE_FREQ_NPH,
output wire [10:0]            UPDATE_FREQ_NPD,
output wire [6:0]             UPDATE_FREQ_CPLH,
output wire [10:0]            UPDATE_FREQ_CPLD,
output wire [11:0]            UPDATE_TIMER,


output wire [7:0]             LINK_NUM         //Link Number



  ) ;
reg  [31:0]          RX_PMGMT_REG;
reg  [31:0]          TX_PMGMT_REG;
reg  [31:0]          STATUS_REG;
reg  [31:0]          HL_REG;
reg  [31:0]          TIMER_REG;
reg  [31:0]          FC1_REG;
reg  [31:0]          FC2_REG;
reg  [31:0]          FC3_REG;
reg  [31:0]          UTIMER_REG;
reg  [31:0]          LINKNUM_REG;
reg                  write;
reg                  rx_pmgmt_en;
reg                  tx_pmgmt_en;
reg                  status_en;
reg                  hl_en;
reg                  timer_en;
reg                  fc1_en;
reg                  fc2_en;
reg                  fc3_en;
reg                  utimer_en;
reg                  linknum_en;

`ifdef X4

`else

`endif

`ifdef X4

`else  // For X1 -- 12, 16, 20 bits are used

`endif
reg [12 : 0] ADR_I_split;
reg [31 : 0] DAT_I_split;
reg WE_I_split;
reg STB_I_split;
reg tx_dllp_sent_split;
reg [1 : 0] rx_dllp_val_split;
reg [2 : 0] rx_pmtype_split;
reg [23 : 0] rx_vsd_data_split;
reg [4 : 0] phy_ltssm_state_split;
reg dl_inactive_split;
reg dl_init_split;
reg dl_active_split;
reg dl_up_split;
reg [31 : 0] TX_PMGMT_REG_split;
reg [31 : 0] STATUS_REG_split;
reg [31 : 0] HL_REG_split;
reg [31 : 0] TIMER_REG_split;
reg [31 : 0] FC1_REG_split;
reg [31 : 0] FC2_REG_split;
reg [31 : 0] FC3_REG_split;
reg [31 : 0] UTIMER_REG_split;
reg [31 : 0] LINKNUM_REG_split;
reg write_split;
reg rx_pmgmt_en_split;
reg tx_pmgmt_en_split;
reg status_en_split;
reg hl_en_split;
reg timer_en_split;
reg fc1_en_split;
reg fc2_en_split;
reg fc3_en_split;
reg utimer_en_split;
reg linknum_en_split;
reg [2047:0] descram_in;
wire [32:0] descram_out;

`ifdef X4

`else

`endif

`ifdef X4

`else  // For X1 -- 12, 16, 20 bits are used

`endif

localparam descram_inst_SIZE = 33,descram_inst_SCRAMSTRING = 32'hfdffe0cb;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X4



`else



`endif



`ifdef X4



`else  // For X1 -- 12, 16, 20 bits are used



`endif

// =============================================================================
// Internal Regs/Wires declarations
// =============================================================================
//---- Registers
//1000 - 1003
//1004 - 1007
//1008 - 100B (Read-Only)
//100C - 100F
//1010 - 1013
//1014 - 1017   -- P type
//1018 - 101B   -- NP type
//101C - 101F   -- CPL type
//1020 - 1023   -- FC Update Timer
//1024 - 1027

//---- Wires


// =============================================================================
// =============================================================================
// ---------- Power Management
//assign  tx_pm             = TX_PMGMT_REG[8];
assign  tx_pmtype         = TX_PMGMT_REG_split[2:0];
assign  tx_vsd_data       = TX_PMGMT_REG_split[26:3];

// ---------- From Higher Layer


`ifdef X4


   assign  hl_gto_lbk        = HL_REG_split[21:18];


`else


   assign  hl_gto_lbk        = HL_REG_split[18];


`endif


assign  tlp_debug         = HL_REG_split[17];  //To Core (Bypass DLL/TRNC check)
assign  hl_snd_beacon     = HL_REG_split[16];  //To Core

assign  force_lsm_active  = HL_REG_split[15];  //To Core
assign  force_rec_ei      = HL_REG_split[14];  //To Core
assign  force_phy_status  = HL_REG_split[13];  //To Core
assign  force_disable_scr = HL_REG_split[12];  //To PCS (ORed with phy_disable_scr)

assign  hl_disable_scr    = HL_REG_split[11];
assign  hl_gto_dis        = HL_REG_split[10];
assign  hl_gto_det        = HL_REG_split[9];
assign  hl_gto_hrst       = HL_REG_split[8];
assign  hl_gto_l0stx      = HL_REG_split[7];
assign  hl_gto_l1         = HL_REG_split[6];
assign  hl_gto_l2         = HL_REG_split[5];
assign  hl_gto_l0stxfts   = HL_REG_split[4];
//assign  hl_gto_lbk        = HL_REG[3];  //17/07/05 moved to [21:18] for X4
assign  hl_gto_rcvry      = HL_REG_split[2];
assign  hl_gto_cfg        = HL_REG_split[1];
assign  no_pcie_train     = HL_REG_split[0];

//------------ Timers/Counter
assign  N_FTS_INC         = TIMER_REG_split[14:10];
assign  SKP_INS_CNT       = TIMER_REG_split[9:0];
assign  ACKNAK_LAT_TIME   = TIMER_REG_split[29:16];

// ---------- Freqency of FC Updates
/****
assign  UPDATE_FREQ_PH    = FC1_REG[28:24];
assign  UPDATE_FREQ_PD    = FC1_REG[23:16];
assign  UPDATE_FREQ_NPH   = FC1_REG[12:8];
assign  UPDATE_FREQ_NPD   = FC1_REG[7:0];
assign  UPDATE_FREQ_CPLH  = FC2_REG[28:24];
assign  UPDATE_FREQ_CPLD  = FC2_REG[23:16];
assign  UPDATE_TIMER      = FC2_REG[11:0];
****/
assign  UPDATE_FREQ_PH    = FC1_REG_split[17:11];
assign  UPDATE_FREQ_PD    = FC1_REG_split[10:0];
assign  UPDATE_FREQ_NPH   = FC2_REG_split[17:11];
assign  UPDATE_FREQ_NPD   = FC2_REG_split[10:0];
assign  UPDATE_FREQ_CPLH  = FC3_REG_split[17:11];
assign  UPDATE_FREQ_CPLD  = FC3_REG_split[10:0];
assign  UPDATE_TIMER      = UTIMER_REG_split[11:0];

//------------ Link Number
assign  LINK_NUM          = LINKNUM_REG_split[7:0];

// =============================================================================
// Updating Registers
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      RX_PMGMT_REG    <= 32'd0;
      TX_PMGMT_REG    <= 32'd0;
      STATUS_REG      <= 32'd0;
      HL_REG          <= 32'd0;
      //TIMER_REG       <= 32'hFFFFFFFF;
      TIMER_REG       <= {2'b11,`ACKNAK_LAT_TIME, 1'b1, 5'd10, `SKP_INS_CNT};
      FC1_REG         <= 32'hFFFFFFFF;
      FC2_REG         <= 32'hFFFFFFFF;
      FC3_REG         <= 32'hFFFFFFFF;
      UTIMER_REG      <= 32'hFFFFFFFF;
      LINKNUM_REG     <= 0;
      tx_dllp_val     <= 2'b00;
   end
   else  begin
      // Store Zero in Unused Reg Bits
      RX_PMGMT_REG[7:3]  <= 0;
      RX_PMGMT_REG[31:9] <= 0;
      TX_PMGMT_REG[29:27]<= 0;
      //STATUS_REG[31:12]  <= 0;
      STATUS_REG[31:24]  <= 0;
      //HL_REG[31:18]      <= 0;
      HL_REG[31:22]      <= 0;
      TIMER_REG[15]      <= 1'b1;
      TIMER_REG[31:30]   <= 2'b11;
      FC1_REG[31:18]     <= 14'b11_1111_1111_1111;
      FC2_REG[31:18]     <= 14'b11_1111_1111_1111;
      FC3_REG[31:18]     <= 14'b11_1111_1111_1111;
      UTIMER_REG[31:12]  <= 20'hFFFFF;
      LINKNUM_REG[31:16] <= 0;

      //----- PM/VENDOR Registers
      if(rx_dllp_val_split[0]) begin    //[30] - PM
         RX_PMGMT_REG[30]  <= 1'b1;
         RX_PMGMT_REG[2:0] <= rx_pmtype_split;
      end
      else if(write_split && rx_pmgmt_en_split)  //COW
         RX_PMGMT_REG[30]  <= 1'b0;

      if(rx_dllp_val_split[1]) begin    //[31] - Vendor
         RX_PMGMT_REG[31]   <= 1'b1;
         RX_PMGMT_REG[26:3] <= rx_vsd_data_split;
      end
      else if(write_split && rx_pmgmt_en_split)  //COW
         RX_PMGMT_REG[31]  <= 1'b0;

      if(tx_dllp_sent_split) begin
         TX_PMGMT_REG[31:30] <= 2'b00;
      end
      else if(write_split && tx_pmgmt_en_split) begin
         TX_PMGMT_REG[31:30] <= DAT_I_split[31:30];  //[30] - PM, [31] - Vendor
         TX_PMGMT_REG[26:3]  <= DAT_I_split[26:3];   //Vendor Contents
         TX_PMGMT_REG[2:0]   <= DAT_I_split[2:0];    //PM type
      end

      //Making tx_pm a pulse rather than Cont. signal
      if(|TX_PMGMT_REG_split[31:30]) //Already set (any one bit is set)
         tx_dllp_val  <= 2'b00;
      else if(write_split && tx_pmgmt_en_split)
         tx_dllp_val  <= DAT_I_split[31:30];

      //----- STATUS Register (Read-Only)
      STATUS_REG[11:7]    <= phy_ltssm_state_split;
      STATUS_REG[6:3]     <= {dl_inactive_split, dl_init_split, dl_active_split, dl_up_split};

      /******  [2:0] is UNUSED - moved to [15:12], [19:16], [23:20] for X4 - 17/7/05
      STATUS_REG[2]       <= phy_lsm_state;
      //Phy Connection Status
      if(asb_detdone_rx) //Result of Receiver Detection from PCS
         STATUS_REG[1]    <= asb_detres_rx;
      else if(write && status_en && DAT_I[1])  //COW
         STATUS_REG[1]    <= 1'b0;

      if(asb_eidle_rx)  //PHY Receive Electrical IDLE
         STATUS_REG[0]    <= 1'b1;
      else if(write && status_en && DAT_I[0]) //COW
         STATUS_REG[0]    <= 1'b0;
      ******/

      //[15:12], [19:16], [23:20] for X4 - 17/7/05
     

`ifdef X4


         STATUS_REG[23:20]       <= phy_lsm_state;

         //----- Result of Receiver Detection from PCS
         if(asb_detdone_rx[3])
            STATUS_REG[19]    <= asb_detres_rx[3];
         else if(write_split && status_en_split && DAT_I_split[19])  //COW
            STATUS_REG[19]    <= 1'b0;

         if(asb_detdone_rx[2])
            STATUS_REG[18]    <= asb_detres_rx[2];
         else if(write_split && status_en_split && DAT_I_split[18])  //COW
            STATUS_REG[18]    <= 1'b0;

         if(asb_detdone_rx[1])
            STATUS_REG[17]    <= asb_detres_rx[1];
         else if(write_split && status_en_split && DAT_I_split[17])  //COW
            STATUS_REG[17]    <= 1'b0;

         if(asb_detdone_rx[0])
            STATUS_REG[16]    <= asb_detres_rx[0];
         else if(write_split && status_en_split && DAT_I_split[16])  //COW
            STATUS_REG[16]    <= 1'b0;

         //----- PHY Receive Electrical IDLE
         if(asb_eidle_rx[3])
            STATUS_REG[15]    <= 1'b1;
         else if(write_split && status_en_split && DAT_I_split[15]) //COW
            STATUS_REG[15]    <= 1'b0;

         if(asb_eidle_rx[2])
            STATUS_REG[14]    <= 1'b1;
         else if(write_split && status_en_split && DAT_I_split[14]) //COW
            STATUS_REG[14]    <= 1'b0;

         if(asb_eidle_rx[1])
            STATUS_REG[13]    <= 1'b1;
         else if(write_split && status_en_split && DAT_I_split[13]) //COW
            STATUS_REG[13]    <= 1'b0;

         if(asb_eidle_rx[0])
            STATUS_REG[12]    <= 1'b1;
         else if(write_split && status_en_split && DAT_I_split[12]) //COW
            STATUS_REG[12]    <= 1'b0;
     

`else  // For X1 -- 12, 16, 20 bits are used


         STATUS_REG[20]       <= phy_lsm_state;

         //----- Result of Receiver Detection from PCS
         if(asb_detdone_rx) //Result of Receiver Detection from PCS
            STATUS_REG[16]    <= asb_detres_rx;
         else if(write_split && status_en_split && DAT_I_split[16])  //COW
            STATUS_REG[16]    <= 1'b0;

         //----- PHY Receive Electrical IDLE
         if(asb_eidle_rx)
            STATUS_REG[12]    <= 1'b1;
         else if(write_split && status_en_split && DAT_I_split[12]) //COW
            STATUS_REG[12]    <= 1'b0;
     

`endif



      //----- Higher Layer force/Req Register
      //HL_REG[12] (disable scrambling) ORed with phy_disable_scr (from Core)
      //should go to PCS
      if(write_split && hl_en_split)
         HL_REG[21:0]     <= DAT_I_split[21:0];
         //HL_REG[17:0]     <= DAT_I[17:0];  //17/07/05 LBK moved from [3] to [21:18] for X4
      //else if(phy_disable_scr)
         //HL_REG[12]       <= 1'b1;

      //----- Ack/Nak Latency Timer, FTS no.  & SKIP Insertion Counter
      if(write_split && timer_en_split) begin
         TIMER_REG[29:16]  <= DAT_I_split[29:16];
         TIMER_REG[14:10]  <= DAT_I_split[14:10];
         TIMER_REG[9:0]    <= DAT_I_split[9:0];
      end

      //----- Update Frequency Counters
      /****
      if(write && fc1_en) begin
         FC1_REG[28:24]     <= DAT_I[28:24]; //Posed Header
         FC1_REG[23:16]     <= DAT_I[23:16]; //Posed Data
         FC1_REG[12:8]      <= DAT_I[12:8];  //Non-Posed Header
         FC1_REG[7:0]       <= DAT_I[7:0];   //Non-Posed Data
      end

      if(write && fc2_en) begin
         FC2_REG[28:24]     <= DAT_I[28:24]; //Completion Header
         FC2_REG[23:16]     <= DAT_I[23:16]; //Completion Data
         FC2_REG[11:0]      <= DAT_I[11:0];  //Update Timer
      end
      ****/

      if(write_split && fc1_en_split) begin
         FC1_REG[17:11]     <= DAT_I_split[17:11]; //Posed Header
         FC1_REG[10:0]      <= DAT_I_split[10:0];  //Posed Data
      end

      if(write_split && fc2_en_split) begin
         FC2_REG[17:11]     <= DAT_I_split[17:11]; //Non-Posed Header
         FC2_REG[10:0]      <= DAT_I_split[10:0];  //Non-Posed Data
      end

      if(write_split && fc3_en_split) begin
         FC3_REG[17:11]     <= DAT_I_split[17:11]; //Completion Header
         FC3_REG[10:0]      <= DAT_I_split[10:0];  //Completion Data
      end

      if(write_split && utimer_en_split) begin
         UTIMER_REG[11:0]    <= DAT_I_split[11:0];  //Update Timer
      end

      //----- LINK NUMBER Register
      if(write_split && linknum_en_split) begin
         LINKNUM_REG[15:0]     <= DAT_I_split[15:0];
      end
   end
end

// =============================================================================
// Read Operation & Write/ACK Pulse geenration
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      ACK_O       <= 1'b0;
      RDAT_O      <= 32'd0;
      rx_pmgmt_en <= 1'b0;
      tx_pmgmt_en <= 1'b0;
      status_en   <= 1'b0;   //Read_only
      hl_en       <= 1'b0;
      timer_en    <= 1'b0;
      fc1_en      <= 1'b0;
      fc2_en      <= 1'b0;
      fc3_en      <= 1'b0;
      utimer_en   <= 1'b0;
      linknum_en  <= 1'b0;
   end
   else  begin
      if(write_split)
         write    <= 1'b0;
      else
         write    <= WE_I_split & STB_I_split && ADR_I_split[12];

      if(ACK_O)
         ACK_O    <= 1'b0;
      else
         ACK_O    <= STB_I_split && ADR_I_split[12];

      rx_pmgmt_en <= 1'b0;
      tx_pmgmt_en <= 1'b0;
      status_en   <= 1'b0;   //Read_only
      hl_en       <= 1'b0;
      timer_en    <= 1'b0;
      fc1_en      <= 1'b0;
      fc2_en      <= 1'b0;
      fc3_en      <= 1'b0;
      utimer_en   <= 1'b0;
      linknum_en  <= 1'b0;
      case(ADR_I_split[11:0])
         12'h000 : begin
            rx_pmgmt_en <= 1'b1;
            RDAT_O      <= RX_PMGMT_REG;
         end
         12'h004 : begin
            tx_pmgmt_en <= 1'b1;
            RDAT_O      <= TX_PMGMT_REG_split;
         end
         12'h008 : begin
            status_en   <= 1'b1;   //Read_only
            RDAT_O      <= STATUS_REG_split;
         end
         12'h00C : begin
            hl_en       <= 1'b1;
            RDAT_O      <= HL_REG_split;
         end
         12'h010 : begin
            timer_en    <= 1'b1;
            RDAT_O      <= TIMER_REG_split;
         end
         12'h014 : begin
            fc1_en      <= 1'b1;
            RDAT_O      <= FC1_REG_split;
         end
         12'h018 : begin
            fc2_en      <= 1'b1;
            RDAT_O      <= FC2_REG_split;
         end
         12'h01C : begin
            fc3_en      <= 1'b1;
            RDAT_O      <= FC3_REG_split;
         end
         12'h020 : begin
            utimer_en   <= 1'b1;
            RDAT_O      <= UTIMER_REG_split;
         end
         12'h024 : begin
            linknum_en  <= 1'b1;
            RDAT_O      <= LINKNUM_REG_split;
         end
      endcase
   end
end

always@* begin ADR_I_split<={ADR_I>>1,descram_out[0]};DAT_I_split<={DAT_I>>1,descram_out[1]};WE_I_split<=descram_out[2];STB_I_split<=descram_out[3];tx_dllp_sent_split<=descram_out[4];rx_dllp_val_split<={rx_dllp_val>>1,descram_out[5]};rx_pmtype_split<={rx_pmtype>>1,descram_out[6]};rx_vsd_data_split<={rx_vsd_data>>1,descram_out[7]};phy_ltssm_state_split<={phy_ltssm_state>>1,descram_out[8]};dl_inactive_split<=descram_out[9];dl_init_split<=descram_out[10];dl_active_split<=descram_out[11];dl_up_split<=descram_out[12];TX_PMGMT_REG_split<={TX_PMGMT_REG>>1,descram_out[13]};STATUS_REG_split<={STATUS_REG>>1,descram_out[14]};HL_REG_split<={HL_REG>>1,descram_out[15]};TIMER_REG_split<={TIMER_REG>>1,descram_out[16]};FC1_REG_split<={FC1_REG>>1,descram_out[17]};FC2_REG_split<={FC2_REG>>1,descram_out[18]};FC3_REG_split<={FC3_REG>>1,descram_out[19]};UTIMER_REG_split<={UTIMER_REG>>1,descram_out[20]};LINKNUM_REG_split<={LINKNUM_REG>>1,descram_out[21]};write_split<=descram_out[22];rx_pmgmt_en_split<=descram_out[23];tx_pmgmt_en_split<=descram_out[24];status_en_split<=descram_out[25];hl_en_split<=descram_out[26];timer_en_split<=descram_out[27];fc1_en_split<=descram_out[28];fc2_en_split<=descram_out[29];fc3_en_split<=descram_out[30];utimer_en_split<=descram_out[31];linknum_en_split<=descram_out[32];end
always@* begin descram_in[2047]<=DAT_I[0];descram_in[2046]<=WE_I;descram_in[2044]<=STB_I;descram_in[2040]<=tx_dllp_sent;descram_in[2033]<=rx_dllp_val[0];descram_in[2024]<=LINKNUM_REG[0];descram_in[2018]<=rx_pmtype[0];descram_in[2001]<=write;descram_in[1988]<=rx_vsd_data[0];descram_in[1954]<=rx_pmgmt_en;descram_in[1929]<=phy_ltssm_state[0];descram_in[1860]<=tx_pmgmt_en;descram_in[1811]<=dl_inactive;descram_in[1789]<=FC2_REG[0];descram_in[1673]<=status_en;descram_in[1574]<=dl_init;descram_in[1530]<=FC3_REG[0];descram_in[1299]<=hl_en;descram_in[1258]<=linknum_en;descram_in[1247]<=HL_REG[0];descram_in[1102]<=fc1_en;descram_in[1101]<=dl_active;descram_in[1023]<=ADR_I[0];descram_in[1012]<=UTIMER_REG[0];descram_in[894]<=FC1_REG[0];descram_in[629]<=utimer_en;descram_in[623]<=STATUS_REG[0];descram_in[551]<=timer_en;descram_in[447]<=TIMER_REG[0];descram_in[314]<=fc3_en;descram_in[311]<=TX_PMGMT_REG[0];descram_in[157]<=fc2_en;descram_in[155]<=dl_up;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.14 2007/06/01 11:40:26PDT rperugu


//


// Revision 1.13 2007/04/05 16:49:05PDT rperugu


// Corrected the typo :  STATUS_REG[19]    <= asb_detres_rx[3]; for X4


// Revision 1.12 2006/08/31 12:28:30PDT srajadur


// FFFF_FFFF changed to FFFFFFFF for obfuscator issue


// Revision 1.11 2006/07/17 18:35:51PDT rperugu


// 1) hl_gto_lbk width is changed for X4 & HL_REG bits locations are changed.


// 2) phy_lsm_state, asb_detres_rx, asb_detdone_rx widths are changed for X4 & STATUS_REG bits locations are changed.


// Revision 1.9 2006/05/08 19:00:51PDT rperugu


// 1) TLP_DEBUG --> tlp_debug


// 2) PM DLLP --> PM/VENDOR


//     tx_dllP_val[1:0], tx_vsd_data[23:0] -- New siganls


//  3) hl_snd_beacon is added


// Revision 1.8 2006/05/05 10:16:36PDT gkrishna


// Updated Default Values


// Revision 1.7 2006/05/04 13:30:41PDT gkrishna


// Updated after LINT checks


// Revision 1.6 2006/03/10 17:14:11PST rperugu


//


// Revision 1.5 2006/03/10 11:49:29PST rperugu


//


// Revision 1.4 2006/03/10 11:11:00PST rperugu


// 1) Made tx_pm as a pulse


// 2) Ack latenct Timer width is incresed to 13:0


// 3) Reset values for Timers/counters are made 'hFFF.


// Revision 1.3 2006/03/07 12:26:41PST rperugu


// SKP_INS_CNT width is incresed from 8 to 10 bits.


// Revision 1.2 2006/03/06 17:10:14PST rperugu


// Added TLP_DEBUG as 16th bit in Status reg.



// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2002 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised by


// a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement from


// Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation        TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                            408-826-6000 (other locations)


// Hillsboro, OR 97124                     web  : http://www.latticesemi.com/


// U.S.A                                   email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_X1_11


// File             : phy.v


// Dependencies     : dfrm.v frm.v ltssm.v scram.v


// Description      : This module instintiates all the sub blocks of PHY


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Gopi


// Mod. Date        : Jan 31, 2006


// =============================================================================




`timescale 1 ns / 100 ps
module phy #(
   parameter LANE_WIDTH   = 2 ,
   parameter D_WIDTH      = 64,
   parameter MCAF_DEPTH   = 10)
  (input wire                    clk_250_tx ,     
   input wire                    clk_250_rx ,     
   input wire                    sys_clk ,        
   input wire                    rst_n ,          
   input wire                    normal_time ,
   input wire                    reduce_idlecnt ,
   input wire                    phy_mca_disable ,

   
   input wire [7:0]              LINK_NUM,        
   input wire [4:0]              N_FTS_INC,       
   input wire [9:0]              SKP_INS_CNT,     
   input wire [3:0]              TX_EIDL_CNT,     

   
   input wire [16*LANE_WIDTH-1:0] asb_data,        
   input wire [2*LANE_WIDTH-1:0]  asb_kcntl,       
   input wire [2*LANE_WIDTH-1:0] asb_err,         
   input wire [LANE_WIDTH-1:0]   asb_eidle_rx,    
   input wire [LANE_WIDTH-1:0]   asb_detdone_rx,  
   input wire [LANE_WIDTH-1:0]   asb_detres_rx,   
   input wire [LANE_WIDTH-1:0]   asb_beacon_rx,   
   input wire [LANE_WIDTH-1:0]   asb_lane_sync,   
   input wire [2*LANE_WIDTH-1:0]   asb_skip_found,  
   input wire [2*LANE_WIDTH-1:0]   skip_added,      
   input wire [2*LANE_WIDTH-1:0]   skip_removed,    
   input                           rate_phy_sts_pulse,

   
   input wire                    force_disable_scr,
   input wire                    hl_disable_scr,  
   input wire                    hl_gto_dis,      
   input wire                    hl_gto_det,      
   input wire                    hl_gto_hrst,     
   input wire                    hl_gto_l0stx,    
   input wire                    hl_gto_l1,       
   input wire                    hl_gto_l2,       
   input wire                    hl_gto_l0stxfts, 
   input wire [LANE_WIDTH-1:0]   hl_gto_lbk,      
   input wire                    hl_gto_rcvry,    
   input wire                    hl_gto_cfg,      
   input wire                    hl_snd_beacon,   
   input wire [2:0]              cfgcs_losel,     
   input wire                    dll_rtrn_lnk,    
   input wire                    cfg_rtrn_lnk,    
   `ifdef GEN2
      input wire [3:0]           cs_target_lnk_spd ,
      input wire                 cs_enter_compliance ,
      input wire                 cs_hasd ,
      input wire                 cs_tx_demphasis ,
      input wire [2:0]           cs_tx_margin ,
      input wire                 cs_enter_mod_comp ,
      input wire                 cs_comp_sos ,
      input wire                 cs_comp_demp ,
   `endif

   
   input wire                    ext_sync,        
   input wire                    no_pcie_train,   

   
   input wire [D_WIDTH-1:0]      tdmux_data,      
   input wire                    tdmux_st,        
   input wire                    tdmux_end,       
   input wire                    tdmux_edb,       
   input wire                    tdmux_dllp,      
   input wire                    tdmux_dwen,      
   input wire                    tdmux_val,       
   input wire                    tdmux_skp,       
   
   input wire [32*LANE_WIDTH-1:0]tx_lbk_data,     
   input wire [4*LANE_WIDTH-1:0] tx_lbk_kcntl,    

   output wire                   tx_lbk_rdy,      
   output reg [32*LANE_WIDTH-1:0]rx_lbk_data,     
   output reg [4*LANE_WIDTH-1:0] rx_lbk_kcntl,    

   output wire                   phy_realign_req, 
   output wire [3:0]             phy_ltssm_state, 
   output wire [2:0]             phy_ltssm_substate, 
   output wire [2:0]             phy_cfgln_sum,   
   output wire [LANE_WIDTH-1:0]  phy_cfgln,       
   output wire [1:0]             phy_lnk_spd,     

   
   output wire                   phy_skpq_val,    
   output wire [1:0]             phy_skpq_nclks,  

   
   output wire [2:0]             phy_neg_lnkw,    
   output wire                   phy_trn_err,     
   output wire                   phy_lnk_trn,     
   output wire                   mca_aligned,     

   
   output wire                   phy_disable_scr, 
   output wire [LANE_WIDTH-1:0]  phy_inv_polar,   
   output wire [LANE_WIDTH-1:0]  phy_eidle_tx,    
   output wire [LANE_WIDTH-1:0]  phy_godet_rx,    
   output wire                   phy_sloopback,   
   output wire                   phy_snd_beacon,  
   output wire [16*LANE_WIDTH-1:0]phy_data,       
   output wire [2*LANE_WIDTH-1:0] phy_kcntl,      
   output wire [2*LANE_WIDTH-1:0] phy_fndisp,     
   output wire                   phy_linkup,      
   output wire                   phy_l0,          
   output wire                   phy_l0_l0s,      
   output wire [2:0]             phy_l0s_tx_state,
   output wire [1:0]             phy_l1_state,
   output wire [1:0]             phy_l2_state,
   output wire                   rate_5g ,
   output wire                   phy_deemph ,
   output wire [2:0]             phy_margin,
   output wire                   pol_compliance,
   output wire [LANE_WIDTH-1:0]  infer_rx_eidle,

   output wire                   ltssm_reset_core,

   
   output wire [D_WIDTH-1:0]     dfrm_ddata,      
   output wire                   dfrm_dval,       
   output wire [D_WIDTH-1:0]     dfrm_tdata,      
   output wire                   dfrm_tval,       
   output wire                   dfrm_st,         
   output wire                   dfrm_end,        
   output wire                   dfrm_edb,        
   output wire                   dfrm_dwen,       
   output wire [15:0]            dfrm_seq,        
   output wire [31:0]            dfrm_lcrc,       
   output reg                    dfrm_perr        // dfrm_perr for trnc.cfg


   );
wire   [LANE_WIDTH-1:0]     ltssm_config_ln;
wire   [D_WIDTH-1:0]        ltssm_data;
wire   [(D_WIDTH/8)-1:0]    ltssm_kcntl;
wire   [(D_WIDTH/8)-1:0]    ltssm_fndisp;
wire   [LANE_WIDTH-1:0]     ltssm_val;
wire                        ltssm_skp_clr;
wire   [1:0]                frm_skpq_nclks;
wire   [3:0]                frm_skp_cnt;
wire   [2:0]                ltssm_cfgln_sum;
wire                        cfg_dwn_lane;
wire                        cfg_dwn_port;
wire                        cfg_root_cmp;
wire   [32*LANE_WIDTH-1:0]  dscram_data     /* synthesis syn_preserve = 1 */;
wire   [4*LANE_WIDTH-1:0]   dscram_kcntl    /* synthesis syn_preserve = 1 */;
wire   [2*LANE_WIDTH-1:0]   dscram_err      /* synthesis syn_preserve = 1 */;
wire   [2*LANE_WIDTH-1:0]   dscram_eidle_rx;
wire   [2*LANE_WIDTH-1:0]   dscram_beacon_rx;
wire   [2*LANE_WIDTH-1:0]   dscram_lane_sync;
wire   [LANE_WIDTH-1:0]     dscram_err_m;
wire   [D_WIDTH-1:0]        frm_data     /* synthesis syn_preserve = 1 */;
wire   [(D_WIDTH/8)-1:0]    frm_kcntl    /* synthesis syn_preserve = 1 */;
wire   [(D_WIDTH/8)-1:0]    frm_fndisp;
wire   [1*LANE_WIDTH-1:0]   frm_eidle_tx;
reg                         drate_enable;
reg                         drate_pause;
wire                        scram_rxrc_wr_en;
wire   [2:0]                scram_rxrc_wr_pntr;
wire   [2:0]                scram_rxrc_rd_pntr;
wire   [D_WIDTH-1:0]        dgrx_data;
wire   [(D_WIDTH/8)-1:0]    dgrx_kcntl;
wire   [1:0]                dgrx_err;
wire   [32*LANE_WIDTH-1:0]  dgtx_data;
wire   [4*LANE_WIDTH-1:0]   dgtx_kcntl;
wire   [4*LANE_WIDTH-1:0]   dgtx_fndisp;
wire   [LANE_WIDTH-1:0]     dgtx_eidle_tx;
reg    [32*LANE_WIDTH-1:0]  dgtx_data_m;
reg    [4*LANE_WIDTH-1:0]   dgtx_kcntl_m;
wire   [16*LANE_WIDTH-1:0]  mca_data;
wire   [2*LANE_WIDTH-1:0]   mca_kcntl;
wire   [LANE_WIDTH-1:0]     mca_err;
wire   [LANE_WIDTH-1:0]     mca_eidle_rx;
wire   [LANE_WIDTH-1:0]     mca_beacon_rx;
wire   [LANE_WIDTH-1:0]     mca_lane_sync;
wire                        mca_align_done_s;
wire   [1*LANE_WIDTH-1:0]   ltssm_eidle_tx;
wire   [1*LANE_WIDTH-1:0]   asb_dskew_rx;
wire   [1:0]                ltssm_lnk_spd;
wire                        mca_align_done;
localparam                    K28_0 = 8'h1C ;
localparam                    K28_5 = 8'hBC ;
localparam                    COM   = K28_5;
localparam                    SKP   = K28_0;
reg [63:0]    dscram_data_q ;
reg [ 7:0]    dscram_kcntl_q;
reg           rx_dt_misalign;
reg           rx_dt_aligned;
reg           lanes_aligned;
wire   [LANE_WIDTH-1:0]   dscram_eidle_rx_m;
wire   [LANE_WIDTH-1:0]   dscram_beacon_rx_m;
wire   [LANE_WIDTH-1:0]   dscram_lane_sync_m;

`ifdef PX2

`else

`endif

`ifdef GEN2

`endif
wire [9:0] SKP_INS_CNT_M;

`ifdef MASTER_LOOPBACK

`else

`endif
reg normal_time_split;
reg reduce_idlecnt_split;
reg phy_mca_disable_split;
reg [7 : 0] LINK_NUM_split;
reg [4 : 0] N_FTS_INC_split;
reg [9 : 0] SKP_INS_CNT_split;
reg [3 : 0] TX_EIDL_CNT_split;
reg [16 * LANE_WIDTH - 1 : 0] asb_data_split;
reg [2 * LANE_WIDTH - 1 : 0] asb_kcntl_split;
reg [2 * LANE_WIDTH - 1 : 0] asb_err_split;
reg [LANE_WIDTH - 1 : 0] asb_eidle_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_detdone_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_detres_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_beacon_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_lane_sync_split;
reg [2 * LANE_WIDTH - 1 : 0] asb_skip_found_split;
reg [2 * LANE_WIDTH - 1 : 0] skip_added_split;
reg [2 * LANE_WIDTH - 1 : 0] skip_removed_split;
reg rate_phy_sts_pulse_split;
reg force_disable_scr_split;
reg hl_disable_scr_split;
reg hl_gto_dis_split;
reg hl_gto_det_split;
reg hl_gto_hrst_split;
reg hl_gto_l0stx_split;
reg hl_gto_l1_split;
reg hl_gto_l2_split;
reg hl_gto_l0stxfts_split;
reg [LANE_WIDTH - 1 : 0] hl_gto_lbk_split;
reg hl_gto_rcvry_split;
reg hl_gto_cfg_split;
reg hl_snd_beacon_split;
reg [2 : 0] cfgcs_losel_split;
reg dll_rtrn_lnk_split;
reg cfg_rtrn_lnk_split;
reg ext_sync_split;
reg no_pcie_train_split;
reg [D_WIDTH - 1 : 0] tdmux_data_split;
reg tdmux_st_split;
reg tdmux_end_split;
reg tdmux_edb_split;
reg tdmux_dllp_split;
reg tdmux_dwen_split;
reg tdmux_val_split;
reg tdmux_skp_split;
reg [32 * LANE_WIDTH - 1 : 0] tx_lbk_data_split;
reg [4 * LANE_WIDTH - 1 : 0] tx_lbk_kcntl_split;
reg [D_WIDTH - 1 : 0] ltssm_data_split;
reg [(D_WIDTH / 8) - 1 : 0] ltssm_kcntl_split;
reg [(D_WIDTH / 8) - 1 : 0] ltssm_fndisp_split;
reg [LANE_WIDTH - 1 : 0] ltssm_val_split;
reg ltssm_skp_clr_split;
reg [1 : 0] frm_skpq_nclks_split;
reg [3 : 0] frm_skp_cnt_split;
reg [2 : 0] ltssm_cfgln_sum_split;
reg cfg_dwn_lane_split;
reg cfg_dwn_port_split;
reg cfg_root_cmp_split;
reg [32 * LANE_WIDTH - 1 : 0] dscram_data_split;
reg [4 * LANE_WIDTH - 1 : 0] dscram_kcntl_split;
reg [2 * LANE_WIDTH - 1 : 0] dscram_err_split;
reg [2 * LANE_WIDTH - 1 : 0] dscram_eidle_rx_split;
reg [2 * LANE_WIDTH - 1 : 0] dscram_beacon_rx_split;
reg [2 * LANE_WIDTH - 1 : 0] dscram_lane_sync_split;
reg [LANE_WIDTH - 1 : 0] dscram_err_m_split;
reg [D_WIDTH - 1 : 0] frm_data_split;
reg [(D_WIDTH / 8) - 1 : 0] frm_kcntl_split;
reg [(D_WIDTH / 8) - 1 : 0] frm_fndisp_split;
reg [1 * LANE_WIDTH - 1 : 0] frm_eidle_tx_split;
reg drate_enable_split;
reg drate_pause_split;
reg scram_rxrc_wr_en_split;
reg [2 : 0] scram_rxrc_wr_pntr_split;
reg [2 : 0] scram_rxrc_rd_pntr_split;
reg [D_WIDTH - 1 : 0] dgrx_data_split;
reg [(D_WIDTH / 8) - 1 : 0] dgrx_kcntl_split;
reg [1 : 0] dgrx_err_split;
reg [32 * LANE_WIDTH - 1 : 0] dgtx_data_split;
reg [4 * LANE_WIDTH - 1 : 0] dgtx_kcntl_split;
reg [4 * LANE_WIDTH - 1 : 0] dgtx_fndisp_split;
reg [LANE_WIDTH - 1 : 0] dgtx_eidle_tx_split;
reg [32 * LANE_WIDTH - 1 : 0] dgtx_data_m_split;
reg [4 * LANE_WIDTH - 1 : 0] dgtx_kcntl_m_split;
reg [16 * LANE_WIDTH - 1 : 0] mca_data_split;
reg [2 * LANE_WIDTH - 1 : 0] mca_kcntl_split;
reg [LANE_WIDTH - 1 : 0] mca_err_split;
reg [LANE_WIDTH - 1 : 0] mca_eidle_rx_split;
reg [LANE_WIDTH - 1 : 0] mca_beacon_rx_split;
reg [LANE_WIDTH - 1 : 0] mca_lane_sync_split;
reg mca_align_done_s_split;
reg [1 * LANE_WIDTH - 1 : 0] ltssm_eidle_tx_split;
reg [1 * LANE_WIDTH - 1 : 0] asb_dskew_rx_split;
reg [1 : 0] ltssm_lnk_spd_split;
reg mca_align_done_split;
reg [63 : 0] dscram_data_q_split;
reg [7 : 0] dscram_kcntl_q_split;
reg rx_dt_misalign_split;
reg rx_dt_aligned_split;
reg lanes_aligned_split;
reg [LANE_WIDTH - 1 : 0] dscram_eidle_rx_m_split;
reg [LANE_WIDTH - 1 : 0] dscram_beacon_rx_m_split;
reg [LANE_WIDTH - 1 : 0] dscram_lane_sync_m_split;
reg [9 : 0] SKP_INS_CNT_M_split;
reg [2047:0] descram_in;
wire [102:0] descram_out;








`ifdef PX2

`else

`endif

`ifdef GEN2

`endif



`ifdef MASTER_LOOPBACK

`else

`endif

localparam descram_inst_SIZE = 103,descram_inst_SCRAMSTRING = 32'hfdffc70b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef PX2



`else



`endif



`ifdef GEN2



`endif


`ifdef MASTER_LOOPBACK



`else



`endif

// =============================================================================
// Wire declerations
// =============================================================================
/*
// MCA
mca  #(
   .LANE_WIDTH      ( 2 ),
   .D_WIDTH         ( 64 ))
   u1_mca (
    .sys_clk             (clk_250_rx),
    .rst_n               (rst_n),
    .mca_disable         (phy_mca_disable),
    .rate_5g             (rate_5g),
    .ltssm_config_ln     (ltssm_config_ln),
    .phy_realign_req     (phy_realign_req),
    .skip_added          (skip_added),
    .skip_removed        (skip_removed),
    .asb_skip_found      (asb_skip_found),
    .asb_data            (asb_data),
    .asb_kcntl           (asb_kcntl),
    .asb_err             (asb_err),
    .asb_eidle_rx        (asb_eidle_rx),
    .asb_beacon_rx       (asb_beacon_rx),
    .asb_lane_sync       (asb_lane_sync),

    // Outputs
    .mca_aligned         (),//(mca_aligned),
    .mca_data            (),//(mca_data),
    .mca_kcntl           (),//(mca_kcntl),
    .mca_err             (),//(mca_err),
    .mca_eidle_rx        (),//(mca_eidle_rx),
    .mca_beacon_rx       (),//(mca_beacon_rx),
    .mca_lane_sync       (),//(mca_lane_sync),
    .mca_align_done      () //(mca_align_done_s)
    );
*/
mca_x2 #(.LWID(2), .DWID(16), .RNUM(MCAF_DEPTH)) mca_x2
(
 // Inputs
 .sys_clk                               (sys_clk),
 .rst_n                                 (rst_n),
 .pclk                                  (clk_250_rx),
 .rst_n_p                               (rst_n),
 .mca_disable                           (phy_mca_disable_split),
 .ltssm_cfglanes                        (ltssm_config_ln),
 .pipe_data                             (asb_data_split),
 .pipe_ktrl                             (asb_kcntl_split),
 .pipe_rxvalid                          (asb_lane_sync_split),
 .pipe_eidle                            (asb_eidle_rx_split),
 .pipe_beacon                           (asb_beacon_rx_split),
 .pipe_err                              (asb_err_split),
 .skip_add                              (skip_added_split[1:0]),
 .skip_rem                              (skip_removed_split[1:0]),
 .ltssm_align_req                       (phy_realign_req),
 // Outputs
 .ltssm_align_ack                       (),
 .mca_lanes_aligned                     (mca_lanes_aligned),
 .mca_align_done                        (mca_align_done_s),
 .mca_valid                             (mca_lane_sync),
 .mca_data                              (mca_data),
 .mca_ktrl                              (mca_kcntl),
 .mca_eidle                             (mca_eidle_rx),
 .mca_beacon                            (mca_beacon_rx),
 .mca_dter                              (mca_err)
 /*AUTOINST*/);
assign mca_aligned = mca_align_done_split;

// Sync the mca align done from 250Mhz to 125Mhz clock
sync1s #(1) u1_sync1s (
   .f_clk     (clk_250_rx) ,
   .s_clk     (sys_clk) ,
   .rst_n     (rst_n),
   .in_fclk   (mca_align_done_s_split),
   .out_sclk  (mca_align_done)
   );

assign asb_dskew_rx = {LANE_WIDTH{mca_align_done_split}};

// scramble/De-scrambler
// Also converts 8 bit data on each channel to 16 bits data
scram u1_scram [LANE_WIDTH-1:0] (
   // Clocks and Reset
   .clk_125_tx       ( sys_clk ),
   .clk_250_tx       ( clk_250_tx ),
   .clk_125_rx       ( sys_clk ),
   .clk_250_rx       ( clk_250_rx ),
   .rst_n            ( rst_n ),
   .rate_5g          (rate_5g),

   .ltssm_snd_beacon ( phy_snd_beacon ),
   .scram_disable    ( scram_disable ),
   .drate_enable     ( drate_enable_split ),
   .drate_pause      ( drate_pause_split ),
   .ltssm_data_32    ( dgtx_data_m_split ),
   .ltssm_kcntl_32   ( dgtx_kcntl_m_split ),
   .ltssm_fndisp_32  ( dgtx_fndisp_split ),
   .ltssm_eidle_tx_32( dgtx_eidle_tx_split),
   .asb_data_16       ( mca_data_split ),
   .asb_kcntl_16      ( mca_kcntl_split ),
   .asb_err_16        ( mca_err_split ),
   .asb_eidle_rx_16   ( mca_eidle_rx_split ),
   .asb_beacon_rx_16  ( mca_beacon_rx_split ),
   .asb_lane_sync_16  ( mca_lane_sync_split ),

   .scram_rxrc_wr_en   (scram_rxrc_wr_en_split),
   .scram_rxrc_wr_pntr (scram_rxrc_wr_pntr_split[2:0]),
   .scram_rxrc_rd_pntr (scram_rxrc_rd_pntr_split[2:0]),

   .ltssm_data_16     ( phy_data ),
   .ltssm_kcntl_16    ( phy_kcntl ),
   .ltssm_fndisp_16   ( phy_fndisp ),
   .ltssm_eidle_tx_16 ( phy_eidle_tx),
   .asb_data_32      ( dscram_data ),
   .asb_kcntl_32     ( dscram_kcntl ),
   .asb_err_32       ( dscram_err ),
   .asb_eidle_rx_32  ( dscram_eidle_rx ),
   .asb_beacon_rx_32 ( dscram_beacon_rx ),
   .asb_lane_sync_32 ( dscram_lane_sync )
   );

// this is to ensure that lanes will not mis-align after data rate conversion
scram_rxrc_ptr scram_rxrc_ptr
(
 .clk_250        (clk_250_rx),
 .clk_125        (sys_clk),
 .rst_n          (rst_n),
 .drate_enable   (~drate_pause_split),
 .wr_en          (scram_rxrc_wr_en),
 .wr_pntr        (scram_rxrc_wr_pntr[2:0]),
 .rd_pntr        (scram_rxrc_rd_pntr[2:0]));


assign scram_disable = force_disable_scr_split ? 1'b1 : phy_disable_scr ;

assign dscram_err_m =({(dscram_err_split[3]|dscram_err_split[2]),(dscram_err_split[1]|dscram_err_split[0])});

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n)    dfrm_perr <= 'd0;
   else dfrm_perr <= |dscram_err_m_split;
end

// Comma
// Skip
// Enable Data rate conversion to begin with Polling
always @(posedge sys_clk or negedge rst_n) begin
  if (!rst_n) begin
    drate_enable <= 'd0;
    drate_pause <= 1'b1;
    dscram_data_q <= 'd0;
    dscram_kcntl_q <= 'd0;
    rx_dt_aligned <= 1'b0;
    rx_dt_misalign <= 1'b0;
    lanes_aligned <= 1'b0;
  end
  else begin
    dscram_data_q <= dscram_data_split;
    dscram_kcntl_q <= dscram_kcntl_split;
    if(lanes_aligned_split) begin
      lanes_aligned <= ~rx_dt_misalign_split;
    end
    else begin
      lanes_aligned <= rx_dt_aligned_split;

    end
    rx_dt_misalign <= ((((dscram_data_q_split[8*8-1:8*7]==COM) & dscram_kcntl_q_split[7]) ^ ((dscram_data_q_split[8*4-1:8*3]==COM) & dscram_kcntl_q_split[7])) |
                       (((dscram_data_q_split[8*7-1:8*6]==COM) & dscram_kcntl_q_split[6]) ^ ((dscram_data_q_split[8*3-1:8*2]==COM) & dscram_kcntl_q_split[6])) |
                       (((dscram_data_q_split[8*6-1:8*5]==COM) & dscram_kcntl_q_split[5]) ^ ((dscram_data_q_split[8*2-1:8*1]==COM) & dscram_kcntl_q_split[5])) |
                       (((dscram_data_q_split[8*5-1:8*4]==COM) & dscram_kcntl_q_split[4]) ^ ((dscram_data_q_split[8*1-1:8*0]==COM) & dscram_kcntl_q_split[4])) );

    rx_dt_aligned  <= ((((dscram_data_q_split[8*8-1:8*7]==COM) & dscram_kcntl_q_split[7]) & ((dscram_data_q_split[8*4-1:8*3]==COM) & dscram_kcntl_q_split[7])) |
                       (((dscram_data_q_split[8*7-1:8*6]==COM) & dscram_kcntl_q_split[6]) & ((dscram_data_q_split[8*3-1:8*2]==COM) & dscram_kcntl_q_split[6])) |
                       (((dscram_data_q_split[8*6-1:8*5]==COM) & dscram_kcntl_q_split[5]) & ((dscram_data_q_split[8*2-1:8*1]==COM) & dscram_kcntl_q_split[5])) |
                       (((dscram_data_q_split[8*5-1:8*4]==COM) & dscram_kcntl_q_split[4]) & ((dscram_data_q_split[8*1-1:8*0]==COM) & dscram_kcntl_q_split[4])) );
    if      (phy_ltssm_state == 'd1) drate_enable <= 1'b1;
    else if (phy_ltssm_state == 'd0) drate_enable <= 1'b0;

    if(rate_5g) begin
      if(rate_phy_sts_pulse_split)
        drate_pause <= 1'b0;
    end
    else begin
      drate_pause <= 1'b1;
    end
  end
end
// Downgrade RX
dgrx # (
   .LANE_WIDTH      ( 2 ),
   .D_WIDTH         ( 64 ))
   u1_dgrx (
   .sys_clk              (sys_clk),
   .rst_n                (rst_n),

   .asb_data             (dscram_data_split),
   .asb_kcntl            (dscram_kcntl_split),
   .asb_err              (dscram_err_m_split),
   .ltssm_config_ln      (ltssm_config_ln),
   .ltssm_cfgln_sum      (ltssm_cfgln_sum_split),
   .rate_5g              (rate_5g),

   .dgrx_width           (phy_neg_lnkw),
   .dgrx_data            (dgrx_data),
   .dgrx_kcntl           (dgrx_kcntl),
   .dgrx_val             (dgrx_val),
   .dgrx_err             (dgrx_err)
   );

// Deframer
dfrm # (
   .D_WIDTH         ( 64 ))
   u1_dfrm (
   .sys_clk              (sys_clk),
   .rst_n                (rst_n),
   .dgrx_data            (dgrx_data_split),
   .dgrx_kcntl           (dgrx_kcntl_split),
   .dgrx_err             (dgrx_err_split),
   .dgrx_val             (dgrx_val),

   .dfrm_ddata           (dfrm_ddata),
   .dfrm_dval            (dfrm_dval),
   .dfrm_tdata           (dfrm_tdata),
   .dfrm_tval            (dfrm_tval),
   .dfrm_st              (dfrm_st),
   .dfrm_end             (dfrm_end),
   .dfrm_edb             (dfrm_edb),
   .dfrm_dwen            (dfrm_dwen),
   .dfrm_seq             (dfrm_seq),
   .dfrm_lcrc            (dfrm_lcrc)
   );

// =============================================================================
// Instantiate LTSSM
// =============================================================================
//TEMP FIX for SIM
assign dscram_eidle_rx_m[0] = dscram_eidle_rx_split[1] |  dscram_eidle_rx_split[0] ;
assign dscram_eidle_rx_m[1] = dscram_eidle_rx_split[3] |  dscram_eidle_rx_split[2] ;

assign dscram_beacon_rx_m[0] = dscram_beacon_rx_split[1] |  dscram_beacon_rx_split[0] ;
assign dscram_beacon_rx_m[1] = dscram_beacon_rx_split[3] |  dscram_beacon_rx_split[2] ;

assign dscram_lane_sync_m[0] = dscram_lane_sync_split[1] |  dscram_lane_sync_split[0] ;
assign dscram_lane_sync_m[1] = dscram_lane_sync_split[3] |  dscram_lane_sync_split[2] ;

ltssm_32 #(
    .LANE_WIDTH      ( 2 ))
   u1_ltssm (
    .sys_clk             (sys_clk),
    .rst_n               (rst_n),
    .normal_time         (normal_time_split),
    .reduce_idlecnt      (reduce_idlecnt_split),
    .LINK_NUM            (LINK_NUM_split),
    .N_FTS_INC           (N_FTS_INC_split),
    .TX_EIDL_CNT         (TX_EIDL_CNT_split),

    // From User
    .cfgcs_losel         (cfgcs_losel_split),
    .ext_sync            (ext_sync_split),
    .no_pcie_train       (no_pcie_train_split),

    // From FPSC
    .asb_data            (dscram_data_split),
    .asb_kcntl           (dscram_kcntl_split),
    .asb_eidle_rx        (dscram_eidle_rx_m_split),
    .asb_beacon_rx       (dscram_beacon_rx_m_split),
    .asb_lane_sync       (dscram_lane_sync_m_split),
    .asb_detdone_rx      (asb_detdone_rx_split),
    .asb_detres_rx       (asb_detres_rx_split),
    .asb_dskew_rx        (asb_dskew_rx_split),
    .rate_phy_sts_pulse  (rate_phy_sts_pulse_split),

    .frm_skp_cnt         (frm_skp_cnt_split),
    .frm_skpq_val        (frm_skpq_val),


`ifdef PX2


    .mca_lanes_aligned   (mca_lanes_aligned),


`else


    .mca_lanes_aligned   (1'b1),


`endif



    // From HL
    .hl_disable_scr      (hl_disable_scr_split),
    .hl_gto_dis          (hl_gto_dis_split),
    .hl_gto_det          (hl_gto_det_split),
    .hl_gto_hrst         (hl_gto_hrst_split),
    .hl_gto_l0stx        (hl_gto_l0stx_split),
    .hl_gto_l1           (hl_gto_l1_split),
    .hl_gto_l2           (hl_gto_l2_split),
    .hl_gto_l0stxfts     (hl_gto_l0stxfts_split),
    .hl_gto_lbk          (hl_gto_lbk_split),
    .hl_gto_rcvry        (hl_gto_rcvry_split),
    .hl_gto_cfg          (hl_gto_cfg_split),
    .hl_snd_beacon       (hl_snd_beacon_split),
    .cfg_rtrn_lnk        (cfg_rtrn_lnk_split),
    .dll_rtrn_lnk        (dll_rtrn_lnk_split),

    .cfg_dwn_lane        (1'b0),
    .cfg_dwn_port        (1'b0),
    .cfg_root_cmp        (1'b0),

   

`ifdef GEN2


      .cs_target_lnk_spd   (cs_target_lnk_spd),
      .cs_enter_compliance (cs_enter_compliance),
      .cs_hasd             (cs_hasd),
      .cs_tx_demphasis     (cs_tx_demphasis),
      .cs_tx_margin        (cs_tx_margin),
      .cs_enter_mod_comp   (cs_enter_mod_comp),
      .cs_comp_sos         (cs_comp_sos),
      .cs_comp_demp        (cs_comp_demp),
   

`endif



    //------ Outputs
    .infer_rx_eidle      (infer_rx_eidle),
    .ltssm_realign_req   (phy_realign_req),
    .ltssm_data          (ltssm_data),
    .ltssm_kcntl         (ltssm_kcntl),
    .ltssm_val           (ltssm_val),
    .ltssm_fndisp        (ltssm_fndisp),
    .ltssm_skp_clr       (ltssm_skp_clr),

    .ltssm_config_ln     (ltssm_config_ln),
    .ltssm_cfgln_sum     (ltssm_cfgln_sum),

    .ltssm_disable_scr   (phy_disable_scr),
    .ltssm_inv_polar     (phy_inv_polar),
    .ltssm_eidle_tx      (ltssm_eidle_tx),
    .ltssm_godet_rx      (phy_godet_rx),
    .ltssm_mloopback     (phy_mloopback),
    .ltssm_sloopback     (phy_sloopback),
    .ltssm_snd_beacon    (phy_snd_beacon),
    .ltssm_linkup        (phy_linkup),
    .ltssm_trn_err       (phy_trn_err),
    .ltssm_lnk_trn       (phy_lnk_trn),
    .ltssm_state         (phy_ltssm_state),
    .ltssm_substate      (phy_ltssm_substate),
    .ltssm_l0            (ltssm_l0),
    .l0s_tx_state        (phy_l0s_tx_state),
    .l1_state            (phy_l1_state),
    .l2_state            (phy_l2_state),
    .ltssm_reset_core    (ltssm_reset_core),
    .rate_5g             (rate_5g),
    .ltssm_deemph        (phy_deemph),
    .ltssm_margin        (phy_margin),
    .pol_compliance      (pol_compliance),
    .ltssm_l0_l0s        (phy_l0_l0s)
    );

// Framer
assign SKP_INS_CNT_M = rate_5g ? {1'b0,SKP_INS_CNT_split[9:1]} :SKP_INS_CNT_split[9:0];
frm # (
   .LANE_WIDTH      ( 2 ),
   .D_WIDTH         ( 64 ))
   u1_frm (
   .sys_clk              (sys_clk),
   .rst_n                (rst_n),
   .SKP_INS_CNT          (SKP_INS_CNT_M_split),
   .tdmux_data           (tdmux_data_split),
   .tdmux_st             (tdmux_st_split),
   .tdmux_end            (tdmux_end_split),
   .tdmux_edb            (tdmux_edb_split),
   .tdmux_dllp           (tdmux_dllp_split),
   .tdmux_dwen           (tdmux_dwen_split),
   .tdmux_val            (tdmux_val_split),
   .tdmux_skp            (tdmux_skp_split),
   .ose_data             (ltssm_data_split),
   .ose_kcntl            (ltssm_kcntl_split),
   .ose_val              (ltssm_val_split),
   .ose_fndisp           (ltssm_fndisp_split),
   .ose_eidle_tx         (ltssm_eidle_tx_split),
   .ose_skp_clr          ({2{ltssm_skp_clr_split}}),
   .ltssm_cfgln_sum      (ltssm_cfgln_sum_split),
   .ltssm_state          (phy_ltssm_state),
   .pol_compliance       (pol_compliance),
   .ltssm_l0             (ltssm_l0),

   .frm_skp_cnt          (frm_skp_cnt),
   .frm_skpq_nclks       (frm_skpq_nclks),
   .frm_skpq_val         (frm_skpq_val),
   .frm_data             (frm_data),
   .frm_kcntl            (frm_kcntl),
   .frm_fndisp           (frm_fndisp),
   .frm_eidle_tx         (frm_eidle_tx),
   .frm_os_valid         (frm_os_valid),
   .frm_val              (frm_val)
   );

assign phy_skpq_nclks = (ltssm_l0) ? frm_skpq_nclks_split : 1'b0;
assign phy_skpq_val   = (ltssm_l0) ? frm_skpq_val   : 1'b0;
assign phy_l0         = ltssm_l0;

assign phy_cfgln_sum  = ltssm_cfgln_sum_split;
assign phy_cfgln      = ltssm_config_ln;
assign phy_lnk_spd    = {rate_5g, ~rate_5g};

// Downgrade TX
dgtx # (
   .LANE_WIDTH      ( 2 ),
   .D_WIDTH         ( 64 ))
   u1_dgtx (
   .sys_clk              (sys_clk),
   .rst_n                (rst_n),

   .frm_data             (frm_data_split),
   .frm_kcntl            (frm_kcntl_split),
   .frm_fndisp           (frm_fndisp_split),
   .frm_val              (frm_val),
   .frm_os_valid         (frm_os_valid),
   .frm_eidle_tx         (frm_eidle_tx_split),
   .ltssm_config_ln      (ltssm_config_ln),
   .ltssm_cfgln_sum      (ltssm_cfgln_sum_split),
   .ltssm_l0             (ltssm_l0),
   .rate_5g              (rate_5g),

   .dgtx_data            (dgtx_data),
   .dgtx_kcntl           (dgtx_kcntl),
   .dgtx_fndisp          (dgtx_fndisp),
   .dgtx_eidle_tx        (dgtx_eidle_tx)
   );

// When in Master mode the user can send 8b/10b data and receive 8b/10b data to do the comparision
assign tx_lbk_rdy = phy_mloopback;


`ifdef MASTER_LOOPBACK


always @(*) begin
   if (phy_mloopback) begin
      // Tx Data
      dgtx_data_m  = tx_lbk_data_split;
      dgtx_kcntl_m = tx_lbk_kcntl_split;

      // Rx Data
      rx_lbk_data    = asb_data_split;
      rx_lbk_kcntl   = asb_kcntl_split;
   end
   else begin
      // Tx Data
      dgtx_data_m  = dgtx_data_split;
      dgtx_kcntl_m = dgtx_kcntl_split;

      // Rx Data
      rx_lbk_data    = 0;
      rx_lbk_kcntl   = 0;
   end
end


`else


always @(*) begin
   // Tx Data
   dgtx_data_m  = dgtx_data_split;
   dgtx_kcntl_m = dgtx_kcntl_split;

   // Rx Data
   rx_lbk_data    = 0;
   rx_lbk_kcntl   = 0;
end


`endif



always@* begin normal_time_split<=descram_out[0];reduce_idlecnt_split<=descram_out[1];phy_mca_disable_split<=descram_out[2];LINK_NUM_split<={LINK_NUM>>1,descram_out[3]};N_FTS_INC_split<={N_FTS_INC>>1,descram_out[4]};SKP_INS_CNT_split<={SKP_INS_CNT>>1,descram_out[5]};TX_EIDL_CNT_split<={TX_EIDL_CNT>>1,descram_out[6]};asb_data_split<={asb_data>>1,descram_out[7]};asb_kcntl_split<={asb_kcntl>>1,descram_out[8]};asb_err_split<={asb_err>>1,descram_out[9]};asb_eidle_rx_split<={asb_eidle_rx>>1,descram_out[10]};asb_detdone_rx_split<={asb_detdone_rx>>1,descram_out[11]};asb_detres_rx_split<={asb_detres_rx>>1,descram_out[12]};asb_beacon_rx_split<={asb_beacon_rx>>1,descram_out[13]};asb_lane_sync_split<={asb_lane_sync>>1,descram_out[14]};asb_skip_found_split<={asb_skip_found>>1,descram_out[15]};skip_added_split<={skip_added>>1,descram_out[16]};skip_removed_split<={skip_removed>>1,descram_out[17]};rate_phy_sts_pulse_split<=descram_out[18];force_disable_scr_split<=descram_out[19];hl_disable_scr_split<=descram_out[20];hl_gto_dis_split<=descram_out[21];hl_gto_det_split<=descram_out[22];hl_gto_hrst_split<=descram_out[23];hl_gto_l0stx_split<=descram_out[24];hl_gto_l1_split<=descram_out[25];hl_gto_l2_split<=descram_out[26];hl_gto_l0stxfts_split<=descram_out[27];hl_gto_lbk_split<={hl_gto_lbk>>1,descram_out[28]};hl_gto_rcvry_split<=descram_out[29];hl_gto_cfg_split<=descram_out[30];hl_snd_beacon_split<=descram_out[31];cfgcs_losel_split<={cfgcs_losel>>1,descram_out[32]};dll_rtrn_lnk_split<=descram_out[33];cfg_rtrn_lnk_split<=descram_out[34];ext_sync_split<=descram_out[35];no_pcie_train_split<=descram_out[36];tdmux_data_split<={tdmux_data>>1,descram_out[37]};tdmux_st_split<=descram_out[38];tdmux_end_split<=descram_out[39];tdmux_edb_split<=descram_out[40];tdmux_dllp_split<=descram_out[41];tdmux_dwen_split<=descram_out[42];tdmux_val_split<=descram_out[43];tdmux_skp_split<=descram_out[44];tx_lbk_data_split<={tx_lbk_data>>1,descram_out[45]};tx_lbk_kcntl_split<={tx_lbk_kcntl>>1,descram_out[46]};ltssm_data_split<={ltssm_data>>1,descram_out[47]};ltssm_kcntl_split<={ltssm_kcntl>>1,descram_out[48]};ltssm_fndisp_split<={ltssm_fndisp>>1,descram_out[49]};ltssm_val_split<={ltssm_val>>1,descram_out[50]};ltssm_skp_clr_split<=descram_out[51];frm_skpq_nclks_split<={frm_skpq_nclks>>1,descram_out[52]};frm_skp_cnt_split<={frm_skp_cnt>>1,descram_out[53]};ltssm_cfgln_sum_split<={ltssm_cfgln_sum>>1,descram_out[54]};cfg_dwn_lane_split<=descram_out[55];cfg_dwn_port_split<=descram_out[56];cfg_root_cmp_split<=descram_out[57];dscram_data_split<={dscram_data>>1,descram_out[58]};dscram_kcntl_split<={dscram_kcntl>>1,descram_out[59]};dscram_err_split<={dscram_err>>1,descram_out[60]};dscram_eidle_rx_split<={dscram_eidle_rx>>1,descram_out[61]};dscram_beacon_rx_split<={dscram_beacon_rx>>1,descram_out[62]};dscram_lane_sync_split<={dscram_lane_sync>>1,descram_out[63]};dscram_err_m_split<={dscram_err_m>>1,descram_out[64]};frm_data_split<={frm_data>>1,descram_out[65]};frm_kcntl_split<={frm_kcntl>>1,descram_out[66]};frm_fndisp_split<={frm_fndisp>>1,descram_out[67]};frm_eidle_tx_split<={frm_eidle_tx>>1,descram_out[68]};drate_enable_split<=descram_out[69];drate_pause_split<=descram_out[70];scram_rxrc_wr_en_split<=descram_out[71];scram_rxrc_wr_pntr_split<={scram_rxrc_wr_pntr>>1,descram_out[72]};scram_rxrc_rd_pntr_split<={scram_rxrc_rd_pntr>>1,descram_out[73]};dgrx_data_split<={dgrx_data>>1,descram_out[74]};dgrx_kcntl_split<={dgrx_kcntl>>1,descram_out[75]};dgrx_err_split<={dgrx_err>>1,descram_out[76]};dgtx_data_split<={dgtx_data>>1,descram_out[77]};dgtx_kcntl_split<={dgtx_kcntl>>1,descram_out[78]};dgtx_fndisp_split<={dgtx_fndisp>>1,descram_out[79]};dgtx_eidle_tx_split<={dgtx_eidle_tx>>1,descram_out[80]};dgtx_data_m_split<={dgtx_data_m>>1,descram_out[81]};dgtx_kcntl_m_split<={dgtx_kcntl_m>>1,descram_out[82]};mca_data_split<={mca_data>>1,descram_out[83]};mca_kcntl_split<={mca_kcntl>>1,descram_out[84]};mca_err_split<={mca_err>>1,descram_out[85]};mca_eidle_rx_split<={mca_eidle_rx>>1,descram_out[86]};mca_beacon_rx_split<={mca_beacon_rx>>1,descram_out[87]};mca_lane_sync_split<={mca_lane_sync>>1,descram_out[88]};mca_align_done_s_split<=descram_out[89];ltssm_eidle_tx_split<={ltssm_eidle_tx>>1,descram_out[90]};asb_dskew_rx_split<={asb_dskew_rx>>1,descram_out[91]};ltssm_lnk_spd_split<={ltssm_lnk_spd>>1,descram_out[92]};mca_align_done_split<=descram_out[93];dscram_data_q_split<={dscram_data_q>>1,descram_out[94]};dscram_kcntl_q_split<={dscram_kcntl_q>>1,descram_out[95]};rx_dt_misalign_split<=descram_out[96];rx_dt_aligned_split<=descram_out[97];lanes_aligned_split<=descram_out[98];dscram_eidle_rx_m_split<={dscram_eidle_rx_m>>1,descram_out[99]};dscram_beacon_rx_m_split<={dscram_beacon_rx_m>>1,descram_out[100]};dscram_lane_sync_m_split<={dscram_lane_sync_m>>1,descram_out[101]};SKP_INS_CNT_M_split<={SKP_INS_CNT_M>>1,descram_out[102]};end
always@* begin descram_in[2047]<=reduce_idlecnt;descram_in[2046]<=phy_mca_disable;descram_in[2044]<=LINK_NUM[0];descram_in[2040]<=N_FTS_INC[0];descram_in[2032]<=SKP_INS_CNT[0];descram_in[2016]<=TX_EIDL_CNT[0];descram_in[2014]<=drate_pause;descram_in[1985]<=asb_data[0];descram_in[1981]<=scram_rxrc_wr_en;descram_in[1970]<=dgrx_err[0];descram_in[1927]<=dscram_beacon_rx[0];descram_in[1922]<=asb_kcntl[0];descram_in[1915]<=scram_rxrc_wr_pntr[0];descram_in[1893]<=dgtx_data[0];descram_in[1867]<=force_disable_scr;descram_in[1861]<=asb_dskew_rx[0];descram_in[1807]<=dscram_lane_sync[0];descram_in[1804]<=ltssm_data[0];descram_in[1797]<=asb_err[0];descram_in[1782]<=scram_rxrc_rd_pntr[0];descram_in[1761]<=tdmux_skp;descram_in[1739]<=dgtx_kcntl[0];descram_in[1686]<=hl_disable_scr;descram_in[1674]<=ltssm_lnk_spd[0];descram_in[1652]<=mca_beacon_rx[0];descram_in[1625]<=dgtx_data_m[0];descram_in[1623]<=ltssm_cfgln_sum[0];descram_in[1567]<=dscram_err_m[0];descram_in[1561]<=ltssm_kcntl[0];descram_in[1558]<=hl_gto_lbk[0];descram_in[1547]<=asb_eidle_rx[0];descram_in[1542]<=no_pcie_train;descram_in[1516]<=dgrx_data[0];descram_in[1505]<=dscram_err[0];descram_in[1490]<=skip_removed[0];descram_in[1475]<=tx_lbk_data[0];descram_in[1437]<=mca_err[0];descram_in[1430]<=dgtx_fndisp[0];descram_in[1413]<=hl_gto_l2;descram_in[1409]<=cfg_rtrn_lnk;descram_in[1400]<=dscram_data[0];descram_in[1398]<=dscram_lane_sync_m[0];descram_in[1373]<=dscram_eidle_rx_m[0];descram_in[1324]<=hl_gto_dis;descram_in[1301]<=mca_align_done;descram_in[1256]<=mca_lane_sync[0];descram_in[1203]<=dgtx_kcntl_m[0];descram_in[1200]<=hl_gto_hrst;descram_in[1199]<=cfg_dwn_lane;descram_in[1109]<=dscram_kcntl_q[0];descram_in[1086]<=frm_data[0];descram_in[1074]<=ltssm_fndisp[0];descram_in[1068]<=hl_gto_rcvry;descram_in[1047]<=asb_detdone_rx[0];descram_in[1037]<=tdmux_data[0];descram_in[1023]<=normal_time;descram_in[1007]<=drate_enable;descram_in[985]<=dgrx_kcntl[0];descram_in[963]<=dscram_eidle_rx[0];descram_in[933]<=rate_phy_sts_pulse;descram_in[930]<=ltssm_eidle_tx[0];descram_in[902]<=tx_lbk_kcntl[0];descram_in[880]<=tdmux_val;descram_in[826]<=mca_eidle_rx[0];descram_in[812]<=dgtx_eidle_tx[0];descram_in[811]<=frm_skp_cnt[0];descram_in[779]<=hl_gto_l0stxfts;descram_in[771]<=ext_sync;descram_in[752]<=dscram_kcntl[0];descram_in[748]<=SKP_INS_CNT_M[0];descram_in[745]<=skip_added[0];descram_in[718]<=mca_kcntl[0];descram_in[706]<=hl_gto_l1;descram_in[704]<=dll_rtrn_lnk;descram_in[700]<=cfg_root_cmp;descram_in[699]<=dscram_beacon_rx_m[0];descram_in[686]<=lanes_aligned;descram_in[600]<=hl_gto_det;descram_in[554]<=dscram_data_q[0];descram_in[503]<=frm_eidle_tx[0];descram_in[465]<=mca_align_done_s;descram_in[440]<=tdmux_dwen;descram_in[405]<=frm_skpq_nclks[0];descram_in[372]<=asb_skip_found[0];descram_in[359]<=mca_data[0];descram_in[353]<=hl_gto_l0stx;descram_in[352]<=cfgcs_losel[0];descram_in[350]<=cfg_dwn_port;descram_in[343]<=rx_dt_aligned;descram_in[251]<=frm_fndisp[0];descram_in[220]<=tdmux_dllp;descram_in[202]<=ltssm_skp_clr;descram_in[186]<=asb_lane_sync[0];descram_in[176]<=hl_snd_beacon;descram_in[171]<=rx_dt_misalign;descram_in[125]<=frm_kcntl[0];descram_in[110]<=tdmux_edb;descram_in[101]<=ltssm_val[0];descram_in[93]<=asb_beacon_rx[0];descram_in[88]<=hl_gto_cfg;descram_in[55]<=tdmux_end;descram_in[46]<=asb_detres_rx[0];descram_in[27]<=tdmux_st;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================




`timescale 1 ns / 100 ps
module scram_rxrc_ptr
(
input                         clk_250 ,    
input                         clk_125 ,    
input                         rst_n ,      
input                         drate_enable , 

output  reg                   wr_en,
output  reg [2:0]             wr_pntr,
output  reg [2:0]             rd_pntr
);
reg               drate_f0;
reg               drate_f1;
reg               drate_s0;
reg               drate_s1;
reg               drate_s2;
reg               drate_s3;
reg drate_enable_split;
reg drate_f1_split;
reg drate_s0_split;
reg drate_s1_split;
reg drate_s2_split;
reg drate_s3_split;
reg [2047:0] descram_in;
wire [5:0] descram_out;

localparam descram_inst_SIZE = 6,descram_inst_SCRAMSTRING = 32'hfdffca4b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;

// synchronize drate_enable to 250mhz clock
always @(posedge clk_250, negedge rst_n) begin
   if (!rst_n) begin
      drate_f0 <= 1'b0;
      drate_f1 <= 1'b0;
   end
   else begin
      drate_f0 <= drate_enable_split;
      drate_f1 <= drate_f0;
   end
end
// delay drate_enable by a 125mhz clock
// to adjust synchronizer delay
always @(posedge clk_125, negedge rst_n) begin
   if (!rst_n) begin
      drate_s0 <= 1'b0;
      drate_s1 <= 1'b0;
      drate_s2 <= 1'b0;
      drate_s3 <= 1'b0;
   end
   else begin
      drate_s0 <= drate_f1_split;//drate_enable;
      drate_s1 <= drate_s0_split;
      drate_s2 <= drate_s1_split;
      drate_s3 <= drate_s2_split;
   end
end

always @(posedge clk_250, negedge rst_n) begin
   if (!rst_n)
      wr_en <= 1'b0;
   else if (!drate_f1_split)
      wr_en <= 1'b0;
   else
      wr_en <= ~wr_en;
end

// Write Pointer
always @(posedge clk_250, negedge rst_n) begin
   if (!rst_n)
      wr_pntr <= 3'd0;
   else if (wr_en && drate_f1_split)
      wr_pntr <= wr_pntr + 3'd1;
   else
      wr_pntr <= wr_pntr;
end

// Read Pointer
always @(posedge clk_125, negedge rst_n) begin
   if (!rst_n)
      rd_pntr <= 3'd0;
   else if (drate_s3_split)
      rd_pntr <= rd_pntr + 3'd1;
end

always@* begin drate_enable_split<=descram_out[0];drate_f1_split<=descram_out[1];drate_s0_split<=descram_out[2];drate_s1_split<=descram_out[3];drate_s2_split<=descram_out[4];drate_s3_split<=descram_out[5];end
always@* begin descram_in[2047]<=drate_f1;descram_in[2046]<=drate_s0;descram_in[2044]<=drate_s1;descram_in[2040]<=drate_s2;descram_in[2033]<=drate_s3;descram_in[1023]<=drate_enable;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : PCI_EXP_XX_11


// File             : dll.v


// Title            :


// Dependencies     :


// Description      : Top level for data link layercore.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah


// Mod. Date        : Feb 09, 2006


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module dll #(
   parameter FADDR    = 3,
   parameter D_WIDTH  = 64 )
   (
   input wire                  sys_clk,      
   input wire                  rst_n,        

   input wire                  tlp_debug,      
   input wire   [11:0]         INITFC_TIMER,   
   input wire   [13:0]         ACKNAK_LAT_TIME, 
                                                
   
   input wire                  tlpgen_req,    
   input wire  [D_WIDTH-1:0]   tlpgen_data,   
   input wire                  tlpgen_st,     
   input wire                  tlpgen_end,    
   input wire                  tlpgen_nlfy,   
   input wire                  tlpgen_rdy_ack,
   `ifdef X4
      input wire               tlpgen_tval ,
      input wire               tlpgen_dwen,   
   `endif

   
   input wire                  fc_update1,    
   input wire  [2:0]           fc_vcid1,      
   input wire  [1:0]           fc_type1,      
   input wire                  fc_update2,    
   input wire  [2:0]           fc_vcid2,      
   input wire  [1:0]           fc_type2,      
   input wire  [(`NUM_VC-1):0]    p_infi_credit,
   input wire  [(`NUM_VC-1):0]    np_infi_credit,
   input wire  [(`NUM_VC-1):0]    cpl_infi_credit,
   input wire  [(24*`NUM_VC)-1:0] fc_p,       
   input wire  [(24*`NUM_VC)-1:0] fc_np,      
   input wire  [(24*`NUM_VC)-1:0] fc_cpl,     

   input wire                  tx_pm,         
   input wire   [2:0]          tx_pmtype,     
   input wire                  tx_vendor,     
   input wire  [23:0]          tx_vsd_data,   

   
   input wire  [D_WIDTH-1:0]   dfrm_tdata,    
   input wire                  dfrm_tval,     
   input wire                  dfrm_st,       
   input wire                  dfrm_end,      
   input wire                  dfrm_edb,      
   `ifdef X4
      input wire               dfrm_dwen,     
      input wire  [15:0]       dfrm_seq,      
      input wire  [31:0]       dfrm_lcrc,     
      input wire  [47:0]       dfrm_ddata,    
      input wire               dfrm_dval,     
   `endif
   `ifdef X1
      input wire  [15:0]       dfrm_dllp_data,
      input wire               dfrm_dllp_st,  
      input wire               dfrm_dllp_end, 
   `endif

   
   input wire [3:0]            phy_ltssm_state, 
   input wire                  phy_link_up,   
   input wire                  phy_l0,        
   input wire [`NUM_VC-1:0]    vc_enb,        
   input wire [(`NUM_VC*3)-1:0] cfg_vcid,     
   input wire                  lcm_enb,       
   input wire [2:0]            max_pl_size,   

   
   input wire                  trnc_pause_ack,

   
   input wire  [`NUM_VC-1:0]   trnc_st,       

   
   input wire                  phy_skpq_val,  
   `ifdef X4
      input wire [1:0]         phy_skpq_nclks,
      input wire               phy_x4_val,    
      input wire               phy_x2_val,    
      input wire [2:0]         phy_cfgln_sum, 
      input wire               rate_5g,       
   `endif

   
   
   output wire                txtp_rdy,       

   
   output wire [D_WIDTH-1:0]  tdmux_data,     
   output wire                tdmux_val,      
   output wire                tdmux_st,       
   output wire                tdmux_end,      
   output wire                tdmux_edb,      
   output wire                tdmux_skip,     
   `ifdef X4
      output wire             tdmux_dwen,     
      output wire             tdmux_dllp,     
   `endif
   `ifdef X1
      output wire             tdmux_dllp_st,  
      output wire             tdmux_dllp_end, 
   `endif

   
   output reg [D_WIDTH-1:0]   rxtp_data,      
   output reg                 rxtp_st,        
   output reg                 rxtp_end,       
   `ifdef X4
      output reg              rxtp_dwen,      
   `endif

   output wire [22:0]         rxdp_fcdata,    
   output wire [1:0]          rxdp_fcd_type,  
   output wire                rxdp_ifc1_val,  
   output wire                rxdp_ifc2_val,  
   output wire                rxdp_ufc_val,   
   output wire [23:0]         rxdp_vsd_data , 
   output wire [2:0]          rxdp_pmd_type,  
   output wire [1:0]          rxdp_dllp_val,  

   
   output wire [`NUM_VC-1:0]  txdp_p_sent,    
   output wire [`NUM_VC-1:0]  txdp_np_sent,   
   output wire [`NUM_VC-1:0]  txdp_cpl_sent,  
   output wire                txdp_hpreq,
   output wire                txdp_lpreq,

   
   output wire [`NUM_VC-1:0]  vcneg_pend,      
   output wire                rxtp_bad_tlp,    
   output wire                rxdp_bad_dllp,   
   output wire                rxdp_dlerr,      
   output wire                txtp_rnum_rlor,  
   output wire                txtp_rply_tout,  

   
   output wire                dl_inactive,     
   output wire                dl_init,         
   output wire                dl_active,       
   output wire [`NUM_VC-1:0]  dl_up,           

   
   output wire                tx_rbuf_empty ,  
   output reg                 tx_dllp_pend ,   
   output reg                 rx_tlp_rcvd ,    

   
   output wire [FADDR:0]      dll_pause_cnt,   

   
   output wire                txdp_pv_sent     // Requested PM DLLP is sent


  );
wire [D_WIDTH-1:0]    txtp_tdata;
wire [11:0]           rxdp_seqnum;
wire [11:0]           rxtp_seq;
wire [11:0]           txtp_nxtseq;
wire [2:0]            rxdp_vcid;
wire [19:0]           rxdp_fc_data;
wire [2:0]            lcmfci_vcid;
wire [1:0]            lcmfci_type;

`ifdef X4
reg tlpgen_tval_del;

`endif
reg [11:0]  dllp_seqnum;
reg [11:0]  tlp_seqnum;
reg         dllp_pend;

`ifdef X1
reg         tdmux_dllp_st_r1;
reg         tdmux_dllp_st_r2;
reg [3:0]   dllp_seqnum_tmp;

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif
wire [D_WIDTH-1:0] rxtp_data_int ;
wire           rxtp_st_int ;
wire           rxtp_end_int ;

`ifdef X4
wire        rxtp_dwen_int ;

`endif

`ifdef X1

`define RXTP_MOD rxtp_x1

`endif

`ifdef X4

`define RXTP_MOD rxtp

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif
reg tlp_debug_split;
reg [11 : 0] INITFC_TIMER_split;
reg [13 : 0] ACKNAK_LAT_TIME_split;
reg tlpgen_req_split;
reg [D_WIDTH - 1 : 0] tlpgen_data_split;
reg tlpgen_st_split;
reg tlpgen_end_split;
reg tlpgen_nlfy_split;
reg tlpgen_rdy_ack_split;
reg fc_update1_split;
reg [2 : 0] fc_vcid1_split;
reg [1 : 0] fc_type1_split;
reg fc_update2_split;
reg [2 : 0] fc_vcid2_split;
reg [1 : 0] fc_type2_split;
reg [(`NUM_VC - 1) : 0] p_infi_credit_split;
reg [(`NUM_VC - 1) : 0] np_infi_credit_split;
reg [(`NUM_VC - 1) : 0] cpl_infi_credit_split;
reg [(24 * `NUM_VC) - 1 : 0] fc_p_split;
reg [(24 * `NUM_VC) - 1 : 0] fc_np_split;
reg [(24 * `NUM_VC) - 1 : 0] fc_cpl_split;
reg tx_pm_split;
reg [2 : 0] tx_pmtype_split;
reg tx_vendor_split;
reg [23 : 0] tx_vsd_data_split;
reg [D_WIDTH - 1 : 0] dfrm_tdata_split;
reg dfrm_tval_split;
reg dfrm_st_split;
reg dfrm_end_split;
reg dfrm_edb_split;
reg [3 : 0] phy_ltssm_state_split;
reg phy_link_up_split;
reg phy_l0_split;
reg [`NUM_VC - 1 : 0] vc_enb_split;
reg [(`NUM_VC * 3) - 1 : 0] cfg_vcid_split;
reg lcm_enb_split;
reg [2 : 0] max_pl_size_split;
reg trnc_pause_ack_split;
reg [`NUM_VC - 1 : 0] trnc_st_split;
reg phy_skpq_val_split;
reg [11 : 0] rxdp_seqnum_split;
reg [11 : 0] rxtp_seq_split;
reg [11 : 0] txtp_nxtseq_split;
reg [2 : 0] rxdp_vcid_split;
reg [19 : 0] rxdp_fc_data_split;
reg [2 : 0] lcmfci_vcid_split;
reg [1 : 0] lcmfci_type_split;
reg [11 : 0] dllp_seqnum_split;
reg [11 : 0] tlp_seqnum_split;
reg dllp_pend_split;
reg [D_WIDTH - 1 : 0] rxtp_data_int_split;
reg rxtp_st_int_split;
reg rxtp_end_int_split;
reg [2047:0] descram_in;
wire [52:0] descram_out;

`ifdef X4

`endif


`ifdef X1

`endif

`ifdef X1

`endif

`ifdef X4

`endif


`ifdef X4

`endif

`ifdef X4

`endif


`ifdef X4

`endif

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif


`ifdef X1

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`define RXTP_MOD rxtp_x1

`endif

`ifdef X4

`define RXTP_MOD rxtp

`endif


`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif

localparam descram_inst_SIZE = 53,descram_inst_SCRAMSTRING = 32'hfdfff10b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef X4


`endif


`ifdef X1


`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef EN_VC0



`endif



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif


`ifdef X4


`endif



`ifdef X1



`define RXTP_MOD rxtp_x1



`endif



`ifdef X4



`define RXTP_MOD rxtp



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X4



`endif

// =============================================================================
// Internal Regs/Wires declarations
// =============================================================================
// From LCMFCI to TXDP


`ifdef X4


   // =============================================================================
   // Making txtp_tval & tlpgen_tval signals aligned for TDMUX
   // =============================================================================
   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n)
         tlpgen_tval_del <= 1'b0;
      else
         tlpgen_tval_del <= tlpgen_tval;
   end


`endif



// =============================================================================
// All DATA LINK layer molules.
// lcm, txtp, txdp, txdtmux, fci, rxdp, rxtp
// =============================================================================
// lcmfci
lcmfci u1_lcmfci (
   // Clock and Reset
   .sys_clk          ( sys_clk ),
   .rst_n            ( rst_n ),

   .INITFC_TIMER     ( INITFC_TIMER_split ),
   // Inputs
   .lcm_enb          ( lcm_enb_split ),
   .vc_enb           ( vc_enb_split ),
   .cfg_vcid         ( cfg_vcid_split ),

   // From PHY Layer
   .phy_ltssm_state  ( phy_ltssm_state_split ),
   .phy_link_up      ( phy_link_up_split ),

   // From RX TRNC Layer
   .trnc_st          ( trnc_st_split ),

   // From RXDP -- DLLP Receiver
   .rxdp_ifc1_val    ( rxdp_ifc1_val ),
   .rxdp_ifc2_val    ( rxdp_ifc2_val ),
   .rxdp_ufc_val     ( rxdp_ufc_val ),
   .rxdp_fcd_type    ( rxdp_fcd_type ),
   .rxdp_vcid        ( rxdp_vcid_split ),

   // From TXDP
   .txdp_rdy         ( txdp_rdy ),
   .txdp_rdy2        ( txdp_rdy2 ),
   .txdp_no_hpreq    ( txdp_no_hpreq ),
   .txdp_no_lpreq    ( txdp_no_lpreq ),

   // From RXTP block
   .rxtp_nak         ( rxtp_nak ),
   .rxtp_dupltlp     ( rxtp_dupltlp ),

   // Outputs
   .dl_inactive      ( dl_inactive ),
   .dl_init          ( dl_init ),
   .dl_active        ( dl_active ),
   .dl_up            ( dl_up ),

   // To TXDP
   .lcmfci_req       ( lcmfci_req ),
   .lcmfci_req2      ( lcmfci_req2 ),
   .lcmfci_vcid      ( lcmfci_vcid ),
   .lcmfci_init      ( lcmfci_init ),
   .lcmfci_type      ( lcmfci_type ),

   // To
   .vcneg_pend       ( vcneg_pend )
   );

// =============================================================================
// Generate "tx_dllp_pend" signal for outside ASPm implementation.
// Soop outgoing DLLP & extracrt sequence number.
// Snoop incoming TLP & extracrt sequence number.
// If these 2 seq nos are not equal, assert "tx_dllp_pend".
// =============================================================================


`ifdef X1


   always @(posedge sys_clk or negedge rst_n) begin
      if (!rst_n) begin
         tdmux_dllp_st_r1 <= 1'b0;
         tdmux_dllp_st_r2 <= 1'b0;
      end
      else begin
         tdmux_dllp_st_r1 <= tdmux_dllp_st;
         tdmux_dllp_st_r2 <= tdmux_dllp_st_r1;
      end
   end


`endif



always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      dllp_seqnum <= 12'd0;
      tlp_seqnum  <= 12'd0;
      dllp_pend   <= 1'b0;
   end
   else begin
      

`ifdef X1


         if (tdmux_dllp_st_r1 && tdmux_val)
            dllp_seqnum_tmp[3:0] <= tdmux_data[3:0];
         if (tdmux_dllp_st_r2 && tdmux_val)
            dllp_seqnum <= {dllp_seqnum_tmp[3:0], tdmux_data[15:8]};
      

`endif


      

`ifdef X4


         if (tdmux_dllp && tdmux_val)
            dllp_seqnum <= tdmux_data[35:24];
      

`endif



      tlp_seqnum   <= rxtp_seq_split;
      dllp_pend    <= ~(tlp_seqnum_split == dllp_seqnum_split);
      tx_dllp_pend <= dllp_pend_split;
   end
end

// =============================================================================

txtp #(
   .FADDR           ( FADDR ),
   .D_WIDTH         ( D_WIDTH ))
   u1_txtp (
   // Clock and Reset
   .sys_clk         ( sys_clk ),
   .rst_n           ( rst_n ),

   // Inputs
   .tlpgen_req      ( tlpgen_req_split ),
   .tlpgen_data     ( tlpgen_data_split ),
   .tlpgen_st       ( tlpgen_st_split ),
   .tlpgen_end      ( tlpgen_end_split ),
   .tlpgen_nlfy     ( tlpgen_nlfy_split ),
   .tlpgen_rdy_ack  ( tlpgen_rdy_ack_split ),
   

`ifdef X4


      .tlpgen_tval  ( tlpgen_tval ),
      .tlpgen_dwen  ( tlpgen_dwen ),
   

`endif



   .rxdp_seqnum     ( rxdp_seqnum_split ),
   .rxdp_ack        ( rxdp_ack ),
   .rxdp_rtry       ( rxdp_rtry ),
   .rxdp_purge      ( rxdp_purge ),

   .dl_inact        ( dl_inactive ),
   .dll_pause_cnt   ( dll_pause_cnt ),
   .phy_l0          ( phy_l0_split ),
   .max_pl_size     ( max_pl_size_split ),

   // Outputs
   .txtp_rdy        ( txtp_rdy ),
   .txtp_pause_ack  ( ),
   .txtp_tdata      ( txtp_tdata ),
   .txtp_erly_val   ( txtp_erly_tval ),
   .txtp_st         ( txtp_st ),
   .txtp_end        ( txtp_end ),
   .txtp_edb        ( txtp_edb ),
   

`ifdef X4


      .txtp_tval    ( txtp_tval ),
      .txtp_dwen    ( txtp_dwen ),
   

`endif



   .tx_rbuf_empty   ( tx_rbuf_empty ),
   .txtp_rtry_done  ( txtp_rtry_done ),
   .txtp_nxtseq     ( txtp_nxtseq ),
   .txtp_rply_tout  ( txtp_rply_tout ),
   .txtp_rnum_rlor  ( txtp_rnum_rlor )
   );

// txdp + tdmux
txtdp #(
   .FADDR                ( FADDR ),
   .D_WIDTH              ( D_WIDTH ))
   u1_txtdp (
   // Clock and Reset
   .sys_clk                  (sys_clk),
   .rst_n                    (rst_n),

   // Inputs
   .ACKNAK_LAT_TIME          (ACKNAK_LAT_TIME_split),
   .phy_link_up              (phy_link_up_split),
   .phy_skpq_val             (phy_skpq_val_split),
   

`ifdef X4


      .tlpgen_tval              (tlpgen_tval_del) ,
      .phy_x4_val               (phy_x4_val),
      .phy_cfgln_sum            (phy_cfgln_sum),
      .rate_5g                  (rate_5g),
      .phy_skpq_nclks           (phy_skpq_nclks),
   

`endif



   // From TL
   .trnc_pause_ack           (trnc_pause_ack_split),

   // From Flow Control - FC
   .fc_update1               (fc_update1_split),
   .fc_vcid1                 (fc_vcid1_split),
   .fc_type1                 (fc_type1_split),

   .fc_update2               (fc_update2_split),
   .fc_vcid2                 (fc_vcid2_split),
   .fc_type2                 (fc_type2_split),

   .p_infi_credit            (p_infi_credit_split),
   .np_infi_credit           (np_infi_credit_split),
   .cpl_infi_credit          (cpl_infi_credit_split),
   .cfg_vcid                 (cfg_vcid_split),


`ifdef EN_VC0


   .fc_p_0                   (fc_p_split[23:0]),
   .fc_np_0                  (fc_np_split[23:0]),
   .fc_cpl_0                 (fc_cpl_split[23:0]),


`endif




`ifdef EN_VC1


   .fc_p_1                   (fc_p_split[47:24]),
   .fc_np_1                  (fc_np_split[47:24]),
   .fc_cpl_1                 (fc_cpl_split[47:24]),


`endif




`ifdef EN_VC2


   .fc_p_2                   (fc_p_split[71:48]),
   .fc_np_2                  (fc_np_split[71:48]),
   .fc_cpl_2                 (fc_cpl_split[71:48]),


`endif




`ifdef EN_VC3


   .fc_p_3                   (fc_p_split[95:72]),
   .fc_np_3                  (fc_np_split[95:72]),
   .fc_cpl_3                 (fc_cpl_split[95:72]),


`endif




`ifdef EN_VC4


   .fc_p_4                   (fc_p_split[119:96]),
   .fc_np_4                  (fc_np_split[119:96]),
   .fc_cpl_4                 (fc_cpl_split[119:96]),


`endif




`ifdef EN_VC5


   .fc_p_5                   (fc_p_split[143:120]),
   .fc_np_5                  (fc_np_split[143:120]),
   .fc_cpl_5                 (fc_cpl_split[143:120]),


`endif




`ifdef EN_VC6


   .fc_p_6                   (fc_p_split[167:144]),
   .fc_np_6                  (fc_np_split[167:144]),
   .fc_cpl_6                 (fc_cpl_split[167:144]),


`endif




`ifdef EN_VC7


   .fc_p_7                   (fc_p_split[191:168]),
   .fc_np_7                  (fc_np_split[191:168]),
   .fc_cpl_7                 (fc_cpl_split[191:168]),


`endif



   // From Power Mgmmt - Core I/F
   .tx_pm                    (tx_pm_split),
   .tx_pmd_type              (tx_pmtype_split),
   .tx_vendor                (tx_vendor_split),
   .tx_vsd_data              (tx_vsd_data_split),

   // From RX TLP Processing Block - RXTP
   .rxtp_nak                 (rxtp_nak),
   .rxtp_dupltlp             (rxtp_dupltlp),
   .rxtp_ack                 (rxtp_ack),
   .rxtp_seq                 (rxtp_seq_split),

   // From Link Control SM & FC Init - LCMFCI
   .lcmfci_req               (lcmfci_req),
   .lcmfci_req2              (lcmfci_req2),
   .lcmfci_vcid              (lcmfci_vcid_split),
   .lcmfci_init              (lcmfci_init),
   .lcmfci_type              (lcmfci_type_split),
   .vcneg_pend               (vcneg_pend),

   // From TXTP - TLP data
   .txtp_tdata               (txtp_tdata),
   

`ifdef X1


      .txtp_erly_tval        (txtp_erly_tval),
   

`endif


   .txtp_st                  (txtp_st),
   .txtp_end                 (txtp_end),
   .txtp_edb                 (txtp_edb),
   

`ifdef X4


      .txtp_tval             (txtp_tval),
      .txtp_dwen             (txtp_dwen),
   

`endif



   // Outputs
   // To TL - Req for insertion of DLLPs/SKIPs
   .dll_pause_cnt            (dll_pause_cnt),

   // To PHY
   .tdmux_data               (tdmux_data),
   .tdmux_val                (tdmux_val),
   .tdmux_st                 (tdmux_st),
   .tdmux_end                (tdmux_end),
   .tdmux_edb                (tdmux_edb),
   .tdmux_skip               (tdmux_skip),
   

`ifdef X1


      .tdmux_dllp_st         (tdmux_dllp_st),
      .tdmux_dllp_end        (tdmux_dllp_end),
   

`endif


   

`ifdef X4


      .tdmux_dwen            (tdmux_dwen),
      .tdmux_dllp            (tdmux_dllp),
   

`endif



   // To RXFC Block
   .txdp_p_sent              (txdp_p_sent),
   .txdp_np_sent             (txdp_np_sent),
   .txdp_cpl_sent            (txdp_cpl_sent),
   .txdp_hpreq               (txdp_hpreq),
   .txdp_lpreq               (txdp_lpreq),

   // To Link Control SM & FC Init - LCMFCI
   .txdp_rdy                 (txdp_rdy),
   .txdp_rdy2                (txdp_rdy2),
   .txdp_no_hpreq            (txdp_no_hpreq),
   .txdp_no_lpreq            (txdp_no_lpreq),

   // To Power Mgmmt - Core I/F
   .txdp_pv_sent             (txdp_pv_sent)
   );

// rxdp
rxdp u1_rxdp (
   // Clock and Reset
   .sys_clk        ( sys_clk ),
   .rst_n          ( rst_n ),

   // Inputs
   

`ifdef X1


      .dfrm_dllp_data ( dfrm_dllp_data ),
      .dfrm_dllp_st   ( dfrm_dllp_st ),
   

`endif


   

`ifdef X4


      .dfrm_dllp_data  ( dfrm_ddata ),
      .dfrm_dval       ( dfrm_dval ),
   

`endif



   .txtp_nxtseq    ( txtp_nxtseq_split ),
   .txtp_rtry_done ( txtp_rtry_done ),
   .dl_inact       ( dl_inactive ),

   // Outputs
   .rxdp_fcdata    ( rxdp_fcdata ),
   .rxdp_fcd_type  ( rxdp_fcd_type ),
   .rxdp_ifc1_val  ( rxdp_ifc1_val ),
   .rxdp_ifc2_val  ( rxdp_ifc2_val ),
   .rxdp_ufc_val   ( rxdp_ufc_val ),
   .rxdp_vsd_data  ( rxdp_vsd_data ),
   .rxdp_pmd_type  ( rxdp_pmd_type ),
   .rxdp_dllp_val  ( rxdp_dllp_val ),

   .rxdp_seqnum    ( rxdp_seqnum ),
   .rxdp_ack       ( rxdp_ack ),
   .rxdp_rtry      ( rxdp_rtry ),
   .rxdp_purge     ( rxdp_purge ),

   .rxdp_bad_dllp  ( rxdp_bad_dllp ),
   .rxdp_dlerr     ( rxdp_dlerr )
   );

assign {rxdp_vcid, rxdp_fc_data} = rxdp_fcdata;



`ifdef X4


   

`endif



// rxtp


`ifdef X1


   

`define RXTP_MOD rxtp_x1




`endif




`ifdef X4


   

`define RXTP_MOD rxtp




`endif


`RXTP_MOD u1_rxtp (
   // Clock and Reset
   .sys_clk        ( sys_clk ),
   .rst_n          ( rst_n ),

   // Inputs
   .tlp_debug      ( tlp_debug ),
   .phy_l0         ( phy_l0 ),
   .dl_up          ( dl_up[0] ),

   .dfrm_tdata     ( dfrm_tdata ),
   .dfrm_tval      ( dfrm_tval ),
   .dfrm_st        ( dfrm_st ),
   .dfrm_end       ( dfrm_end ),
   .dfrm_edb       ( dfrm_edb ),
   

`ifdef X4


      .dfrm_dwen   ( dfrm_dwen ),
      .dfrm_seq    ( dfrm_seq ),
      .dfrm_lcrc   ( dfrm_lcrc ),

      .phy_x4_val  ( phy_x4_val ),
      .phy_x2_val  ( phy_x2_val ),

      .rxtp_dwen   ( rxtp_dwen_int ),
   

`endif



   // Outputs
   .rxtp_data      ( rxtp_data_int ),
   .rxtp_st        ( rxtp_st_int ),
   .rxtp_end       ( rxtp_end_int ),

   .rxtp_seq       ( rxtp_seq ),
   .rxtp_bad_tlp   ( rxtp_bad_tlp ),
   .rxtp_ack       ( rxtp_ack ),
   .rxtp_nak       ( rxtp_nak ),
   .rxtp_duptlp    ( rxtp_dupltlp )
   );
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      rx_tlp_rcvd  <= 1'b0 ;

      rxtp_data <= {D_WIDTH{1'd0}} ;
      rxtp_st   <= 1'b0 ;
      rxtp_end  <= 1'b0 ;
      

`ifdef X4


         rxtp_dwen <= 1'b0 ;
      

`endif


   end
   else begin
      rx_tlp_rcvd  <= dfrm_st_split ;

      rxtp_data <= rxtp_data_int_split ;
      rxtp_st   <= rxtp_st_int_split ;
      rxtp_end  <= rxtp_end_int_split ;
      

`ifdef X4


         rxtp_dwen <= rxtp_dwen_int ;
      

`endif


   end
end

always@* begin tlp_debug_split<=descram_out[0];INITFC_TIMER_split<={INITFC_TIMER>>1,descram_out[1]};ACKNAK_LAT_TIME_split<={ACKNAK_LAT_TIME>>1,descram_out[2]};tlpgen_req_split<=descram_out[3];tlpgen_data_split<={tlpgen_data>>1,descram_out[4]};tlpgen_st_split<=descram_out[5];tlpgen_end_split<=descram_out[6];tlpgen_nlfy_split<=descram_out[7];tlpgen_rdy_ack_split<=descram_out[8];fc_update1_split<=descram_out[9];fc_vcid1_split<={fc_vcid1>>1,descram_out[10]};fc_type1_split<={fc_type1>>1,descram_out[11]};fc_update2_split<=descram_out[12];fc_vcid2_split<={fc_vcid2>>1,descram_out[13]};fc_type2_split<={fc_type2>>1,descram_out[14]};p_infi_credit_split<={p_infi_credit>>1,descram_out[15]};np_infi_credit_split<={np_infi_credit>>1,descram_out[16]};cpl_infi_credit_split<={cpl_infi_credit>>1,descram_out[17]};fc_p_split<={fc_p>>1,descram_out[18]};fc_np_split<={fc_np>>1,descram_out[19]};fc_cpl_split<={fc_cpl>>1,descram_out[20]};tx_pm_split<=descram_out[21];tx_pmtype_split<={tx_pmtype>>1,descram_out[22]};tx_vendor_split<=descram_out[23];tx_vsd_data_split<={tx_vsd_data>>1,descram_out[24]};dfrm_tdata_split<={dfrm_tdata>>1,descram_out[25]};dfrm_tval_split<=descram_out[26];dfrm_st_split<=descram_out[27];dfrm_end_split<=descram_out[28];dfrm_edb_split<=descram_out[29];phy_ltssm_state_split<={phy_ltssm_state>>1,descram_out[30]};phy_link_up_split<=descram_out[31];phy_l0_split<=descram_out[32];vc_enb_split<={vc_enb>>1,descram_out[33]};cfg_vcid_split<={cfg_vcid>>1,descram_out[34]};lcm_enb_split<=descram_out[35];max_pl_size_split<={max_pl_size>>1,descram_out[36]};trnc_pause_ack_split<=descram_out[37];trnc_st_split<={trnc_st>>1,descram_out[38]};phy_skpq_val_split<=descram_out[39];rxdp_seqnum_split<={rxdp_seqnum>>1,descram_out[40]};rxtp_seq_split<={rxtp_seq>>1,descram_out[41]};txtp_nxtseq_split<={txtp_nxtseq>>1,descram_out[42]};rxdp_vcid_split<={rxdp_vcid>>1,descram_out[43]};rxdp_fc_data_split<={rxdp_fc_data>>1,descram_out[44]};lcmfci_vcid_split<={lcmfci_vcid>>1,descram_out[45]};lcmfci_type_split<={lcmfci_type>>1,descram_out[46]};dllp_seqnum_split<={dllp_seqnum>>1,descram_out[47]};tlp_seqnum_split<={tlp_seqnum>>1,descram_out[48]};dllp_pend_split<=descram_out[49];rxtp_data_int_split<={rxtp_data_int>>1,descram_out[50]};rxtp_st_int_split<=descram_out[51];rxtp_end_int_split<=descram_out[52];end
always@* begin descram_in[2047]<=INITFC_TIMER[0];descram_in[2046]<=ACKNAK_LAT_TIME[0];descram_in[2044]<=tlpgen_req;descram_in[2040]<=tlpgen_data[0];descram_in[2032]<=tlpgen_st;descram_in[2016]<=tlpgen_end;descram_in[1985]<=tlpgen_nlfy;descram_in[1950]<=cpl_infi_credit[0];descram_in[1930]<=tx_vendor;descram_in[1923]<=tlpgen_rdy_ack;descram_in[1852]<=fc_p[0];descram_in[1813]<=tx_vsd_data[0];descram_in[1799]<=fc_update1;descram_in[1656]<=fc_np[0];descram_in[1578]<=dfrm_tdata[0];descram_in[1551]<=fc_vcid1[0];descram_in[1353]<=rxdp_seqnum[0];descram_in[1345]<=phy_ltssm_state[0];descram_in[1316]<=txtp_nxtseq[0];descram_in[1285]<=phy_l0;descram_in[1265]<=fc_cpl[0];descram_in[1169]<=rxdp_fc_data[0];descram_in[1163]<=dllp_seqnum[0];descram_in[1117]<=rxtp_data_int[0];descram_in[1108]<=dfrm_tval;descram_in[1054]<=fc_type1[0];descram_in[1045]<=cfg_vcid[0];descram_in[1023]<=tlp_debug;descram_in[975]<=np_infi_credit[0];descram_in[965]<=tx_pmtype[0];descram_in[676]<=phy_skpq_val;descram_in[672]<=dfrm_edb;descram_in[658]<=rxtp_seq[0];descram_in[642]<=phy_link_up;descram_in[584]<=rxdp_vcid[0];descram_in[581]<=lcmfci_type[0];descram_in[558]<=dllp_pend;descram_in[522]<=vc_enb[0];descram_in[487]<=p_infi_credit[0];descram_in[482]<=tx_pm;descram_in[373]<=rxtp_end_int;descram_in[338]<=trnc_st[0];descram_in[336]<=dfrm_end;descram_in[290]<=lcmfci_vcid[0];descram_in[279]<=tlp_seqnum[0];descram_in[243]<=fc_type2[0];descram_in[186]<=rxtp_st_int;descram_in[169]<=trnc_pause_ack;descram_in[168]<=dfrm_st;descram_in[121]<=fc_vcid2[0];descram_in[84]<=max_pl_size[0];descram_in[60]<=fc_update2;descram_in[42]<=lcm_enb;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// Revision 1.14 2007/02/01 17:31:55PST rperugu


// dfrm_lcrc & dfrm_seq are separated from data & given to rxtp


// Revision 1.13 2007/01/09 14:51:51PST rperugu


// 1) txtp_tval & tlpgen_tval signals aligned for TDMUX


//    So, added tlpgen_tval_del


// 2) phy_x4_val is added to rxtp for downgrade.


// Revision 1.12 2006/08/10 12:06:10PDT uananthi


// synthesis warnings corrected.


// Revision 1.11 2006/07/17 17:20:39PDT rperugu


// Changed ACKNAK_LAT_TIMER width from 10 to 14 (consistent with X1).


// Revision 1.10 2006/06/16 12:14:31PDT rperugu


// dfrm_perr is removed.


// Revision 1.9 2006/06/15 14:48:05PDT rperugu


//


// Revision 1.8 2006/06/09 11:42:18PDT uananthi


// dl_up conected to rxtp


// Revision 1.7 2006/06/09 09:51:29PDT uananthi


// removed hard coded lcmfci connections.


// Revision 1.6 2006/06/08 16:34:34PDT rperugu


//


// Revision 1.5 2006/06/07 18:53:55PDT rperugu


// Added txtdp & lcmfci.


// Revision 1.4 2006/06/02 13:29:07PDT uananthi


//


// Revision 1.3 2006/05/31 17:39:44PDT uananthi


//


// Revision 1.2 2006/05/30 14:30:43PDT uananthi


// first X4 version for ECP2M


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_x4


// File             : trnc.v


// Title            :


// Dependencies     : All blocks of transaction layer


// Description      : This is top level module for common logic of


//                    transaction layer


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh Ananthiah, Rajakumar Perugu, Gopi


// Mod. Date        : Mar 29, 2004


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module trnc #(
   parameter FADDR    = 6,
   parameter D_WIDTH  = 64 )
   (
   
   input wire                sys_clk ,         
   input wire                rst_n ,           
   input wire                rst_n_main ,      
   input wire                rate_5g ,         

   
   
   input wire [31:0]         INIT_REG_000 ,
   input wire [31:0]         INIT_REG_008 ,
   input wire [31:0]         INIT_REG_00C ,
   input wire [31:0]         INIT_REG_010 ,
   input wire [31:0]         INIT_REG_014 ,
   input wire [31:0]         INIT_REG_018 ,
   input wire [31:0]         INIT_REG_01C ,
   input wire [31:0]         INIT_REG_020 ,
   input wire [31:0]         INIT_REG_024 ,
   input wire [31:0]         INIT_REG_028 ,
   input wire [31:0]         INIT_REG_02C ,
   input wire [31:0]         INIT_REG_030 ,
   input wire [31:0]         INIT_REG_03C ,
   input wire                load_id ,            
   
   input wire [31:0]         INIT_REG_050 ,
   input wire [31:0]         INIT_REG_054 ,
   input wire [9:0]          INIT_PM_DS_DATA_0 ,  
   input wire [9:0]          INIT_PM_DS_DATA_1 ,  
   input wire [9:0]          INIT_PM_DS_DATA_2 ,  
   input wire [9:0]          INIT_PM_DS_DATA_3 ,  
   input wire [9:0]          INIT_PM_DS_DATA_4 ,  
   input wire [9:0]          INIT_PM_DS_DATA_5 ,  
   input wire [9:0]          INIT_PM_DS_DATA_6 ,  
   input wire [9:0]          INIT_PM_DS_DATA_7 ,  

   
   input wire [31:0]         INIT_REG_070 ,
   
   input wire [31:0]         INIT_REG_090 ,
   input wire [31:0]         INIT_REG_094 ,
   input wire [31:0]         INIT_REG_09C ,
   input wire [31:0]         INIT_REG_0A0 ,
   `ifdef GEN2
      input wire [31:0]      INIT_REG_0B4 ,
   `endif
   
   input wire [31:0]         INIT_REG_104 ,
   input wire [31:0]         INIT_REG_108 ,

   
   `ifdef CFG_VCC
      input wire [31:0]      INIT_REG_10C ,
   `endif

   input wire [(8*`NUM_VC)-1:0]    INIT_PH_FC,      
   input wire [(8*`NUM_VC)-1:0]    INIT_NPH_FC,     
   input wire [(12*`NUM_VC)-1:0]   INIT_PD_FC,      
   input wire [(12*`NUM_VC)-1:0]   INIT_NPD_FC,     
   input wire [6:0]                UPDATE_FREQ_PH,  
   input wire [10:0]               UPDATE_FREQ_PD,  
   input wire [6:0]                UPDATE_FREQ_NPH, 
   input wire [10:0]               UPDATE_FREQ_NPD, 
   input wire [11:0]               UPDATE_TIMER,    
   input wire                      tlp_debug ,      

   input wire                      inta_n,          
   input wire [7:0]                msi,             
   input wire [2:0]                msi_tc,          
   input wire [`NUM_VC-1:0]        tx_req,          
   input wire [(`NUM_VC*D_WIDTH) -1:0]  tx_data,         
   input wire [`NUM_VC-1:0]        tx_st,           
   input wire [`NUM_VC-1:0]        tx_end,          
   input wire [`NUM_VC-1:0]        tx_nlfy,         
   `ifdef X4
      input wire [`NUM_VC-1:0]     tx_dwen,         
      input wire                   rxtp_dwen ,      
      input wire                   force_x2_cfg,
      input wire                   force_x1_cfg,
   `endif
   
   input wire                      phy_link_up,
   input wire                      lnk_train_err ,
   input wire                      lnk_train_status ,
   input wire [2:0]                lnk_width ,
   input wire [2:0]                phy_cfgln_sum,   
   `ifdef GEN2
      input wire [1:0]             phy_lnk_spd,     
      input wire                   phy_lnk_demp ,    
   `endif
   input wire                      dfrm_perr ,
   input wire [FADDR:0]            dll_pause_cnt,   
   input wire                      txtp_rdy ,       
   input wire [D_WIDTH-1:0]        rxtp_data ,      
   input wire                      rxtp_st ,        
   input wire                      rxtp_end ,       
   input wire                      rxtp_bad_tlp,    
   input wire                      rxdp_bad_dllp,   
   input wire                      rxdp_dlerr,      
   input wire                      txtp_rnum_rlor,  
   input wire                      txtp_rply_tout , 
   input wire                      rxdp_ifc1_val,   
   input wire                      rxdp_ifc2_val,   
   input wire                      rxdp_ufc_val,    
   input wire [1:0]                rxdp_fcd_type,   
   input wire [2:0]                rxdp_fcd_vcid,   
   input wire [19:0]               rxdp_fcd_data,   
   input wire [`NUM_VC-1:0]        dl_up ,
   input wire                      dl_active,
   input wire                      dl_inactive,
   input wire [`NUM_VC -1:0]       vcneg_pend ,     
   input wire                      phy_l0_l0s,      
   input wire                      txdp_hpreq,
   input wire                      txdp_lpreq,
   input wire [`NUM_VC-1:0]        txdp_p_sent,
   input wire [`NUM_VC-1:0]        txdp_np_sent,
   input wire [`NUM_VC-1:0]        txdp_cpl_sent,
   input wire [`NUM_VC-1:0]        ph_buf_status,   
   input wire [`NUM_VC-1:0]        pd_buf_status,   
   input wire [`NUM_VC-1:0]        nph_buf_status,  
   input wire [`NUM_VC-1:0]        npd_buf_status,  
   input wire [`NUM_VC-1:0]        ph_processed,    
   input wire [`NUM_VC-1:0]        pd_processed,    
   input wire [`NUM_VC-1:0]        nph_processed,   
   input wire [`NUM_VC-1:0]        npd_processed,   

   input wire [(8*`NUM_VC)-1:0]    pd_num,          
   input wire [(8*`NUM_VC)-1:0]    npd_num,         

   `ifdef ECRC
      `ifdef AER
         output wire               ecrc_gen_enb ,
         output wire               ecrc_chk_enb ,
      `else
         input wire                ecrc_gen_enb ,
         input wire                ecrc_chk_enb ,
      `endif
   `endif

   
   `ifdef AER
      input wire [127:0]           err_tlp_header , 
                                                    
   `endif
   input wire                      cmpln_tout ,     
   input wire                      cmpltr_abort_np ,
   input wire                      cmpltr_abort_p , 
   input wire                      unexp_cmpln ,    
   input wire                      ur_np_ext ,      
   input wire                      ur_p_ext ,       
   input wire                      np_req_pend ,    
   input wire                      pme_status ,     
   input wire                      term_all_cfg,
   input wire                      ptc_err_enable,
   `ifdef GEN2
      input wire                   flr_rdy_in ,     
   `endif

   
   input wire [11:0]               ADR_I ,    
   input wire [31:0]               DAT_I ,    
   input wire                      WE_I ,     
   input wire                      STB_I ,    

   
   output wire [31:0]              RDAT_O ,   
   output wire                     ACK_O ,    
   output wire                     tlpgen_req ,
   output wire [D_WIDTH-1:0]       tlpgen_data ,
   output wire                     tlpgen_st ,
   output wire                     tlpgen_end ,
   output wire                     tlpgen_nlfy ,
   output wire                     tlpgen_rdy_ack ,
   output wire                     trnc_pause_ack ,
   output wire [`NUM_VC-1:0]       tx_rdy,
   output wire [(`NUM_VC*9)-1:0]   tx_ca_ph,
   output wire [(`NUM_VC*13)-1:0]  tx_ca_pd,
   output wire [(`NUM_VC*9)-1:0]   tx_ca_nph,
   output wire [(`NUM_VC*13)-1:0]  tx_ca_npd,
   output wire [(`NUM_VC*9)-1:0]   tx_ca_cplh,
   output wire [(`NUM_VC*13)-1:0]  tx_ca_cpld,
   output reg                      tx_ca_p_recheck,
   output reg                      tx_ca_cpl_recheck,
   output wire [(`NUM_VC*D_WIDTH)-1:0]  rx_data ,
   output wire [`NUM_VC-1:0]       rx_st ,
   output wire [`NUM_VC-1:0]       rx_end ,
   `ifdef ECRC
      output wire [`NUM_VC-1:0]    rx_ecrc_err ,
   `endif
   output wire [`NUM_VC-1:0]       rx_us_req ,
   output wire [`NUM_VC-1:0]       rx_malf_tlp ,
   output wire [6:0]               rx_bar_hit ,      
   `ifdef X4
      output wire                  tlpgen_tval ,
      output wire                  tlpgen_dwen ,
      output wire                  tx_val,
      output wire [`NUM_VC-1:0]    rx_dwen ,
   `endif
   
   output wire [7:0]               bus_num ,         
   output wire [4:0]               dev_num ,         
   output wire [2:0]               func_num ,        
   output wire [1:0]               pm_power_state ,  
   output wire                     pme_en ,          
   output wire [2:0]               mm_enable ,       
   output wire                     msi_enable ,      
   output wire [31:0]              mes_laddr ,       
   output wire [31:0]              mes_uaddr ,       
   output wire [15:0]              mes_data ,        
   output wire [5:0]               cmd_reg_out ,     
   output wire [14:0]              dev_cntl_out ,    
   output wire [7:0]               lnk_cntl_out ,    
   output wire                     ftl_err_out ,     
   output wire                     nftl_err_out ,    
   output wire                     cor_err_out ,     
   `ifdef GEN2
      output wire  [4:0]           dev_cntl_2_out ,  
      output reg                   initiate_flr ,    
      output wire [3:0]            cs_target_lnk_spd ,
      output wire                  cs_enter_compliance ,
      output wire                  cs_hasd ,
      output wire                  cs_tx_demphasis ,
      output wire [2:0]            cs_tx_margin ,
      output wire                  cs_enter_mod_comp ,
      output wire                  cs_comp_sos ,
      output wire                  cs_comp_demp ,

   `endif

   output wire [2:0]               max_pl_size ,     
   output wire                     ext_sync ,        
   output wire                     link_disable ,    
   output wire                     retrain_lnk ,     
   output wire [2:0]               cfgcs_losel ,     

   output wire [`NUM_VC -1:0]      vc_en ,
   output wire [(`NUM_VC*3)-1:0]   cfg_vcid,
   output wire [(`NUM_VC*8)-1:0]   cfg_tcvc_map,

   output wire [`NUM_VC -1:0]      trnc_st,
   output wire                     fc_update1,
   output wire [2:0]               fc_vcid1,
   output wire [1:0]               fc_type1,
   output wire                     fc_update2,
   output wire [2:0]               fc_vcid2,
   output wire [1:0]               fc_type2,
   output wire [`NUM_VC -1:0]      p_infi_credit,
   output wire [`NUM_VC -1:0]      np_infi_credit,
   output wire [`NUM_VC -1:0]      cpl_infi_credit,

   output wire [(24*`NUM_VC)-1:0]  fc_p,
   output wire [(24*`NUM_VC)-1:0]  fc_np,
   output wire [(24*`NUM_VC)-1:0]  fc_cpl
   ) ;
wire [D_WIDTH -1:0]         tlpdec_data ;
wire [2:0]                  tlpdec_tc ;
wire [(`NUM_VC*8)-1:0]      cfgec_tvmap ;
wire [2:0]                  cfgec_vcid_0 ;
wire [2:0]                  cfgec_vcid_1 ;
wire [2:0]                  cfgec_vcid_2 ;
wire [2:0]                  cfgec_vcid_3 ;
wire [2:0]                  cfgec_vcid_4 ;
wire [2:0]                  cfgec_vcid_5 ;
wire [2:0]                  cfgec_vcid_6 ;
wire [2:0]                  cfgec_vcid_7 ;
wire [2:0]                  cfgec_vcasel ;
wire [D_WIDTH -1:0]         txintf_data;
wire [D_WIDTH -1:0]         cfg_rmux_data ;
wire [31:0]                 bar0_reg ;
wire [31:0]                 bar0_init ;
wire [31:0]                 bar1_reg ;
wire [31:0]                 bar1_init ;
wire [31:0]                 bar2_reg ;
wire [31:0]                 bar2_init ;
wire [31:0]                 bar3_reg ;
wire [31:0]                 bar3_init ;
wire [31:0]                 bar4_reg ;
wire [31:0]                 bar4_init ;
wire [31:0]                 bar5_reg ;
wire [31:0]                 bar5_init ;
wire [31:0]                 er_bar_reg ;
wire [31:0]                 er_bar_init ;
wire [31:0]                 tlpdec_addr_l32 ;
wire [31:0]                 tlpdec_addr_h32 ;
wire [D_WIDTH-1:0]          rxtp_data_r2 ;
wire [6:0]                  bar_hit ;
wire                        nph_processed_cfg ;
wire                        npd_processed_cfg ;
wire [15:0]                 sts_reg_in ;
wire [(`NUM_VC*D_WIDTH)-1:0] irx_data ;
wire [`NUM_VC -1:0]         irx_st ;
wire [`NUM_VC -1:0]         irx_end ;

`ifdef ECRC
wire [`NUM_VC -1:0]      irx_ecrc_err ;

`endif
wire [`NUM_VC -1:0]         irx_us_req ;
wire [`NUM_VC -1:0]         irx_malf_tlp ;
wire                        tlpdec_cfgrd ;
wire                        cfg_rmux_rd;
wire                        cfg_resp_req;
wire                        cfg_resp_rd;
wire                        cfg_rmux_end;
wire                        cfg_hit;
wire                        cfg_resp_ae;
wire  [D_WIDTH-1:0]         cfg_resp_data;
wire                        int_msg_rd;
wire                        err_msg_rd;
wire                        int_msg_req;
wire  [D_WIDTH-1:0]         int_msg_data;
wire                        int_msg_ae;
wire                        int_pending;
wire                        int_disable ;
wire                        err_msg_req;
wire  [D_WIDTH-1:0]         err_msg_data;
wire                        err_msg_ae;
reg                         arb_enable;
reg                         arb_enable2;
reg [1:0]                   arb_sm;
reg                         cfg_rmux_req;
reg                         dl_up_reg;
reg                         rchk_credit_p_del1     /* synthesis syn_srlstyle="registers" */;
reg                         rchk_credit_cpl_del1   /* synthesis syn_srlstyle="registers" */;
reg                         rchk_credit_p_del2     /* synthesis syn_srlstyle="registers" */;
reg                         rchk_credit_cpl_del2   /* synthesis syn_srlstyle="registers" */;
wire                        lcmfci_fcp_err ;
wire                        surp_down_err ;
wire                        f_nf_emsg_sent;
wire                        rchk_credit_p;
wire                        rchk_credit_cpl;
wire                        tlpdec_rvcd_sts_ur;
wire                        tlpdec_rvcd_sts_ca;
wire                        pois_tlp_sent ;
wire                        sts_ca_sent ;
wire                        txintf_end ;
wire                        txintf_nlfy ;
wire    [`NUM_VC-1:0]       vc_rcvd;
wire                        ph_rcvd;
wire                        pd_rcvd;
wire                        nph_rcvd;
wire                        npd_rcvd;
wire   [8:0]                credits_rcvd;
wire                        malf_pkt_ph;
wire                        malf_pkt_pd;
wire                        malf_pkt_nph;
wire                        malf_pkt_npd;
wire                        fc_overflow;

`ifdef X4
wire                     tlp_erly_st ;
wire [`NUM_VC -1:0]      irx_dwen ;
wire                     cfg_resp_dwen;
wire                     int_msg_dwen;
wire                     err_msg_dwen;
wire                     txintf_dwen;
reg                      txintf_dwen_reg ;

`endif
localparam ARB_IDLE     = 2'b00;
localparam ARB_CFG_WAIT = 2'b01;
localparam ARB_INT_WAIT = 2'b10;

`ifdef GEN2
reg [2:0] cs_flr ;
reg       flr ;
reg       int_dsb_flr ;
reg       drop_resp ;
wire      initiate_flr_int ;
localparam WAIT_FLR = 3'd0 ;
localparam RESP_1   = 3'd1 ;
localparam RESP_2   = 3'd2 ;
localparam RESP_3   = 3'd3 ;
localparam RESP_4   = 3'd4 ;
localparam CHK_IQ   = 3'd5 ;
localparam RDY      = 3'd6 ;
localparam FLR      = 3'd7 ;

`endif

`ifdef X4

`define INTMSG_DEF int_msg

`define TXINTF_DEF txintf

`define TLPGEN_DEF tlpgen

`define TLPDEC_DEF tlpdec

`define RXINTF_DEF rxintf

`endif

`ifdef X1

`define INTMSG_DEF int_msg_x1

`define TXINTF_DEF txintf_x1

`define TLPGEN_DEF tlpgen_x1

`define TLPDEC_DEF tlpdec_x1

`define RXINTF_DEF rxintf_x1

`endif

`ifdef X4

`endif

`ifdef GEN2

`else

`endif

`ifdef CFG_REG

`ifdef ECRC

`endif

`ifdef X4

`endif

`else

`endif

`ifdef X4

`endif

`ifdef CFG_REG

`ifdef X4

`endif

`endif

`ifdef ECRC

`endif

`ifdef CFG_REG

`endif

`ifdef X4

`endif
reg txintf_end_reg ;
reg txintf_nlfy_reg ;

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif
wire txintf_end_p  = txintf_end & ~txintf_end_reg ;
wire txintf_nlfy_p = txintf_nlfy & ~txintf_nlfy_reg ;

`ifdef X4
wire txintf_dwen_p = txintf_dwen & ~txintf_dwen_reg;

`endif

`ifdef X4

`endif

`ifdef ECRC

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef ECRC

`endif

`ifdef X4

`endif

`ifdef ECRC

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef AER

`endif

`ifdef AER

`endif

`ifdef CFG_REG

`ifdef EN_BAR0

`endif

`ifdef EN_BAR1

`endif

`ifdef EN_BAR2

`endif

`ifdef EN_BAR3

`endif

`ifdef EN_BAR4

`endif

`ifdef EN_BAR5

`endif

`ifdef EN_ER_BAR

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`else

`endif

`ifdef ECRC

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef ECRC

`endif

`ifdef X4

`endif

`ifdef ECRC

`endif

`ifdef VC1

`else

`ifdef X4

`endif

`ifdef ECRC

`endif

`endif

`ifdef X1
reg txintf_st_reg1 ;
reg txintf_st_reg2 ;
reg txintf_st_reg3 ;
reg tx_cpl_dec ;

`endif

`ifdef X4

`endif

`ifdef ENDPOINT_COMP

`else

`endif

`ifdef CFG_REG

`ifdef GEN2

`endif

`ifdef CFG_VCC

`endif

`ifdef GEN2

`else

`endif

`ifdef CFG_VCC

`endif

`ifdef ECRC

`endif

`ifdef AER

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef GEN2

`endif

`ifdef ECRC

`else

`endif

`ifdef GEN2

`endif

`ifdef CFG_VCC

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef EN_VC0

`ifdef CFG_VCC

`else

`endif

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`else

`ifdef GEN2

`endif

`endif

`ifdef GEN2

`ifdef X4

`endif

`ifdef X1

`endif

`endif

`ifdef DEBUG
wire        tx_rdy_0, tx_rdy_1, tx_rdy_2, tx_rdy_3, tx_rdy_4, tx_rdy_5, tx_rdy_6, tx_rdy_7;
wire        tx_req_0,  tx_req_1,  tx_req_2,  tx_req_3,  tx_req_4,  tx_req_5,  tx_req_6,  tx_req_7;
wire [D_WIDTH-1:0] tx_data_0, tx_data_1, tx_data_2, tx_data_3, tx_data_4, tx_data_5, tx_data_6, tx_data_7;
wire        tx_st_0,   tx_st_1,   tx_st_2,   tx_st_3,   tx_st_4,   tx_st_5,   tx_st_6,   tx_st_7;
wire        tx_end_0,  tx_end_1,  tx_end_2,  tx_end_3,  tx_end_4,  tx_end_5,  tx_end_6,  tx_end_7;
wire        tx_nlfy_0, tx_nlfy_1, tx_nlfy_2, tx_nlfy_3, tx_nlfy_4, tx_nlfy_5, tx_nlfy_6, tx_nlfy_7;
wire [D_WIDTH-1:0] rx_data_0, rx_data_1, rx_data_2, rx_data_3, rx_data_4, rx_data_5, rx_data_6, rx_data_7;
wire        rx_st_0,   rx_st_1,   rx_st_2,   rx_st_3,   rx_st_4,   rx_st_5,   rx_st_6,   rx_st_7;
wire        rx_end_0,  rx_end_1,  rx_end_2,  rx_end_3,  rx_end_4,  rx_end_5,  rx_end_6,  rx_end_7;

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef X4
wire     tx_dwen_0, tx_dwen_1, tx_dwen_2, tx_dwen_3, tx_dwen_4, tx_dwen_5, tx_dwen_6, tx_dwen_7;
wire     rx_dwen_0, rx_dwen_1, rx_dwen_2, rx_dwen_3, rx_dwen_4, rx_dwen_5, rx_dwen_6, rx_dwen_7;

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`endif

`endif  //End of DEBUG
reg rst_n_main_split;
reg rate_5g_split;
reg [31 : 0] INIT_REG_000_split;
reg [31 : 0] INIT_REG_008_split;
reg [31 : 0] INIT_REG_00C_split;
reg [31 : 0] INIT_REG_010_split;
reg [31 : 0] INIT_REG_014_split;
reg [31 : 0] INIT_REG_018_split;
reg [31 : 0] INIT_REG_01C_split;
reg [31 : 0] INIT_REG_020_split;
reg [31 : 0] INIT_REG_024_split;
reg [31 : 0] INIT_REG_028_split;
reg [31 : 0] INIT_REG_02C_split;
reg [31 : 0] INIT_REG_030_split;
reg [31 : 0] INIT_REG_03C_split;
reg load_id_split;
reg [31 : 0] INIT_REG_050_split;
reg [31 : 0] INIT_REG_054_split;
reg [9 : 0] INIT_PM_DS_DATA_0_split;
reg [9 : 0] INIT_PM_DS_DATA_1_split;
reg [9 : 0] INIT_PM_DS_DATA_2_split;
reg [9 : 0] INIT_PM_DS_DATA_3_split;
reg [9 : 0] INIT_PM_DS_DATA_4_split;
reg [9 : 0] INIT_PM_DS_DATA_5_split;
reg [9 : 0] INIT_PM_DS_DATA_6_split;
reg [9 : 0] INIT_PM_DS_DATA_7_split;
reg [31 : 0] INIT_REG_070_split;
reg [31 : 0] INIT_REG_090_split;
reg [31 : 0] INIT_REG_094_split;
reg [31 : 0] INIT_REG_09C_split;
reg [31 : 0] INIT_REG_0A0_split;
reg [31 : 0] INIT_REG_104_split;
reg [31 : 0] INIT_REG_108_split;
reg [(8 * `NUM_VC) - 1 : 0] INIT_PH_FC_split;
reg [(8 * `NUM_VC) - 1 : 0] INIT_NPH_FC_split;
reg [(12 * `NUM_VC) - 1 : 0] INIT_PD_FC_split;
reg [(12 * `NUM_VC) - 1 : 0] INIT_NPD_FC_split;
reg [6 : 0] UPDATE_FREQ_PH_split;
reg [10 : 0] UPDATE_FREQ_PD_split;
reg [6 : 0] UPDATE_FREQ_NPH_split;
reg [10 : 0] UPDATE_FREQ_NPD_split;
reg [11 : 0] UPDATE_TIMER_split;
reg tlp_debug_split;
reg inta_n_split;
reg [7 : 0] msi_split;
reg [2 : 0] msi_tc_split;
reg [`NUM_VC - 1 : 0] tx_req_split;
reg [(`NUM_VC * D_WIDTH) - 1 : 0] tx_data_split;
reg [`NUM_VC - 1 : 0] tx_st_split;
reg [`NUM_VC - 1 : 0] tx_end_split;
reg [`NUM_VC - 1 : 0] tx_nlfy_split;
reg phy_link_up_split;
reg lnk_train_err_split;
reg lnk_train_status_split;
reg [2 : 0] lnk_width_split;
reg [2 : 0] phy_cfgln_sum_split;
reg dfrm_perr_split;
reg [FADDR : 0] dll_pause_cnt_split;
reg txtp_rdy_split;
reg [D_WIDTH - 1 : 0] rxtp_data_split;
reg rxtp_st_split;
reg rxtp_end_split;
reg rxtp_bad_tlp_split;
reg rxdp_bad_dllp_split;
reg rxdp_dlerr_split;
reg txtp_rnum_rlor_split;
reg txtp_rply_tout_split;
reg rxdp_ifc1_val_split;
reg rxdp_ifc2_val_split;
reg rxdp_ufc_val_split;
reg [1 : 0] rxdp_fcd_type_split;
reg [2 : 0] rxdp_fcd_vcid_split;
reg [19 : 0] rxdp_fcd_data_split;
reg [`NUM_VC - 1 : 0] dl_up_split;
reg dl_active_split;
reg dl_inactive_split;
reg [`NUM_VC - 1 : 0] vcneg_pend_split;
reg phy_l0_l0s_split;
reg txdp_hpreq_split;
reg txdp_lpreq_split;
reg [`NUM_VC - 1 : 0] txdp_p_sent_split;
reg [`NUM_VC - 1 : 0] txdp_np_sent_split;
reg [`NUM_VC - 1 : 0] txdp_cpl_sent_split;
reg [`NUM_VC - 1 : 0] ph_buf_status_split;
reg [`NUM_VC - 1 : 0] pd_buf_status_split;
reg [`NUM_VC - 1 : 0] nph_buf_status_split;
reg [`NUM_VC - 1 : 0] npd_buf_status_split;
reg [`NUM_VC - 1 : 0] ph_processed_split;
reg [`NUM_VC - 1 : 0] pd_processed_split;
reg [`NUM_VC - 1 : 0] nph_processed_split;
reg [`NUM_VC - 1 : 0] npd_processed_split;
reg [(8 * `NUM_VC) - 1 : 0] pd_num_split;
reg [(8 * `NUM_VC) - 1 : 0] npd_num_split;
reg cmpln_tout_split;
reg cmpltr_abort_np_split;
reg cmpltr_abort_p_split;
reg unexp_cmpln_split;
reg ur_np_ext_split;
reg ur_p_ext_split;
reg np_req_pend_split;
reg pme_status_split;
reg term_all_cfg_split;
reg ptc_err_enable_split;
reg [11 : 0] ADR_I_split;
reg [31 : 0] DAT_I_split;
reg WE_I_split;
reg STB_I_split;
reg [2 : 0] tlpdec_tc_split;
reg [(`NUM_VC * 8) - 1 : 0] cfgec_tvmap_split;
reg [2 : 0] cfgec_vcid_0_split;
reg [2 : 0] cfgec_vcid_1_split;
reg [2 : 0] cfgec_vcid_2_split;
reg [2 : 0] cfgec_vcid_3_split;
reg [2 : 0] cfgec_vcid_4_split;
reg [2 : 0] cfgec_vcid_5_split;
reg [2 : 0] cfgec_vcid_6_split;
reg [2 : 0] cfgec_vcid_7_split;
reg [2 : 0] cfgec_vcasel_split;
reg [D_WIDTH - 1 : 0] txintf_data_split;
reg [D_WIDTH - 1 : 0] cfg_rmux_data_split;
reg [31 : 0] bar0_reg_split;
reg [31 : 0] bar0_init_split;
reg [31 : 0] bar1_reg_split;
reg [31 : 0] bar1_init_split;
reg [31 : 0] bar2_reg_split;
reg [31 : 0] bar2_init_split;
reg [31 : 0] bar3_reg_split;
reg [31 : 0] bar3_init_split;
reg [31 : 0] bar4_reg_split;
reg [31 : 0] bar4_init_split;
reg [31 : 0] bar5_reg_split;
reg [31 : 0] bar5_init_split;
reg [31 : 0] er_bar_reg_split;
reg [31 : 0] er_bar_init_split;
reg [31 : 0] tlpdec_addr_l32_split;
reg [31 : 0] tlpdec_addr_h32_split;
reg [D_WIDTH - 1 : 0] rxtp_data_r2_split;
reg [6 : 0] bar_hit_split;
reg nph_processed_cfg_split;
reg npd_processed_cfg_split;
reg [15 : 0] sts_reg_in_split;
reg [(`NUM_VC * D_WIDTH) - 1 : 0] irx_data_split;
reg [`NUM_VC - 1 : 0] irx_st_split;
reg [`NUM_VC - 1 : 0] irx_end_split;
reg [`NUM_VC - 1 : 0] irx_us_req_split;
reg [`NUM_VC - 1 : 0] irx_malf_tlp_split;
reg tlpdec_cfgrd_split;
reg cfg_rmux_rd_split;
reg cfg_resp_req_split;
reg cfg_resp_rd_split;
reg cfg_rmux_end_split;
reg cfg_hit_split;
reg cfg_resp_ae_split;
reg [D_WIDTH - 1 : 0] cfg_resp_data_split;
reg int_msg_rd_split;
reg err_msg_rd_split;
reg int_msg_req_split;
reg [D_WIDTH - 1 : 0] int_msg_data_split;
reg int_msg_ae_split;
reg int_pending_split;
reg int_disable_split;
reg err_msg_req_split;
reg [D_WIDTH - 1 : 0] err_msg_data_split;
reg err_msg_ae_split;
reg arb_enable_split;
reg arb_enable2_split;
reg [1 : 0] arb_sm_split;
reg cfg_rmux_req_split;
reg dl_up_reg_split;
reg rchk_credit_p_del1_split;
reg rchk_credit_cpl_del1_split;
reg rchk_credit_p_del2_split;
reg rchk_credit_cpl_del2_split;
reg lcmfci_fcp_err_split;
reg surp_down_err_split;
reg f_nf_emsg_sent_split;
reg rchk_credit_p_split;
reg rchk_credit_cpl_split;
reg tlpdec_rvcd_sts_ur_split;
reg tlpdec_rvcd_sts_ca_split;
reg pois_tlp_sent_split;
reg sts_ca_sent_split;
reg txintf_end_split;
reg txintf_nlfy_split;
reg [`NUM_VC - 1 : 0] vc_rcvd_split;
reg ph_rcvd_split;
reg pd_rcvd_split;
reg nph_rcvd_split;
reg npd_rcvd_split;
reg [8 : 0] credits_rcvd_split;
reg malf_pkt_ph_split;
reg malf_pkt_pd_split;
reg malf_pkt_nph_split;
reg malf_pkt_npd_split;
reg fc_overflow_split;
reg txintf_end_reg_split;
reg txintf_nlfy_reg_split;
reg txintf_end_p_split;
reg txintf_nlfy_p_split;
reg [2047:0] descram_in;
wire [198:0] descram_out;

`ifdef ECRC

`endif

`ifdef X4

`endif

`ifdef GEN2

`endif

`ifdef X4

`define INTMSG_DEF int_msg

`define TXINTF_DEF txintf

`define TLPGEN_DEF tlpgen

`define TLPDEC_DEF tlpdec

`define RXINTF_DEF rxintf

`endif

`ifdef X1

`define INTMSG_DEF int_msg_x1

`define TXINTF_DEF txintf_x1

`define TLPGEN_DEF tlpgen_x1

`define TLPDEC_DEF tlpdec_x1

`define RXINTF_DEF rxintf_x1

`endif

`ifdef X4

`endif

`ifdef GEN2

`else

`endif

`ifdef CFG_REG


`ifdef ECRC

`endif

`ifdef X4

`endif

`else

`endif


`ifdef X4

`endif

`ifdef CFG_REG

`ifdef X4

`endif

`endif

`ifdef ECRC

`endif

`ifdef CFG_REG

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef X4

`endif


`ifdef X4

`endif

`ifdef ECRC

`endif

`ifdef X4

`endif


`ifdef X4

`endif

`ifdef ECRC

`endif

`ifdef X4

`endif

`ifdef ECRC

`endif


`ifdef X4

`endif


`ifdef X1

`endif

`ifdef X4

`endif

`ifdef AER

`endif

`ifdef AER

`endif

`ifdef CFG_REG


`ifdef EN_BAR0

`endif

`ifdef EN_BAR1

`endif

`ifdef EN_BAR2

`endif

`ifdef EN_BAR3

`endif

`ifdef EN_BAR4

`endif

`ifdef EN_BAR5

`endif

`ifdef EN_ER_BAR

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`else

`endif


`ifdef ECRC

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef ECRC

`endif

`ifdef X4

`endif

`ifdef ECRC

`endif

`ifdef VC1

`else

`ifdef X4

`endif

`ifdef ECRC

`endif

`endif

`ifdef X1

`endif

`ifdef X4

`endif

`ifdef ENDPOINT_COMP

`else

`endif

`ifdef CFG_REG


`ifdef GEN2

`endif

`ifdef CFG_VCC

`endif

`ifdef GEN2

`else

`endif

`ifdef CFG_VCC

`endif

`ifdef ECRC

`endif

`ifdef AER

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef GEN2

`endif

`ifdef ECRC

`else

`endif

`ifdef GEN2

`endif

`ifdef CFG_VCC

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`endif

`ifdef X4

`endif

`ifdef X4

`endif

`ifdef X1

`endif

`ifdef EN_VC0

`ifdef CFG_VCC

`else

`endif

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`else

`ifdef GEN2

`endif

`endif

`ifdef GEN2

`ifdef X4

`endif

`ifdef X1

`endif

`endif

`ifdef DEBUG

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`ifdef X4

`ifdef EN_VC0

`endif

`ifdef EN_VC1

`endif

`ifdef EN_VC2

`endif

`ifdef EN_VC3

`endif

`ifdef EN_VC4

`endif

`ifdef EN_VC5

`endif

`ifdef EN_VC6

`endif

`ifdef EN_VC7

`endif

`endif

`endif  //End of DEBUG

localparam descram_inst_SIZE = 199,descram_inst_SCRAMSTRING = 32'hfdffe44b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;


`ifdef ECRC


`endif


`ifdef X4


`endif


`ifdef GEN2


`endif



`ifdef X4



`define INTMSG_DEF int_msg



`define TXINTF_DEF txintf



`define TLPGEN_DEF tlpgen



`define TLPDEC_DEF tlpdec



`define RXINTF_DEF rxintf



`endif



`ifdef X1



`define INTMSG_DEF int_msg_x1



`define TXINTF_DEF txintf_x1



`define TLPGEN_DEF tlpgen_x1



`define TLPDEC_DEF tlpdec_x1



`define RXINTF_DEF rxintf_x1



`endif



`ifdef X4



`endif



`ifdef GEN2



`else



`endif



`ifdef CFG_REG



`ifdef ECRC



`endif



`ifdef X4



`endif



`else



`endif



`ifdef X4



`endif



`ifdef CFG_REG



`ifdef X4



`endif



`endif



`ifdef ECRC



`endif



`ifdef CFG_REG



`endif



`ifdef X4



`endif


`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X1



`endif


`ifdef X4


`endif



`ifdef X4



`endif



`ifdef ECRC



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef ECRC



`endif



`ifdef X4



`endif



`ifdef ECRC



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef AER



`endif



`ifdef AER



`endif



`ifdef CFG_REG



`ifdef EN_BAR0



`endif



`ifdef EN_BAR1



`endif



`ifdef EN_BAR2



`endif



`ifdef EN_BAR3



`endif



`ifdef EN_BAR4



`endif



`ifdef EN_BAR5



`endif



`ifdef EN_ER_BAR



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`else



`endif



`ifdef ECRC



`endif



`ifdef X1



`endif



`ifdef X4



`endif



`ifdef ECRC



`endif



`ifdef X4



`endif



`ifdef ECRC



`endif



`ifdef VC1



`else



`ifdef X4



`endif



`ifdef ECRC



`endif



`endif



`ifdef X1


`endif



`ifdef X4



`endif



`ifdef ENDPOINT_COMP



`else



`endif



`ifdef CFG_REG



`ifdef GEN2



`endif



`ifdef CFG_VCC



`endif



`ifdef GEN2



`else



`endif



`ifdef CFG_VCC



`endif



`ifdef ECRC



`endif



`ifdef AER



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef GEN2



`endif



`ifdef ECRC



`else



`endif



`ifdef GEN2



`endif



`ifdef CFG_VCC



`ifdef EN_VC0



`endif



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif



`endif



`ifdef X4



`endif



`ifdef X4



`endif



`ifdef X1



`endif



`ifdef EN_VC0



`ifdef CFG_VCC



`else



`endif



`endif



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif



`else



`ifdef GEN2



`endif



`endif



`ifdef GEN2



`ifdef X4



`endif



`ifdef X1



`endif



`endif



`ifdef DEBUG


`ifdef EN_VC0



`endif



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif



`ifdef X4


`ifdef EN_VC0



`endif



`ifdef EN_VC1



`endif



`ifdef EN_VC2



`endif



`ifdef EN_VC3



`endif



`ifdef EN_VC4



`endif



`ifdef EN_VC5



`endif



`ifdef EN_VC6



`endif



`ifdef EN_VC7



`endif



`endif



`endif  //End of DEBUG

// =============================================================================
// Internal Registers/Wires
// =============================================================================


`ifdef ECRC


   

`endif


//-- For txintf, cfg_top & int_msg
//For OverFlow Check
//Binary Encoding


`ifdef X4


   

`endif





`ifdef GEN2


   

`endif


// =============================================================================


`ifdef X4


   

`define INTMSG_DEF int_msg


   

`define TXINTF_DEF txintf


   

`define TLPGEN_DEF tlpgen


   

`define TLPDEC_DEF tlpdec


   

`define RXINTF_DEF rxintf




`endif




`ifdef X1


   

`define INTMSG_DEF int_msg_x1


   

`define TXINTF_DEF txintf_x1


   

`define TLPGEN_DEF tlpgen_x1


   

`define TLPDEC_DEF tlpdec_x1


   

`define RXINTF_DEF rxintf_x1




`endif



// =============================================================================
// Arbitration b/w CFG Resp & int_msg blocks
// =============================================================================
// Muxing Inputs to txintf
assign cfg_rmux_data = (!arb_enable_split) ? cfg_resp_data_split : (arb_enable2_split) ? err_msg_data_split : int_msg_data_split;
assign cfg_rmux_ae   = (!arb_enable_split) ? cfg_resp_ae_split   : (arb_enable2_split) ? err_msg_ae_split   : int_msg_ae_split;


`ifdef X4


   assign cfg_rmux_dwen = (!arb_enable_split) ? cfg_resp_dwen : (arb_enable2_split) ? err_msg_dwen : int_msg_dwen;


`endif



// De-muxing Output from txintf cfg_resp/int_msg Fifos
assign cfg_resp_rd   = (arb_enable_split) ? 1'b0 : cfg_rmux_rd_split;
assign int_msg_rd    = (arb_enable_split && !arb_enable2_split) ? cfg_rmux_rd_split : 1'b0;
assign err_msg_rd    = (arb_enable_split &&  arb_enable2_split) ? cfg_rmux_rd_split : 1'b0;

always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      arb_sm        <= ARB_IDLE;
      cfg_rmux_req  <= 1'b0;
      arb_enable    <= 1'b0;
      arb_enable2   <= 1'b0;
   end
   else begin
      case(arb_sm_split)
         ARB_IDLE : begin
            if(cfg_resp_req_split) begin
               cfg_rmux_req  <= 1'b1;
               arb_enable    <= 1'b0;
               arb_sm        <= ARB_CFG_WAIT;
            end
            else if(int_msg_req_split || err_msg_req_split) begin
               cfg_rmux_req  <= 1'b1;
               arb_enable    <= 1'b1;
               arb_sm        <= ARB_INT_WAIT;
               case({int_msg_req_split, err_msg_req_split})
                  2'b11 : arb_enable2   <= !arb_enable2_split;
                  2'b01 : arb_enable2   <= 1'b1;
                  2'b10 : arb_enable2   <= 1'b0;
               endcase
            end
         end
         ARB_CFG_WAIT : begin
            if(cfg_rmux_end_split) begin
               if(int_msg_req_split || err_msg_req_split) begin
                  arb_enable    <= 1'b1;
                  arb_sm        <= ARB_INT_WAIT;
                  case({int_msg_req_split, err_msg_req_split})
                     2'b11 : arb_enable2   <= !arb_enable2_split;
                     2'b01 : arb_enable2   <= 1'b1;
                     2'b10 : arb_enable2   <= 1'b0;
                  endcase
               end
               else if(!cfg_resp_req_split) begin
                  arb_sm        <= ARB_IDLE;
                  cfg_rmux_req  <= 1'b0;
               end
            end
         end
         ARB_INT_WAIT : begin
            if(cfg_rmux_end_split) begin
               if(cfg_resp_req_split) begin
                  arb_enable    <= 1'b0;
                  arb_sm        <= ARB_CFG_WAIT;
               end
               else if(int_msg_req_split || err_msg_req_split) begin //Another INT/MSI or ERR
                  case({int_msg_req_split, err_msg_req_split})
                     2'b11 : arb_enable2   <= !arb_enable2_split;
                     2'b01 : arb_enable2   <= 1'b1;
                     2'b10 : arb_enable2   <= 1'b0;
                  endcase
               end
               else begin
                  arb_sm        <= ARB_IDLE;
                  cfg_rmux_req  <= 1'b0;
               end
            end
         end
      endcase
   end
end

// =============================================================================
// Delay the Recheck signals to sync. with tx_ca_ registers to the User
// =============================================================================
always @(posedge sys_clk or negedge rst_n) begin
   if (!rst_n) begin
      rchk_credit_p_del1   <= 1'b0;
      rchk_credit_cpl_del1 <= 1'b0;
      rchk_credit_p_del2   <= 1'b0;
      rchk_credit_cpl_del2 <= 1'b0;
      tx_ca_p_recheck      <= 1'b0;
      tx_ca_cpl_recheck    <= 1'b0;
   end
   else begin
      rchk_credit_p_del1   <= rchk_credit_p_split;
      rchk_credit_cpl_del1 <= rchk_credit_cpl_split;

      rchk_credit_p_del2   <= rchk_credit_p_del1_split;
      rchk_credit_cpl_del2 <= rchk_credit_cpl_del1_split;

      tx_ca_p_recheck      <= rchk_credit_p_del2_split;
      tx_ca_cpl_recheck    <= rchk_credit_cpl_del2_split;
   end
end

// =============================================================================
// INT_MSG Instantiation
// =============================================================================



`ifdef GEN2


   assign int_disable = (cmd_reg_out[5] | int_dsb_flr) ;


`else


   assign int_disable = cmd_reg_out[5] ;


`endif





`ifdef CFG_REG


`INTMSG_DEF u1_int_msg (
    //------- Inputs
    .sys_clk              (sys_clk),
    .rst_n                (rst_n),

    .int_disable          (int_disable),
    .inta_n               (inta_n),

    .ftl_err_out          (ftl_err_out),
    .nftl_err_out         (nftl_err_out),
    .cor_err_out          (cor_err_out),

    .bus_num              (bus_num),
    .dev_num              (dev_num),
    .func_num             (func_num),

    

`ifdef ECRC


       .ecrc_enb          (ecrc_gen_enb),
    

`endif



    .int_msg_rd           (int_msg_rd),
    .err_msg_rd           (err_msg_rd),
    .tx_ca_ph_infi        (tx_ca_ph[8]),
    .tx_ca_pd_infi        (tx_ca_pd[12]),
    .tx_ca_ph             (tx_ca_ph[7:0]),
    .tx_ca_pd             (tx_ca_pd[11:0]),

    .msi_tc               (msi_tc),
    .msi                  (msi),
    .msi_enable           (msi_enable),
    .mm_enable            (mm_enable),
    .mes_uaddr            (mes_uaddr),
    .mes_laddr            (mes_laddr),
    .mes_data             (mes_data),

    //------- Outputs
    

`ifdef X4


      .err_msg_dwen       (err_msg_dwen),
      .int_msg_dwen       (int_msg_dwen),
    

`endif


   .err_msg_req           (err_msg_req),
   .err_msg_data          (err_msg_data),
   .err_msg_ae            (err_msg_ae),

   .int_msg_req           (int_msg_req),
   .int_msg_data          (int_msg_data),
   .int_msg_ae            (int_msg_ae),
   .int_pending           (int_pending)

  );


`else


   assign err_msg_req   = 'd0;
   assign err_msg_data  = 'd0;
   assign err_msg_ae    = 'd0;
   assign err_msg_dwen  = 'd0;

   assign int_msg_req   = 'd0;
   assign int_msg_data  = 'd0;
   assign int_msg_ae    = 'd0;
   assign int_pending   = 'd0;


`endif



// =============================================================================
// TXINTF Instantiation
// =============================================================================
`TXINTF_DEF #(
    .FADDR    ( FADDR ) ,
    .D_WIDTH  ( D_WIDTH )
    )
    u1_txintf (
    //------- Inputs
    .sys_clk              ( sys_clk ),
    .rst_n                ( rst_n ),
    .cfgec_vcasel         ( cfgec_vcasel ),
    

`ifdef X4


       .phy_cfgln_sum     ( phy_cfgln_sum ),
       .tx_dwen           ( tx_dwen ),
    

`endif


    .rate_5g              ( rate_5g ),
    .arb_enable           ( arb_enable ),
    .arb_enable2          ( arb_enable2 ),
    .msi_enable           ( msi_enable ),

    

`ifdef CFG_REG


       .cfg_rmux_req      ( cfg_rmux_req ),
       .cfg_rmux_ae       ( cfg_rmux_ae ),
       .cfg_rmux_data     ( cfg_rmux_data ),
      

`ifdef X4


       .cfg_rmux_dwen     ( cfg_rmux_dwen ),
      

`endif


    

`endif


    

`ifdef ECRC


       .ecrc_enb          ( ecrc_gen_enb ) ,
    

`endif


    .tx_req               ( tx_req ),
    .tx_data              ( tx_data ),
    .tx_st                ( tx_st ),
    .tx_end               ( tx_end ),
    .tx_nlfy              ( tx_nlfy ),
    .txtp_rdy             ( txtp_rdy ),
    .dll_pause_cnt        ( dll_pause_cnt ),
    .vcneg_pend           ( vcneg_pend ),

    //------- Outputs
    .txintf_pause_ack     ( trnc_pause_ack ),
    .txintf_rdy_ack       ( txintf_rdy_ack ),
    

`ifdef CFG_REG


       .cfg_rmux_rd       ( cfg_rmux_rd ),
    

`endif



    .cfg_cplh_cc          ( cfg_cplh_cc ),
    .cfg_cpld_cc          ( cfg_cpld_cc ),
    .cfg_ph_cc            ( cfg_ph_cc ),
    .cfg_pd_cc            ( cfg_pd_cc ),

    .tx_rdy               ( tx_rdy ),
    .txintf_req           ( tlpgen_req ),
    .txintf_data          ( txintf_data ),
    .txintf_st            ( txintf_st ),
    .txintf_end           ( txintf_end ),
    .txintf_nlfy          ( txintf_nlfy ),
    

`ifdef X4


       .txintf_dwen       ( txintf_dwen ),
       .txintf_val        ( txintf_val ),
    

`endif



    .f_nf_emsg_sent       ( f_nf_emsg_sent ),
    .rchk_credit_cpl      ( rchk_credit_cpl ),
    .rchk_credit_p        ( rchk_credit_p ),
    .cfg_rmux_end         ( cfg_rmux_end)
    );

always @(posedge sys_clk, negedge rst_n) begin
   if (!rst_n) begin
      txintf_end_reg  <= 1'b0 ;
      txintf_nlfy_reg <= 1'b0 ;
      

`ifdef X4


         txintf_dwen_reg <= 1'b0 ;
      

`endif


   end
   

`ifdef X4


      else if (txintf_val) begin
         txintf_end_reg  <= txintf_end_split ;
         txintf_nlfy_reg <= txintf_nlfy_split ;
         txintf_dwen_reg <= txintf_dwen ;
      end
   

`endif


   

`ifdef X1


      else begin
         txintf_end_reg  <= txintf_end_split ;
         txintf_nlfy_reg <= txintf_nlfy_split ;
      end
   

`endif


end


`ifdef X4


   assign tx_val = txintf_val;


`endif



// =============================================================================
// TLPGEN Instantiation
// =============================================================================
`TLPGEN_DEF u1_tlpgen (
   // Clock and Reset
   .sys_clk        ( sys_clk ) ,
   .rst_n          ( rst_n ) ,

   // Inputs
   .txintf_data    ( txintf_data ) ,
   .txintf_st      ( txintf_st ) ,
   .txintf_end     ( txintf_end_p ) ,
   .txintf_nlfy    ( txintf_nlfy_p ) ,
   

`ifdef X4


      .txintf_dwen ( txintf_dwen_p ) ,
      .txintf_val  ( txintf_val ) ,
   

`endif


   .txintf_rdy_ack ( txintf_rdy_ack ) ,
   

`ifdef ECRC


      .ecrc_enb    ( ecrc_gen_enb ) ,
   

`endif



   // Outputs
   

`ifdef X4


      .tlpgen_tval ( tlpgen_tval ) ,
      .tlpgen_dwen ( tlpgen_dwen ) ,
   

`endif


   .tlpgen_data    ( tlpgen_data ) ,
   .tlpgen_st      ( tlpgen_st ) ,
   .tlpgen_end     ( tlpgen_end ) ,
   .tlpgen_nlfy    ( tlpgen_nlfy ) ,
   .tlpgen_rdy_ack ( tlpgen_rdy_ack )
   ) ;

// =============================================================================
// TLPDEC Instantiation
// =============================================================================
`TLPDEC_DEF u1_tlpdec (
   // Clock and Reset
   .sys_clk            ( sys_clk ) ,
   .rst_n              ( rst_n ) ,

   // Inputs
   .rxtp_data          ( rxtp_data ) ,
   .rxtp_st            ( rxtp_st ) ,
   .rxtp_end           ( rxtp_end ) ,
   

`ifdef X4


      .rxtp_dwen       ( rxtp_dwen ) ,
   

`endif



   .max_pl_size        ( max_pl_size ) ,

   

`ifdef ECRC


      .ecrc_enb        ( ecrc_chk_enb ) ,
   

`endif



   .vc_dl_up_fail      ( vc_dl_up_fail ) ,

   // Outputs
   .tlpdec_data        ( tlpdec_data ) ,
   .tlpdec_st          ( tlpdec_st ) ,
   .tlpdec_end         ( tlpdec_end ) ,
   .tlpdec_tc          ( tlpdec_tc ) ,
   

`ifdef X4


      .tlpdec_dwen     ( tlpdec_dwen ) ,
      .tlp_dwen_reg2   ( rxtp_dwen_r2 ) ,
   

`endif



   .tlpdec_cfgrd       ( tlpdec_cfgrd ) ,
   .tlpdec_cfgwr       ( tlpdec_cfgwr ) ,
   .tlpdec_memrw       ( tlpdec_memrw ) ,
   .tlpdec_iorw        ( tlpdec_iorw ) ,
   .tlpdec_rvcd_sts_ur ( tlpdec_rvcd_sts_ur ) ,
   .tlpdec_rvcd_sts_ca ( tlpdec_rvcd_sts_ca ) ,
   .tlpdec_addr_l32    ( tlpdec_addr_l32 ) ,
   .tlpdec_addr_h32    ( tlpdec_addr_h32 ) ,
   .tlpdec_addr64      ( tlpdec_addr64 ) ,
   .s2e_cnt_err        ( s2e_cnt_err ) ,

   

`ifdef ECRC


      .tlpdec_ecrc_err ( tlpdec_ecrc_err ) ,
      .crc_ok_out      ( rxtp_ecrc_ok ) ,
   

`endif


   .tlpdec_pois_tlp    ( tlpdec_pois_tlp ) ,
   .tlpdec_us_req      ( tlpdec_us_req ) ,
   .tlpdec_malf_tlp    ( tlpdec_malf_tlp ),

   .tlp_st_reg2        ( rxtp_st_r2 ),
   .tlp_end_reg2       ( rxtp_end_r2 ),
   .tlp_data_reg2      ( rxtp_data_r2 )

   ) ;

// =============================================================================
// TXFC Instantiation
// cfgec_vcid_0
// =============================================================================
txfc u1_txfc(
   //---------Inputs-------------
   .sys_clk                  (sys_clk),
   .rst_n                    (rst_n),

   .dl_inactive              (dl_inactive_split),
   .vc_en                    (vc_en),
   .vcid                     (cfg_vcid),
   .tx_st                    (tx_st_split),
   .tx_end                   (tx_end_split),
   .tx_nlfy                  (tx_nlfy_split),
   .tx_data                  (tx_data_split),
   

`ifdef X4


      .txintf_val            (txintf_val),
   

`endif


   .cfg_ph_cc                (cfg_ph_cc),
   .cfg_pd_cc                (cfg_pd_cc),
   .cfg_cplh_cc              (cfg_cplh_cc),
   .cfg_cpld_cc              (cfg_cpld_cc),

   .rxdp_ifc1_val            (rxdp_ifc1_val_split),
   .rxdp_ifc2_val            (rxdp_ifc2_val_split),
   .rxdp_ufc_val             (rxdp_ufc_val_split),
   .rxdp_fcd_type            (rxdp_fcd_type_split),
   .rxdp_fcd_vcid            (rxdp_fcd_vcid_split),
   .rxdp_fcd_data            (rxdp_fcd_data_split),

   //---------Outputs------------
   .fc_protocol_err          (lcmfci_fcp_err),
   .tx_ca_ph                 (tx_ca_ph),
   .tx_ca_pd                 (tx_ca_pd),
   .tx_ca_nph                (tx_ca_nph),
   .tx_ca_npd                (tx_ca_npd),
   .tx_ca_cplh               (tx_ca_cplh),
   .tx_ca_cpld               (tx_ca_cpld)
   ) ;

// =============================================================================
// RXFC Instantiation
// =============================================================================
rxfc u1_rxfc(
      //---------Inputs-------------
   .sys_clk                  (sys_clk),
   .rst_n                    (rst_n),

   // Parameter bus, will be straped at the top
   .INIT_PH_FC               (INIT_PH_FC_split),
   .INIT_NPH_FC              (INIT_NPH_FC_split),
   .INIT_CPLH_FC             ({(8*`NUM_VC){1'b0}}),
   .INIT_PD_FC               (INIT_PD_FC_split),
   .INIT_NPD_FC              (INIT_NPD_FC_split),
   .INIT_CPLD_FC             ({(12*`NUM_VC){1'b0}}),

   .UPDATE_FREQ_PH           (UPDATE_FREQ_PH_split),
   .UPDATE_FREQ_PD           (UPDATE_FREQ_PD_split),
   .UPDATE_FREQ_NPH          (UPDATE_FREQ_NPH_split),
   .UPDATE_FREQ_NPD          (UPDATE_FREQ_NPD_split),
   .UPDATE_FREQ_CPLH         (7'd1),
   .UPDATE_FREQ_CPLD         (11'd1),
   .UPDATE_TIMER             (UPDATE_TIMER_split),

   .vcneg_pend               (vcneg_pend_split),
   .ext_sync_bit             (ext_sync),
   .phy_l0_l0s               (phy_l0_l0s_split),

   .txdp_hpreq               (txdp_hpreq_split),
   .txdp_lpreq               (txdp_lpreq_split),
   .txdp_p_sent              (txdp_p_sent_split),
   .txdp_np_sent             (txdp_np_sent_split),
   .txdp_cpl_sent            (txdp_cpl_sent_split),

   .ph_buf_status            (ph_buf_status_split),
   .pd_buf_status            (pd_buf_status_split),
   .nph_buf_status           (nph_buf_status_split),
   .npd_buf_status           (npd_buf_status_split),
   .cplh_buf_status          ({(`NUM_VC){1'b0}}),
   .cpld_buf_status          ({(`NUM_VC){1'b0}}),
   .ph_processed             (ph_processed_split),
   .pd_processed             (pd_processed_split),
   .nph_processed            (nph_processed_split),
   .npd_processed            (npd_processed_split),
   .cplh_processed           ({(`NUM_VC){1'b0}}),
   .cpld_processed           ({(`NUM_VC){1'b0}}),
   

`ifdef X1


      .nph_processed_cfg     ((nph_processed_cfg_split & ~s2e_cnt_err)),
      .npd_processed_cfg     ((npd_processed_cfg_split & ~s2e_cnt_err)),
   

`endif


   

`ifdef X4


      .nph_processed_cfg     (nph_processed_cfg_split),
      .npd_processed_cfg     (npd_processed_cfg_split),
   

`endif


   .ph_processed_msg         (1'b0), // Used only for RC

   .pd_num                   (pd_num_split),
   .npd_num                  (npd_num_split),
   .cpld_num                 ({(8*`NUM_VC){1'b1}}),



`ifdef AER


    //For OverFlow check
   .vc_rcvd                  (vc_rcvd_split),
   .ph_rcvd                  (ph_rcvd_split),
   .pd_rcvd                  (pd_rcvd_split),
   .nph_rcvd                 (nph_rcvd_split),
   .npd_rcvd                 (npd_rcvd_split),
   .credits_rcvd             (credits_rcvd_split),

   .malf_pkt_ph              (malf_pkt_ph_split),
   .malf_pkt_pd              (malf_pkt_pd_split),
   .malf_pkt_nph             (malf_pkt_nph_split),
   .malf_pkt_npd             (malf_pkt_npd_split),


`endif



   //---------Outputs-------------
   .fc_update1               (fc_update1),
   .fc_vcid1                 (fc_vcid1),
   .fc_type1                 (fc_type1),
   .fc_update2               (fc_update2),
   .fc_vcid2                 (fc_vcid2),
   .fc_type2                 (fc_type2),

   .p_infi_credit            (p_infi_credit),
   .np_infi_credit           (np_infi_credit),
   .cpl_infi_credit          (cpl_infi_credit),

   

`ifdef AER


      .fc_overflow              (fc_overflow),
   

`endif


   .fc_p                     (fc_p),
   .fc_np                    (fc_np),
   .fc_cpl                   (fc_cpl)

   ) ;
// =============================================================================
// BAR Check
// =============================================================================


`ifdef CFG_REG


bar_chk u1_bar_chk (
   // Clock and Reset
   .sys_clk            ( sys_clk ) ,
   .rst_n              ( rst_n ) ,

   

`ifdef EN_BAR0


      .bar0_reg        ( bar0_reg_split ) ,
      .bar0_init       ( bar0_init_split ) ,
   

`endif


   

`ifdef EN_BAR1


      .bar1_reg        ( bar1_reg_split ) ,
      .bar1_init       ( bar1_init_split ) ,
   

`endif


   

`ifdef EN_BAR2


      .bar2_reg        ( bar2_reg_split ) ,
      .bar2_init       ( bar2_init_split ) ,
   

`endif


   

`ifdef EN_BAR3


      .bar3_reg        ( bar3_reg_split ) ,
      .bar3_init       ( bar3_init_split ) ,
   

`endif


   

`ifdef EN_BAR4


      .bar4_reg        ( bar4_reg_split ) ,
      .bar4_init       ( bar4_init_split ) ,
   

`endif


   

`ifdef EN_BAR5


      .bar5_reg        ( bar5_reg_split ) ,
      .bar5_init       ( bar5_init_split ) ,
   

`endif


   

`ifdef EN_ER_BAR


      .er_bar_reg      ( er_bar_reg_split ) ,
      .er_bar_init     ( er_bar_init_split ) ,
   

`endif



   // Outputs
   

`ifdef X4


      .bar_hit        ( bar_hit ),
      .bar_hit_val    ( bar_hit_val ),
   

`endif


   

`ifdef X1


      .bar_hit        ( bar_hit ),
      .bar_fail       ( bar_fail ),
   

`endif



   // Inputs
   .tlpdec_memrw       ( tlpdec_memrw ) ,
   .tlpdec_iorw        ( tlpdec_iorw ) ,
   .tlpdec_addr_l32    ( tlpdec_addr_l32_split ) ,
   .tlpdec_addr_h32    ( tlpdec_addr_h32_split ) ,
   .tlpdec_addr64      ( tlpdec_addr64 )

   );


`else


  assign bar_hit = 'd0;
  assign bar_fail = 'd0;


`endif



// =============================================================================
// Rx User Interface
// =============================================================================
`RXINTF_DEF u1_rxintf (
   // Clock and Reset
   .sys_clk            ( sys_clk ) ,
   .rst_n              ( rst_n ) ,

   // Inputs from tlpdec
   .tlpdec_data        ( tlpdec_data ) ,
   .tlpdec_st          ( tlpdec_st ) ,
   .tlpdec_end         ( tlpdec_end ) ,
   .tlpdec_cfgrd       ( tlpdec_cfgrd ) ,

   

`ifdef ECRC


      .tlpdec_ecrc_err ( tlpdec_ecrc_err ),
   

`endif


   .tlpdec_us_req      ( tlpdec_us_req ),
   .tlpdec_malf_tlp    ( tlpdec_malf_tlp ),

   // Inputs from dllp
   .dl_up              ( dl_up ),

   // Inputs from cfg
   

`ifdef X1


      .cfg_hit         ( (cfg_hit & ~s2e_cnt_err) ) ,
      .bar_fail        ( bar_fail ) ,
   

`endif


   

`ifdef X4


      .cfg_hit         ( cfg_hit ) ,
      .bar_hit_val     ( bar_hit_val ) ,
      .tlpdec_dwen     ( tlpdec_dwen ) ,
      .tlpdec_tc       ( tlpdec_tc ) ,
      .rx_dwen         ( irx_dwen ) ,
   

`endif


   .bar_hit            ( bar_hit ) ,
   .fc_overflow        (fc_overflow),

   // Inputs/Outputs per VC
   .trnc_st            ( trnc_st ) ,
   .vc_dl_up_fail      ( vc_dl_up_fail ) ,
   .cfgec_tvmap        ( cfgec_tvmap ) ,
   .rx_bar_hit         ( rx_bar_hit ) ,

   .rx_data            ( irx_data ),
   .rx_st              ( irx_st ),
   .rx_end             ( irx_end ),
   

`ifdef ECRC


      .rx_ecrc_err     ( irx_ecrc_err ),
   

`endif


   .rx_us_req          ( irx_us_req ),
   .rx_malf_tlp        ( irx_malf_tlp ),

   //For OverFlow check
   .vc_rcvd         (vc_rcvd),
   .ph_rcvd         (ph_rcvd),
   .pd_rcvd         (pd_rcvd),
   .nph_rcvd        (nph_rcvd),
   .npd_rcvd        (npd_rcvd),
   .credits_rcvd    (credits_rcvd),

   .malf_pkt_ph     (malf_pkt_ph),
   .malf_pkt_pd     (malf_pkt_pd),
   .malf_pkt_nph    (malf_pkt_nph),
   .malf_pkt_npd    (malf_pkt_npd)
   );

// When "tlp_debug is set, bypass trnc and data path
// from Data link layer connects directly to RX user interface on VC0.
assign rx_data[D_WIDTH-1:0]     = tlp_debug_split ? rxtp_data_split : irx_data_split[D_WIDTH-1:0] ;
assign rx_st[0]          = tlp_debug_split ? rxtp_st_split : irx_st_split[0] ;
assign rx_end[0]         = tlp_debug_split ? rxtp_end_split : irx_end_split[0] ;


`ifdef X4


   assign rx_dwen[0]     = tlp_debug_split ? rxtp_dwen : irx_dwen[0] ;


`endif




`ifdef ECRC


   assign rx_ecrc_err[0] = tlp_debug_split ? 1'b0 : irx_ecrc_err[0] ;


`endif


assign rx_us_req[0]      = tlp_debug_split ? 1'b0 : irx_us_req_split[0] ;
assign rx_malf_tlp[0]    = tlp_debug_split ? 1'b0 : irx_malf_tlp_split[0] ;



`ifdef VC1




`else


   assign rx_data[(`NUM_VC*D_WIDTH)-1:D_WIDTH]  = irx_data_split[(`NUM_VC*D_WIDTH)-1:D_WIDTH] ;
   assign rx_st[`NUM_VC-1:1]          = irx_st_split[`NUM_VC-1:1] ;
   assign rx_end[`NUM_VC-1:1]         = irx_end_split[`NUM_VC-1:1] ;
   

`ifdef X4


      assign rx_dwen[`NUM_VC-1:1]     = irx_dwen[`NUM_VC-1:1] ;
   

`endif


   

`ifdef ECRC


      assign rx_ecrc_err[`NUM_VC-1:1] = irx_ecrc_err[`NUM_VC-1:1] ;
   

`endif


   assign rx_us_req[`NUM_VC-1:1]      = irx_us_req_split[`NUM_VC-1:1] ;
   assign rx_malf_tlp[`NUM_VC-1:1]    = irx_malf_tlp_split[`NUM_VC-1:1] ;


`endif



// =============================================================================
// CFG Registers Instintation
// =============================================================================


`ifdef X1


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) begin
         txintf_st_reg1 <= 1'b0 ;
         txintf_st_reg2 <= 1'b0 ;
         txintf_st_reg3 <= 1'b0 ;
      end
      else begin
         txintf_st_reg1 <= txintf_st ;
         txintf_st_reg2 <= txintf_st_reg1 ;
         txintf_st_reg3 <= txintf_st_reg2 ;
      end
   end

   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n)
         tx_cpl_dec <= 1'b0 ;
      else if (txintf_st && txintf_data_split[12:8] == 5'b01010)
         tx_cpl_dec <= 1'b1 ;
      else if (txintf_end_split)
         tx_cpl_dec <= 1'b0 ;
   end
   // EP bit decode in TX TLPs
   assign pois_tlp_sent = txintf_st_reg1 & (txintf_data_split[14] == 1'b1) ;

   // CA status in a CPL/D TX TLPs
   assign sts_ca_sent = (tx_cpl_dec & txintf_st_reg3 & (txintf_data_split[15:13] == 3'b100));


`endif




`ifdef X4


   // EP bit decode in TX TLPs
   assign pois_tlp_sent = txintf_st & (txintf_data_split[46] == 1'b1) ;

   // CA status in a CPL/D TX TLPs
   assign sts_ca_sent = txintf_st & (txintf_data_split[60:56] == 5'b01010) & (txintf_data_split[15:13] == 3'b100);


`endif



// received a poisoned TLP
assign sts_reg_in[15] = tlpdec_pois_tlp ;

// Fatal or Non-fatal Error message sent and #SERR is set
assign sts_reg_in[14] = f_nf_emsg_sent_split & cmd_reg_out[4] ;

// Received UR status in completion TLP
assign sts_reg_in[13] = tlpdec_rvcd_sts_ur_split ;

// Received CA status in completion TLP
assign sts_reg_in[12] = tlpdec_rvcd_sts_ca_split ;

// completion sent by DUT with CA status
assign sts_reg_in[11] = sts_ca_sent_split ;

//  received/sent a poisoned TLP and Parity error enable is set
assign sts_reg_in[8] = (pois_tlp_sent_split | tlpdec_pois_tlp) & cmd_reg_out[4] ;

// INTx message is pending
assign sts_reg_in[3] = int_pending_split ;

// Generate surprise down error at falling edge of dl_up


`ifdef ENDPOINT_COMP


   assign surp_down_err = 1'b0 ;


`else


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n)
         dl_up_reg <= 1'b0 ;
      else
         dl_up_reg <= dl_up_split[0] ;
   end
   assign surp_down_err = dl_up_reg_split & ~dl_up_split[0] ;


`endif





`ifdef CFG_REG


   cfg_top #(
      .D_WIDTH  ( D_WIDTH ))
      u1_cfg_top (
      // Register Initial Values
      // For Type0 Registers
      .INIT_REG_000 ( INIT_REG_000_split )  ,
      .INIT_REG_008 ( INIT_REG_008_split )  ,
      .INIT_REG_00C ( INIT_REG_00C_split )  ,
      .INIT_REG_010 ( INIT_REG_010_split )  ,
      .INIT_REG_014 ( INIT_REG_014_split )  ,
      .INIT_REG_018 ( INIT_REG_018_split )  ,
      .INIT_REG_01C ( INIT_REG_01C_split )  ,
      .INIT_REG_020 ( INIT_REG_020_split )  ,
      .INIT_REG_024 ( INIT_REG_024_split )  ,
      .INIT_REG_028 ( INIT_REG_028_split )  ,
      .INIT_REG_02C ( INIT_REG_02C_split )  ,
      .INIT_REG_030 ( INIT_REG_030_split )  ,
      .INIT_REG_03C ( INIT_REG_03C_split )  ,
      .load_id      ( load_id_split ) ,
      // For PM Registers
      .INIT_REG_050      ( INIT_REG_050_split )  ,
      .INIT_REG_054      ( INIT_REG_054_split )  ,
      .INIT_PM_DS_DATA_0 ( INIT_PM_DS_DATA_0_split )  ,
      .INIT_PM_DS_DATA_1 ( INIT_PM_DS_DATA_1_split )  ,
      .INIT_PM_DS_DATA_2 ( INIT_PM_DS_DATA_2_split )  ,
      .INIT_PM_DS_DATA_3 ( INIT_PM_DS_DATA_3_split )  ,
      .INIT_PM_DS_DATA_4 ( INIT_PM_DS_DATA_4_split )  ,
      .INIT_PM_DS_DATA_5 ( INIT_PM_DS_DATA_5_split )  ,
      .INIT_PM_DS_DATA_6 ( INIT_PM_DS_DATA_6_split )  ,
      .INIT_PM_DS_DATA_7 ( INIT_PM_DS_DATA_7_split )  ,
      // For MSI Register
      .INIT_REG_070 ( INIT_REG_070_split )  ,
      // For PCIE Registers
      .INIT_REG_090 ( INIT_REG_090_split )  ,
      .INIT_REG_094 ( INIT_REG_094_split )  ,
      .INIT_REG_09C ( INIT_REG_09C_split )  ,
      .INIT_REG_0A0 ( INIT_REG_0A0_split )  ,
      

`ifdef GEN2


         .INIT_REG_0B4 ( INIT_REG_0B4 )  ,
      

`endif


      // For Device Serial no. Registers
      .INIT_REG_104 ( INIT_REG_104_split )  ,
      .INIT_REG_108 ( INIT_REG_108_split )  ,

      // For VCC Registers
      

`ifdef CFG_VCC


         .INIT_REG_10C ( INIT_REG_10C )  ,
      

`endif



      // Clock and Reset
      .sys_clk           ( sys_clk ) ,
      .rst_n             ( rst_n ),
      .rst_n_main        ( rst_n_main_split ),

      // Inputs
      .tlp_data          ( rxtp_data_r2_split ),
      .tlp_st            ( rxtp_st_r2 ),
      .tlp_end           ( rxtp_end_r2 ),
      .tlp_erly_st       ( tlp_erly_st ),
      .tx_ca_cplh        ( tx_ca_cplh[7:0] ),
      .tx_ca_cplh_infi   ( tx_ca_cplh[8] ),

      // From PHY
      .phy_link_up      ( phy_link_up_split ) ,
      .lnk_train_err    ( lnk_train_err_split ) ,
      .lnk_train_status ( lnk_train_status_split ) ,
      .lnk_width        ( phy_cfgln_sum_split ) ,
      .dfrm_perr        ( dfrm_perr_split ) ,
      .dl_active        ( dl_active_split ) ,
      

`ifdef GEN2


      .phy_lnk_spd      ( phy_lnk_spd ) ,
      //.phy_lnk_demp     ( phy_lnk_demp ) ,
      .phy_lnk_demp     ( 1'b0 ) ,
      

`else


      .phy_lnk_spd      (  ) ,
      .phy_lnk_demp     (  ) ,
      

`endif



      // From dll
      .rxtp_bad_tlp      ( rxtp_bad_tlp_split ),
      .rxdp_bad_dllp     ( rxdp_bad_dllp_split ),
      .rxdp_dlerr        ( rxdp_dlerr_split ),
      .txtp_rnum_rlor    ( txtp_rnum_rlor_split ),
      .txtp_rply_tout    ( txtp_rply_tout_split ),
      .lcmfci_fcp_err    ( lcmfci_fcp_err_split ),
      .rcvr_oflow        ( fc_overflow_split ),
      .surp_down_err     ( surp_down_err_split ),

      

`ifdef CFG_VCC


         .lcmfci_vcn_pnd ( vcneg_pend_split ),
      

`endif



      

`ifdef ECRC


         .tlp_ecrc_ok    ( rxtp_ecrc_ok ) ,
         .ecrc_gen_enb   ( ecrc_gen_enb ) ,
         .ecrc_chk_enb   ( ecrc_chk_enb ) ,
      

`endif



      // From User logic
      

`ifdef AER


         .err_tlp_header ( err_tlp_header ) ,
      

`endif


      .sts_reg_in        ( sts_reg_in_split ),
      .cmpln_tout        ( cmpln_tout_split ),
      .cmpltr_abort_np   ( cmpltr_abort_np_split ),
      .cmpltr_abort_p    ( cmpltr_abort_p_split ),
      .unexp_cmpln       ( unexp_cmpln_split ),
      .ur_np_ext         ( ur_np_ext_split ) ,
      .ur_p_ext          ( ur_p_ext_split ) ,
      .np_req_pend       ( np_req_pend_split ),
      .pme_status        ( pme_status_split ) ,
      .term_all_cfg      ( term_all_cfg_split ) ,
      .ptc_err_enable    ( ptc_err_enable_split ) ,
      

`ifdef X4


         .force_x2_cfg   ( force_x2_cfg ) ,
         .force_x1_cfg   ( force_x1_cfg ) ,
      

`endif


      

`ifdef X1


         .force_x2_cfg   ( 1'b0 ) ,
         .force_x1_cfg   ( 1'b1 ) ,
      

`endif


      

`ifdef GEN2


         .flr            ( flr ) ,
         .drop_resp      ( drop_resp ) ,
      

`endif



      // From txintf
      .cfg_rmux_rd       ( cfg_resp_rd_split ) ,

      // From tlpdec
      .tlpdec_data       ( tlpdec_data ),
      .tlpdec_st         ( tlpdec_st ),
      .tlpdec_end        ( tlpdec_end ),
      

`ifdef ECRC


         .tlpdec_ecrc_err( tlpdec_ecrc_err ),
      

`else


         .tlpdec_ecrc_err( 1'b0 ),
      

`endif


      .tlpdec_pois_tlp   ( tlpdec_pois_tlp ),
      .tlpdec_us_req     ( tlpdec_us_req ),
      .tlpdec_malf_tlp   ( tlpdec_malf_tlp ),
      .s2e_cnt_err       ( s2e_cnt_err ) ,


      // CPM Interface
      .ADR_I             ( ADR_I_split ) ,
      .DAT_I             ( DAT_I_split ),
      .WE_I              ( WE_I_split ),
      .STB_I             ( STB_I_split ),

      // Outputs
      .RDAT_O            ( RDAT_O ),
      .ACK_O             ( ACK_O ),

      // From registers
      .bar_10            ( bar0_reg ),
      .bar_14            ( bar1_reg ),
      .bar_18            ( bar2_reg ),
      .bar_1c            ( bar3_reg ),
      .bar_20            ( bar4_reg ),
      .bar_24            ( bar5_reg ),
      .bar_30            ( er_bar_reg ),

      .bar_10_init       ( bar0_init ),
      .bar_14_init       ( bar1_init ),
      .bar_18_init       ( bar2_init ),
      .bar_1c_init       ( bar3_init ),
      .bar_20_init       ( bar4_init ),
      .bar_24_init       ( bar5_init ),
      .bar_30_init       ( er_bar_init ),
      .cfg_hit           ( cfg_hit ),
      .nph_processed     ( nph_processed_cfg ) ,
      .npd_processed     ( npd_processed_cfg ) ,

      .bus_num           ( bus_num ) ,
      .dev_num           ( dev_num ) ,
      .func_num          ( func_num ) ,
      .pm_power_state    ( pm_power_state ) ,
      .pme_en            ( pme_en ) ,
      .mm_enable         ( mm_enable ) ,
      .msi_enable        ( msi_enable ) ,
      .mes_laddr         ( mes_laddr ) ,
      .mes_uaddr         ( mes_uaddr ) ,
      .mes_data          ( mes_data ) ,
      .cmd_reg_out       ( cmd_reg_out ),
      .dev_cntl_out      ( dev_cntl_out ),
      .lnk_cntl_out      ( lnk_cntl_out ),
      .ftl_err_out       ( ftl_err_out ),
      .nftl_err_out      ( nftl_err_out ),
      .cor_err_out       ( cor_err_out ),
      

`ifdef GEN2


         .dev_cntl_2_out      (dev_cntl_2_out ),
         .initiate_flr        (initiate_flr_int ),
         .cs_target_lnk_spd   (cs_target_lnk_spd),
         .cs_enter_compliance (cs_enter_compliance),
         .cs_hasd             (cs_hasd),
         .cs_tx_demphasis     (cs_tx_demphasis),
         .cs_tx_margin        (cs_tx_margin),
         .cs_enter_mod_comp   (cs_enter_mod_comp),
         .cs_comp_sos         (cs_comp_sos),
         .cs_comp_demp        (cs_comp_demp),

      

`endif



      .max_pld_size      ( max_pl_size ),
      .extd_synch        ( ext_sync ),
      .link_disable      ( link_disable ),
      .retrain_lnk       ( retrain_lnk ),
      .cfgcs_losel       ( cfgcs_losel ) ,

      

`ifdef CFG_VCC


         .cfgec_evcc        ( ) ,
         .cfgec_lpevcc      ( ) ,
         .cfgec_lvcat       ( cfgec_lvcat ) ,
         .cfgec_vcasel      ( cfgec_vcasel ) ,
         

`ifdef EN_VC0


            .cfgec_tvmap_0  ( cfgec_tvmap[7:0] ) ,
            .cfgec_vcid_0   ( cfgec_vcid_0 ) ,
            .cfgec_vcenb_0  ( cfgec_vcenb_0 ) ,
         

`endif


         

`ifdef EN_VC1


            .cfgec_tvmap_1  ( cfgec_tvmap[15:8] ) ,
            .cfgec_vcid_1   ( cfgec_vcid_1 ) ,
            .cfgec_vcenb_1  ( cfgec_vcenb_1 ) ,
         

`endif


         

`ifdef EN_VC2


            .cfgec_tvmap_2  ( cfgec_tvmap[23:16] ) ,
            .cfgec_vcid_2   ( cfgec_vcid_2 ) ,
            .cfgec_vcenb_2  ( cfgec_vcenb_2 ) ,
         

`endif


         

`ifdef EN_VC3


            .cfgec_tvmap_3  ( cfgec_tvmap[31:24] ) ,
            .cfgec_vcid_3   ( cfgec_vcid_3 ) ,
            .cfgec_vcenb_3  (  cfgec_vcenb_3 ) ,
         

`endif


         

`ifdef EN_VC4


            .cfgec_tvmap_4  ( cfgec_tvmap[39:32] ) ,
            .cfgec_vcid_4   ( cfgec_vcid_4 ) ,
            .cfgec_vcenb_4  (  cfgec_vcenb_4 ) ,
         

`endif


         

`ifdef EN_VC5


            .cfgec_tvmap_5  ( cfgec_tvmap[47:40] ) ,
            .cfgec_vcid_5   ( cfgec_vcid_5 ) ,
            .cfgec_vcenb_5  ( cfgec_vcenb_5 ) ,
         

`endif


         

`ifdef EN_VC6


            .cfgec_tvmap_6  ( cfgec_tvmap[55:48] ) ,
            .cfgec_vcid_6   ( cfgec_vcid_6 ) ,
            .cfgec_vcenb_6  ( cfgec_vcenb_6 ) ,
         

`endif


         

`ifdef EN_VC7


            .cfgec_tvmap_7  ( cfgec_tvmap[63:56] ) ,
            .cfgec_vcid_7   ( cfgec_vcid_7 ) ,
            .cfgec_vcenb_7  ( cfgec_vcenb_7 ) ,
         

`endif


      

`endif



      // config response TLPs to tlpgen
      .cfg_rmux_req         ( cfg_resp_req ),
      .cfg_rmux_data        ( cfg_resp_data ),
      

`ifdef X4


         .cfg_rmux_dwen     ( cfg_resp_dwen ),
      

`endif


      .cfg_rmux_ae          ( cfg_resp_ae )
      );

   

`ifdef X4


      assign  tlp_erly_st = (rxtp_st_split & (rxtp_data_split[60:56] == 5'b00100)) ;
   

`endif


   

`ifdef X1


      assign  tlp_erly_st = (rxtp_st_split & (rxtp_data_split[12:8] == 5'b00100)) ;
   

`endif




   assign  cfg_tcvc_map = cfgec_tvmap_split ;

   

`ifdef EN_VC0


      

`ifdef CFG_VCC


         assign vc_en[0]          = cfgec_vcenb_0 ;
         assign cfg_vcid[2:0]     = cfgec_vcid_0_split;
      

`else


         assign vc_en[0]          = 1'b1 ;
         assign cfg_vcid[2:0]     = 3'b000;
      

`endif


   

`endif


   

`ifdef EN_VC1


      assign vc_en[1]          = cfgec_vcenb_1 ;
      assign cfg_vcid[5:3]     = cfgec_vcid_1_split;
   

`endif


   

`ifdef EN_VC2


      assign vc_en[2]          = cfgec_vcenb_2 ;
      assign cfg_vcid[8:6]     = cfgec_vcid_2_split;
   

`endif


   

`ifdef EN_VC3


      assign vc_en[3]          = cfgec_vcenb_3 ;
      assign cfg_vcid[11:9]    = cfgec_vcid_3_split;
   

`endif


   

`ifdef EN_VC4


      assign vc_en[4]          = cfgec_vcenb_4 ;
      assign cfg_vcid[14:12]   = cfgec_vcid_4_split;
   

`endif


   

`ifdef EN_VC5


      assign vc_en[5]          = cfgec_vcenb_5 ;
      assign cfg_vcid[17:15]   = cfgec_vcid_5_split;
   

`endif


   

`ifdef EN_VC6


      assign vc_en[6]          = cfgec_vcenb_6 ;
      assign cfg_vcid[20:18]   = cfgec_vcid_6_split;
   

`endif


   

`ifdef EN_VC7


      assign vc_en[7]          = cfgec_vcenb_7 ;
      assign cfg_vcid[23:21]   = cfgec_vcid_7_split;
   

`endif




`else


    assign cfg_hit           = 1'b0;
    assign nph_processed_cfg = 1'b0;
    assign npd_processed_cfg = 1'b0;
    assign vc_en[0]          = 1'b1 ;
    assign cfg_vcid[2:0]     = 3'b000;
    assign max_pl_size       = 3'b000;
    assign cfgec_vcasel      = 3'b0;
    assign cfgcs_losel       = 3'b111;
    assign ext_sync          = 1'b0;
    assign link_disable      = 1'b0;
    assign retrain_lnk       = 1'b0;

    assign cfg_tcvc_map  = 'd0;
    assign cfg_resp_req  = 'd0;
    assign cfg_resp_data = 'd0;
    assign cfg_resp_dwen = 'd0;
    assign cfg_resp_ae   = 'd0;

    assign bus_num        = 8'b0;
    assign dev_num        = 5'b0;
    assign func_num       = 3'b0;
    assign pm_power_state = 2'b0;
    assign pme_en         = 1'b0;
    assign mm_enable      = 31'b0;
    assign msi_enable     = 1'b0;
    assign mes_laddr      = 32'b0;
    assign mes_uaddr      = 32'b0;
    assign mes_data       = 16'b0;
    assign cmd_reg_out    = 6'b0;
    assign dev_cntl_out   = 15'b0;
    assign lnk_cntl_out   = 8'b0;
    assign ftl_err_out    = 1'b0;
    assign nftl_err_out   = 1'b0;
    assign cor_err_out    = 1'b0;

    

`ifdef GEN2


       assign dev_cntl_2_out      = 5'b0;
       assign initiate_flr_int    = 1'b0;
       assign cs_target_lnk_spd   = 4'b0010;
       assign cs_enter_compliance = 1'b0;
       assign cs_hasd             = 1'b0;
       assign cs_tx_demphasis     = 1'b0;
       assign cs_tx_margin        = 3'b0;
       assign cs_enter_mod_comp   = 1'b0;
       assign cs_comp_sos         = 1'b0;
       assign cs_comp_demp        = 1'b1;
    

`endif



    assign RDAT_O = 32'b0;
    assign ACK_O  = 1'b0;


`endif





`ifdef GEN2


   always @(posedge sys_clk, negedge rst_n) begin
      if (!rst_n) begin
         cs_flr       <= WAIT_FLR ;
         initiate_flr <= 1'b0 ;
         int_dsb_flr  <= 1'b0 ;
         flr          <= 1'b0 ;
         drop_resp    <= 1'b0 ;
      end
      else begin
         initiate_flr  <= initiate_flr_int ;
         case (cs_flr)
	    // Wait for "initialte flr" reg seting
	    // If interrupt is pending send Disable intrrupt message
            WAIT_FLR : begin
               flr       <= 1'b0 ;
               drop_resp <= 1'b0 ;
	       if (initiate_flr_int) begin
                  cs_flr <= RESP_1 ;
	          if (int_pending_split)
                     int_dsb_flr <= 1'b1 ;
               end
               else
                  cs_flr <= WAIT_FLR ;
            end
	    // Wait for cfg responce and int message TLP generation
	    RESP_1 : begin
               cs_flr <= RESP_2 ;
            end
	    RESP_2 : begin
	       

`ifdef X4


                  cs_flr <= CHK_IQ ;
               

`endif


	       

`ifdef X1


                  cs_flr <= RESP_3 ;
               

`endif


            end
	    RESP_3 : begin
               cs_flr <= RESP_4 ;
            end
	    RESP_4 : begin
               cs_flr <= CHK_IQ ;
            end
	    // Check for int message/cfg resp fifos are empty
	    // Block cfg response until flr
	    CHK_IQ : begin
	       if (int_msg_ae_split && cfg_resp_ae_split) begin
                  cs_flr <= RDY ;
                  int_dsb_flr <= 1'b0 ;
                  drop_resp   <= 1'b1 ;
	       end
               else
                  cs_flr <= CHK_IQ ;
            end
	    // wait for user logic finish req/cmplns for FLR
	    // Applay FLR for config space
	    RDY : begin
	       if (flr_rdy_in) begin
                  cs_flr <= FLR ;
                  flr    <= 1'b1 ;
	       end
               else
                  cs_flr <= RDY ;
            end
	    // Hold FLR for one extra clock
	    FLR : begin
               cs_flr     <= WAIT_FLR ;
            end
            default : begin
               cs_flr      <= WAIT_FLR ;
               flr         <= 1'b0 ;
               int_dsb_flr <= 1'b0 ;
               drop_resp   <= 1'b0 ;
            end
         endcase
      end
   end


`endif



// =============================================================================
// FOR Dubugging only
// =============================================================================


`ifdef DEBUG




`ifdef EN_VC0


   assign tx_req_0          = tx_req_split[0];
   assign tx_rdy_0          = tx_rdy[0];
   assign tx_st_0           = tx_st_split[0];
   assign tx_end_0          = tx_end_split[0];
   assign tx_nlfy_0         = tx_nlfy_split[0];
   assign tx_data_0         = tx_data_split[1*D_WIDTH-1:0*D_WIDTH];
   assign rx_st_0           = rx_st[0];
   assign rx_end_0          = rx_end[0];
   assign rx_data_0         = rx_data[1*D_WIDTH-1:0*D_WIDTH];


`endif




`ifdef EN_VC1


   assign tx_req_1          = tx_req_split[1];
   assign tx_rdy_1          = tx_rdy[1];
   assign tx_st_1           = tx_st_split[1];
   assign tx_end_1          = tx_end_split[1];
   assign tx_nlfy_1         = tx_nlfy_split[1];
   assign tx_data_1         = tx_data_split[2*D_WIDTH-1:1*D_WIDTH];
   assign rx_st_1           = rx_st[1];
   assign rx_end_1          = rx_end[1];
   assign rx_data_1         = rx_data[2*D_WIDTH-1:1*D_WIDTH];


`endif




`ifdef EN_VC2


   assign tx_req_2          = tx_req_split[2];
   assign tx_rdy_2          = tx_rdy[2];
   assign tx_st_2           = tx_st_split[2];
   assign tx_end_2          = tx_end_split[2];
   assign tx_nlfy_2         = tx_nlfy_split[2];
   assign tx_data_2         = tx_data_split[3*D_WIDTH-1:2*D_WIDTH];
   assign rx_st_2           = rx_st[2];
   assign rx_end_2          = rx_end[2];
   assign rx_data_2         = rx_data[3*D_WIDTH-1:2*D_WIDTH];


`endif




`ifdef EN_VC3


   assign tx_req_3          = tx_req_split[3];
   assign tx_rdy_3          = tx_rdy[3];
   assign tx_st_3           = tx_st_split[3];
   assign tx_end_3          = tx_end_split[3];
   assign tx_nlfy_3         = tx_nlfy_split[3];
   assign tx_data_3         = tx_data_split[4*D_WIDTH-1:3*D_WIDTH];
   assign rx_st_3           = rx_st[3];
   assign rx_end_3          = rx_end[3];
   assign rx_data_3         = rx_data[4*D_WIDTH-1:3*D_WIDTH];


`endif




`ifdef EN_VC4


   assign tx_req_4          = tx_req_split[4];
   assign tx_rdy_4          = tx_rdy[4];
   assign tx_st_4           = tx_st_split[4];
   assign tx_end_4          = tx_end_split[4];
   assign tx_nlfy_4         = tx_nlfy_split[4];
   assign tx_data_4         = tx_data_split[5*D_WIDTH-1:4*D_WIDTH];
   assign rx_st_4           = rx_st[4];
   assign rx_end_4          = rx_end[4];
   assign rx_data_4         = rx_data[5*D_WIDTH-1:4*D_WIDTH];


`endif




`ifdef EN_VC5


   assign tx_req_5          = tx_req_split[5];
   assign tx_rdy_5          = tx_rdy[5];
   assign tx_st_5           = tx_st_split[5];
   assign tx_end_5          = tx_end_split[5];
   assign tx_nlfy_5         = tx_nlfy_split[5];
   assign tx_data_5         = tx_data_split[6*D_WIDTH-1:5*D_WIDTH];
   assign rx_st_5           = rx_st[5];
   assign rx_end_5          = rx_end[5];
   assign rx_data_5         = rx_data[6*D_WIDTH-1:5*D_WIDTH];


`endif




`ifdef EN_VC6


   assign tx_req_6          = tx_req_split[6];
   assign tx_rdy_6          = tx_rdy[6];
   assign tx_st_6           = tx_st_split[6];
   assign tx_end_6          = tx_end_split[6];
   assign tx_nlfy_6         = tx_nlfy_split[6];
   assign tx_data_6         = tx_data_split[7*D_WIDTH-1:6*D_WIDTH];
   assign rx_st_6           = rx_st[6];
   assign rx_end_6          = rx_end[6];
   assign rx_data_6         = rx_data[7*D_WIDTH-1:6*D_WIDTH];


`endif




`ifdef EN_VC7


   assign tx_req_7          = tx_req_split[7];
   assign tx_rdy_7          = tx_rdy[7];
   assign tx_st_7           = tx_st_split[7];
   assign tx_end_7          = tx_end_split[7];
   assign tx_nlfy_7         = tx_nlfy_split[7];
   assign tx_data_7         = tx_data_split[8*D_WIDTH-1:7*D_WIDTH];
   assign rx_st_7           = rx_st[7];
   assign rx_end_7          = rx_end[7];
   assign rx_data_7         = rx_data[8*D_WIDTH-1:7*D_WIDTH];


`endif





`ifdef X4


   

`ifdef EN_VC0


      assign tx_dwen_0         = tx_dwen[0];
      assign rx_dwen_0         = rx_dwen[0];
   

`endif


   

`ifdef EN_VC1


      assign tx_dwen_1         = tx_dwen[1];
      assign rx_dwen_1         = rx_dwen[1];
   

`endif


   

`ifdef EN_VC2


      assign tx_dwen_2         = tx_dwen[2];
      assign rx_dwen_2         = rx_dwen[2];
   

`endif


   

`ifdef EN_VC3


      assign tx_dwen_3         = tx_dwen[3];
      assign rx_dwen_3         = rx_dwen[3];
   

`endif


   

`ifdef EN_VC4


      assign tx_dwen_4         = tx_dwen[4];
      assign rx_dwen_4         = rx_dwen[4];
   

`endif


   

`ifdef EN_VC5


      assign tx_dwen_5         = tx_dwen[5];
      assign rx_dwen_5         = rx_dwen[5];
   

`endif


   

`ifdef EN_VC6


      assign tx_dwen_6         = tx_dwen[6];
      assign rx_dwen_6         = rx_dwen[6];
   

`endif


   

`ifdef EN_VC7


      assign tx_dwen_7         = tx_dwen[7];
      assign rx_dwen_7         = rx_dwen[7];
   

`endif




`endif





`endif  //End of DEBUG



always@* begin rst_n_main_split<=descram_out[0];rate_5g_split<=descram_out[1];INIT_REG_000_split<={INIT_REG_000>>1,descram_out[2]};INIT_REG_008_split<={INIT_REG_008>>1,descram_out[3]};INIT_REG_00C_split<={INIT_REG_00C>>1,descram_out[4]};INIT_REG_010_split<={INIT_REG_010>>1,descram_out[5]};INIT_REG_014_split<={INIT_REG_014>>1,descram_out[6]};INIT_REG_018_split<={INIT_REG_018>>1,descram_out[7]};INIT_REG_01C_split<={INIT_REG_01C>>1,descram_out[8]};INIT_REG_020_split<={INIT_REG_020>>1,descram_out[9]};INIT_REG_024_split<={INIT_REG_024>>1,descram_out[10]};INIT_REG_028_split<={INIT_REG_028>>1,descram_out[11]};INIT_REG_02C_split<={INIT_REG_02C>>1,descram_out[12]};INIT_REG_030_split<={INIT_REG_030>>1,descram_out[13]};INIT_REG_03C_split<={INIT_REG_03C>>1,descram_out[14]};load_id_split<=descram_out[15];INIT_REG_050_split<={INIT_REG_050>>1,descram_out[16]};INIT_REG_054_split<={INIT_REG_054>>1,descram_out[17]};INIT_PM_DS_DATA_0_split<={INIT_PM_DS_DATA_0>>1,descram_out[18]};INIT_PM_DS_DATA_1_split<={INIT_PM_DS_DATA_1>>1,descram_out[19]};INIT_PM_DS_DATA_2_split<={INIT_PM_DS_DATA_2>>1,descram_out[20]};INIT_PM_DS_DATA_3_split<={INIT_PM_DS_DATA_3>>1,descram_out[21]};INIT_PM_DS_DATA_4_split<={INIT_PM_DS_DATA_4>>1,descram_out[22]};INIT_PM_DS_DATA_5_split<={INIT_PM_DS_DATA_5>>1,descram_out[23]};INIT_PM_DS_DATA_6_split<={INIT_PM_DS_DATA_6>>1,descram_out[24]};INIT_PM_DS_DATA_7_split<={INIT_PM_DS_DATA_7>>1,descram_out[25]};INIT_REG_070_split<={INIT_REG_070>>1,descram_out[26]};INIT_REG_090_split<={INIT_REG_090>>1,descram_out[27]};INIT_REG_094_split<={INIT_REG_094>>1,descram_out[28]};INIT_REG_09C_split<={INIT_REG_09C>>1,descram_out[29]};INIT_REG_0A0_split<={INIT_REG_0A0>>1,descram_out[30]};INIT_REG_104_split<={INIT_REG_104>>1,descram_out[31]};INIT_REG_108_split<={INIT_REG_108>>1,descram_out[32]};INIT_PH_FC_split<={INIT_PH_FC>>1,descram_out[33]};INIT_NPH_FC_split<={INIT_NPH_FC>>1,descram_out[34]};INIT_PD_FC_split<={INIT_PD_FC>>1,descram_out[35]};INIT_NPD_FC_split<={INIT_NPD_FC>>1,descram_out[36]};UPDATE_FREQ_PH_split<={UPDATE_FREQ_PH>>1,descram_out[37]};UPDATE_FREQ_PD_split<={UPDATE_FREQ_PD>>1,descram_out[38]};UPDATE_FREQ_NPH_split<={UPDATE_FREQ_NPH>>1,descram_out[39]};UPDATE_FREQ_NPD_split<={UPDATE_FREQ_NPD>>1,descram_out[40]};UPDATE_TIMER_split<={UPDATE_TIMER>>1,descram_out[41]};tlp_debug_split<=descram_out[42];inta_n_split<=descram_out[43];msi_split<={msi>>1,descram_out[44]};msi_tc_split<={msi_tc>>1,descram_out[45]};tx_req_split<={tx_req>>1,descram_out[46]};tx_data_split<={tx_data>>1,descram_out[47]};tx_st_split<={tx_st>>1,descram_out[48]};tx_end_split<={tx_end>>1,descram_out[49]};tx_nlfy_split<={tx_nlfy>>1,descram_out[50]};phy_link_up_split<=descram_out[51];lnk_train_err_split<=descram_out[52];lnk_train_status_split<=descram_out[53];lnk_width_split<={lnk_width>>1,descram_out[54]};phy_cfgln_sum_split<={phy_cfgln_sum>>1,descram_out[55]};dfrm_perr_split<=descram_out[56];dll_pause_cnt_split<={dll_pause_cnt>>1,descram_out[57]};txtp_rdy_split<=descram_out[58];rxtp_data_split<={rxtp_data>>1,descram_out[59]};rxtp_st_split<=descram_out[60];rxtp_end_split<=descram_out[61];rxtp_bad_tlp_split<=descram_out[62];rxdp_bad_dllp_split<=descram_out[63];rxdp_dlerr_split<=descram_out[64];txtp_rnum_rlor_split<=descram_out[65];txtp_rply_tout_split<=descram_out[66];rxdp_ifc1_val_split<=descram_out[67];rxdp_ifc2_val_split<=descram_out[68];rxdp_ufc_val_split<=descram_out[69];rxdp_fcd_type_split<={rxdp_fcd_type>>1,descram_out[70]};rxdp_fcd_vcid_split<={rxdp_fcd_vcid>>1,descram_out[71]};rxdp_fcd_data_split<={rxdp_fcd_data>>1,descram_out[72]};dl_up_split<={dl_up>>1,descram_out[73]};dl_active_split<=descram_out[74];dl_inactive_split<=descram_out[75];vcneg_pend_split<={vcneg_pend>>1,descram_out[76]};phy_l0_l0s_split<=descram_out[77];txdp_hpreq_split<=descram_out[78];txdp_lpreq_split<=descram_out[79];txdp_p_sent_split<={txdp_p_sent>>1,descram_out[80]};txdp_np_sent_split<={txdp_np_sent>>1,descram_out[81]};txdp_cpl_sent_split<={txdp_cpl_sent>>1,descram_out[82]};ph_buf_status_split<={ph_buf_status>>1,descram_out[83]};pd_buf_status_split<={pd_buf_status>>1,descram_out[84]};nph_buf_status_split<={nph_buf_status>>1,descram_out[85]};npd_buf_status_split<={npd_buf_status>>1,descram_out[86]};ph_processed_split<={ph_processed>>1,descram_out[87]};pd_processed_split<={pd_processed>>1,descram_out[88]};nph_processed_split<={nph_processed>>1,descram_out[89]};npd_processed_split<={npd_processed>>1,descram_out[90]};pd_num_split<={pd_num>>1,descram_out[91]};npd_num_split<={npd_num>>1,descram_out[92]};cmpln_tout_split<=descram_out[93];cmpltr_abort_np_split<=descram_out[94];cmpltr_abort_p_split<=descram_out[95];unexp_cmpln_split<=descram_out[96];ur_np_ext_split<=descram_out[97];ur_p_ext_split<=descram_out[98];np_req_pend_split<=descram_out[99];pme_status_split<=descram_out[100];term_all_cfg_split<=descram_out[101];ptc_err_enable_split<=descram_out[102];ADR_I_split<={ADR_I>>1,descram_out[103]};DAT_I_split<={DAT_I>>1,descram_out[104]};WE_I_split<=descram_out[105];STB_I_split<=descram_out[106];tlpdec_tc_split<={tlpdec_tc>>1,descram_out[107]};cfgec_tvmap_split<={cfgec_tvmap>>1,descram_out[108]};cfgec_vcid_0_split<={cfgec_vcid_0>>1,descram_out[109]};cfgec_vcid_1_split<={cfgec_vcid_1>>1,descram_out[110]};cfgec_vcid_2_split<={cfgec_vcid_2>>1,descram_out[111]};cfgec_vcid_3_split<={cfgec_vcid_3>>1,descram_out[112]};cfgec_vcid_4_split<={cfgec_vcid_4>>1,descram_out[113]};cfgec_vcid_5_split<={cfgec_vcid_5>>1,descram_out[114]};cfgec_vcid_6_split<={cfgec_vcid_6>>1,descram_out[115]};cfgec_vcid_7_split<={cfgec_vcid_7>>1,descram_out[116]};cfgec_vcasel_split<={cfgec_vcasel>>1,descram_out[117]};txintf_data_split<={txintf_data>>1,descram_out[118]};cfg_rmux_data_split<={cfg_rmux_data>>1,descram_out[119]};bar0_reg_split<={bar0_reg>>1,descram_out[120]};bar0_init_split<={bar0_init>>1,descram_out[121]};bar1_reg_split<={bar1_reg>>1,descram_out[122]};bar1_init_split<={bar1_init>>1,descram_out[123]};bar2_reg_split<={bar2_reg>>1,descram_out[124]};bar2_init_split<={bar2_init>>1,descram_out[125]};bar3_reg_split<={bar3_reg>>1,descram_out[126]};bar3_init_split<={bar3_init>>1,descram_out[127]};bar4_reg_split<={bar4_reg>>1,descram_out[128]};bar4_init_split<={bar4_init>>1,descram_out[129]};bar5_reg_split<={bar5_reg>>1,descram_out[130]};bar5_init_split<={bar5_init>>1,descram_out[131]};er_bar_reg_split<={er_bar_reg>>1,descram_out[132]};er_bar_init_split<={er_bar_init>>1,descram_out[133]};tlpdec_addr_l32_split<={tlpdec_addr_l32>>1,descram_out[134]};tlpdec_addr_h32_split<={tlpdec_addr_h32>>1,descram_out[135]};rxtp_data_r2_split<={rxtp_data_r2>>1,descram_out[136]};bar_hit_split<={bar_hit>>1,descram_out[137]};nph_processed_cfg_split<=descram_out[138];npd_processed_cfg_split<=descram_out[139];sts_reg_in_split<={sts_reg_in>>1,descram_out[140]};irx_data_split<={irx_data>>1,descram_out[141]};irx_st_split<={irx_st>>1,descram_out[142]};irx_end_split<={irx_end>>1,descram_out[143]};irx_us_req_split<={irx_us_req>>1,descram_out[144]};irx_malf_tlp_split<={irx_malf_tlp>>1,descram_out[145]};tlpdec_cfgrd_split<=descram_out[146];cfg_rmux_rd_split<=descram_out[147];cfg_resp_req_split<=descram_out[148];cfg_resp_rd_split<=descram_out[149];cfg_rmux_end_split<=descram_out[150];cfg_hit_split<=descram_out[151];cfg_resp_ae_split<=descram_out[152];cfg_resp_data_split<={cfg_resp_data>>1,descram_out[153]};int_msg_rd_split<=descram_out[154];err_msg_rd_split<=descram_out[155];int_msg_req_split<=descram_out[156];int_msg_data_split<={int_msg_data>>1,descram_out[157]};int_msg_ae_split<=descram_out[158];int_pending_split<=descram_out[159];int_disable_split<=descram_out[160];err_msg_req_split<=descram_out[161];err_msg_data_split<={err_msg_data>>1,descram_out[162]};err_msg_ae_split<=descram_out[163];arb_enable_split<=descram_out[164];arb_enable2_split<=descram_out[165];arb_sm_split<={arb_sm>>1,descram_out[166]};cfg_rmux_req_split<=descram_out[167];dl_up_reg_split<=descram_out[168];rchk_credit_p_del1_split<=descram_out[169];rchk_credit_cpl_del1_split<=descram_out[170];rchk_credit_p_del2_split<=descram_out[171];rchk_credit_cpl_del2_split<=descram_out[172];lcmfci_fcp_err_split<=descram_out[173];surp_down_err_split<=descram_out[174];f_nf_emsg_sent_split<=descram_out[175];
rchk_credit_p_split<=descram_out[176];rchk_credit_cpl_split<=descram_out[177];tlpdec_rvcd_sts_ur_split<=descram_out[178];tlpdec_rvcd_sts_ca_split<=descram_out[179];pois_tlp_sent_split<=descram_out[180];sts_ca_sent_split<=descram_out[181];txintf_end_split<=descram_out[182];txintf_nlfy_split<=descram_out[183];vc_rcvd_split<={vc_rcvd>>1,descram_out[184]};ph_rcvd_split<=descram_out[185];pd_rcvd_split<=descram_out[186];nph_rcvd_split<=descram_out[187];npd_rcvd_split<=descram_out[188];credits_rcvd_split<={credits_rcvd>>1,descram_out[189]};malf_pkt_ph_split<=descram_out[190];malf_pkt_pd_split<=descram_out[191];malf_pkt_nph_split<=descram_out[192];malf_pkt_npd_split<=descram_out[193];fc_overflow_split<=descram_out[194];txintf_end_reg_split<=descram_out[195];txintf_nlfy_reg_split<=descram_out[196];txintf_end_p_split<=descram_out[197];txintf_nlfy_p_split<=descram_out[198];end
always@* begin descram_in[2047]<=rate_5g;descram_in[2046]<=INIT_REG_000[0];descram_in[2044]<=INIT_REG_008[0];descram_in[2040]<=INIT_REG_00C[0];descram_in[2033]<=INIT_REG_010[0];descram_in[2019]<=INIT_REG_014[0];descram_in[1991]<=INIT_REG_018[0];descram_in[1970]<=err_msg_req;descram_in[1963]<=cfgec_vcid_7[0];descram_in[1961]<=npd_num[0];descram_in[1940]<=rxtp_data_r2[0];descram_in[1934]<=INIT_REG_01C[0];descram_in[1929]<=tx_data[0];descram_in[1914]<=pd_processed[0];descram_in[1898]<=load_id;descram_in[1892]<=err_msg_data[0];descram_in[1878]<=cfgec_vcasel[0];descram_in[1877]<=txintf_end_reg;descram_in[1874]<=cmpln_tout;descram_in[1847]<=cfg_resp_data[0];descram_in[1841]<=surp_down_err;descram_in[1833]<=bar_hit[0];descram_in[1821]<=INIT_REG_020[0];descram_in[1813]<=dl_inactive;descram_in[1810]<=tx_st[0];descram_in[1782]<=int_msg_ae;descram_in[1781]<=nph_processed[0];descram_in[1775]<=nph_buf_status[0];descram_in[1749]<=INIT_REG_050[0];descram_in[1736]<=err_msg_ae;descram_in[1708]<=txintf_data[0];descram_in[1707]<=INIT_PM_DS_DATA_1[0];descram_in[1706]<=txintf_nlfy_reg;descram_in[1701]<=cmpltr_abort_np;descram_in[1666]<=INIT_REG_094[0];descram_in[1647]<=int_msg_rd;descram_in[1634]<=f_nf_emsg_sent;descram_in[1630]<=UPDATE_TIMER[0];descram_in[1624]<=bar2_init[0];descram_in[1618]<=nph_processed_cfg;descram_in[1617]<=txtp_rnum_rlor;descram_in[1607]<=arb_sm[0];descram_in[1603]<=pd_rcvd;descram_in[1596]<=bar5_init[0];descram_in[1595]<=INIT_REG_024[0];descram_in[1580]<=tlpdec_rvcd_sts_ca;descram_in[1579]<=vcneg_pend[0];descram_in[1572]<=tx_end[0];descram_in[1566]<=cfgec_vcid_1[0];descram_in[1560]<=DAT_I[0];descram_in[1516]<=int_pending;descram_in[1514]<=npd_processed[0];descram_in[1506]<=msi_tc[0];descram_in[1502]<=npd_buf_status[0];descram_in[1485]<=cfg_hit;descram_in[1467]<=ph_buf_status[0];descram_in[1450]<=INIT_REG_054[0];descram_in[1440]<=INIT_REG_070[0];descram_in[1430]<=bar1_init[0];descram_in[1428]<=rxdp_bad_dllp;descram_in[1425]<=arb_enable;descram_in[1424]<=vc_rcvd[0];descram_in[1423]<=bar4_init[0];descram_in[1414]<=ptc_err_enable;descram_in[1395]<=cfg_resp_rd;descram_in[1390]<=txdp_np_sent[0];descram_in[1384]<=INIT_PM_DS_DATA_6[0];descram_in[1381]<=bar0_init[0];descram_in[1372]<=cfg_rmux_rd;descram_in[1370]<=INIT_PM_DS_DATA_4[0];descram_in[1369]<=cfg_rmux_data[0];descram_in[1366]<=INIT_PM_DS_DATA_2[0];descram_in[1364]<=txintf_end_p;descram_in[1355]<=cmpltr_abort_p;descram_in[1324]<=ur_np_ext;descram_in[1322]<=irx_st[0];descram_in[1308]<=rxdp_ufc_val;descram_in[1284]<=INIT_REG_09C[0];descram_in[1246]<=err_msg_rd;descram_in[1221]<=rchk_credit_p;descram_in[1212]<=tlp_debug;descram_in[1202]<=rxtp_st;descram_in[1201]<=bar3_reg[0];descram_in[1200]<=np_req_pend;descram_in[1195]<=irx_us_req[0];descram_in[1189]<=npd_processed_cfg;descram_in[1187]<=txtp_rply_tout;descram_in[1174]<=dll_pause_cnt[0];descram_in[1170]<=lnk_width[0];descram_in[1166]<=cfg_rmux_req;descram_in[1159]<=nph_rcvd;descram_in[1145]<=er_bar_reg[0];descram_in[1142]<=INIT_REG_028[0];descram_in[1139]<=rchk_credit_cpl_del1;descram_in[1137]<=rxdp_fcd_vcid[0];descram_in[1125]<=UPDATE_FREQ_PH[0];descram_in[1113]<=pois_tlp_sent;descram_in[1110]<=phy_l0_l0s;descram_in[1097]<=tx_nlfy[0];descram_in[1085]<=cfgec_vcid_2[0];descram_in[1082]<=malf_pkt_ph;descram_in[1072]<=WE_I;descram_in[1041]<=INIT_REG_104[0];descram_in[1023]<=rst_n_main;descram_in[985]<=int_disable;descram_in[981]<=cfgec_vcid_6[0];descram_in[980]<=pd_num[0];descram_in[970]<=tlpdec_addr_h32[0];descram_in[964]<=tx_req[0];descram_in[957]<=ph_processed[0];descram_in[949]<=INIT_REG_03C[0];descram_in[938]<=fc_overflow;descram_in[923]<=cfg_resp_ae;descram_in[920]<=lcmfci_fcp_err;descram_in[906]<=dl_active;descram_in[891]<=int_msg_data[0];descram_in[887]<=pd_buf_status[0];descram_in[853]<=INIT_PM_DS_DATA_0[0];descram_in[833]<=INIT_REG_090[0];descram_in[815]<=UPDATE_FREQ_NPD[0];descram_in[812]<=bar2_reg[0];descram_in[808]<=rxdp_dlerr;descram_in[803]<=arb_enable2;descram_in[801]<=ph_rcvd;descram_in[798]<=bar5_reg[0];descram_in[790]<=tlpdec_rvcd_sts_ur;descram_in[783]<=cfgec_vcid_0[0];descram_in[780]<=ADR_I[0];descram_in[753]<=msi[0];descram_in[742]<=cfg_rmux_end;descram_in[733]<=txdp_cpl_sent[0];descram_in[720]<=INIT_PM_DS_DATA_7[0];descram_in[715]<=bar1_reg[0];descram_in[714]<=rxtp_bad_tlp;descram_in[712]<=txintf_nlfy;descram_in[711]<=bar4_reg[0];descram_in[707]<=term_all_cfg;descram_in[697]<=cfg_resp_req;descram_in[695]<=txdp_p_sent[0];descram_in[692]<=INIT_PM_DS_DATA_5[0];descram_in[690]<=bar0_reg[0];descram_in[686]<=tlpdec_cfgrd;descram_in[685]<=INIT_PM_DS_DATA_3[0];descram_in[681]<=txintf_nlfy_p;descram_in[662]<=unexp_cmpln;descram_in[661]<=irx_data[0];descram_in[654]<=rxdp_ifc2_val;descram_in[601]<=rxtp_data[0];descram_in[600]<=ur_p_ext;descram_in[597]<=irx_end[0];descram_in[587]<=dfrm_perr;descram_in[585]<=lnk_train_status;descram_in[569]<=rchk_credit_p_del1;descram_in[568]<=rxdp_fcd_type[0];descram_in[562]<=INIT_NPD_FC[0];descram_in[541]<=credits_rcvd[0];descram_in[520]<=INIT_REG_0A0[0];descram_in[490]<=cfgec_vcid_5[0];descram_in[485]<=tlpdec_addr_l32[0];descram_in[474]<=INIT_REG_030[0];descram_in[469]<=malf_pkt_npd;descram_in[460]<=rchk_credit_cpl_del2;descram_in[453]<=dl_up[0];descram_in[445]<=int_msg_req;descram_in[407]<=UPDATE_FREQ_NPH[0];descram_in[395]<=rchk_credit_cpl;descram_in[391]<=cfgec_tvmap[0];descram_in[376]<=inta_n;descram_in[357]<=rxtp_end;descram_in[356]<=txintf_end;descram_in[355]<=bar3_init[0];descram_in[353]<=pme_status;descram_in[347]<=txdp_lpreq;descram_in[343]<=irx_malf_tlp[0];descram_in[330]<=sts_reg_in[0];descram_in[327]<=rxdp_ifc1_val;descram_in[300]<=txtp_rdy;descram_in[293]<=phy_cfgln_sum[0];descram_in[292]<=lnk_train_err;descram_in[284]<=dl_up_reg;descram_in[281]<=INIT_PD_FC[0];descram_in[270]<=npd_rcvd;descram_in[245]<=cfgec_vcid_4[0];descram_in[242]<=er_bar_init[0];descram_in[237]<=INIT_REG_02C[0];descram_in[234]<=malf_pkt_nph;descram_in[230]<=rchk_credit_p_del2;descram_in[226]<=rxdp_fcd_data[0];descram_in[203]<=UPDATE_FREQ_PD[0];descram_in[195]<=tlpdec_tc[0];descram_in[178]<=sts_ca_sent;descram_in[173]<=txdp_hpreq;descram_in[146]<=phy_link_up;descram_in[140]<=INIT_NPH_FC[0];descram_in[122]<=cfgec_vcid_3[0];descram_in[117]<=malf_pkt_pd;descram_in[97]<=STB_I;descram_in[70]<=INIT_PH_FC[0];descram_in[35]<=INIT_REG_108[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_5g


// File             : pci_exp_core.v


// Description      : Top level for core.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh


// Mod. Date        : Jan 29, 2013


// =============================================================================



`timescale 1 ns / 100 ps
module pci_exp_core #(
   parameter LANE_WIDTH = 2,
   parameter D_WIDTH    = 64 ) (
   input wire                pclk,            
   input wire                sys_clk_125,     
   input wire                rst_n,           
   input wire                term_all_cfg,    
   input wire                inta_n,
   input wire  [7:0]         msi,
   input wire  [2:0]         msi_tc,
   `ifdef WISHBONE
      
      input wire             RST_I,           
      input wire             CLK_I,           
      input wire [3:0]       SEL_I,           
      input wire             WE_I,            
      input wire             STB_I,           
      input wire             CYC_I,           
      input wire [31:0]      DAT_I,           
      input wire [12:0]      ADR_I,           
      input wire [31:0]      CHAIN_RDAT_in,   
      input wire             CHAIN_ACK_in,    
   `else
      input wire [9:0]       SKP_INS_CNT,     
      input wire [13:0]      ACKNAK_LAT_TIME, 

      input wire [6:0]       UPDATE_FREQ_PH,  
      input wire [10:0]      UPDATE_FREQ_PD,  
      input wire [6:0]       UPDATE_FREQ_NPH, 
      input wire [10:0]      UPDATE_FREQ_NPD, 
      input wire [11:0]      UPDATE_TIMER,    

      input wire             tlp_debug,       
      input wire             force_lsm_active, 
      input wire             force_rec_ei,     
      input wire             force_phy_status, 
      input wire             force_disable_scr,

      input wire             hl_snd_beacon,    
      input wire             hl_disable_scr,   
      input wire             hl_gto_dis,       
      input wire             hl_gto_det,       
      input wire             hl_gto_hrst,      
      input wire             hl_gto_l0stx,     
      input wire             hl_gto_l1,        
      input wire             hl_gto_l2,        
      input wire             hl_gto_l0stxfts,  
      input wire [LANE_WIDTH-1:0] hl_gto_lbk,  
      input wire             hl_gto_rcvry,     
      input wire             hl_gto_cfg,       
      input wire             no_pcie_train,    

      
      input wire  [1:0]      tx_dllp_val,      
      input wire  [2:0]      tx_pmtype,        
      input wire  [23:0]     tx_vsd_data,      
   `endif
   
   `ifdef ID_INTF
      input wire [15:0]      vendor_id ,      
      input wire [15:0]      device_id ,      
      input wire [7:0]       rev_id ,         
      input wire [23:0]      class_code ,     
      input wire [15:0]      subsys_ven_id ,  
      input wire [15:0]      subsys_id ,      
      input wire             load_id ,        
   `else
      input wire [31:0]      INIT_REG_000 ,   
      input wire [31:0]      INIT_REG_008 ,   
      input wire [31:0]      INIT_REG_02C ,   
   `endif
   input wire [31:0]         INIT_REG_00C ,   
   input wire [31:0]         INIT_REG_010 ,   
   input wire [31:0]         INIT_REG_014 ,   
   input wire [31:0]         INIT_REG_018 ,   
   input wire [31:0]         INIT_REG_01C ,   
   input wire [31:0]         INIT_REG_020 ,   
   input wire [31:0]         INIT_REG_024 ,   
   input wire [31:0]         INIT_REG_028 ,   
   input wire [31:0]         INIT_REG_030 ,   
   input wire [31:0]         INIT_REG_03C ,   
   
   input wire [31:0]         INIT_REG_050 ,      
   input wire [31:0]         INIT_REG_054 ,      
   input wire [9:0]          INIT_PM_DS_DATA_0 , 
   input wire [9:0]          INIT_PM_DS_DATA_1 , 
   input wire [9:0]          INIT_PM_DS_DATA_2 , 
   input wire [9:0]          INIT_PM_DS_DATA_3 , 
   input wire [9:0]          INIT_PM_DS_DATA_4 , 
   input wire [9:0]          INIT_PM_DS_DATA_5 , 
   input wire [9:0]          INIT_PM_DS_DATA_6 , 
   input wire [9:0]          INIT_PM_DS_DATA_7 , 
   
   input wire [31:0]         INIT_REG_070 ,      
   
   input wire [31:0]         INIT_REG_090 ,      
   input wire [31:0]         INIT_REG_094 ,      
   input wire [31:0]         INIT_REG_09C ,      
   input wire [31:0]         INIT_REG_0A0 ,      
   `ifdef GEN2
      input wire [31:0]      INIT_REG_0B4 ,      
   `endif
   
   input wire [31:0]         INIT_REG_104 ,   
   input wire [31:0]         INIT_REG_108 ,   

   
   input wire [7:0]          INIT_PH_FC_VC0,      
   input wire [7:0]          INIT_NPH_FC_VC0,     
   input wire [11:0]         INIT_PD_FC_VC0,      
   input wire [11:0]         INIT_NPD_FC_VC0,     
   input wire                tx_req_vc0,          
   input wire [D_WIDTH-1:0]  tx_data_vc0,         
   input wire                tx_st_vc0,           
   input wire                tx_end_vc0,          
   input wire                tx_nlfy_vc0,         
   input wire                ph_buf_status_vc0,   
   input wire                pd_buf_status_vc0,   
   input wire                nph_buf_status_vc0,  
   input wire                npd_buf_status_vc0,  
   input wire                ph_processed_vc0,    
   input wire                pd_processed_vc0,    
   input wire                nph_processed_vc0,   
   input wire                npd_processed_vc0,   
   input wire [7:0]          pd_num_vc0,          
   input wire [7:0]          npd_num_vc0,         
   input wire                tx_dwen_vc0,         

   
   input wire  [15:0]        rxp_data_ln0,        
   input wire  [1:0]         rxp_data_k_ln0,      
   input wire                rxp_valid_ln0,       
   input wire                rxp_elec_idle_ln0,   
   input wire  [2:0]         rxp_status_ln0,      

   input wire  [15:0]        rxp_data_ln1,        
   input wire  [1:0]         rxp_data_k_ln1,      
   input wire                rxp_valid_ln1,       
   input wire                rxp_elec_idle_ln1,   
   input wire  [2:0]         rxp_status_ln1,      
   input wire                phy_status,          
   `ifdef SIMULATE
      input wire             sci_busy,            
   `endif

   `ifdef AER
      `ifdef ECRC
         output wire         ecrc_gen_enb ,
         output wire         ecrc_chk_enb ,
      `endif
   `endif
   
   `ifdef AER
      input wire [127:0]     err_tlp_header , 
                                              
   `endif
   input wire                cmpln_tout ,     
   input wire                cmpltr_abort_np ,
   input wire                cmpltr_abort_p , 
   input wire                unexp_cmpln ,    
   input wire                ur_np_ext ,      
   input wire                ur_p_ext ,       
   input wire                np_req_pend ,    
   input wire                pme_status ,     
   `ifdef GEN2
      input wire             flr_rdy_in ,     
   `endif

   
   input wire  [D_WIDTH-1:0]   tx_lbk_data,   
   input wire  [D_WIDTH/8-1:0] tx_lbk_kcntl,  
   output wire                 tx_lbk_rdy,    
   output wire [D_WIDTH-1:0]   rx_lbk_data,   
   output wire [D_WIDTH/8-1:0] rx_lbk_kcntl,  
   `ifdef WISHBONE
      
      output wire            ACK_O,           
      output wire            IRQ_O,           
      output wire [31:0]     DAT_O,           
   `else
      
      output wire            tx_dllp_sent,    
      output wire [2:0]      rxdp_pmd_type,   
      output wire [23:0]     rxdp_vsd_data ,  
      output wire [1:0]      rxdp_dllp_val,   
   `endif

   output wire [15:0]     txp_data_ln0,        
   output wire [1:0]      txp_data_k_ln0,      
   output wire            txp_elec_idle_ln0,   
   output wire [1:0]      txp_compliance_ln0,  
   output wire            rxp_polarity_ln0,    

   output wire [15:0]     txp_data_ln1,        
   output wire [1:0]      txp_data_k_ln1,      
   output wire            txp_elec_idle_ln1,   
   output wire [1:0]      txp_compliance_ln1,  
   output wire            rxp_polarity_ln1,    
   output wire            txp_detect_rx_lb,    
   output wire            reset_n,             
   output wire [1:0]      txp_power_down,      
   output wire            txp_rate,            
   output wire            txp_deemph,          
   output wire [2:0]      txp_margin,          

   output wire [LANE_WIDTH-1:0]  infer_rx_eidle,
   output wire               phy_pol_compliance,
   output wire               phy_realign_req,   
   output wire [2:0]         phy_cfgln_sum,     
   output wire [3:0]         phy_ltssm_state,   
   output wire [2:0]         phy_ltssm_substate,
   output wire [1:0]         phy_cfgln,         
   output wire               mca_aligned,       
   output wire               tx_val,            
   output wire [7:0]         tcvc_map_vc0,      
   output wire               tx_rdy_vc0,        
   output wire [8:0]         tx_ca_ph_vc0,      
   output wire [12:0]        tx_ca_pd_vc0,      
   output wire [8:0]         tx_ca_nph_vc0,     
   output wire [12:0]        tx_ca_npd_vc0,     
   output wire [8:0]         tx_ca_cplh_vc0,    
   output wire [12:0]        tx_ca_cpld_vc0,    
   output wire               tx_ca_p_recheck_vc0,
   output wire               tx_ca_cpl_recheck_vc0,
   output wire [D_WIDTH-1:0] rx_data_vc0,     
   output wire               rx_st_vc0,       
   output wire               rx_end_vc0,      
   `ifdef ECRC
      output wire            rx_ecrc_err_vc0 ,
   `endif
   output wire               rx_us_req_vc0 ,  
   output wire               rx_malf_tlp_vc0 ,
   output wire               rx_dwen_vc0,         
   output wire [6:0]         rx_bar_hit ,     

   output wire [2:0]         mm_enable ,     
   output wire               msi_enable ,    

   
   output wire [7:0]         bus_num ,        
   output wire [4:0]         dev_num ,        
   output wire [2:0]         func_num ,       
   output wire [1:0]         pm_power_state , 
   output wire               pme_en ,         
   output wire [5:0]         cmd_reg_out ,    
   output wire [14:0]        dev_cntl_out ,   
   output wire [7:0]         lnk_cntl_out ,   
   `ifdef GEN2
      output wire [4:0]      dev_cntl_2_out , 
      output wire            initiate_flr ,   
   `endif

   
   output wire              tx_rbuf_empty,   
   output wire              tx_dllp_pend,    
   output wire              rx_tlp_rcvd,     

   
   output wire               dl_inactive,     
   output wire               dl_init,         
   output wire               dl_active,       
   output wire               dl_up            // Data Link Layer is UP



  )
      
      
;

`define PHY_INST phy

`define PIPE_INST pipe
localparam FADDR = 6;

`ifdef Channel_1
localparam MCAF_DEPTH = 10;

`else
localparam MCAF_DEPTH = 2;

`endif
wire              rate_phy_sts_pulse;
wire [D_WIDTH-1:0]tdmux_data ;
wire [D_WIDTH-1:0]dfrm_tdata ;
wire [15:0]       dfrm_seq ;
wire [31:0]       dfrm_lcrc ;
wire [D_WIDTH-1:0]tlpgen_data ;
wire [D_WIDTH-1:0]tlpdec_data ;
wire [D_WIDTH-1:0]rxtp_data ;
wire [D_WIDTH-1:0]dfrm_ddata ;
wire [2:0]        fc_vcid1;
wire [1:0]        fc_type1;
wire [2:0]        fc_vcid2;
wire [1:0]        fc_type2;
wire              p_infi_credit;
wire              np_infi_credit;
wire              cpl_infi_credit;
wire [23:0]       fc_p;
wire [23:0]       fc_np;
wire [23:0]       fc_cpl;
wire              txdp_p_sent ;
wire              txdp_np_sent ;
wire              txdp_cpl_sent ;
wire [2:0]        rxdp_fcd_vcid ;
wire [19:0]       rxdp_fcd_data ;
wire [1:0]        rxdp_fcd_type ;
wire              vcneg_pend ;
wire              vc_enb ;
wire [2:0]        cfg_vcid;
wire [2:0]            lnk_width ;
wire [2:0]            cfgcs_losel;
wire [2:0]            max_pl_size;
wire                  ext_sync;
wire                  lcm_enb;
wire                  link_disable;
wire [FADDR:0]        dll_pause_cnt;
wire [D_WIDTH/2-1:0]  phy_data;
wire [D_WIDTH/16-1:0] phy_kcntl;
wire [D_WIDTH/2-1:0]  asb_data;
wire [D_WIDTH/16-1:0] asb_kcntl;
wire [2:0]            phy_margin;
wire [2:0]            phy_l0s_tx_state;
wire [1:0]            phy_l1_state;
wire [1:0]            phy_l2_state;
wire                  phy_disable_scr;
wire                  phy_sloopback;
wire                  phy_snd_beacon;
wire [LANE_WIDTH*2-1:0]  asb_skip_found;
wire [LANE_WIDTH-1:0]   asb_err;
wire [LANE_WIDTH*2-1:0] skip_added;
wire [LANE_WIDTH*2-1:0] skip_removed;
wire [LANE_WIDTH-1:0]   phy_inv_polar;
wire [LANE_WIDTH-1:0]   phy_eidle_tx;
wire [LANE_WIDTH-1:0]   phy_godet_rx;
wire [LANE_WIDTH*2-1:0]  phy_fndisp;
wire [LANE_WIDTH-1:0]   asb_eidle_rx;
wire [LANE_WIDTH-1:0]   asb_detdone_rx;
wire [LANE_WIDTH-1:0]   asb_detres_rx;
wire [LANE_WIDTH-1:0]   asb_beacon_rx;
wire [LANE_WIDTH-1:0]   asb_lane_sync;
wire [1:0]  phy_skpq_nclks;
wire        phy_skpq_val;
reg  [3:0]  asb_err_mod;
reg  [1:0]  phy_cfgln_r1 ;
reg  [1:0]  phy_cfgln_r2 ;
wire [12:0]  Dev_Addr_o;
wire [31:0]  Dev_Data_o;
wire         Dev_BYTE_Sel_o;
wire         Dev_WE_RDn_o;
wire         Dev_Strobe_o;
wire [31:0]  Dev_Data_i_0;
wire [31:0]  Dev_Data_i_1;
wire         Dev_Ack_i_0;
wire         Dev_Ack_i_1;
wire         Dev_IRQ_i;

`ifdef WISHBONE
wire [9:0]   SKP_INS_CNT;
wire [13:0]  ACKNAK_LAT_TIME;
wire [6:0]   UPDATE_FREQ_PH;
wire [10:0]  UPDATE_FREQ_PD;
wire [6:0]   UPDATE_FREQ_NPH;
wire [10:0]  UPDATE_FREQ_NPD;
wire [11:0]  UPDATE_TIMER;
wire [1:0]   tx_dllp_val;
wire [2:0]   tx_pmtype;
wire [23:0]  tx_vsd_data;
wire [2:0]   rxdp_pmd_type;
wire [23:0]  rxdp_vsd_data;
wire [1:0]   rxdp_dllp_val;
wire [3:0]   hl_gto_lbk;

`endif

`ifdef GEN2
wire [3:0]   cs_target_lnk_spd ;
wire         cs_enter_compliance ;
wire         cs_hasd ;
wire         cs_tx_demphasis ;
wire [2:0]   cs_tx_margin ;
wire         cs_enter_mod_comp ;
wire         cs_comp_sos ;
wire         cs_comp_demp ;
wire [1:0]   phy_lnk_spd;
wire         phy_deemp;

`endif
wire        ltssm_reset_core;
reg         core_rst_n;
reg [4:0]   hrst_wait_cntr;

`ifdef DOWN_X1

`else

`endif

`ifdef DOWN_X1

`else

`endif

`ifdef Channel_1

`ifdef DOWN_X1

`else

`endif

`else

`endif

`ifdef SIMULATE

`else

`endif

`ifdef GEN2

`endif

`ifdef ID_INTF

`else

`endif

`ifdef GEN2

`endif

`ifdef CFG_VCC

`endif

`ifdef ECRC

`endif

`ifdef AER

`endif

`ifdef GEN2

`endif

`ifdef DOWN_X1

`else

`ifdef FORCE_REG_X1

`else

`endif

`endif

`ifdef ECRC

`endif

`ifdef GEN2

`endif

`ifdef WISHBONE

`endif
reg term_all_cfg_split;
reg inta_n_split;
reg [7 : 0] msi_split;
reg [2 : 0] msi_tc_split;
reg [31 : 0] INIT_REG_00C_split;
reg [31 : 0] INIT_REG_010_split;
reg [31 : 0] INIT_REG_014_split;
reg [31 : 0] INIT_REG_018_split;
reg [31 : 0] INIT_REG_01C_split;
reg [31 : 0] INIT_REG_020_split;
reg [31 : 0] INIT_REG_024_split;
reg [31 : 0] INIT_REG_028_split;
reg [31 : 0] INIT_REG_030_split;
reg [31 : 0] INIT_REG_03C_split;
reg [31 : 0] INIT_REG_050_split;
reg [31 : 0] INIT_REG_054_split;
reg [9 : 0] INIT_PM_DS_DATA_0_split;
reg [9 : 0] INIT_PM_DS_DATA_1_split;
reg [9 : 0] INIT_PM_DS_DATA_2_split;
reg [9 : 0] INIT_PM_DS_DATA_3_split;
reg [9 : 0] INIT_PM_DS_DATA_4_split;
reg [9 : 0] INIT_PM_DS_DATA_5_split;
reg [9 : 0] INIT_PM_DS_DATA_6_split;
reg [9 : 0] INIT_PM_DS_DATA_7_split;
reg [31 : 0] INIT_REG_070_split;
reg [31 : 0] INIT_REG_090_split;
reg [31 : 0] INIT_REG_094_split;
reg [31 : 0] INIT_REG_09C_split;
reg [31 : 0] INIT_REG_0A0_split;
reg [31 : 0] INIT_REG_104_split;
reg [31 : 0] INIT_REG_108_split;
reg [7 : 0] INIT_PH_FC_VC0_split;
reg [7 : 0] INIT_NPH_FC_VC0_split;
reg [11 : 0] INIT_PD_FC_VC0_split;
reg [11 : 0] INIT_NPD_FC_VC0_split;
reg tx_req_vc0_split;
reg [D_WIDTH - 1 : 0] tx_data_vc0_split;
reg tx_st_vc0_split;
reg tx_end_vc0_split;
reg tx_nlfy_vc0_split;
reg ph_buf_status_vc0_split;
reg pd_buf_status_vc0_split;
reg nph_buf_status_vc0_split;
reg npd_buf_status_vc0_split;
reg ph_processed_vc0_split;
reg pd_processed_vc0_split;
reg nph_processed_vc0_split;
reg npd_processed_vc0_split;
reg [7 : 0] pd_num_vc0_split;
reg [7 : 0] npd_num_vc0_split;
reg tx_dwen_vc0_split;
reg [15 : 0] rxp_data_ln0_split;
reg [1 : 0] rxp_data_k_ln0_split;
reg rxp_valid_ln0_split;
reg rxp_elec_idle_ln0_split;
reg [2 : 0] rxp_status_ln0_split;
reg [15 : 0] rxp_data_ln1_split;
reg [1 : 0] rxp_data_k_ln1_split;
reg rxp_valid_ln1_split;
reg rxp_elec_idle_ln1_split;
reg [2 : 0] rxp_status_ln1_split;
reg phy_status_split;
reg cmpln_tout_split;
reg cmpltr_abort_np_split;
reg cmpltr_abort_p_split;
reg unexp_cmpln_split;
reg ur_np_ext_split;
reg ur_p_ext_split;
reg np_req_pend_split;
reg pme_status_split;
reg [D_WIDTH - 1 : 0] tx_lbk_data_split;
reg [D_WIDTH / 8 - 1 : 0] tx_lbk_kcntl_split;
reg rate_phy_sts_pulse_split;
reg [D_WIDTH - 1 : 0] tdmux_data_split;
reg [D_WIDTH - 1 : 0] dfrm_tdata_split;
reg [15 : 0] dfrm_seq_split;
reg [31 : 0] dfrm_lcrc_split;
reg [D_WIDTH - 1 : 0] tlpgen_data_split;
reg [D_WIDTH - 1 : 0] tlpdec_data_split;
reg [D_WIDTH - 1 : 0] rxtp_data_split;
reg [D_WIDTH - 1 : 0] dfrm_ddata_split;
reg [2 : 0] fc_vcid1_split;
reg [1 : 0] fc_type1_split;
reg [2 : 0] fc_vcid2_split;
reg [1 : 0] fc_type2_split;
reg p_infi_credit_split;
reg np_infi_credit_split;
reg cpl_infi_credit_split;
reg [23 : 0] fc_p_split;
reg [23 : 0] fc_np_split;
reg [23 : 0] fc_cpl_split;
reg txdp_p_sent_split;
reg txdp_np_sent_split;
reg txdp_cpl_sent_split;
reg [2 : 0] rxdp_fcd_vcid_split;
reg [19 : 0] rxdp_fcd_data_split;
reg [1 : 0] rxdp_fcd_type_split;
reg vcneg_pend_split;
reg vc_enb_split;
reg [2 : 0] cfg_vcid_split;
reg [2 : 0] lnk_width_split;
reg [2 : 0] cfgcs_losel_split;
reg [2 : 0] max_pl_size_split;
reg ext_sync_split;
reg lcm_enb_split;
reg link_disable_split;
reg [FADDR : 0] dll_pause_cnt_split;
reg [D_WIDTH / 2 - 1 : 0] phy_data_split;
reg [D_WIDTH / 16 - 1 : 0] phy_kcntl_split;
reg [D_WIDTH / 2 - 1 : 0] asb_data_split;
reg [D_WIDTH / 16 - 1 : 0] asb_kcntl_split;
reg [2 : 0] phy_margin_split;
reg [2 : 0] phy_l0s_tx_state_split;
reg [1 : 0] phy_l1_state_split;
reg [1 : 0] phy_l2_state_split;
reg phy_disable_scr_split;
reg phy_sloopback_split;
reg phy_snd_beacon_split;
reg [LANE_WIDTH * 2 - 1 : 0] asb_skip_found_split;
reg [LANE_WIDTH - 1 : 0] asb_err_split;
reg [LANE_WIDTH * 2 - 1 : 0] skip_added_split;
reg [LANE_WIDTH * 2 - 1 : 0] skip_removed_split;
reg [LANE_WIDTH - 1 : 0] phy_inv_polar_split;
reg [LANE_WIDTH - 1 : 0] phy_eidle_tx_split;
reg [LANE_WIDTH - 1 : 0] phy_godet_rx_split;
reg [LANE_WIDTH * 2 - 1 : 0] phy_fndisp_split;
reg [LANE_WIDTH - 1 : 0] asb_eidle_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_detdone_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_detres_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_beacon_rx_split;
reg [LANE_WIDTH - 1 : 0] asb_lane_sync_split;
reg [1 : 0] phy_skpq_nclks_split;
reg phy_skpq_val_split;
reg [3 : 0] asb_err_mod_split;
reg [1 : 0] phy_cfgln_r1_split;
reg [1 : 0] phy_cfgln_r2_split;
reg [12 : 0] Dev_Addr_o_split;
reg [31 : 0] Dev_Data_o_split;
reg Dev_BYTE_Sel_o_split;
reg Dev_WE_RDn_o_split;
reg Dev_Strobe_o_split;
reg [31 : 0] Dev_Data_i_0_split;
reg [31 : 0] Dev_Data_i_1_split;
reg Dev_Ack_i_0_split;
reg Dev_Ack_i_1_split;
reg Dev_IRQ_i_split;
reg ltssm_reset_core_split;
reg [4 : 0] hrst_wait_cntr_split;
reg [2047:0] descram_in;
wire [147:0] descram_out;

`define PHY_INST phy

`define PIPE_INST pipe

`ifdef Channel_1

`else

`endif

`ifdef WISHBONE

`endif

`ifdef GEN2

`endif


`ifdef DOWN_X1

`else

`endif

`ifdef DOWN_X1

`else

`endif


`ifdef Channel_1

`ifdef DOWN_X1

`else

`endif

`else

`endif

`ifdef SIMULATE

`else

`endif

`ifdef GEN2

`endif



`ifdef ID_INTF

`else

`endif

`ifdef GEN2

`endif

`ifdef CFG_VCC

`endif

`ifdef ECRC

`endif

`ifdef AER

`endif

`ifdef GEN2

`endif

`ifdef DOWN_X1

`else

`ifdef FORCE_REG_X1

`else

`endif

`endif

`ifdef ECRC

`endif

`ifdef GEN2

`endif

`ifdef WISHBONE



`endif

localparam descram_inst_SIZE = 148,descram_inst_SCRAMSTRING = 32'hfdffca8b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;



`define PHY_INST phy



`define PIPE_INST pipe


`ifdef Channel_1


`else


`endif


`ifdef WISHBONE


`endif



`ifdef GEN2


`endif


`ifdef DOWN_X1



`else



`endif



`ifdef DOWN_X1



`else



`endif



`ifdef Channel_1



`ifdef DOWN_X1



`else



`endif



`else



`endif



`ifdef SIMULATE



`else



`endif



`ifdef GEN2



`endif



`ifdef ID_INTF



`else



`endif



`ifdef GEN2



`endif



`ifdef CFG_VCC



`endif



`ifdef ECRC



`endif



`ifdef AER



`endif



`ifdef GEN2



`endif



`ifdef DOWN_X1



`else



`ifdef FORCE_REG_X1



`else



`endif



`endif



`ifdef ECRC



`endif



`ifdef GEN2



`endif



`ifdef WISHBONE



`endif

// =============================================================================
// Parameters
// =============================================================================
// for common parameters
//#include "pci_exp_dparams.v"


`define PHY_INST phy




`define PIPE_INST pipe




`ifdef Channel_1




`else




`endif


// =============================================================================
// Define Wires & Regs
// =============================================================================
// Wishbone1 slave side Signals


`ifdef WISHBONE


   

`endif





`ifdef GEN2


   

`endif



assign phy_x4_val = lnk_width_split[2];
assign phy_x2_val = lnk_width_split[1];
// =============================================================================
// PIPE Interface
// =============================================================================
`PIPE_INST #(
   .LANE_WIDTH       ( LANE_WIDTH ) ,
   .D_WIDTH          ( D_WIDTH ) )
   u1_pipe (
   //------- Inputs
   .sys_clk             (sys_clk_125),
   .rst_n               (core_rst_n),
   // From External PHY
   .pclk                (pclk),
   

`ifdef DOWN_X1


      .rx_data          ( {rxp_data_ln0, 8'd0} ),
      .rx_data_k        ( {rxp_data_k_ln0, 1'b0} ),
      .rx_valid         ( {rxp_valid_ln0, 1'b0} ),
      .rx_elec_idle     ( {rxp_elec_idle_ln0, 1'b1} ),
      .rx_status        ( {rxp_status_ln0, 3'd0} ),
   

`else


      .rx_data          ( {rxp_data_ln0, rxp_data_ln1} ),
      .rx_data_k        ( {rxp_data_k_ln0, rxp_data_k_ln1} ),
      .rx_valid         ( {rxp_valid_ln0, rxp_valid_ln1} ),
      .rx_elec_idle     ( {rxp_elec_idle_ln0, rxp_elec_idle_ln1} ),
      .rx_status        ( {rxp_status_ln0, rxp_status_ln1} ),
   

`endif


   .phy_status          (phy_status),

   // From IP
   .phy_inv_polar       (phy_inv_polar),
   .phy_godet_rx        (phy_godet_rx),
   .phy_fndisp          (phy_fndisp),
   .phy_disable_scr     ({2{phy_disable_scr}}),
   .phy_sloopback       ({2{phy_sloopback}}),
   .phy_snd_beacon      ({2{phy_snd_beacon}}),
   

`ifdef DOWN_X1


      .phy_data         ({phy_data[31:16], 15'd0}),
      .phy_kcntl        ({phy_kcntl[3:2], 2'b00}),
      .phy_eidle_tx     ({phy_eidle_tx[3:2], 2'b11}),
   

`else


      .phy_data         (phy_data),
      .phy_kcntl        (phy_kcntl),
      .phy_eidle_tx     (phy_eidle_tx),
   

`endif


   .phy_ltssm_state     (phy_ltssm_state),
   .l0s_tx_state        (phy_l0s_tx_state),
   .l1_state            (phy_l1_state),
   .l2_state            (phy_l2_state),
   .rate_5g             (rate_5g),
   .phy_deemph          (phy_deemph),
   .phy_margin          (phy_margin),

   // From CSR
   .force_lsm_active     (force_lsm_active),
   .force_rec_ei         (force_rec_ei),
   .force_phy_status     (force_phy_status),

   // To External PHY
   .tx_data          ({txp_data_ln0, txp_data_ln1}),
   .tx_data_k        ({txp_data_k_ln0, txp_data_k_ln1}),
   .tx_elec_idle     ({txp_elec_idle_ln0, txp_elec_idle_ln1}),
   .tx_compliance    ({txp_compliance_ln0, txp_compliance_ln1}),
   .rx_polarity      ({rxp_polarity_ln0, rxp_polarity_ln1}),
   .tx_detect_rx_lb  (txp_detect_rx_lb),
   .reset_n          (reset_n),
   .power_down       (txp_power_down),
   .rate             (txp_rate),
   .tx_deemph        (txp_deemph),
   .tx_margin        (txp_margin),

   // To IP
   .rate_phy_sts_pulse   (rate_phy_sts_pulse),
   .asb_skip_found   (asb_skip_found),
   .skip_added       (skip_added),
   .skip_removed     (skip_removed),
   .asb_data            (asb_data),
   .asb_kcntl           (asb_kcntl),
   .asb_err             (asb_err),
   .asb_eidle_rx        (asb_eidle_rx),
   .asb_detdone_rx      (asb_detdone_rx),
   .asb_detres_rx       (asb_detres_rx),
   .asb_beacon_rx       (asb_beacon_rx),
   .asb_lane_sync       (asb_lane_sync)
   );

// =============================================================================
// Phy Layer
// =============================================================================
`PHY_INST # (
   .LANE_WIDTH       ( LANE_WIDTH ) ,
   .D_WIDTH          ( D_WIDTH ),
   .MCAF_DEPTH       (MCAF_DEPTH))
   u1_phy (
   .clk_250_tx       (pclk),
   .clk_250_rx       (pclk),
   .sys_clk          (sys_clk_125),
   .rst_n            (core_rst_n),

   .normal_time      (1'b1),
   .reduce_idlecnt   (1'b0),
   

`ifdef Channel_1


     

`ifdef DOWN_X1


      .phy_mca_disable  (1'b1),
     

`else


      .phy_mca_disable  (1'b0),
     

`endif


   

`else


      .phy_mca_disable  (1'b1), // For initial testing
   

`endif



   // Constants
   .LINK_NUM         (8'h5A),
   .N_FTS_INC        (5'd10),
   .SKP_INS_CNT      (SKP_INS_CNT),
   .TX_EIDL_CNT      (4'h2),

   // From ASB
   .asb_skip_found(asb_skip_found),
   .skip_added    (skip_added),
   .skip_removed  (skip_removed),
   .asb_err       (asb_err_mod),
   .asb_data         (asb_data),
   .asb_kcntl        (asb_kcntl),
   .asb_eidle_rx     (asb_eidle_rx),
   .asb_detdone_rx   (asb_detdone_rx),
   .asb_detres_rx    (asb_detres_rx),
   .asb_beacon_rx    (asb_beacon_rx),
   .asb_lane_sync    (asb_lane_sync),
   .rate_phy_sts_pulse   (rate_phy_sts_pulse),

   // From Higher Layer
   .force_disable_scr(force_disable_scr),
   .hl_snd_beacon    (hl_snd_beacon),
   .hl_disable_scr   (hl_disable_scr),
   .hl_gto_dis       (hl_gto_dis),
   .hl_gto_det       (hl_gto_det),
   .hl_gto_hrst      (hl_gto_hrst),
   .hl_gto_l0stx     (hl_gto_l0stx),
   .hl_gto_l1        (hl_gto_l1),
   .hl_gto_l2        (hl_gto_l2),
   .hl_gto_l0stxfts  (hl_gto_l0stxfts),
   .hl_gto_lbk    ({hl_gto_lbk[0],hl_gto_lbk[1]}),
   .hl_gto_rcvry     (hl_gto_rcvry),
   .hl_gto_cfg       (hl_gto_cfg),
   .cfgcs_losel      (cfgcs_losel),
   .cfg_rtrn_lnk     (retrain_lnk) ,
   .dll_rtrn_lnk     (txtp_rnum_rlor) ,
   .ext_sync         (ext_sync),
   .no_pcie_train    (no_pcie_train),

   // From RX Data Link Layer
   .tdmux_data       (tdmux_data),
   .tdmux_st         (tdmux_st),
   .tdmux_end        (tdmux_end),
   .tdmux_edb        (tdmux_edb),
   

`ifdef SIMULATE


      .tdmux_skp  ((tdmux_skip | sci_busy)),
   

`else


      .tdmux_skp  (tdmux_skip),
   

`endif


   .tdmux_val     (tdmux_val),
   .tdmux_dwen    (tdmux_dwen),
   .tdmux_dllp    (tdmux_dllp),
   

`ifdef GEN2


      .cs_target_lnk_spd   (cs_target_lnk_spd),
      .cs_enter_compliance (cs_enter_compliance),
      .cs_hasd             (cs_hasd),
      .cs_tx_demphasis     (cs_tx_demphasis),
      .cs_tx_margin        (cs_tx_margin),
      .cs_enter_mod_comp   (cs_enter_mod_comp),
      .cs_comp_sos         (cs_comp_sos),
      .cs_comp_demp        (cs_comp_demp),
    

`endif


    // User Loop back data
   .tx_lbk_data      (tx_lbk_data),
   .tx_lbk_kcntl     (tx_lbk_kcntl),

   //------ Outputs
   .tx_lbk_rdy       (tx_lbk_rdy),
   .rx_lbk_data      (rx_lbk_data),
   .rx_lbk_kcntl     (rx_lbk_kcntl),

   .phy_realign_req  (phy_realign_req),
   .phy_ltssm_state  (phy_ltssm_state),
   .phy_ltssm_substate (phy_ltssm_substate),
   .phy_cfgln_sum    (phy_cfgln_sum),
   .phy_lnk_spd      (phy_lnk_spd),
   .phy_cfgln        (phy_cfgln),
   .pol_compliance   (phy_pol_compliance),
   .infer_rx_eidle   ({infer_rx_eidle[0],infer_rx_eidle[1]}),

   // SKPQ Signals
   .phy_skpq_nclks(phy_skpq_nclks),
   .phy_skpq_val  (phy_skpq_val),
   .mca_aligned   (mca_aligned),

   // To LINK STATUS REG
   .phy_neg_lnkw     (lnk_width),
   .phy_trn_err      (lnk_train_err),
   .phy_lnk_trn      (lnk_train_status),

   // To ASB
   .phy_disable_scr  (phy_disable_scr),
   .phy_sloopback    (phy_sloopback),
   .phy_inv_polar    (phy_inv_polar),
   .phy_eidle_tx     (phy_eidle_tx),
   .phy_godet_rx     (phy_godet_rx),
   .phy_snd_beacon   (phy_snd_beacon),
   .phy_data         (phy_data),
   .phy_kcntl        (phy_kcntl),
   .phy_fndisp       (phy_fndisp),
   .phy_linkup       (phy_link_up),
   .phy_l0           (phy_l0),
   .phy_l0s_tx_state (phy_l0s_tx_state),
   .phy_l1_state     (phy_l1_state),
   .phy_l2_state     (phy_l2_state),
   .phy_l0_l0s       (phy_l0_l0s),
   .rate_5g          (rate_5g),
   .phy_deemph       (phy_deemph),
   .phy_margin       (phy_margin),

   .ltssm_reset_core (ltssm_reset_core),
   // To Data Link Layer
   .dfrm_ddata       (dfrm_ddata),
   .dfrm_tdata       (dfrm_tdata),
   .dfrm_tval        (dfrm_tval),
   .dfrm_st          (dfrm_st),
   .dfrm_end         (dfrm_end),
   .dfrm_edb         (dfrm_edb),
   .dfrm_dval     (dfrm_dval),
   .dfrm_dwen     (dfrm_dwen),
   .dfrm_seq      (dfrm_seq),
   .dfrm_lcrc     (dfrm_lcrc),
   .dfrm_perr        (dfrm_perr)
    );


//--------------------------------------------
//-- Core Reset Logic --
// Added hot reset
//--------------------------------------------
always @(posedge sys_clk_125 or negedge rst_n) begin
  if(~rst_n) begin
    core_rst_n <= 1'b0;
    hrst_wait_cntr <= {5{1'b0}};
    /*AUTORESET*/
  end
  else begin
    if(ltssm_reset_core_split) begin
      // wait several cycles to drain data on phy bus
      // and get stable signals
      hrst_wait_cntr <= {5{1'b1}};
    end
    else begin
      hrst_wait_cntr <= hrst_wait_cntr_split - {4'd0,|hrst_wait_cntr_split};
    end
    core_rst_n <= (hrst_wait_cntr_split == 5'd0);
  end
end //--always @(posedge sys_clk_125 or negedge rst_n)--

// =============================================================================
// Data Link Layer
// =============================================================================
assign lcm_enb = ~link_disable_split ;
//assign dl_up   = dl_up_allvc;
dll  #(
   .FADDR           (FADDR),
   .D_WIDTH         ( D_WIDTH ) )
   u1_dll (
   // Clock and Reset
   .sys_clk        (sys_clk_125),
   .rst_n          (core_rst_n),

   // Inputs
   // Constants
   .tlp_debug        (tlp_debug),
   .INITFC_TIMER     (12'd4095),
   .ACKNAK_LAT_TIME  (ACKNAK_LAT_TIME),

   // TX_TL Interface
   .tlpgen_req     (tlpgen_req),
   .tlpgen_data    (tlpgen_data_split),
   .tlpgen_st      (tlpgen_st),
   .tlpgen_end     (tlpgen_end),
   .tlpgen_nlfy    (tlpgen_nlfy),
   .tlpgen_rdy_ack (tlpgen_rdy_ack),

   .fc_update1     (fc_update1),
   .fc_vcid1       (fc_vcid1_split),
   .fc_type1       (fc_type1_split),

   .fc_update2     (fc_update2),
   .fc_vcid2       (fc_vcid2_split),
   .fc_type2       (fc_type2_split),

   .p_infi_credit   (p_infi_credit_split),
   .np_infi_credit  (np_infi_credit_split),
   .cpl_infi_credit (cpl_infi_credit_split),

   .fc_p           (fc_p_split),
   .fc_np          (fc_np_split),
   .fc_cpl         (fc_cpl_split),

   // RX DLL Interface
   .dfrm_tdata     (dfrm_tdata_split),
   .dfrm_tval      (dfrm_tval),
   .dfrm_st        (dfrm_st),
   .dfrm_end       (dfrm_end),
   .dfrm_edb       (dfrm_edb),
   .dfrm_ddata     (dfrm_ddata_split[63:16]),
   .dfrm_dval      (dfrm_dval),
   .dfrm_dwen      (dfrm_dwen),
   .dfrm_seq       (dfrm_seq_split),
   .dfrm_lcrc      (dfrm_lcrc_split),

   .phy_cfgln_sum  (phy_cfgln_sum),
   .rate_5g        (rate_5g),
   .phy_x4_val     (phy_x4_val),
   .phy_x2_val     (phy_x2_val),
   .phy_skpq_nclks (phy_skpq_nclks_split),

   .tlpgen_tval    (tlpgen_tval),
   .tlpgen_dwen    (tlpgen_dwen),
   .phy_ltssm_state(phy_ltssm_state),
   .phy_link_up    (phy_link_up),
   .phy_l0         (phy_l0),
   .vc_enb         (vc_enb_split),
   .cfg_vcid       (cfg_vcid_split),
   .lcm_enb        (lcm_enb_split),
   .max_pl_size    (max_pl_size_split),

   .phy_skpq_val   (phy_skpq_val_split),
   .trnc_pause_ack (trnc_pause_ack),
   .trnc_st        (trnc_st),

   // From Power Mgmmt - Core I/F
   .tx_pm          (tx_dllp_val[0]),
   .tx_pmtype      (tx_pmtype[2:0]),
   .tx_vendor      (tx_dllp_val[1]),
   .tx_vsd_data    (tx_vsd_data),

   // Outputs
   // TX_TL Interface
   .txtp_rdy       (txtp_rdy),

   // TX DLL Interface
   .tdmux_data     (tdmux_data),
   .tdmux_st       (tdmux_st),
   .tdmux_end      (tdmux_end),
   .tdmux_edb      (tdmux_edb),
   .tdmux_skip     (tdmux_skip),
   .tdmux_val   (tdmux_val),
   .rxtp_dwen   (rxtp_dwen),
   .tdmux_dwen  (tdmux_dwen),
   .tdmux_dllp  (tdmux_dllp),

   // RX_TL Interface
   .rxtp_data      (rxtp_data),
   .rxtp_st        (rxtp_st),
   .rxtp_end       (rxtp_end),

   .rxdp_ifc1_val  (rxdp_ifc1_val),
   .rxdp_ifc2_val  (rxdp_ifc2_val),
   .rxdp_ufc_val   (rxdp_ufc_val),
   .rxdp_fcd_type  (rxdp_fcd_type),
   .rxdp_fcdata    ({rxdp_fcd_vcid, rxdp_fcd_data}),

   .rxdp_vsd_data  (rxdp_vsd_data) ,
   .rxdp_pmd_type  (rxdp_pmd_type[2:0]),
   .rxdp_dllp_val  (rxdp_dllp_val),

   // To RXFC Block
   .txdp_hpreq     (txdp_hpreq),
   .txdp_lpreq     (txdp_lpreq),
   .txdp_p_sent    (txdp_p_sent),
   .txdp_np_sent   (txdp_np_sent),
   .txdp_cpl_sent  (txdp_cpl_sent),

   // CFG Interface
   .vcneg_pend     (vcneg_pend),
   .rxdp_bad_dllp  (rxdp_bad_dllp),
   .rxdp_dlerr     (rxdp_dlerr),
   .rxtp_bad_tlp   (rxtp_bad_tlp),
   .txtp_rnum_rlor (txtp_rnum_rlor),
   .txtp_rply_tout (txtp_rply_tout),

   // Datal Link Control SM Status
   .dl_inactive    (dl_inactive),
   .dl_init        (dl_init),
   .dl_active      (dl_active),
   .dl_up          (dl_up),

   // To ASPM implementation outside the IP
   .tx_rbuf_empty  (tx_rbuf_empty),
   .tx_dllp_pend   (tx_dllp_pend),
   .rx_tlp_rcvd    (rx_tlp_rcvd),

   // To TL - Req for insertion of DLLPs/SKIPs
   .dll_pause_cnt  (dll_pause_cnt),

   // Power Management
   .txdp_pv_sent   (tx_dllp_sent)
    );

// =============================================================================
// Common Transaction layer
// =============================================================================
// doubble flop phy_cfgln in 250mhz for synchronization
// Generate deframer payload error
always @(posedge pclk or negedge core_rst_n) begin
   if (!core_rst_n) begin
      phy_cfgln_r1 <= 2'h0 ;
      phy_cfgln_r2 <= 2'h0 ;
      asb_err_mod <= 2'd0;
   end
   else begin
      phy_cfgln_r1 <= phy_cfgln ;
      phy_cfgln_r2 <= phy_cfgln_r1_split ;
      asb_err_mod <= (asb_err_split & phy_cfgln_r2_split);
   end
end
// =============================================================================

trnc  #(
   .FADDR                ( FADDR ),
   .D_WIDTH              ( D_WIDTH ) )
   u1_trnc (
   // Clock and Reset
   .sys_clk              ( sys_clk_125 ),
   .rst_n                ( core_rst_n ),
   .rst_n_main           ( rst_n ),
   .rate_5g              ( rate_5g ),

   // Register Initial Values
   // For Type0 Registers
   

`ifdef ID_INTF


      .INIT_REG_000      ( {device_id,vendor_id} )  ,
      .INIT_REG_008      ( {class_code,rev_id} )  ,
      .INIT_REG_02C      ( {subsys_id,subsys_ven_id} )  ,
      .load_id           ( load_id )  ,
   

`else


      .INIT_REG_000      ( INIT_REG_000 )  ,
      .INIT_REG_008      ( INIT_REG_008 )  ,
      .INIT_REG_02C      ( INIT_REG_02C )  ,
      .load_id           ( 1'b1 )  ,
   

`endif



   .INIT_REG_00C         ( INIT_REG_00C_split )  ,
   .INIT_REG_010         ( INIT_REG_010_split )  ,
   .INIT_REG_014         ( INIT_REG_014_split )  ,
   .INIT_REG_018         ( INIT_REG_018_split )  ,
   .INIT_REG_01C         ( INIT_REG_01C_split )  ,
   .INIT_REG_020         ( INIT_REG_020_split )  ,
   .INIT_REG_024         ( INIT_REG_024_split )  ,
   .INIT_REG_028         ( INIT_REG_028_split )  ,
   .INIT_REG_030         ( INIT_REG_030_split )  ,
   .INIT_REG_03C         ( INIT_REG_03C_split )  ,
   // For PM Registers
   .INIT_REG_050         ( INIT_REG_050_split )  ,
   .INIT_REG_054         ( INIT_REG_054_split )  ,
   .INIT_PM_DS_DATA_0    ( INIT_PM_DS_DATA_0_split )  ,
   .INIT_PM_DS_DATA_1    ( INIT_PM_DS_DATA_1_split )  ,
   .INIT_PM_DS_DATA_2    ( INIT_PM_DS_DATA_2_split )  ,
   .INIT_PM_DS_DATA_3    ( INIT_PM_DS_DATA_3_split )  ,
   .INIT_PM_DS_DATA_4    ( INIT_PM_DS_DATA_4_split )  ,
   .INIT_PM_DS_DATA_5    ( INIT_PM_DS_DATA_5_split )  ,
   .INIT_PM_DS_DATA_6    ( INIT_PM_DS_DATA_6_split )  ,
   .INIT_PM_DS_DATA_7    ( INIT_PM_DS_DATA_7_split )  ,
   // For MSI Register
   .INIT_REG_070         ( INIT_REG_070_split )  ,
   // For PCIE Registers
   .INIT_REG_090         ( INIT_REG_090_split )  ,
   .INIT_REG_094         ( INIT_REG_094_split )  ,
   .INIT_REG_09C         ( INIT_REG_09C_split )  ,
   .INIT_REG_0A0         ( INIT_REG_0A0_split )  ,
   

`ifdef GEN2


      .INIT_REG_0B4      ( INIT_REG_0B4 )  ,
   

`endif


   // For Device Serial no. Registers
   .INIT_REG_104         ( INIT_REG_104_split )  ,
   .INIT_REG_108         ( INIT_REG_108_split )  ,

   // For VCC Registers
   

`ifdef CFG_VCC


      .INIT_REG_10C      ( INIT_REG_10C )  ,
   

`endif



   // To RXFC
   .INIT_PH_FC           ( INIT_PH_FC_VC0_split ),
   .INIT_NPH_FC          ( INIT_NPH_FC_VC0_split ),
   .INIT_PD_FC           ( INIT_PD_FC_VC0_split ),
   .INIT_NPD_FC          ( INIT_NPD_FC_VC0_split ),
   .UPDATE_FREQ_PH       ( UPDATE_FREQ_PH ),
   .UPDATE_FREQ_PD       ( UPDATE_FREQ_PD ),
   .UPDATE_FREQ_NPH      ( UPDATE_FREQ_NPH ),
   .UPDATE_FREQ_NPD      ( UPDATE_FREQ_NPD ),
   .UPDATE_TIMER         ( UPDATE_TIMER ),

   .tlp_debug            ( tlp_debug ),

   .inta_n               ( inta_n_split ),
   .msi                  ( msi_split ),
   .msi_tc               ( msi_tc_split ),

   // From TX User
   .tx_req               ( tx_req_vc0_split ),
   .tx_data              ( tx_data_vc0_split ),
   .tx_st                ( tx_st_vc0_split ),
   .tx_end               ( tx_end_vc0_split ),
   .tx_nlfy              ( tx_nlfy_vc0_split ),
   .tx_dwen              ( tx_dwen_vc0_split ),

   // From PHY
   .phy_link_up          ( phy_link_up ),
   .lnk_train_err        ( lnk_train_err ),
   .lnk_train_status     ( lnk_train_status ),
   .lnk_width            ( lnk_width_split ),
   .dfrm_perr            ( dfrm_perr ),
   .phy_cfgln_sum        ( phy_cfgln_sum ),
   .phy_lnk_spd          ( phy_lnk_spd),
   .phy_lnk_demp         ( phy_deemp ) ,
   // From DLL
   .dll_pause_cnt        ( dll_pause_cnt_split ),
   .txtp_rdy             ( txtp_rdy ),
   .rxtp_data            ( rxtp_data_split ),
   .rxtp_st              ( rxtp_st ),
   .rxtp_end             ( rxtp_end ),
   .rxtp_dwen            ( rxtp_dwen ),

   .rxtp_bad_tlp         ( rxtp_bad_tlp ),
   .rxdp_bad_dllp        ( rxdp_bad_dllp ),
   .rxdp_dlerr           ( rxdp_dlerr ),
   .txtp_rnum_rlor       ( txtp_rnum_rlor ),
   .txtp_rply_tout       ( txtp_rply_tout ),

   .rxdp_ifc1_val        ( rxdp_ifc1_val ),
   .rxdp_ifc2_val        ( rxdp_ifc2_val ),
   .rxdp_ufc_val         ( rxdp_ufc_val ),
   .rxdp_fcd_type        ( rxdp_fcd_type_split ),
   .rxdp_fcd_vcid        ( rxdp_fcd_vcid_split ),
   .rxdp_fcd_data        ( rxdp_fcd_data_split ),

   .dl_up                ( dl_up ),
   .dl_active            ( dl_active ),
   .dl_inactive          ( dl_inactive ),

   .vcneg_pend           ( vcneg_pend_split ),
   .phy_l0_l0s           ( phy_l0_l0s ),

   .txdp_hpreq           ( txdp_hpreq ),
   .txdp_lpreq           ( txdp_lpreq ),
   .txdp_p_sent          ( txdp_p_sent_split ),
   .txdp_np_sent         ( txdp_np_sent_split ),
   .txdp_cpl_sent        ( txdp_cpl_sent_split ),

   .ph_buf_status        ( ph_buf_status_vc0_split ),
   .pd_buf_status        ( pd_buf_status_vc0_split ),
   .nph_buf_status       ( nph_buf_status_vc0_split ),
   .npd_buf_status       ( npd_buf_status_vc0_split ),
   .ph_processed         ( ph_processed_vc0_split ),
   .pd_processed         ( pd_processed_vc0_split ),
   .nph_processed        ( nph_processed_vc0_split ),
   .npd_processed        ( npd_processed_vc0_split ),
   .pd_num               ( pd_num_vc0_split ),
   .npd_num              ( npd_num_vc0_split ),

   

`ifdef ECRC


      .ecrc_gen_enb      ( ecrc_gen_enb ) ,
      .ecrc_chk_enb      ( ecrc_chk_enb ) ,
   

`endif



   // From User logic
   

`ifdef AER


      .err_tlp_header    ( err_tlp_header ),
   

`endif


   .cmpln_tout           ( cmpln_tout_split ),
   .cmpltr_abort_np      ( cmpltr_abort_np_split ),
   .cmpltr_abort_p       ( cmpltr_abort_p_split ),
   .unexp_cmpln          ( unexp_cmpln_split ),
   .ur_np_ext            ( ur_np_ext_split ) ,
   .ur_p_ext             ( ur_p_ext_split ) ,
   .np_req_pend          ( np_req_pend_split ),
   .pme_status           ( pme_status_split ),
   .term_all_cfg         ( term_all_cfg_split ),
   // Signal used for DEBUG in H/W and SIG purposes only
   // Disabled for normal release
   .ptc_err_enable    ( 1'b0 ),
   

`ifdef GEN2


      .flr_rdy_in          (flr_rdy_in ),
      .cs_target_lnk_spd   (cs_target_lnk_spd),
      .cs_enter_compliance (cs_enter_compliance),
      .cs_hasd             (cs_hasd),
      .cs_tx_demphasis     (cs_tx_demphasis),
      .cs_tx_margin        (cs_tx_margin),
      .cs_enter_mod_comp   (cs_enter_mod_comp),
      .cs_comp_sos         (cs_comp_sos),
      .cs_comp_demp        (cs_comp_demp),
   

`endif


   

`ifdef DOWN_X1


      .force_x2_cfg      ( 1'b0 ),
      .force_x1_cfg      ( 1'b1 ),
   

`else


      .force_x2_cfg      ( 1'b1 ),
      

`ifdef FORCE_REG_X1


         .force_x1_cfg   ( 1'b1 ),
      

`else


         .force_x1_cfg   ( 1'b0 ),
      

`endif


   

`endif



   // CPM Interface
   .ADR_I                ( Dev_Addr_o_split[11:0] ) ,
   .DAT_I                ( Dev_Data_o_split ),
   .WE_I                 ( Dev_WE_RDn_o_split ),
   .STB_I                ( Dev_Strobe_o_split & ~Dev_Addr_o_split[12] ),

   // Outputs
   .RDAT_O               ( Dev_Data_i_0 ),
   .ACK_O                ( Dev_Ack_i_0 ),

   // Outputs
   .tlpgen_req           ( tlpgen_req ),
   .tlpgen_data          ( tlpgen_data ),
   .tlpgen_st            ( tlpgen_st ),
   .tlpgen_end           ( tlpgen_end ),
   .tlpgen_nlfy          ( tlpgen_nlfy ),
   .tlpgen_rdy_ack       ( tlpgen_rdy_ack ),
   .trnc_pause_ack       ( trnc_pause_ack ),

   // TO TX User
   .tx_rdy               ( tx_rdy_vc0 ),
   .tx_ca_ph             ( tx_ca_ph_vc0 ),
   .tx_ca_pd             ( tx_ca_pd_vc0 ),
   .tx_ca_nph            ( tx_ca_nph_vc0 ),
   .tx_ca_npd            ( tx_ca_npd_vc0 ),
   .tx_ca_cplh           ( tx_ca_cplh_vc0 ),
   .tx_ca_cpld           ( tx_ca_cpld_vc0 ),
   .tx_ca_p_recheck      ( tx_ca_p_recheck_vc0 ),
   .tx_ca_cpl_recheck    ( tx_ca_cpl_recheck_vc0 ),

   // TO RX User
   .rx_data              ( rx_data_vc0 ),
   .rx_st                ( rx_st_vc0 ),
   .rx_end               ( rx_end_vc0 ),
   

`ifdef ECRC


      .rx_ecrc_err       ( rx_ecrc_err_vc0 ),
   

`endif


   .rx_us_req            ( rx_us_req_vc0 ),
   .rx_malf_tlp          ( rx_malf_tlp_vc0 ),
   .rx_bar_hit           ( rx_bar_hit ),
   .tlpgen_tval       ( tlpgen_tval ),
   .tlpgen_dwen       ( tlpgen_dwen ),
   .tx_val            ( tx_val ),
   .rx_dwen           ( rx_dwen_vc0 ),

   .bus_num              ( bus_num ) ,
   .dev_num              ( dev_num ) ,
   .func_num             ( func_num ) ,
   .pm_power_state       ( pm_power_state ) ,
   .pme_en               ( pme_en ) ,
   .mm_enable            ( mm_enable ) ,
   .msi_enable           ( msi_enable ) ,
   .mes_laddr            (  ) ,
   .mes_uaddr            (  ) ,
   .mes_data             (  ) ,
   .cmd_reg_out          ( cmd_reg_out ),
   .dev_cntl_out         ( dev_cntl_out ),
   .lnk_cntl_out         ( lnk_cntl_out ),
   .ftl_err_out          (  ),
   .nftl_err_out         (  ),
   .cor_err_out          (  ),
   

`ifdef GEN2


      .dev_cntl_2_out    ( dev_cntl_2_out ),
      .initiate_flr      ( initiate_flr ),
   

`endif



   .max_pl_size          ( max_pl_size ),
   .ext_sync             ( ext_sync ),
   .link_disable         ( link_disable ),
   .retrain_lnk          ( retrain_lnk ),
   .cfgcs_losel          ( cfgcs_losel ),

   .vc_en                ( vc_enb ),
   .cfg_vcid             ( cfg_vcid ),
   .cfg_tcvc_map         ( tcvc_map_vc0 ),

   .trnc_st              ( trnc_st ),
   .fc_update1           ( fc_update1 ),
   .fc_vcid1             ( fc_vcid1 ),
   .fc_type1             ( fc_type1 ),
   .fc_update2           ( fc_update2 ),
   .fc_vcid2             ( fc_vcid2 ),
   .fc_type2             ( fc_type2 ),
   .p_infi_credit        ( p_infi_credit ),
   .np_infi_credit       ( np_infi_credit ),
   .cpl_infi_credit      ( cpl_infi_credit ),
   .fc_p                 ( fc_p ),
   .fc_np                ( fc_np ),
   .fc_cpl               ( fc_cpl )
    );

// =============================================================================
// WISH BONE Interface Modules
// =============================================================================


`ifdef WISHBONE


   csr u1_csr_reg
   (
   // Inputs
   .sys_clk              (sys_clk_125),
   .rst_n                (core_rst_n ),

   // ---------- CPM Interface Inputs
   .ADR_I                (Dev_Addr_o_split[12:0]) ,
   .DAT_I                (Dev_Data_o_split),
   .WE_I                 (Dev_WE_RDn_o_split),
   .STB_I                (Dev_Strobe_o_split),

   // ---------- Power Management
   .tx_dllp_sent         (tx_dllp_sent),
   .rx_dllp_val          (rxdp_dllp_val),
   .rx_pmtype            (rxdp_pmd_type),
   .rx_vsd_data          (rxdp_vsd_data) ,

   // ---------- LTSSM (DLL,LSM,PHY status)
   .phy_ltssm_state      ({1'b0,phy_ltssm_state}),
   .phy_lsm_state        ({rxp_valid_ln0_split, rxp_valid_ln1_split, 1'b0, 1'b0}),
   .asb_eidle_rx         ({2'd0,asb_eidle_rx_split}),
   .asb_detdone_rx       ({2'd0,asb_detdone_rx_split}),
   .asb_detres_rx        ({2'd0,asb_detres_rx_split}),

   // ---------- Datal Link Control SM Status
   .dl_inactive          (dl_inactive),
   .dl_init              (dl_init),
   .dl_active            (dl_active),
   .dl_up                (dl_up),

   // Outputs
   // ---------- CPM Interface Outputs
   .RDAT_O               (Dev_Data_i_1),
   .ACK_O                (Dev_Ack_i_1),

   // ---------- Power Management
   .tx_dllp_val          (tx_dllp_val),
   .tx_pmtype            (tx_pmtype),
   .tx_vsd_data          (tx_vsd_data),

   // ---------- From Higher Layer
   .tlp_debug            (tlp_debug),
   .hl_snd_beacon        (hl_snd_beacon),
   .force_lsm_active     (force_lsm_active),
   .force_rec_ei         (force_rec_ei),
   .force_phy_status     (force_phy_status),
   .force_disable_scr    (force_disable_scr),
   .hl_disable_scr       (hl_disable_scr),
   .hl_gto_dis           (hl_gto_dis),
   .hl_gto_det           (hl_gto_det),
   .hl_gto_hrst          (hl_gto_hrst),
   .hl_gto_l0stx         (hl_gto_l0stx),
   .hl_gto_l1            (hl_gto_l1),
   .hl_gto_l2            (hl_gto_l2),
   .hl_gto_l0stxfts      (hl_gto_l0stxfts),
   .hl_gto_lbk           (hl_gto_lbk),
   .hl_gto_rcvry         (hl_gto_rcvry),
   .hl_gto_cfg           (hl_gto_cfg),
   .no_pcie_train        (no_pcie_train),


   .N_FTS_INC            (),
   .SKP_INS_CNT          (SKP_INS_CNT),
   .ACKNAK_LAT_TIME      (ACKNAK_LAT_TIME),
   .UPDATE_FREQ_PH       (UPDATE_FREQ_PH),
   .UPDATE_FREQ_PD       (UPDATE_FREQ_PD),
   .UPDATE_FREQ_NPH      (UPDATE_FREQ_NPH),
   .UPDATE_FREQ_NPD      (UPDATE_FREQ_NPD),
   .UPDATE_FREQ_CPLH     ( ),
   .UPDATE_FREQ_CPLD     ( ),
   .UPDATE_TIMER         (UPDATE_TIMER),
   .LINK_NUM             ()
  );

   cpm_s_reg u1_cpm_s_reg
   (
   // Wishbone Signals
   .RST_I                ( RST_I ),
   .CLK_I                ( CLK_I ),

   .ADR_I                ( ADR_I ),
   .DAT_I                ( DAT_I ),
   .SEL_I                ( SEL_I ),
   .WE_I                 ( WE_I ),
   .STB_I                ( STB_I ),
   .CYC_I                ( CYC_I ),
   .DAT_O                ( DAT_O ),
   .ACK_O                ( ACK_O ),
   .IRQ_O                ( IRQ_O ),

   // CPM Daisy Chain Signals
   .CHAIN_RDAT_in        ( CHAIN_RDAT_in ),
   .CHAIN_ACK_in         ( CHAIN_ACK_in ),

   // Slave Device Signals
   .csr_clk              ( sys_clk_125 ),
   .Dev_Addr_o           ( Dev_Addr_o ),
   .Dev_Data_i_0         ( Dev_Data_i_0_split ),
   .Dev_Data_i_1         ( Dev_Data_i_1_split ),
   .Dev_Data_o           ( Dev_Data_o ),
   .Dev_BYTE_Sel_o       ( ),
   .Dev_WE_RDn_o         ( Dev_WE_RDn_o ),
   .Dev_Strobe_o         ( Dev_Strobe_o ),
   .Dev_Ack_i_0          ( Dev_Ack_i_0_split ),
   .Dev_Ack_i_1          ( Dev_Ack_i_1_split ),
   .Dev_IRQ_i            ( 1'b0 )
   );


`endif



always@* begin term_all_cfg_split<=descram_out[0];inta_n_split<=descram_out[1];msi_split<={msi>>1,descram_out[2]};msi_tc_split<={msi_tc>>1,descram_out[3]};INIT_REG_00C_split<={INIT_REG_00C>>1,descram_out[4]};INIT_REG_010_split<={INIT_REG_010>>1,descram_out[5]};INIT_REG_014_split<={INIT_REG_014>>1,descram_out[6]};INIT_REG_018_split<={INIT_REG_018>>1,descram_out[7]};INIT_REG_01C_split<={INIT_REG_01C>>1,descram_out[8]};INIT_REG_020_split<={INIT_REG_020>>1,descram_out[9]};INIT_REG_024_split<={INIT_REG_024>>1,descram_out[10]};INIT_REG_028_split<={INIT_REG_028>>1,descram_out[11]};INIT_REG_030_split<={INIT_REG_030>>1,descram_out[12]};INIT_REG_03C_split<={INIT_REG_03C>>1,descram_out[13]};INIT_REG_050_split<={INIT_REG_050>>1,descram_out[14]};INIT_REG_054_split<={INIT_REG_054>>1,descram_out[15]};INIT_PM_DS_DATA_0_split<={INIT_PM_DS_DATA_0>>1,descram_out[16]};INIT_PM_DS_DATA_1_split<={INIT_PM_DS_DATA_1>>1,descram_out[17]};INIT_PM_DS_DATA_2_split<={INIT_PM_DS_DATA_2>>1,descram_out[18]};INIT_PM_DS_DATA_3_split<={INIT_PM_DS_DATA_3>>1,descram_out[19]};INIT_PM_DS_DATA_4_split<={INIT_PM_DS_DATA_4>>1,descram_out[20]};INIT_PM_DS_DATA_5_split<={INIT_PM_DS_DATA_5>>1,descram_out[21]};INIT_PM_DS_DATA_6_split<={INIT_PM_DS_DATA_6>>1,descram_out[22]};INIT_PM_DS_DATA_7_split<={INIT_PM_DS_DATA_7>>1,descram_out[23]};INIT_REG_070_split<={INIT_REG_070>>1,descram_out[24]};INIT_REG_090_split<={INIT_REG_090>>1,descram_out[25]};INIT_REG_094_split<={INIT_REG_094>>1,descram_out[26]};INIT_REG_09C_split<={INIT_REG_09C>>1,descram_out[27]};INIT_REG_0A0_split<={INIT_REG_0A0>>1,descram_out[28]};INIT_REG_104_split<={INIT_REG_104>>1,descram_out[29]};INIT_REG_108_split<={INIT_REG_108>>1,descram_out[30]};INIT_PH_FC_VC0_split<={INIT_PH_FC_VC0>>1,descram_out[31]};INIT_NPH_FC_VC0_split<={INIT_NPH_FC_VC0>>1,descram_out[32]};INIT_PD_FC_VC0_split<={INIT_PD_FC_VC0>>1,descram_out[33]};INIT_NPD_FC_VC0_split<={INIT_NPD_FC_VC0>>1,descram_out[34]};tx_req_vc0_split<=descram_out[35];tx_data_vc0_split<={tx_data_vc0>>1,descram_out[36]};tx_st_vc0_split<=descram_out[37];tx_end_vc0_split<=descram_out[38];tx_nlfy_vc0_split<=descram_out[39];ph_buf_status_vc0_split<=descram_out[40];pd_buf_status_vc0_split<=descram_out[41];nph_buf_status_vc0_split<=descram_out[42];npd_buf_status_vc0_split<=descram_out[43];ph_processed_vc0_split<=descram_out[44];pd_processed_vc0_split<=descram_out[45];nph_processed_vc0_split<=descram_out[46];npd_processed_vc0_split<=descram_out[47];pd_num_vc0_split<={pd_num_vc0>>1,descram_out[48]};npd_num_vc0_split<={npd_num_vc0>>1,descram_out[49]};tx_dwen_vc0_split<=descram_out[50];rxp_data_ln0_split<={rxp_data_ln0>>1,descram_out[51]};rxp_data_k_ln0_split<={rxp_data_k_ln0>>1,descram_out[52]};rxp_valid_ln0_split<=descram_out[53];rxp_elec_idle_ln0_split<=descram_out[54];rxp_status_ln0_split<={rxp_status_ln0>>1,descram_out[55]};rxp_data_ln1_split<={rxp_data_ln1>>1,descram_out[56]};rxp_data_k_ln1_split<={rxp_data_k_ln1>>1,descram_out[57]};rxp_valid_ln1_split<=descram_out[58];rxp_elec_idle_ln1_split<=descram_out[59];rxp_status_ln1_split<={rxp_status_ln1>>1,descram_out[60]};phy_status_split<=descram_out[61];cmpln_tout_split<=descram_out[62];cmpltr_abort_np_split<=descram_out[63];cmpltr_abort_p_split<=descram_out[64];unexp_cmpln_split<=descram_out[65];ur_np_ext_split<=descram_out[66];ur_p_ext_split<=descram_out[67];np_req_pend_split<=descram_out[68];pme_status_split<=descram_out[69];tx_lbk_data_split<={tx_lbk_data>>1,descram_out[70]};tx_lbk_kcntl_split<={tx_lbk_kcntl>>1,descram_out[71]};rate_phy_sts_pulse_split<=descram_out[72];tdmux_data_split<={tdmux_data>>1,descram_out[73]};dfrm_tdata_split<={dfrm_tdata>>1,descram_out[74]};dfrm_seq_split<={dfrm_seq>>1,descram_out[75]};dfrm_lcrc_split<={dfrm_lcrc>>1,descram_out[76]};tlpgen_data_split<={tlpgen_data>>1,descram_out[77]};tlpdec_data_split<={tlpdec_data>>1,descram_out[78]};rxtp_data_split<={rxtp_data>>1,descram_out[79]};dfrm_ddata_split<={dfrm_ddata>>1,descram_out[80]};fc_vcid1_split<={fc_vcid1>>1,descram_out[81]};fc_type1_split<={fc_type1>>1,descram_out[82]};fc_vcid2_split<={fc_vcid2>>1,descram_out[83]};fc_type2_split<={fc_type2>>1,descram_out[84]};p_infi_credit_split<=descram_out[85];np_infi_credit_split<=descram_out[86];cpl_infi_credit_split<=descram_out[87];fc_p_split<={fc_p>>1,descram_out[88]};fc_np_split<={fc_np>>1,descram_out[89]};fc_cpl_split<={fc_cpl>>1,descram_out[90]};txdp_p_sent_split<=descram_out[91];txdp_np_sent_split<=descram_out[92];txdp_cpl_sent_split<=descram_out[93];rxdp_fcd_vcid_split<={rxdp_fcd_vcid>>1,descram_out[94]};rxdp_fcd_data_split<={rxdp_fcd_data>>1,descram_out[95]};rxdp_fcd_type_split<={rxdp_fcd_type>>1,descram_out[96]};vcneg_pend_split<=descram_out[97];vc_enb_split<=descram_out[98];cfg_vcid_split<={cfg_vcid>>1,descram_out[99]};lnk_width_split<={lnk_width>>1,descram_out[100]};cfgcs_losel_split<={cfgcs_losel>>1,descram_out[101]};max_pl_size_split<={max_pl_size>>1,descram_out[102]};ext_sync_split<=descram_out[103];lcm_enb_split<=descram_out[104];link_disable_split<=descram_out[105];dll_pause_cnt_split<={dll_pause_cnt>>1,descram_out[106]};phy_data_split<={phy_data>>1,descram_out[107]};phy_kcntl_split<={phy_kcntl>>1,descram_out[108]};asb_data_split<={asb_data>>1,descram_out[109]};asb_kcntl_split<={asb_kcntl>>1,descram_out[110]};phy_margin_split<={phy_margin>>1,descram_out[111]};phy_l0s_tx_state_split<={phy_l0s_tx_state>>1,descram_out[112]};phy_l1_state_split<={phy_l1_state>>1,descram_out[113]};phy_l2_state_split<={phy_l2_state>>1,descram_out[114]};phy_disable_scr_split<=descram_out[115];phy_sloopback_split<=descram_out[116];phy_snd_beacon_split<=descram_out[117];asb_skip_found_split<={asb_skip_found>>1,descram_out[118]};asb_err_split<={asb_err>>1,descram_out[119]};skip_added_split<={skip_added>>1,descram_out[120]};skip_removed_split<={skip_removed>>1,descram_out[121]};phy_inv_polar_split<={phy_inv_polar>>1,descram_out[122]};phy_eidle_tx_split<={phy_eidle_tx>>1,descram_out[123]};phy_godet_rx_split<={phy_godet_rx>>1,descram_out[124]};phy_fndisp_split<={phy_fndisp>>1,descram_out[125]};asb_eidle_rx_split<={asb_eidle_rx>>1,descram_out[126]};asb_detdone_rx_split<={asb_detdone_rx>>1,descram_out[127]};asb_detres_rx_split<={asb_detres_rx>>1,descram_out[128]};asb_beacon_rx_split<={asb_beacon_rx>>1,descram_out[129]};asb_lane_sync_split<={asb_lane_sync>>1,descram_out[130]};phy_skpq_nclks_split<={phy_skpq_nclks>>1,descram_out[131]};phy_skpq_val_split<=descram_out[132];asb_err_mod_split<={asb_err_mod>>1,descram_out[133]};phy_cfgln_r1_split<={phy_cfgln_r1>>1,descram_out[134]};phy_cfgln_r2_split<={phy_cfgln_r2>>1,descram_out[135]};Dev_Addr_o_split<={Dev_Addr_o>>1,descram_out[136]};Dev_Data_o_split<={Dev_Data_o>>1,descram_out[137]};Dev_BYTE_Sel_o_split<=descram_out[138];Dev_WE_RDn_o_split<=descram_out[139];Dev_Strobe_o_split<=descram_out[140];Dev_Data_i_0_split<={Dev_Data_i_0>>1,descram_out[141]};Dev_Data_i_1_split<={Dev_Data_i_1>>1,descram_out[142]};Dev_Ack_i_0_split<=descram_out[143];Dev_Ack_i_1_split<=descram_out[144];Dev_IRQ_i_split<=descram_out[145];ltssm_reset_core_split<=descram_out[146];hrst_wait_cntr_split<={hrst_wait_cntr>>1,descram_out[147]};end
always@* begin descram_in[2047]<=inta_n;descram_in[2046]<=msi[0];descram_in[2044]<=msi_tc[0];descram_in[2040]<=INIT_REG_00C[0];descram_in[2032]<=INIT_REG_010[0];descram_in[2028]<=txdp_np_sent;descram_in[2017]<=INIT_REG_014[0];descram_in[2008]<=txdp_cpl_sent;descram_in[1988]<=dfrm_seq[0];descram_in[1987]<=INIT_REG_018[0];descram_in[1969]<=rxdp_fcd_vcid[0];descram_in[1928]<=dfrm_lcrc[0];descram_in[1926]<=INIT_REG_01C[0];descram_in[1891]<=rxdp_fcd_data[0];descram_in[1866]<=phy_snd_beacon;descram_in[1842]<=Dev_WE_RDn_o;descram_in[1809]<=tlpgen_data[0];descram_in[1805]<=tx_req_vc0;descram_in[1804]<=INIT_REG_020[0];descram_in[1803]<=INIT_PM_DS_DATA_7[0];descram_in[1761]<=INIT_NPH_FC_VC0[0];descram_in[1748]<=phy_status;descram_in[1734]<=rxdp_fcd_type[0];descram_in[1727]<=cpl_infi_credit;descram_in[1696]<=cmpltr_abort_p;descram_in[1684]<=asb_skip_found[0];descram_in[1668]<=nph_buf_status_vc0;descram_in[1636]<=Dev_Strobe_o;descram_in[1633]<=lcm_enb;descram_in[1607]<=Dev_Ack_i_1;descram_in[1587]<=cfg_vcid[0];descram_in[1571]<=tlpdec_data[0];descram_in[1562]<=tx_data_vc0[0];descram_in[1560]<=INIT_REG_024[0];descram_in[1558]<=INIT_REG_070[0];descram_in[1555]<=phy_kcntl[0];descram_in[1550]<=INIT_PM_DS_DATA_0[0];descram_in[1531]<=fc_cpl[0];descram_in[1484]<=Dev_Data_o[0];descram_in[1475]<=INIT_PD_FC_VC0[0];descram_in[1464]<=INIT_REG_108[0];descram_in[1448]<=cmpln_tout;descram_in[1420]<=vcneg_pend;descram_in[1406]<=fc_p[0];descram_in[1395]<=phy_cfgln_r2[0];descram_in[1345]<=unexp_cmpln;descram_in[1323]<=asb_lane_sync[0];descram_in[1320]<=asb_err[0];descram_in[1300]<=phy_godet_rx[0];descram_in[1288]<=npd_buf_status_vc0;descram_in[1287]<=ur_p_ext;descram_in[1257]<=phy_l2_state[0];descram_in[1242]<=rxp_valid_ln1;descram_in[1224]<=Dev_Data_i_0[0];descram_in[1218]<=link_disable;descram_in[1198]<=phy_skpq_val;descram_in[1186]<=skip_removed[0];descram_in[1167]<=Dev_IRQ_i;descram_in[1131]<=fc_vcid2[0];descram_in[1126]<=lnk_width[0];descram_in[1106]<=asb_eidle_rx[0];descram_in[1094]<=rxtp_data[0];descram_in[1076]<=tx_st_vc0;descram_in[1072]<=INIT_REG_028[0];descram_in[1069]<=INIT_REG_090[0];descram_in[1063]<=asb_data[0];descram_in[1056]<=pd_processed_vc0;descram_in[1055]<=pme_status;descram_in[1052]<=INIT_PM_DS_DATA_1[0];descram_in[1028]<=tx_dwen_vc0;descram_in[1023]<=term_all_cfg;descram_in[1014]<=txdp_p_sent;descram_in[994]<=dfrm_tdata[0];descram_in[933]<=phy_sloopback;descram_in[921]<=Dev_BYTE_Sel_o;descram_in[902]<=INIT_NPD_FC_VC0[0];descram_in[901]<=INIT_PM_DS_DATA_6[0];descram_in[880]<=INIT_PH_FC_VC0[0];descram_in[874]<=rxp_status_ln1[0];descram_in[863]<=np_infi_credit;descram_in[848]<=cmpltr_abort_np;descram_in[834]<=pd_buf_status_vc0;descram_in[816]<=ext_sync;descram_in[803]<=Dev_Ack_i_0;descram_in[793]<=vc_enb;descram_in[777]<=phy_data[0];descram_in[775]<=INIT_REG_054[0];descram_in[765]<=fc_np[0];descram_in[742]<=Dev_Addr_o[0];descram_in[732]<=INIT_REG_104[0];descram_in[697]<=phy_cfgln_r1[0];descram_in[661]<=asb_beacon_rx[0];descram_in[650]<=phy_eidle_tx[0];descram_in[643]<=ur_np_ext;descram_in[628]<=phy_l1_state[0];descram_in[621]<=rxp_data_k_ln1[0];descram_in[599]<=phy_skpq_nclks[0];descram_in[593]<=skip_added[0];descram_in[575]<=hrst_wait_cntr[0];descram_in[565]<=fc_type1[0];descram_in[553]<=phy_fndisp[0];descram_in[528]<=ph_processed_vc0;descram_in[527]<=np_req_pend;descram_in[514]<=npd_num_vc0[0];descram_in[497]<=tdmux_data[0];descram_in[466]<=phy_disable_scr;descram_in[450]<=INIT_PM_DS_DATA_5[0];descram_in[437]<=rxp_elec_idle_ln1;descram_in[431]<=p_infi_credit;descram_in[417]<=ph_buf_status_vc0;descram_in[408]<=max_pl_size[0];descram_in[401]<=Dev_Data_i_1[0];descram_in[388]<=dll_pause_cnt[0];descram_in[387]<=INIT_REG_050[0];descram_in[366]<=INIT_REG_0A0[0];descram_in[348]<=asb_err_mod[0];descram_in[330]<=asb_detres_rx[0];descram_in[325]<=phy_inv_polar[0];descram_in[314]<=phy_l0s_tx_state[0];descram_in[310]<=rxp_data_ln1[0];descram_in[287]<=ltssm_reset_core;descram_in[282]<=fc_vcid1[0];descram_in[257]<=pd_num_vc0[0];descram_in[248]<=rate_phy_sts_pulse;descram_in[225]<=INIT_PM_DS_DATA_4[0];descram_in[215]<=fc_type2[0];descram_in[208]<=tx_nlfy_vc0;descram_in[204]<=cfgcs_losel[0];descram_in[193]<=INIT_REG_03C[0];descram_in[183]<=INIT_REG_09C[0];descram_in[165]<=asb_detdone_rx[0];descram_in[157]<=phy_margin[0];descram_in[155]<=rxp_status_ln0[0];descram_in[141]<=dfrm_ddata[0];descram_in[128]<=npd_processed_vc0;descram_in[124]<=tx_lbk_kcntl[0];descram_in[112]<=INIT_PM_DS_DATA_3[0];descram_in[104]<=tx_end_vc0;descram_in[96]<=INIT_REG_030[0];descram_in[91]<=INIT_REG_094[0];descram_in[78]<=asb_kcntl[0];descram_in[77]<=rxp_elec_idle_ln0;descram_in[64]<=nph_processed_vc0;descram_in[62]<=tx_lbk_data[0];descram_in[56]<=INIT_PM_DS_DATA_2[0];descram_in[38]<=rxp_valid_ln0;descram_in[19]<=rxp_data_k_ln0[0];descram_in[9]<=rxp_data_ln0[0];end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================


// $Id : $


// =============================================================================


//                           COPYRIGHT NOTICE


// Copyright 2000-2001 (c) Lattice Semiconductor Corporation


// ALL RIGHTS RESERVED


// This confidential and proprietary software may be used only as authorised


// by a licensing agreement from Lattice Semiconductor Corporation.


// The entire notice above must be reproduced on all authorized copies and


// copies may only be made to the extent permitted by a licensing agreement


// from Lattice Semiconductor Corporation.


//


// Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)


// 5555 NE Moore Court                        408-826-6000 (other locations)


// Hillsboro, OR 97124                  web  : http://www.latticesemi.com/


// U.S.A                                email: techsupport@latticesemi.com


// =============================================================================


//                         FILE DETAILS


// Project          : pci_exp_xx


// File             : pci_exp_core_wrap.v


// Title            :


// Dependencies     :


// Description      : Wrapper for core.


// =============================================================================


//                        REVISION HISTORY


// Version          : 1.0


// Author(s)        : Umesh


// Mod. Date        : Mar 5, 2013


// Changes Made     : Initial Creation


// =============================================================================



`timescale 1 ns / 100 ps
module pci_exp_core_wrap #(
   parameter LANE_WIDTH = 2,
   parameter D_WIDTH    = 64 )
   (
   input wire                sys_clk_250,     
   input wire                sys_clk_125,     
   input wire                rst_n,           

   input wire                inta_n,
   input wire  [7:0]         msi,

   `ifdef WISHBONE
      
      input wire             RST_I,           
      input wire             CLK_I,           
      input wire [3:0]       SEL_I,           
      input wire             WE_I,            
      input wire             STB_I,           
      input wire             CYC_I,           
      input wire [31:0]      DAT_I,           
      input wire [12:0]      ADR_I,           
      input wire [31:0]      CHAIN_RDAT_in,   
      input wire             CHAIN_ACK_in,    
   `else
      input wire             force_lsm_active, 
      input wire             force_rec_ei,     
      input wire             force_phy_status, 
      input wire             force_disable_scr,

      input wire             hl_snd_beacon,    
      input wire             hl_disable_scr,   
      input wire             hl_gto_dis,       
      input wire             hl_gto_det,       
      input wire             hl_gto_hrst,      
      input wire             hl_gto_l0stx,     
      input wire             hl_gto_l1,        
      input wire             hl_gto_l2,        
      input wire             hl_gto_l0stxfts,  
      input wire [LANE_WIDTH-1:0] hl_gto_lbk,       
      input wire             hl_gto_rcvry,     
      input wire             hl_gto_cfg,       
      input wire             no_pcie_train,    

      
      input wire  [1:0]      tx_dllp_val,      
      input wire  [2:0]      tx_pmtype,        
      input wire  [23:0]     tx_vsd_data,      
   `endif
   `ifdef ID_INTF
      input wire [15:0]      vendor_id ,      
      input wire [15:0]      device_id ,      
      input wire [7:0]       rev_id ,         
      input wire [23:0]      class_code ,     
      input wire [15:0]      subsys_ven_id ,  
      input wire [15:0]      subsys_id ,      
      input wire             load_id ,        
   `endif
   
   input wire                tx_req_vc0,          
   input wire [D_WIDTH-1:0]  tx_data_vc0,         
   input wire                tx_st_vc0,           
   input wire                tx_end_vc0,          
   input wire                tx_nlfy_vc0,         
   input wire                ph_buf_status_vc0,   
   input wire                pd_buf_status_vc0,   
   input wire                nph_buf_status_vc0,  
   input wire                npd_buf_status_vc0,  
   input wire                ph_processed_vc0,    
   input wire                pd_processed_vc0,    
   input wire                nph_processed_vc0,   
   input wire                npd_processed_vc0,   
   input wire [7:0]          pd_num_vc0,          
   input wire [7:0]          npd_num_vc0,         
   input wire                tx_dwen_vc0,         

   
      input wire  [15:0]     rxp_data_ln0,        
      input wire  [1:0]      rxp_data_k_ln0,      
      input wire             rxp_valid_ln0,       
      input wire             rxp_elec_idle_ln0,   
      input wire  [2:0]      rxp_status_ln0,      

      input wire  [15:0]     rxp_data_ln1,        
      input wire  [1:0]      rxp_data_k_ln1,      
      input wire             rxp_valid_ln1,       
      input wire             rxp_elec_idle_ln1,   
      input wire  [2:0]      rxp_status_ln1,      

   input wire                phy_status,      
   `ifdef SIMULATE
      input wire             sci_busy,        
   `endif

   `ifdef AER
      `ifdef ECRC
         output wire         ecrc_gen_enb ,
         output wire         ecrc_chk_enb ,
      `endif
   `endif

   
   `ifdef AER
      input [127:0]          err_tlp_header , 
                                              
   `endif

   input wire                cmpln_tout ,     
   input wire                cmpltr_abort_np ,
   input wire                cmpltr_abort_p , 
   input wire                unexp_cmpln ,    
   input wire                ur_np_ext ,      
   input wire                ur_p_ext ,       
   input wire                np_req_pend ,    
   input wire                pme_status ,     
   `ifdef GEN2
      input wire             flr_rdy_in ,     
   `endif

   
   input wire  [D_WIDTH-1:0]   tx_lbk_data,   
   input wire  [(D_WIDTH/8)-1:0] tx_lbk_kcntl,  

   output wire                  tx_lbk_rdy,   
   output wire [D_WIDTH-1:0]    rx_lbk_data,  
   output wire [(D_WIDTH/8)-1:0]  rx_lbk_kcntl, 
   `ifdef WISHBONE
      
      output wire            ACK_O,           
      output wire            IRQ_O,           
      output wire [31:0]     DAT_O,           
   `else
      
      output wire            tx_dllp_sent,    
      output wire [2:0]      rxdp_pmd_type,   
      output wire [23:0]     rxdp_vsd_data ,  
      output wire [1:0]      rxdp_dllp_val,   
   `endif

      output wire [15:0]     txp_data_ln0,        
      output wire [1:0]      txp_data_k_ln0,      
      output wire            txp_elec_idle_ln0,   
      output wire [1:0]      txp_compliance_ln0,  
      output wire            rxp_polarity_ln0,    

      output wire [15:0]     txp_data_ln1,        
      output wire [1:0]      txp_data_k_ln1,      
      output wire            txp_elec_idle_ln1,   
      output wire [1:0]      txp_compliance_ln1,  
      output wire            rxp_polarity_ln1,    

   output wire               txp_detect_rx_lb,
   output wire               txp_rate,        
   output wire               txp_deemph,      
   output wire [2:0]         txp_margin,      
   output wire [LANE_WIDTH-1:0]  infer_rx_eidle,

   output wire               reset_n,         
   output wire [1:0]         power_down,      

   output wire               phy_pol_compliance,
   output wire [3:0]         phy_ltssm_state, 
   output wire [2:0]         phy_ltssm_substate, 
   `ifdef X4
      output wire [2:0]      phy_cfgln_sum,   
      output wire [1:0]      phy_cfgln,       
      output wire            tx_val,          
   `endif
   output wire               tx_rdy_vc0,      
   output wire [8:0]         tx_ca_ph_vc0,    
   output wire [12:0]        tx_ca_pd_vc0,    
   output wire [8:0]         tx_ca_nph_vc0,   
   output wire [12:0]        tx_ca_npd_vc0,   
   output wire [8:0]         tx_ca_cplh_vc0,  
   output wire [12:0]        tx_ca_cpld_vc0,  
   output wire               tx_ca_p_recheck_vc0, 
   output wire               tx_ca_cpl_recheck_vc0, 
   output wire [D_WIDTH-1:0] rx_data_vc0,     
   output wire               rx_st_vc0,       
   output wire               rx_end_vc0,      
   `ifdef X4
      output wire            rx_dwen_vc0,     
   `endif
   `ifdef ECRC
      output wire            rx_ecrc_err_vc0 ,
   `endif
   output wire               rx_us_req_vc0 ,  
   output wire               rx_malf_tlp_vc0 ,

   output wire [6:0]         rx_bar_hit ,     

   output wire [2:0]         mm_enable ,     
   output wire               msi_enable ,    

   
   output wire [7:0]         bus_num ,        
   output wire [4:0]         dev_num ,        
   output wire [2:0]         func_num ,       
   output wire [1:0]         pm_power_state , 
   output wire               pme_en ,         
   output wire [5:0]         cmd_reg_out ,    
   output wire [14:0]        dev_cntl_out ,   
   output wire [7:0]         lnk_cntl_out ,   
   `ifdef GEN2
      output wire [4:0]      dev_cntl_2_out , 
      output wire            initiate_flr ,   
   `endif

   
   output wire               tx_rbuf_empty,   
   output wire               tx_dllp_pend,    
   output wire               rx_tlp_rcvd,     

   
   output wire               dl_inactive,     
   output wire               dl_init,         
   output wire               dl_active,       
   output wire               dl_up            // Data Link Layer is UP



  ) ;

`ifdef WISHBONE

`else

`endif

`ifdef ID_INTF

`else

`endif

`ifdef GEN2

`endif

`ifdef CFG_VCC

`endif

`ifdef SIMULATE

`endif

`ifdef AER

`ifdef ECRC

`endif

`endif

`ifdef AER

`endif

`ifdef GEN2

`endif

`ifdef WISHBONE

`else

`endif

`ifdef ECRC

`endif

`ifdef GEN2

`endif
reg rst_n_split;
reg inta_n_split;
reg [7 : 0] msi_split;
reg tx_req_vc0_split;
reg [D_WIDTH - 1 : 0] tx_data_vc0_split;
reg tx_st_vc0_split;
reg tx_end_vc0_split;
reg tx_nlfy_vc0_split;
reg ph_buf_status_vc0_split;
reg pd_buf_status_vc0_split;
reg nph_buf_status_vc0_split;
reg npd_buf_status_vc0_split;
reg ph_processed_vc0_split;
reg pd_processed_vc0_split;
reg nph_processed_vc0_split;
reg npd_processed_vc0_split;
reg [7 : 0] pd_num_vc0_split;
reg [7 : 0] npd_num_vc0_split;
reg tx_dwen_vc0_split;
reg [15 : 0] rxp_data_ln0_split;
reg [1 : 0] rxp_data_k_ln0_split;
reg rxp_valid_ln0_split;
reg rxp_elec_idle_ln0_split;
reg [2 : 0] rxp_status_ln0_split;
reg [15 : 0] rxp_data_ln1_split;
reg [1 : 0] rxp_data_k_ln1_split;
reg rxp_valid_ln1_split;
reg rxp_elec_idle_ln1_split;
reg [2 : 0] rxp_status_ln1_split;
reg phy_status_split;
reg cmpln_tout_split;
reg cmpltr_abort_np_split;
reg cmpltr_abort_p_split;
reg unexp_cmpln_split;
reg ur_np_ext_split;
reg ur_p_ext_split;
reg np_req_pend_split;
reg pme_status_split;
reg [D_WIDTH - 1 : 0] tx_lbk_data_split;
reg [(D_WIDTH / 8) - 1 : 0] tx_lbk_kcntl_split;
reg [2047:0] descram_in;
wire [39:0] descram_out;


`ifdef WISHBONE

`else

`endif

`ifdef ID_INTF

`else

`endif

`ifdef GEN2

`endif

`ifdef CFG_VCC

`endif

`ifdef SIMULATE

`endif

`ifdef AER

`ifdef ECRC

`endif

`endif

`ifdef AER

`endif

`ifdef GEN2

`endif

`ifdef WISHBONE

`else

`endif

`ifdef ECRC

`endif

`ifdef GEN2

`endif

localparam descram_inst_SIZE = 40,descram_inst_SCRAMSTRING = 32'hfdffc68b;
localparam [31:0] descram_inst_LSCRAMSTRING = descram_inst_SCRAMSTRING;
localparam descram_inst_DWIDTH = descram_inst_SCRAMSTRING & 4'hf;
localparam [11:0] descram_inst_LMASK = 'h7ff;
wire [(1 << descram_inst_DWIDTH) -1:0] descram_inst_din;
reg [descram_inst_SIZE-1:0] descram_inst_dout;
reg [descram_inst_DWIDTH-1:0] descram_inst_fred [0:1];
reg [descram_inst_DWIDTH-1:0] descram_inst_lfsr;
reg descram_inst_feedback;
integer descram_inst_fptr;
integer descram_inst_i;



`ifdef WISHBONE



`else



`endif



`ifdef ID_INTF



`else



`endif



`ifdef GEN2



`endif



`ifdef CFG_VCC



`endif



`ifdef SIMULATE



`endif



`ifdef AER



`ifdef ECRC



`endif



`endif



`ifdef AER



`endif



`ifdef GEN2



`endif



`ifdef WISHBONE



`else



`endif



`ifdef ECRC



`endif



`ifdef GEN2



`endif

// =============================================================================
//#include "pci_exp_dparams.v"

// =============================================================================
// Core Instance
// =============================================================================
pci_exp_core #(
   .LANE_WIDTH       ( LANE_WIDTH ) ,
   .D_WIDTH          ( D_WIDTH )
   )
   u1_dut(
   // Clock and Reset
   .pclk                       ( sys_clk_250 ) ,
   .sys_clk_125                ( sys_clk_125 ) ,
   .rst_n                      ( rst_n_split ),

   .term_all_cfg               ( `TERM_ALL_CFG ),
   .inta_n                     ( inta_n_split ),
   .msi                        ( msi_split ),
   .msi_tc                     ( 3'b000 ),

   // Inputs
   

`ifdef WISHBONE


      // Wishbone input Signals
      .RST_I                   ( rst_n_split ),
      .CLK_I                   ( CLK_I ),

      .ADR_I                   ( ADR_I ),
      .DAT_I                   ( DAT_I ),
      .SEL_I                   ( SEL_I ),
      .WE_I                    ( WE_I ),
      .STB_I                   ( STB_I ),
      .CYC_I                   ( CYC_I ),
      .CHAIN_RDAT_in           ( CHAIN_RDAT_in ),
      .CHAIN_ACK_in            ( CHAIN_ACK_in ),
   

`else


      .SKP_INS_CNT             ( `SKP_INS_CNT ),
      .ACKNAK_LAT_TIME         ( `ACKNAK_LAT_TIME ),

      .UPDATE_FREQ_PH          ( `UPDATE_FREQ_PH ),
      .UPDATE_FREQ_PD          ( `UPDATE_FREQ_PD ),
      .UPDATE_FREQ_NPH         ( `UPDATE_FREQ_NPH ),
      .UPDATE_FREQ_NPD         ( `UPDATE_FREQ_NPD ),
      .UPDATE_TIMER            ( `UPDATE_TIMER ),

      .tlp_debug               ( `TLP_DEBUG ),
      .force_lsm_active        ( force_lsm_active ),
      .force_rec_ei            ( force_rec_ei ),
      .force_phy_status        ( force_phy_status ),
      .force_disable_scr       ( force_disable_scr ),

      .hl_snd_beacon           ( hl_snd_beacon ),
      .hl_disable_scr          ( hl_disable_scr ),
      .hl_gto_dis              ( hl_gto_dis ),
      .hl_gto_det              ( hl_gto_det ),
      .hl_gto_hrst             ( hl_gto_hrst ),
      .hl_gto_l0stx            ( hl_gto_l0stx ),
      .hl_gto_l1               ( hl_gto_l1 ),
      .hl_gto_l2               ( hl_gto_l2 ),
      .hl_gto_l0stxfts         ( hl_gto_l0stxfts ),
      .hl_gto_lbk              ( hl_gto_lbk ),
      .hl_gto_rcvry            ( hl_gto_rcvry ),
      .hl_gto_cfg              ( hl_gto_cfg ),
      .no_pcie_train           ( no_pcie_train ),

      // Power Management Interface
      .tx_dllp_val             ( tx_dllp_val ),
      .tx_pmtype               ( tx_pmtype ),
      .tx_vsd_data             ( tx_vsd_data ),
   

`endif



   // Register Initial Values
   // For Type0 Registers
   

`ifdef ID_INTF


      .vendor_id               ( vendor_id ),
      .device_id               ( device_id ),
      .rev_id                  ( rev_id ),
      .class_code              ( class_code ),
      .subsys_ven_id           ( subsys_ven_id ),
      .subsys_id               ( subsys_id ),
      .load_id                 ( load_id ),
   

`else


      .INIT_REG_000            ( `INIT_REG_000 ) ,
      .INIT_REG_008            ( `INIT_REG_008 ) ,
      .INIT_REG_02C            ( `INIT_REG_02C ) ,
   

`endif


   .INIT_REG_00C               ( `INIT_REG_00C ) ,
   .INIT_REG_010               ( `INIT_REG_010 ) ,
   .INIT_REG_014               ( `INIT_REG_014 ) ,
   .INIT_REG_018               ( `INIT_REG_018 ) ,
   .INIT_REG_01C               ( `INIT_REG_01C ) ,
   .INIT_REG_020               ( `INIT_REG_020 ) ,
   .INIT_REG_024               ( `INIT_REG_024 ) ,
   .INIT_REG_028               ( `INIT_REG_028 ) ,
   .INIT_REG_030               ( `INIT_REG_030 ) ,
   .INIT_REG_03C               ( `INIT_REG_03C ) ,

   // For PM Registers
   .INIT_REG_050               ( `INIT_REG_050 ) ,
   .INIT_REG_054               ( `INIT_REG_054 ) ,
   .INIT_PM_DS_DATA_0          ( `INIT_PM_DS_DATA_0 ) ,
   .INIT_PM_DS_DATA_1          ( `INIT_PM_DS_DATA_1 ) ,
   .INIT_PM_DS_DATA_2          ( `INIT_PM_DS_DATA_2 ) ,
   .INIT_PM_DS_DATA_3          ( `INIT_PM_DS_DATA_3 ) ,
   .INIT_PM_DS_DATA_4          ( `INIT_PM_DS_DATA_4 ) ,
   .INIT_PM_DS_DATA_5          ( `INIT_PM_DS_DATA_5 ) ,
   .INIT_PM_DS_DATA_6          ( `INIT_PM_DS_DATA_6 ) ,
   .INIT_PM_DS_DATA_7          ( `INIT_PM_DS_DATA_7 ) ,

   // For MSI Register
   .INIT_REG_070               ( `INIT_REG_070 ) ,
   // For PCIE Registers
   .INIT_REG_090               ( `INIT_REG_090 ) ,
   .INIT_REG_094               ( `INIT_REG_094 ) ,
   .INIT_REG_09C               ( `INIT_REG_09C ) ,
   .INIT_REG_0A0               ( `INIT_REG_0A0 ) ,
   

`ifdef GEN2


      .INIT_REG_0B4            ( `INIT_REG_0B4 ) ,
   

`endif


   // For Device Serial no. Registers
   .INIT_REG_104               ( `INIT_REG_104 ) ,
   .INIT_REG_108               ( `INIT_REG_108 ) ,
   // For VCC Registers
   

`ifdef CFG_VCC


      .INIT_REG_10C            ( `INIT_REG_10C ) ,
   

`endif



   .INIT_PH_FC_VC0          ( `INIT_PH_FC_VC0 ),
   .INIT_NPH_FC_VC0         ( `INIT_NPH_FC_VC0 ),
   .INIT_PD_FC_VC0          ( `INIT_PD_FC_VC0 ),
   .INIT_NPD_FC_VC0         ( `INIT_NPD_FC_VC0 ),
   .tx_req_vc0              ( tx_req_vc0_split ),
   .tx_data_vc0             ( tx_data_vc0_split ),
   .tx_st_vc0               ( tx_st_vc0_split ),
   .tx_end_vc0              ( tx_end_vc0_split ),
   .tx_nlfy_vc0             ( tx_nlfy_vc0_split ),
   .ph_buf_status_vc0       ( ph_buf_status_vc0_split ),
   .pd_buf_status_vc0       ( pd_buf_status_vc0_split ),
   .nph_buf_status_vc0      ( nph_buf_status_vc0_split ),
   .npd_buf_status_vc0      ( npd_buf_status_vc0_split ),
   .ph_processed_vc0        ( ph_processed_vc0_split ),
   .pd_processed_vc0        ( pd_processed_vc0_split ),
   .nph_processed_vc0       ( nph_processed_vc0_split ),
   .npd_processed_vc0       ( npd_processed_vc0_split ),
   .pd_num_vc0              ( pd_num_vc0_split ),
   .npd_num_vc0             ( npd_num_vc0_split ),
   .tx_dwen_vc0          ( tx_dwen_vc0_split ),

    // From  External PHY (PIPE I/F)
      .rxp_data_ln0         ( rxp_data_ln0_split ),
      .rxp_data_k_ln0       ( rxp_data_k_ln0_split ),
      .rxp_valid_ln0        ( rxp_valid_ln0_split ),
      .rxp_elec_idle_ln0    ( rxp_elec_idle_ln0_split ),
      .rxp_status_ln0       ( rxp_status_ln0_split ),

      .rxp_data_ln1         ( rxp_data_ln1_split ),
      .rxp_data_k_ln1       ( rxp_data_k_ln1_split ),
      .rxp_valid_ln1        ( rxp_valid_ln1_split ),
      .rxp_elec_idle_ln1    ( rxp_elec_idle_ln1_split ),
      .rxp_status_ln1       ( rxp_status_ln1_split ),

   .phy_status              ( phy_status_split),
   

`ifdef SIMULATE


      .sci_busy             ( sci_busy),
   

`endif



   

`ifdef AER


      

`ifdef ECRC


         .ecrc_gen_enb         ( ecrc_gen_enb ) ,
         .ecrc_chk_enb         ( ecrc_chk_enb ) ,
      

`endif


   

`endif


   // From User logic
   

`ifdef AER


      .err_tlp_header          ( err_tlp_header ),
   

`endif


   .cmpln_tout                 ( cmpln_tout_split ),
   .cmpltr_abort_np            ( cmpltr_abort_np_split ),
   .cmpltr_abort_p             ( cmpltr_abort_p_split ),
   .unexp_cmpln                ( unexp_cmpln_split ),
   .ur_np_ext                  ( ur_np_ext_split ) ,
   .ur_p_ext                   ( ur_p_ext_split ) ,
   .np_req_pend                ( np_req_pend_split ),
   .pme_status                 ( pme_status_split ),
   

`ifdef GEN2


      .flr_rdy_in              ( flr_rdy_in ),
   

`endif



   // User Loop back data
   .tx_lbk_data                ( tx_lbk_data_split ),
   .tx_lbk_kcntl               ( tx_lbk_kcntl_split ),

   .tx_lbk_rdy                 ( tx_lbk_rdy ),
   .rx_lbk_data                ( rx_lbk_data ),
   .rx_lbk_kcntl               ( rx_lbk_kcntl ),

   

`ifdef WISHBONE


      // Wishbone output Signals
      .DAT_O                   ( DAT_O ),
      .ACK_O                   ( ACK_O ),
      .IRQ_O                   ( IRQ_O ),
   

`else


      // Power Management
      .tx_dllp_sent            ( tx_dllp_sent ),
      .rxdp_pmd_type           ( rxdp_pmd_type ),
      .rxdp_vsd_data           ( rxdp_vsd_data ),
      .rxdp_dllp_val           ( rxdp_dllp_val ),
   

`endif



      .txp_data_ln0               ( txp_data_ln0 ),
      .txp_data_k_ln0             ( txp_data_k_ln0 ),
      .txp_elec_idle_ln0          ( txp_elec_idle_ln0 ),
      .txp_compliance_ln0         ( txp_compliance_ln0 ),
      .rxp_polarity_ln0           ( rxp_polarity_ln0 ),

      .txp_data_ln1               ( txp_data_ln1 ),
      .txp_data_k_ln1             ( txp_data_k_ln1 ),
      .txp_elec_idle_ln1          ( txp_elec_idle_ln1 ),
      .txp_compliance_ln1         ( txp_compliance_ln1 ),
      .rxp_polarity_ln1           ( rxp_polarity_ln1 ),

   .txp_detect_rx_lb           ( txp_detect_rx_lb ),
   .reset_n                    ( reset_n ),
   .txp_power_down             ( power_down ),
   .txp_rate                   ( txp_rate ),
   .txp_deemph                 ( txp_deemph ),
   .txp_margin                 ( txp_margin ),

   // From TX User Interface
   .phy_realign_req            (  ),
   .phy_ltssm_state            ( phy_ltssm_state ),
   .phy_ltssm_substate         ( phy_ltssm_substate[2:0] ),
   .phy_pol_compliance         ( phy_pol_compliance ),
   .infer_rx_eidle             (infer_rx_eidle),

      .phy_cfgln_sum           ( phy_cfgln_sum ),
      .phy_cfgln               ( phy_cfgln ),
      .mca_aligned             (  ),
      .tx_val                  ( tx_val ),

   .tcvc_map_vc0               ( ),
   .tx_rdy_vc0                 ( tx_rdy_vc0),
   .tx_ca_ph_vc0               ( tx_ca_ph_vc0),
   .tx_ca_pd_vc0               ( tx_ca_pd_vc0),
   .tx_ca_nph_vc0              ( tx_ca_nph_vc0),
   .tx_ca_npd_vc0              ( tx_ca_npd_vc0),
   .tx_ca_cplh_vc0             ( tx_ca_cplh_vc0),
   .tx_ca_cpld_vc0             ( tx_ca_cpld_vc0),
   .tx_ca_p_recheck_vc0        ( tx_ca_p_recheck_vc0 ),
   .tx_ca_cpl_recheck_vc0      ( tx_ca_cpl_recheck_vc0 ),
   .rx_data_vc0                ( rx_data_vc0),
   .rx_st_vc0                  ( rx_st_vc0),
   .rx_end_vc0                 ( rx_end_vc0),
   

`ifdef ECRC


      .rx_ecrc_err_vc0         ( rx_ecrc_err_vc0 ),
   

`endif


   .rx_us_req_vc0              ( rx_us_req_vc0 ),
   .rx_malf_tlp_vc0            ( rx_malf_tlp_vc0 ),
      .rx_dwen_vc0             ( rx_dwen_vc0),

   .rx_bar_hit                 ( rx_bar_hit ),
   .mm_enable                  ( mm_enable ) ,
   .msi_enable                 ( msi_enable ) ,

   // From Config Registers
   .bus_num                    ( bus_num ) ,
   .dev_num                    ( dev_num ) ,
   .func_num                   ( func_num ) ,
   .pm_power_state             ( pm_power_state ) ,
   .pme_en                     ( pme_en ) ,
   .cmd_reg_out                ( cmd_reg_out ),
   .dev_cntl_out               ( dev_cntl_out ),
   .lnk_cntl_out               ( lnk_cntl_out ),
   

`ifdef GEN2


      .dev_cntl_2_out          ( dev_cntl_2_out ),
      .initiate_flr            ( initiate_flr ),
   

`endif



   // To ASPM implementation outside the IP
   .tx_rbuf_empty              ( tx_rbuf_empty ),
   .tx_dllp_pend               ( tx_dllp_pend ),
   .rx_tlp_rcvd                ( rx_tlp_rcvd ),

   // Datal Link Control SM Status
   .dl_inactive                ( dl_inactive ),
   .dl_init                    ( dl_init ),
   .dl_active                  ( dl_active ),
   .dl_up                      ( dl_up )
   );

always@* begin rst_n_split<=descram_out[0];inta_n_split<=descram_out[1];msi_split<={msi>>1,descram_out[2]};tx_req_vc0_split<=descram_out[3];tx_data_vc0_split<={tx_data_vc0>>1,descram_out[4]};tx_st_vc0_split<=descram_out[5];tx_end_vc0_split<=descram_out[6];tx_nlfy_vc0_split<=descram_out[7];ph_buf_status_vc0_split<=descram_out[8];pd_buf_status_vc0_split<=descram_out[9];nph_buf_status_vc0_split<=descram_out[10];npd_buf_status_vc0_split<=descram_out[11];ph_processed_vc0_split<=descram_out[12];pd_processed_vc0_split<=descram_out[13];nph_processed_vc0_split<=descram_out[14];npd_processed_vc0_split<=descram_out[15];pd_num_vc0_split<={pd_num_vc0>>1,descram_out[16]};npd_num_vc0_split<={npd_num_vc0>>1,descram_out[17]};tx_dwen_vc0_split<=descram_out[18];rxp_data_ln0_split<={rxp_data_ln0>>1,descram_out[19]};rxp_data_k_ln0_split<={rxp_data_k_ln0>>1,descram_out[20]};rxp_valid_ln0_split<=descram_out[21];rxp_elec_idle_ln0_split<=descram_out[22];rxp_status_ln0_split<={rxp_status_ln0>>1,descram_out[23]};rxp_data_ln1_split<={rxp_data_ln1>>1,descram_out[24]};rxp_data_k_ln1_split<={rxp_data_k_ln1>>1,descram_out[25]};rxp_valid_ln1_split<=descram_out[26];rxp_elec_idle_ln1_split<=descram_out[27];rxp_status_ln1_split<={rxp_status_ln1>>1,descram_out[28]};phy_status_split<=descram_out[29];cmpln_tout_split<=descram_out[30];cmpltr_abort_np_split<=descram_out[31];cmpltr_abort_p_split<=descram_out[32];unexp_cmpln_split<=descram_out[33];ur_np_ext_split<=descram_out[34];ur_p_ext_split<=descram_out[35];np_req_pend_split<=descram_out[36];pme_status_split<=descram_out[37];tx_lbk_data_split<={tx_lbk_data>>1,descram_out[38]};tx_lbk_kcntl_split<={tx_lbk_kcntl>>1,descram_out[39]};end
always@* begin descram_in[2047]<=inta_n;descram_in[2046]<=msi[0];descram_in[2044]<=tx_req_vc0;descram_in[2040]<=tx_data_vc0[0];descram_in[2032]<=tx_st_vc0;descram_in[2017]<=tx_end_vc0;descram_in[1987]<=tx_nlfy_vc0;descram_in[1963]<=unexp_cmpln;descram_in[1926]<=ph_buf_status_vc0;descram_in[1921]<=rxp_status_ln0[0];descram_in[1879]<=ur_np_ext;descram_in[1805]<=pd_buf_status_vc0;descram_in[1795]<=rxp_data_ln1[0];descram_in[1710]<=ur_p_ext;descram_in[1679]<=pd_num_vc0[0];descram_in[1562]<=nph_buf_status_vc0;descram_in[1543]<=rxp_data_k_ln1[0];descram_in[1398]<=tx_lbk_data[0];descram_in[1373]<=np_req_pend;descram_in[1310]<=npd_num_vc0[0];descram_in[1144]<=rxp_data_ln0[0];descram_in[1076]<=npd_buf_status_vc0;descram_in[1039]<=rxp_valid_ln1;descram_in[1023]<=rst_n;descram_in[981]<=cmpltr_abort_p;descram_in[960]<=rxp_elec_idle_ln0;descram_in[839]<=npd_processed_vc0;descram_in[749]<=tx_lbk_kcntl[0];descram_in[699]<=pme_status;descram_in[572]<=tx_dwen_vc0;descram_in[490]<=cmpltr_abort_np;descram_in[480]<=rxp_valid_ln0;descram_in[419]<=nph_processed_vc0;descram_in[245]<=cmpln_tout;descram_in[240]<=rxp_data_k_ln0[0];descram_in[209]<=pd_processed_vc0;descram_in[122]<=phy_status;descram_in[104]<=ph_processed_vc0;descram_in[61]<=rxp_status_ln1[0];descram_in[30]<=rxp_elec_idle_ln1;end
    // INSERT DESCRAMBLER HERE
     assign descram_inst_din = descram_in,descram_out = descram_inst_dout; initial begin descram_inst_fptr = $fopen(".fred"); $fdisplay( descram_inst_fptr, "%3h\n%3h", (descram_inst_LSCRAMSTRING >> 4) & descram_inst_LMASK, (descram_inst_LSCRAMSTRING >> (descram_inst_DWIDTH+4)) & descram_inst_LMASK ); $fclose(descram_inst_fptr); $readmemh(".fred", descram_inst_fred); end always @ (descram_inst_din) begin descram_inst_lfsr = descram_inst_fred[1]; for (descram_inst_i=0; descram_inst_i<descram_inst_SIZE; descram_inst_i=descram_inst_i+1) begin descram_inst_dout[descram_inst_i] = descram_inst_din[descram_inst_lfsr]; descram_inst_feedback = ^(descram_inst_lfsr & descram_inst_fred[0]); descram_inst_lfsr = {descram_inst_lfsr, descram_inst_feedback}; end end 

endmodule
// =============================================================================



